#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticInstructionGeneration :
  import "semanticExpressionGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

abstract method @actualParameterForGeneration generateActualParameter
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist ioJokerParametersToReleaseList
  ?!@stringlist ioOutputVariableList
  ?!@stringset unused ioUnusedVariableCppNameSet
  !@string outCppName
;

#---------------------------------------------------------------------------*

override method @outputActualParameterForGeneration generateActualParameter
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist unused ioJokerParametersToReleaseList
  ?!@stringlist unused ioOutputVariableList
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppName
:
  [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  [mOutputActualParameterExpression generateExpression !?ioImplementation !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?outCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @outputInputActualParameterForGeneration generateActualParameter
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@string unused ioImplementation
  ?!@stringlist unused ioJokerParametersToReleaseList
  ?!@stringlist unused ioOutputVariableList
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppName
:
  for (t) in mTypeList do
    [t addHeaderFileName !?ioInclusionSet] ;
  end for ;
  outCppName := mOutputInputVariableCppName ;
  foreach mStructAttributeList do
    outCppName .= ".mAttribute_" . [mValue identifierRepresentation] ;
  end foreach ;
  [!?ioUnusedVariableCppNameSet removeKey !mOutputInputVariableCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputActualParameterForGeneration generateActualParameter
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@string unused ioImplementation
  ?!@stringlist unused ioJokerParametersToReleaseList
  ?!@stringlist ioOutputVariableList
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppName
:
  outCppName := mInputActualCppName ;
  ioOutputVariableList += !mInputActualCppName ;
  [!?ioUnusedVariableCppNameSet removeKey !outCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputJokerParameterForGeneration generateActualParameter
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist ioJokerParametersToReleaseList
  ?!@stringlist ioOutputVariableList
  ?!@stringset unused ioUnusedVariableCppNameSet
  !@string outCppName
:
  [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  outCppName := mInputActualCppName ;
  ioImplementation .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " . outCppName . " ; // Joker input parameter\n" ;
  ioJokerParametersToReleaseList += !mInputActualCppName ;
  ioOutputVariableList += !mInputActualCppName ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           I N S T R U C T I O N    G E N E R A T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
;

#---------------------------------------------------------------------------*

routine generateInstructionList
  ?!@stringset ioInclusionSet
  ??@semanticInstructionListForGeneration inInstructionList
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [!?ioGeneratedCode incIndentation !2] ;
  for element in inInstructionList do
    [element->mInstruction generateInstruction
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ] ;
  end for ;
  [!?ioGeneratedCode decIndentation !2] ;
end routine ;

#---------------------------------------------------------------------------*

override method @semanticBlockInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioGeneratedCode += "{\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode += "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithSourceExpressionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mTargetType addHeaderFileName !?ioInclusionSet] ;
  [mSourceExpression generateExpression
     !?ioGeneratedCode
     !?ioInclusionSet
     !?ioTemporaryVariableIndex
     !?ioUnusedVariableCppNameSet
     ??@string sourceVar
  ] ;
  ioGeneratedCode .= "GALGAS_" . [mTargetType identifierRepresentation] . " " . mCppVariableName . " = " . sourceVar . " ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mVariableType addHeaderFileName !?ioInclusionSet] ;
  ioGeneratedCode .= "GALGAS_" . [mVariableType identifierRepresentation] . " " . mCppVariableName . " ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithDefaultConstructorForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mTargetType addHeaderFileName !?ioInclusionSet] ;
  ioGeneratedCode .= "GALGAS_" . [mTargetType identifierRepresentation]
                  . " " . mTargetVariableCppName
                  . " = GALGAS_"  . [mTargetType identifierRepresentation]
                  . "::constructor_"
                  . [[mTargetType mDefaultConstructorName] identifierRepresentation]
                  . " (" . [mInstructionLocation sourceFile] . ") ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mTargetType addHeaderFileName !?ioInclusionSet] ;
  @stringlist parameterList [emptyList] ;
  foreach mConstructorArguments do
    @string parameter ;
    [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?parameter] ;
    parameterList += !parameter ;  
  end foreach ;
  ioGeneratedCode .= "GALGAS_" . [mTargetType identifierRepresentation]
                   . " " . mTargetVariableCppName
                   . " = GALGAS_"  . [mTargetType identifierRepresentation]
                   . "::constructor_" . [mConstructorName identifierRepresentation]
                   . " (" ;
  foreach parameterList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  @bool needsComma := [parameterList length] > 0 ;
  if mHasCompilerArgument then
    if needsComma then
      ioGeneratedCode .= ", " ;
    end if ;
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .= compilerCppName [] ;
    needsComma := true ;
  end if ;
  if needsComma then
    ioGeneratedCode .= [mInstructionLocation commaSourceFile] . ") ;\n" ;
  else
    ioGeneratedCode .= [mInstructionLocation sourceFile] . ") ;\n" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @assignmentInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  @string sourceVar ;
  [mSourceExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  [!?ioUnusedVariableCppNameSet removeKey !mNameForCheckingFormalParameterUsing] ;
#---
  @string receiverCppName := mTargetCppName ;
  foreach mStructAttributeList do
    receiverCppName .= ".mAttribute_" . [[mValue string] identifierRepresentation] ;
  end foreach ;
  ioGeneratedCode .= receiverCppName . " = " . sourceVar . " ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !mTargetCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @dropInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  for (t) in mDropTypeList do
    [t addHeaderFileName !?ioInclusionSet] ;
  end for ;
  foreach mDropList do
    ioGeneratedCode .= mValue . ".drop () ; // " . mComment . "\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @concatInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mTargetType addHeaderFileName !?ioInclusionSet] ;
  [mSourceExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ??@string sourceVar
  ] ;
  [!?ioUnusedVariableCppNameSet removeKey !mNameForCheckingFormalParameterUsing] ;
  ioGeneratedCode .= mTargetVariableCppName ;
  foreach mStructAttributeList do
    ioGeneratedCode .= ".mAttribute_" . mValue ;
  end foreach ;
  ioGeneratedCode .= ".dotAssign_operation (" . sourceVar . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !mTargetVariableCppName] ;
end method ;

#---------------------------------------------------------------------------*
#! Grammar
#---------------------------------------------------------------------------*

override method @grammarInstructionWithSourceFileForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioInclusionSet += !"grammar-" . mGrammarName ;
#--- Source string
  [mSourceFileExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ??@string sourceVar
  ] ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ??@string parameterCppName
    ] ;
    parameterCppNameList += !parameterCppName ;
    if (mActualParameter is >= @inputActualParameterForGeneration) then
      ioGeneratedCode .= parameterCppName . ".drop () ;\n" ;
    end if ;
  end foreach ;
  if mGrammarHasTranslateFeature then
    ioGeneratedCode .= "C_String " . mSyntaxDirectedTranslationResultVarName . " ;\n" ;
  end if ;
  ioGeneratedCode .= "cGrammar_" . [mGrammarName identifierRepresentation]
                  .  "::_performSourceFileParsing_" . [mLabelName identifierRepresentation] 
                  .  " ("
                  . compilerCppName [] . ", "
                  . if mGrammarHasTranslateFeature then mSyntaxDirectedTranslationResultVarName . ", " else "" end
                  . sourceVar ;
  foreach parameterCppNameList do
    ioGeneratedCode .= ", " . mValue ;
  end foreach ;
  ioGeneratedCode .= " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  for s in mAssignementList do
    ioGeneratedCode .= s->mValue . "\n" ;
  end for ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionWithSourceExpressionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioInclusionSet += !"grammar-" . mGrammarName ;
#--- Source string
  @string sourceVar ;
  [mSourceStringExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    [mActualParameter generateActualParameter
       !?ioInclusionSet
       !?ioTemporaryVariableIndex
       !?ioGeneratedCode
       !?jokerParametersToReleaseList
       !?inputVariableList
       !?ioUnusedVariableCppNameSet
       ??@string parameterCppName
    ] ;
    parameterCppNameList += !parameterCppName ;
    if (mActualParameter is >= @inputActualParameterForGeneration) then
      ioGeneratedCode .= parameterCppName . ".drop () ;\n" ;
    end if ;
  end foreach ;
  if mGrammarHasTranslateFeature then
    ioGeneratedCode .= "C_String " . mSyntaxDirectedTranslationResultVarName . " ;\n" ;
  end if ;
  ioGeneratedCode .= "cGrammar_" . [mGrammarName identifierRepresentation]
                  .  "::_performSourceStringParsing_" . [mLabelName identifierRepresentation] 
                  .  " (" . compilerCppName [] . ", "
                  . if mGrammarHasTranslateFeature then mSyntaxDirectedTranslationResultVarName . ", " else "" end
                  . sourceVar ;
  foreach parameterCppNameList do
    ioGeneratedCode .= ", " . mValue ;
  end foreach ;
  ioGeneratedCode .= " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  for s in mAssignementList do
    ioGeneratedCode .= s->mValue . "\n" ;
  end for ;
end method ;

#---------------------------------------------------------------------------*

override method @ifInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Generate test expression
  @string cppVarName ;
  [mIFexpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?cppVarName] ;
  const @string testVar := "test_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "const enumGalgasBool " . testVar . " = " . cppVarName . ".boolEnum () ;\n" ;
#--- If test expression is not valuated or false, execute 'else' part
  ioGeneratedCode .= "if (kBoolTrue == " . testVar . ") {\n" ;
  generateInstructionList
    !?ioInclusionSet
    !m_then_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  if [m_else_instructionList length] > 0 then
    ioGeneratedCode .= "}else if (kBoolFalse == " . testVar . ") {\n" ;
    generateInstructionList
      !?ioInclusionSet
      !m_else_instructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  end if ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @errorInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Receiver expression
  @string receiverCppVarName ;
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?receiverCppVarName] ;
#--- Receiver expression
  @string messageCppVarName ;
  [mErrorExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?messageCppVarName] ;
#--- Use location reader ?
  if mUseLocationReader then
    const @string locationVar := "location_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "GALGAS_location " . locationVar . " (" . receiverCppVarName . ".reader_location (HERE)) ; // Implicit use of 'location' reader\n" ;
    receiverCppVarName := locationVar ;
  end if ;
#--- Generate error instruction
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->emitSemanticError (" . receiverCppVarName . ", " . messageCppVarName
                   . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
#--- Release dropped variables
  foreach mBuiltVariableCppNameList do
    [!?ioUnusedVariableCppNameSet removeKey !mValue] ;
    ioGeneratedCode .= mValue . ".drop () ; // Release error dropped variable\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @warningInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Receiver expression
  @string receiverCppVarName ;
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?receiverCppVarName] ;
#--- Receiver expression
  @string messageCppVarName ;
  [mWarningExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?messageCppVarName] ;
#--- Use location reader ?
  if mUseLocationReader then
    const @string locationVar := "location_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "GALGAS_location " . locationVar . " (" . receiverCppVarName . ".reader_location (HERE)) ; // Implicit use of 'location' reader\n" ;
    receiverCppVarName := locationVar ;
  end if ;
#--- Generate warning instruction
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->emitSemanticWarning (" . receiverCppVarName . ", " . messageCppVarName
                  . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
end method ;


#---------------------------------------------------------------------------*
#! Calls
#---------------------------------------------------------------------------*


override method @methodCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Receiver expression
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string receiverCppName] ;
  [!?ioUnusedVariableCppNameSet removeKey !receiverCppName] ;
#---
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioInclusionSet !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?inputVariableList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  switch mKind
  when definedAsCategory :
    ioInclusionSet += !"method-" . [mMethodBaseType key] . "-" . mMethodName ;
    if [mReceiverType mTypeKindEnum] == [@typeKindEnum classType] then
      ioGeneratedCode .= "callCategoryMethod_" . [mMethodName identifierRepresentation]
                      . " ((const cPtr_" . [[mReceiverExpression mType] identifierRepresentation] . " *) " . receiverCppName . ".ptr (), " ;
    else
      ioGeneratedCode .= "categoryMethod_" . [mMethodName identifierRepresentation] . " (" . receiverCppName . ", " ;
    end if ;
  when definedAsMember :
    ioGeneratedCode .= receiverCppName . ".method_" . [mMethodName identifierRepresentation] . " (" ;
  end switch ;
  foreach parameterCppNameList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  if [parameterCppNameList length] == 0 then
    if mHasCompilerArgument then
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
      ioGeneratedCode .= compilerCppName [] ;
      ioGeneratedCode .= " COMMA_" ;
    end if ;
  elsif mHasCompilerArgument then
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .= ", " . compilerCppName [] ;
    ioGeneratedCode .= " COMMA_" ;
  else
    ioGeneratedCode .= " COMMA_" ;
  end if ;
  ioGeneratedCode .= [mInstructionLocation sourceFile] . ") ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @routineCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioInclusionSet += !"proc-" . mRoutineName ;
  ioGeneratedCode .= "{\n" ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioInclusionSet !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?inputVariableList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  ioGeneratedCode .= "routine_" . [[mRoutineName string] identifierRepresentation] . " (" ;
  foreach parameterCppNameList do
    ioGeneratedCode .= mValue . ", " ;
  end foreach ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .=  compilerCppName [] . " " . [[mRoutineName location] commaSourceFile] . ") ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @modifierCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "{\n" ;
  @string receiverCppName := mReceiverCppName ;
  foreach mReceiverStructAttributes do
    receiverCppName .= ".mAttribute_" . [[mValue string] identifierRepresentation] ;
  end foreach ;
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverBaseName] ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?parameterCppName
    ] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  switch mKind
  when definedAsCategory :
    ioInclusionSet += !"setter-" . [mMethodBaseType key]. "-" . mModifierName ;
    if [mReceiverType mTypeKindEnum] == [@typeKindEnum classType] then
      if ([[mReceiverType mAllTypedAttributeList] length] > 0) & [mReceiverType mIsConcrete] then
        ioGeneratedCode .= receiverCppName . ".insulate (HERE) ;\n" ;
      end if ;
      ioGeneratedCode .= "callCategoryModifier_" . [mModifierName identifierRepresentation]
                      . " ((cPtr_" . [mReceiverType identifierRepresentation] . " *) " . receiverCppName . ".ptr (), " ;
    else
      ioGeneratedCode .= "categoryModifier_" . [mModifierName identifierRepresentation] . " (" . receiverCppName . ", " ;
    end if ;
  when definedAsMember :
    [mReceiverType addHeaderFileName !?ioInclusionSet] ;
    ioGeneratedCode .= receiverCppName . ".modifier_" . [[mModifierName string] identifierRepresentation] . " (" ;
  end switch ;
  foreach parameterCppNameList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  if mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode .=  ", " ;
    end if ;
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .=  compilerCppName [] ;
    ioGeneratedCode .= " COMMA_" ;
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode .= " COMMA_" ;
  end if ;
  ioGeneratedCode .= [[mModifierName location] sourceFile] . ") ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @selfModifierCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "{\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !mSelfCppName] ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ??@string parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate modifier call
  switch mKind
  when definedAsCategory :
    ioInclusionSet += !"setter-" . [mReceiverType key]. "-" . mModifierName ;
    if [mReceiverType mTypeKindEnum] == [@typeKindEnum classType] then
      ioGeneratedCode .= "callCategoryModifier_" . [mModifierName identifierRepresentation] . " (" . mSelfCppName . ", " ;
    else
      ioGeneratedCode .= "categoryModifier_" . [mModifierName identifierRepresentation] . " (" . mSelfCppName . ", " ;
    end if ;
  when definedAsMember :
    if [mReceiverType mTypeKindEnum] == [@typeKindEnum classType] then
      ioGeneratedCode .= mSelfCppName . "->modifier_" . [mModifierName identifierRepresentation] . " (" ;
    else
      ioGeneratedCode .= mSelfCppName . ".modifier_" . [mModifierName identifierRepresentation] . " (" ;
    end if ;
  end switch ;
  foreach parameterCppNameList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  if mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode .=  ", " ;
    end if ;
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .=  compilerCppName [] ;
    ioGeneratedCode .= " COMMA_" ;
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode .= " COMMA_" ;
  end if ;
  ioGeneratedCode .= [[mModifierName location] sourceFile] . ") ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @typeMethodInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "{\n" ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ??@string parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  ioGeneratedCode .= "GALGAS_" . [[mTypeName string] identifierRepresentation]
                  . "::class_method_" . [[mMethodName string] identifierRepresentation] . " (" ;
  foreach parameterCppNameList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  if mHasCompilerArgument then
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    if [parameterCppNameList length] > 0 then
      ioGeneratedCode .= ", " ;
    end if ;
    ioGeneratedCode .=  compilerCppName [] ;
  end if ;
  if mHasCompilerArgument | ([parameterCppNameList length] > 0) then
    ioGeneratedCode .= " COMMA_" ;
  end if ;
  ioGeneratedCode .= [[mMethodName location] sourceFile] . ") ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*
#! Cast
#---------------------------------------------------------------------------*

override method @structuredCastInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Cast expression
  [mExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ??@string castCppVarName
  ] ;
#---
  ioGeneratedCode .= "if (" . castCppVarName . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  foreach mCastBranchList do
   [mType addHeaderFileName !?ioInclusionSet] ;
    switch mTypeComparisonKind
    when equal :
      ioGeneratedCode .= "if (" . castCppVarName
      . ".dynamicTypeDescriptor () == & kTypeDescriptor_GALGAS_"
      . [mType identifierRepresentation] . ") {\n" ;
    when inherited :
      ioGeneratedCode .= "if (NULL != dynamic_cast <const cPtr_"
      . [mType identifierRepresentation]
      . " *> (" . castCppVarName . ".ptr ())) {\n" ;
    when strictlyInherited :
      ioGeneratedCode .= "if ((" . castCppVarName
      . ".dynamicTypeDescriptor () != & kTypeDescriptor_GALGAS_"
      . [mType identifierRepresentation] . ") && (NULL != dynamic_cast <const cPtr_"
      . [mType identifierRepresentation]
      . " *> (" . castCppVarName . ".ptr ()))) {\n" ;
    end switch ;
    if [mCastedVarCppName length] > 0 then
      ioGeneratedCode .=
        "  GALGAS_" . [mType identifierRepresentation]
      . " " . mCastedVarCppName . " ((cPtr_" . [mType identifierRepresentation]
      . " *) " . castCppVarName . ".ptr ()) ;\n" ;
    end if ;
    generateInstructionList
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  between ioGeneratedCode .= "}else " ;
  end foreach ;
#--- 'else' branch
  if [mElseInstructionList length] > 0 then
    ioGeneratedCode .= "}else{\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mElseInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;  
  end if ;
#---
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @plusEqualnstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Parameters
  [mTargetType addHeaderFileName !?ioInclusionSet] ;
  @stringlist parameterList [emptyList] ;
  foreach mExpressionList do
    [mExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ??@string parameter
    ] ;
    parameterList += !parameter ;  
  end foreach ;
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mNameForCheckingFormalParameterUsing] ;
  ioGeneratedCode .= mReceiverCppName ;
  foreach mStructAttributeList do
    ioGeneratedCode .= ".mAttribute_" . [[mValue string] identifierRepresentation] ;
  end foreach ;
#--- Call add assign (+=) operator
  ioGeneratedCode .= ".addAssign_operation (" ;
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  foreach parameterList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  if ([mTargetType mHandledOperatorFlags] & plusEqualOperatorWithFieldListNeedsCompilerArg []) != 0 then
    ioGeneratedCode  .= ", " . compilerCppName [] ;
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  end if ;
  ioGeneratedCode .= " " . [mInstructionLocation commaSourceFile] . ") ;\n"  ;
end method ;

#---------------------------------------------------------------------------*

override method @incrementInstructionForGeneration generateInstruction
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  @string receiverCppName := mReceiverCppName ;
  foreach mStructAttributeList do
    receiverCppName .= ".mAttribute_" . [[mValue string] identifierRepresentation] ;
  end foreach ;
#--- Invoke incrementation
  ioGeneratedCode .= receiverCppName . ".increment_operation (" . compilerCppName []
                  . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
end method ;

#---------------------------------------------------------------------------*

override method @decrementInstructionForGeneration generateInstruction
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  @string receiverCppName := mReceiverCppName ;
  foreach mStructAttributeList do
    receiverCppName .= ".mAttribute_" . [[mValue string] identifierRepresentation] ;
  end foreach ;
#--- Invoke incrementation
  ioGeneratedCode .= receiverCppName . ".decrement_operation (" . compilerCppName []
                  . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
end method ;

#---------------------------------------------------------------------------*

override method @messageInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Message expression
  [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string messageCppVarName] ;
#--- Invoke 'printMessage' method of C_Compiler
  ioGeneratedCode .= compilerCppName [] . "->printMessage (" . messageCppVarName ;
  ioGeneratedCode .= " " . [mInstructionLocation commaSourceFile] . ") ;\n"  ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
end method ;

#---------------------------------------------------------------------------*

override method @loopInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Variant expression
  @string variantCppVarName ;
  [mVariantExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantCppVarName] ;
  ioGeneratedCode .= "if (" . variantCppVarName . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  const @string variantVar := "variant_" . [[mInstructionLocation locationIndex] string] ;
  ioGeneratedCode .= "uint32_t " . variantVar . " = " . variantCppVarName . ".uintValue () ;\n" ;
  const @string loopVar := "loop_" . [[mInstructionLocation locationIndex] string] ;
  ioGeneratedCode .= "bool " . loopVar . " = true ;\n"
                  . "while (" . loopVar . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  generateInstructionList
    !?ioInclusionSet
    !mFirstInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  @string loopExpressionVar ;
  [mLoopExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?loopExpressionVar] ;
  ioGeneratedCode .= loopVar . " = " . loopExpressionVar . ".isValid () ;\n"
                   . "if (" . loopVar . ") {\n"
                   . "  " . loopVar . " = " . loopExpressionVar . ".boolValue () ;\n"
                   . "}\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= "if (" . loopVar . " && (0 == " . variantVar . ")) {\n"
                     "  " . loopVar . " = false ;\n"
                     "  " . compilerCppName [] . "->loopRunTimeVariantError (" . [mInstructionLocation sourceFile] . ") ;\n"
                     "}\n"
                   . "if (" . loopVar . ") {\n" ;
  ioGeneratedCode .= "  " . variantVar . " -- ;\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mSecondInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*
#! with
#---------------------------------------------------------------------------*

override method @readOnlyWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Receiver expression
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string receiverVarCppName] ;
  const receiverType := [mReceiverExpression mType] ;
#--- key expression
  [mKeyExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string keyVarCppName] ;
#---
  ioGeneratedCode .= "const cMapElement_" . [receiverType identifierRepresentation]
                  . " * " . mObjectArrayCppName . " = (const cMapElement_" . [receiverType identifierRepresentation]
                  . " *) " . receiverVarCppName . "." ;
  if mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode .= "readAccessForWithInstruction (" . keyVarCppName . ") ;\n" ;
  else
    ioGeneratedCode .= "performSearch (" . keyVarCppName
                    . ", " . compilerCppName []
                    . ", kSearchErrorMessage_" . [receiverType identifierRepresentation] . "_" . mSearchMethodNameForErrorSignaling
                    . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  end if ;
  ioGeneratedCode .=  "if (NULL != " . mObjectArrayCppName . ") {\n"
                  .  "    macroValidSharedObject (" . mObjectArrayCppName . ", cMapElement_" . [receiverType identifierRepresentation] . ") ;\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  if [mElseBranchInstructions length] > 0 then
    ioGeneratedCode .= "}else{\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  end if ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @readWriteWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  @string receiverCppName := mReceiverVariableCppName ;
  foreach mStructAttributeList do
    receiverCppName .= ".mAttribute_" . [[mValue string] identifierRepresentation] ;
  end foreach ;
#--- key expression
  [mKeyExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string keyVarCppName] ;
#---
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverVariableCppName] ;
  ioGeneratedCode .= "cMapElement_" . [mReceiverType identifierRepresentation]
                  . " * " . mObjectArrayCppName . " = (cMapElement_" . [mReceiverType identifierRepresentation]
                  . " *) " . receiverCppName . "." ;
  if mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode .= "readWriteAccessForWithInstruction (" . compilerCppName [] .  ", " . keyVarCppName ;
  else
    ioGeneratedCode .= "readWriteAccessForWithInstructionWithErrorMessage (" . compilerCppName [] .  ", " . keyVarCppName ;
    ioGeneratedCode .= ", kSearchErrorMessage_" . [mReceiverType identifierRepresentation] . "_" . mSearchMethodNameForErrorSignaling ;
  end if ;
  ioGeneratedCode .=  " " . [mInstructionLocation commaSourceFile] . ") ;\n"
                  .  "if (NULL != " . mObjectArrayCppName . ") {\n"
                  .  "    macroValidSharedObject (" . mObjectArrayCppName . ", cMapElement_" . [mReceiverType identifierRepresentation] . ") ;\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  if [mElseBranchInstructions length] > 0 then
    ioGeneratedCode .= "}else{\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  end if ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*
#! foreach
#---------------------------------------------------------------------------*

override method @foreachInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  @stringlist enumerationVarCppNameList [emptyList] ;
  foreach mEnumeratedObjectList do
    @string enumerationVar ;
    [mEnumeratedExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?enumerationVar] ;
    enumerationVarCppNameList += !enumerationVar ;
  end foreach ;
  foreach mEnumeratedObjectList, enumerationVarCppNameList do
    ioGeneratedCode .= "cEnumerator_" . [[mEnumeratedExpression mType] identifierRepresentation] . " " . mEnumeratorCppName . " (" . mValue
                    . ", kEnumeration_" . mEnumerationOrder . ") ;\n" ;
  end foreach ;
#--- Analyse 'while' expression
  const @bool whileExpressionIsAllwaysTrue := [mWhileExpression isTrueExpression] ;
#--- Has 'before', 'after' or expression ? If yes, generate 'before' instructions
  if (([mBeforeInstructionList length] + [mAfterInstructionList length]) > 0) | not whileExpressionIsAllwaysTrue then
  #--- Index
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "GALGAS_uint " . mIndexVariableCppName . " ((uint32_t) 0) ;\n" ;
    end if ;
    const @string boolVarCppName := "bool_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    if whileExpressionIsAllwaysTrue then
      ioGeneratedCode .= "const bool " . boolVarCppName . " = true ;\n" ;
    else
      @string whileVar ;
      [mWhileExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVar] ;
      ioGeneratedCode .= "bool " . boolVarCppName . " = " . whileVar . ".isValidAndTrue () ;\n" ;
    end if ;
    ioGeneratedCode .= "if (" ;
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject () && " ;
    end foreach ;
    ioGeneratedCode .= boolVarCppName . ") {\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mBeforeInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    [!?ioGeneratedCode incIndentation !2] ;
    ioGeneratedCode .= "while (" ;
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject () && " ;
    end foreach ;
    ioGeneratedCode .= boolVarCppName . ") {\n" ;
  #--- Generate 'do' instruction
    generateInstructionList
      !?ioInclusionSet
      !mDoInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  #--- Goto next object
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= "  " . mEnumeratorCppName . ".gotoNextObject () ;\n" ;
    end foreach ;
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "  " . mIndexVariableCppName . ".increment () ;\n" ;
    end if ;
  #--- Compute 'while' expression
    if not whileExpressionIsAllwaysTrue then
      ioGeneratedCode .= "  if (" ;
      foreach mEnumeratedObjectList
      do  ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject ()" ;
      between ioGeneratedCode .= " && " ;
      end foreach ;
      ioGeneratedCode .= ") {\n" ;
      @string whileVar ;
      [mWhileExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVar] ;
      ioGeneratedCode .= "    " . boolVarCppName . " = " . whileVar . ".isValidAndTrue () ;\n" ;
      ioGeneratedCode .= "  }\n" ;
    end if ;
  #--- Generate 'between' instruction
    if [mBetweenInstructionList length] > 0 then
      [!?ioGeneratedCode incIndentation !2] ;
      ioGeneratedCode .= "if (" ;
      foreach mEnumeratedObjectList do
        ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject () && " ;
      end foreach ;
      ioGeneratedCode .= boolVarCppName . ") {\n" ;
      generateInstructionList
        !?ioInclusionSet
        !mBetweenInstructionList
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !inGenerateSyntaxDirectedTranslationString
        !?ioGeneratedCode
      ;
      ioGeneratedCode .= "}\n" ;
      [!?ioGeneratedCode decIndentation !2] ;
    end if ;
  #--- End of foreach instruction
    ioGeneratedCode .= "}\n" ;
  #--- Generate 'after' instruction
    [!?ioGeneratedCode decIndentation !2] ;
    generateInstructionList
      !?ioInclusionSet
      !mAfterInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "}\n" ;
  else #----- foreach instruction without 'before', 'after', while expression
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "GALGAS_uint " . mIndexVariableCppName . " ((uint32_t) 0) ;\n" ;
    end if ;
    ioGeneratedCode .= "while (" ;
    foreach mEnumeratedObjectList
      do ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject ()" ;
      between ioGeneratedCode .= " && " ;
    end foreach ;
    ioGeneratedCode .= ") {\n" ;
  #--- Generate 'do' instruction
    generateInstructionList
      !?ioInclusionSet
      !mDoInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  #--- Generate 'between' instruction
    if [mBetweenInstructionList length] > 0 then
      [!?ioGeneratedCode incIndentation !2] ;
      ioGeneratedCode .= "if (" ;
      foreach mEnumeratedObjectList
        do ioGeneratedCode .= mEnumeratorCppName . ".hasNextObject ()" ;
        between ioGeneratedCode .= " && " ;
      end foreach ;
      ioGeneratedCode .= ") {\n" ;
      generateInstructionList
        !?ioInclusionSet
        !mBetweenInstructionList
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !inGenerateSyntaxDirectedTranslationString
        !?ioGeneratedCode
      ;
      ioGeneratedCode .= "}\n" ;
      [!?ioGeneratedCode decIndentation !2] ;
    end if ;
  #--- End of foreach instruction
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= "  " . mEnumeratorCppName . ".gotoNextObject () ;\n" ;
    end foreach ;
    if mIndexVariableCppName != "" then
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
      ioGeneratedCode .= "  " . mIndexVariableCppName . ".increment_operation (" . compilerCppName []
      . " " . [mInstructionLocation commaSourceFile] . ") ;\n" ;
    end if ;
    ioGeneratedCode .= "}\n" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#! Log
#---------------------------------------------------------------------------*

override method @logInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mLogExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string logVar] ;
  ioGeneratedCode .= logVar . ".log (" . [mLogMessage utf8Representation]
  . " " . [[mLogMessage location] commaSourceFile] . ") ;\n" ;
end method ;

#---------------------------------------------------------------------------*
#! switch
#---------------------------------------------------------------------------*

override method @switchInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Switch expression
  [mSwitchExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string switchVar] ;
  ioGeneratedCode .= "if (" . switchVar . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= "switch (" . switchVar . ".enumValue ()) {\n" ;
  ioGeneratedCode .= "case GALGAS_" . [[mSwitchExpression mType] identifierRepresentation] . "::kNotBuilt:\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  foreach mBranches do
    foreach mSwitchConstantList do
      ioGeneratedCode .= "case GALGAS_" . [[mSwitchExpression mType] identifierRepresentation] . "::kEnum_" . [[mValue string] identifierRepresentation] . ": " ;
    end foreach ;
    ioGeneratedCode .= "{\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "  } break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*
#! Match
#---------------------------------------------------------------------------*

override method @matchInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  @stringlist receiverList [emptyList] ;
  foreach mMatchedExpressionList do
    [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string variable] ;
    receiverList += !variable ;
  end foreach ;
  ioGeneratedCode .= "if (" ;
  foreach receiverList
    do ioGeneratedCode .= mValue . ".isValid ()" ;
    between ioGeneratedCode .= " && " ;
  end foreach ;
  ioGeneratedCode .= ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  foreach mMatchInstructionBranchList do
    ioGeneratedCode .= "if (" ;
    foreach mMatchListForGeneration, receiverList do
      if mIsType then
        ioGeneratedCode .= "(NULL != dynamic_cast <const cPtr_" . [mTypeNameOrEnumerationConstantName identifierRepresentation]
                        . " *> (" . mValue . ".ptr ()))" ;
      else
        ioGeneratedCode .= "(" . mValue . ".enumValue () == GALGAS_"
                        . [mLocalConstantName identifierRepresentation]
                        . "::kEnum_" . [mTypeNameOrEnumerationConstantName identifierRepresentation] . ")" ;
      end if ;
      between ioGeneratedCode .= " && " ;
    end foreach ;
    ioGeneratedCode .= ") {\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mMatchBranchInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  between ioGeneratedCode .= "}else " ;
  end foreach ;
  ioGeneratedCode .= "}else{\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mElseInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
