#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticInstructionGeneration :
  import "semanticExpressionGeneration.gSemantics" ;

  import semantics semanticExpressionGeneration in "semanticExpressionGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

abstract method @actualParameterForGeneration generateActualParameter
  ?!@uint ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist ioJokerParametersToReleaseList
  ?!@stringset unused ioUnusedVariableCppNameSet
  !@string outCppName
;

#---------------------------------------------------------------------------*

override method @outputActualParameterForGeneration generateActualParameter
  ?!@uint ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist unused ioJokerParametersToReleaseList
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppName
:
  [mOutputActualParameterExpression generateExpression !?ioImplementation !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?outCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @outputInputActualParameterForGeneration generateActualParameter
  ?!@uint unused ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist unused ioJokerParametersToReleaseList
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppName
:
  foreach mStructAttributeList do
    ioImplementation .= "(handle field in @outputInputActualParameterForGeneration)\n" ;
  end foreach ;
  outCppName := mOutputInputVariableCppName ;
  [!?ioUnusedVariableCppNameSet removeKey !outCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputActualParameterForGeneration generateActualParameter
  ?!@uint unused ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist unused ioJokerParametersToReleaseList
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppName
:
  outCppName := mInputActualCppName ;
  ioImplementation .= "macroReleaseObject (" . outCppName . ") ; // Release input parameter\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !outCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputJokerParameterForGeneration generateActualParameter
  ?!@uint unused ioTemporaryVariableIndex
  ?!@string ioImplementation
  ?!@stringlist ioJokerParametersToReleaseList
  ?!@stringset unused ioUnusedVariableCppNameSet
  !@string outCppName
:
  outCppName := mInputActualCppName ;
  ioImplementation .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " * " . outCppName . " = NULL ; // Joker input parameter\n" ;
  ioJokerParametersToReleaseList += !mInputActualCppName ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           I N S T R U C T I O N    G E N E R A T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

method @semanticInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "?UNHANDLED INSTRUCTION?\n" ;
end method ;

#---------------------------------------------------------------------------*

function generateRoutineBody
  ??@semanticInstructionListForGeneration inInstructionList
  ->@string outGeneratedCode
:
  @stringset unusedVariableCppNameSet [emptySet] ;
  outGeneratedCode := "" ;
  @uint temporaryVariableIndex := 0 ;
  [!?outGeneratedCode incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?temporaryVariableIndex !?unusedVariableCppNameSet !?outGeneratedCode] ;
  end foreach ;
  [!?outGeneratedCode decIndentation !2] ;
end function ;

#---------------------------------------------------------------------------*

routine generateInstructionList
  ??@semanticInstructionListForGeneration inInstructionList
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  [!?ioGeneratedCode incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode] ;
  end foreach ;
  [!?ioGeneratedCode decIndentation !2] ;
end routine ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithSourceExpressionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @localVariableOrConstantDeclarationWithSourceExpressionForGeneration\n" ;
  @string sourceVar ;
  [mSourceExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  if mIsConstant then
    ioGeneratedCode .= "const " ;
  end if ;
  ioGeneratedCode .= "GALGAS_" . [mTargetType identifierRepresentation] . " * " . mCppVariableName
                    . " = " . sourceVar . " ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @localVariableDeclarationForGeneration\n" ;
  ioGeneratedCode .= "GALGAS_" . [mVariableType identifierRepresentation] . " * " . mCppVariableName . " = NULL ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @localVariableOrConstantDeclarationWithConstructorCallForGeneration\n" ;
  @stringlist parameterList [emptyList] ;
  foreach mConstructorArguments do
    @string parameter ;
    [mExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?parameter] ;
    parameterList += !parameter ;  
  end foreach ;
  if mIsConstant then
    ioGeneratedCode .= "const " ;
  end if ;
  ioGeneratedCode .= "GALGAS_" . [mTargetType identifierRepresentation]
                   . " * " . mTargetVariableCppName
                   . " = GALGAS_"  . [mTargetType identifierRepresentation]
                   . "::constructor_" . [mConstructorName identifierRepresentation]
                   . " (" ;
  foreach parameterList
    do ioGeneratedCode .= mValue ;
    between ioGeneratedCode .= ", " ;
  end foreach ;
  @bool needsComma := [parameterList length] > 0 ;
  if mHasCompilerArgument then
    if needsComma then
      ioGeneratedCode .= ", " ;
    end if ;
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .= compilerCppName [] ;
    needsComma := true ;
  end if ;
  if needsComma then
    ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  else
    ioGeneratedCode .= "SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @assignmentInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @assignmentInstructionForGeneration\n" ;
  @string sourceVar ;
  [mSourceExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  foreach mStructAttributeList do
    ioGeneratedCode .= "(TO DO handle field in @assignmentInstructionForGeneration)\n" ;
  end foreach ;
  ioGeneratedCode .= "macroReleaseObject (" . mTargetCppName . ") ;\n" ;
  ioGeneratedCode .= mTargetCppName . " = " . sourceVar . " ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !mTargetCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @dropInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @dropInstructionForGeneration\n" ;
  foreach mDropList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // " . mComment . "\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @appendInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @appendInstructionForGeneration\n" ;
  @string sourceVar ;
  [mSourceExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  foreach mStructAttributeList do
    ioGeneratedCode .= "(TO DO handle field in @appendInstructionForGeneration)\n" ;
  end foreach ;
  ioGeneratedCode .= "dotAssign_operation (" . mTargetVariableCppName . ", " . sourceVar
                  . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  ioGeneratedCode .= "macroReleaseObject (" . sourceVar . ") ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !mTargetVariableCppName] ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionWithSourceFileForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @grammarInstructionWithSourceFileForGeneration\n" ;
#--- Source string
  @string sourceVar ;
  [mSourceFileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
  ioGeneratedCode .= "cGrammar_" . [mGrammarName identifierRepresentation]
                  .  "::_performSourceFileParsing_" . [mLabelName identifierRepresentation] 
                  .  " (" . compilerCppName [] . ", " . sourceVar ;
  foreach parameterCppNameList do
    ioGeneratedCode .= ", " . mValue ;
  end foreach ;
  ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionWithSourceExpressionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//---- @grammarInstructionWithSourceExpressionForGeneration\n" ;
#--- Source string
  @string sourceVar ;
  [mSourceStringExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
  ioGeneratedCode .= "cGrammar_" . [mGrammarName identifierRepresentation]
                  .  "::_performSourceStringParsing_" . [mLabelName identifierRepresentation] 
                  .  " (" . compilerCppName [] . ", " . sourceVar ;
  foreach parameterCppNameList do
    ioGeneratedCode .= ", " . mValue ;
  end foreach ;
  ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @ifInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @ifInstructionForGeneration\n" ;
#--- Generate test expression
  @string cppVarName ;
  [mIFexpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?cppVarName] ;
#--- If test expression is not valuated, skip if instruction
  ioGeneratedCode .= "if (NULL != " . cppVarName . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= "macroValidObject (" . cppVarName . ", GALGAS_bool) ;\n" ;
  const @string testVar := "test_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "const bool " . testVar . " = " . cppVarName . "->boolValue () ;\n" ;
  ioGeneratedCode .= "macroReleaseObject (" . cppVarName . ") ; // Release test temporary variable\n" ;
  ioGeneratedCode .= "if (" . testVar . ") {\n" ;
  generateInstructionList !m_then_instructionList !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode ;
  if [m_else_instructionList length] > 0 then
    ioGeneratedCode .= "}else{\n" ;
    generateInstructionList !m_else_instructionList !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode ;
  end if ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @errorInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @errorInstructionForGeneration\n" ;
#--- Receiver expression
  @string receiverCppVarName ;
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?receiverCppVarName] ;
#--- Receiver expression
  @string messageCppVarName ;
  [mErrorExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?messageCppVarName] ;
#--- Use location reader ?
  if mUseLocationReader then
    const @string locationVar := "location_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "GALGAS_location * " . locationVar . " = readerCall_location (" . receiverCppVarName . " COMMA_HERE) ; // Implicit use of 'location' reader\n" ;
    receiverCppVarName := locationVar ;
  end if ;
#--- Generate error instruction
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->emitSemanticError (" . receiverCppVarName . ", " . messageCppVarName
                   . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
#--- Release temporary variables
  ioGeneratedCode .= "macroReleaseObject (" . receiverCppVarName . ") ; // Release receiver temporary variable\n" ;
  ioGeneratedCode .= "macroReleaseObject (" . messageCppVarName . ") ; // Release message temporary variable\n" ;
#--- Release dropped variables
  foreach mBuiltVariableCppNameList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release error dropped variable\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @warningInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @warningInstructionForGeneration\n" ;
#--- Receiver expression
  @string receiverCppVarName ;
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?receiverCppVarName] ;
#--- Receiver expression
  @string messageCppVarName ;
  [mWarningExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?messageCppVarName] ;
#--- Use location reader ?
  if mUseLocationReader then
    const @string locationVar := "location_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "GALGAS_location * " . locationVar . " = readerCall_location (" . receiverCppVarName . " COMMA_HERE) ; // Implicit use of 'location' reader\n" ;
    receiverCppVarName := locationVar ;
  end if ;
#--- Generate warning instruction
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->emitSemanticWarning (" . receiverCppVarName . ", " . messageCppVarName
                  . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
#--- Release temporary variables
  ioGeneratedCode .= "macroReleaseObject (" . receiverCppVarName . ") ; // Release receiver temporary variable\n" ;
  ioGeneratedCode .= "macroReleaseObject (" . messageCppVarName . ") ; // Release message temporary variable\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @methodCallInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @methodCallInstructionForGeneration\n" ;
#--- Receiver expression
  @string receiverVar ;
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?receiverVar] ;
#---
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  ioGeneratedCode .= "instanceMethodCall_" . [mMethodName identifierRepresentation] . " ("
                    . receiverVar ;
  foreach parameterCppNameList do
    ioGeneratedCode .= ", " . mValue ;
  end foreach ;
  if mHasCompilerArgument then
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .= ", " . compilerCppName [] ;
  end if ;
  ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
#--- Release receiver temporary variable
  ioGeneratedCode .= "macroReleaseObject (" . receiverVar . ") ; // Release receiver temporary variable\n" ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @routineCallInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @routineCallInstructionForGeneration\n" ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  ioGeneratedCode .= "routine_" . [mRoutineName identifierRepresentation] . " (" ;
  foreach parameterCppNameList do
    ioGeneratedCode .= mValue . ", " ;
  end foreach ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .=  compilerCppName [] . " COMMA_SOURCE_FILE_AT_LINE (" . [[[mRoutineName location] line] string] . ")) ;\n" ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @modifierCallInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @typeMethodInstructionForGeneration\n" ;
  @string receiverCppName := mReceiverCppName ;
  @string okVar := "" ;
  if [mReceiverStructAttributes length] > 0 then
    okVar := "ok_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "bool " . okVar . " = NULL != " . mReceiverCppName . " ;  // Handle field access\n" ;
    @string accessorPath := mReceiverCppName ;
    foreach mReceiverStructAttributes do
      accessorPath .= "->mAttribute_" . [mValue identifierRepresentation] ;
      ioGeneratedCode .= "if (" . okVar . ") {\n"
                      .  "  " . okVar . " = NULL != " . accessorPath . " ;\n"
                      .  "}\n" ;
    end foreach ;
    const @string nullVar := "nullVar_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "GALGAS_" . [mReceiverType identifierRepresentation] . " * " . nullVar . " = NULL ;\n" ;
    receiverCppName := "modifierReceiver_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "GALGAS_" . [mReceiverType identifierRepresentation] . " * & " . receiverCppName . " = "
                    . okVar . " ? (" . accessorPath . ") : " . nullVar . "  ;\n" ;
  end if ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  ioGeneratedCode .= "modifierCall_" . [mModifierName identifierRepresentation] . " (" . receiverCppName ;
  foreach parameterCppNameList do
    ioGeneratedCode .= ", "  . mValue ;
  end foreach ;
  if mHasCompilerArgument then
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
    ioGeneratedCode .=  ", " . compilerCppName [] ;
  end if ;
  ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[[mModifierName location] line] string] . ")) ;\n" ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @typeMethodInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "@modifierCallInstructionForGeneration generateInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @structuredCastInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @structuredCastInstructionForGeneration\n" ;
#--- Cast expression
  @string castCppVarName ;
  [mExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?castCppVarName] ;
#---
  ioGeneratedCode .= "if (NULL != " . castCppVarName . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  foreach mCastBranchList do
    if mUseKindOfClass then
      ioGeneratedCode .= "if (NULL != dynamic_cast <GALGAS_" . [mType identifierRepresentation] . " *> (" . castCppVarName . ")) {\n" ;
    else
      ioGeneratedCode .= "if (" . castCppVarName . "->typeDescriptor () == & kTypeDescriptor_GALGAS_" . [mType identifierRepresentation] . ") {\n" ;
    end if ;
    if [mCastedVarCppName length] > 0 then
      ioGeneratedCode .= "GALGAS_" . [mType identifierRepresentation] . " * " . mCastedVarCppName . " = (GALGAS_" . [mType identifierRepresentation] . " *) " . castCppVarName . " ;\n" ;
    end if ;
    generateInstructionList
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
  between ioGeneratedCode .= "}else " ;
  end foreach ;
#--- 'else' branch
  if [mElseInstructionList length] > 0 then
    ioGeneratedCode .= "}else{\n" ;
    generateInstructionList
      !mElseInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;  
  end if ;
#---
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
#---
  ioGeneratedCode .= "  macroReleaseObject (" . castCppVarName . ") ; // Release 'cast' instruction receiver\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @addAssignInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @addAssignInstructionForGeneration\n" ;
#--- Parameters
  @stringlist parameterList [emptyList] ;
  foreach mExpressionList do
    @string parameter ;
    [mExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?parameter] ;
    parameterList += !parameter ;  
  end foreach ;
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  foreach mStructAttributeList do
    ioGeneratedCode .= "(handle fields)\n" ;
  end foreach ;
#--- Call add assign (+=) operator
  ioGeneratedCode .= "addAssign_operation (" . mReceiverCppName ;
  foreach parameterList do
    ioGeneratedCode .= ", " . mValue ;
  end foreach ;
  ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n"  ;
#--- Release temporary parameters
  foreach parameterList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release add assign temporary parameter\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @incrementInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @incrementInstructionForGeneration\n" ;
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  foreach mStructAttributeList do
    ioGeneratedCode .= "(handle fields)\n" ;
  end foreach ;
#--- Invoke incrementation
  ioGeneratedCode .= "GALGAS_" . [mReceiverType identifierRepresentation]
                  . "::increment_operation (" . mReceiverCppName
                  . ", " . compilerCppName []
                  . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
end method ;

#---------------------------------------------------------------------------*

override method @decrementInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @decrementInstructionForGeneration\n" ;
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName] ;
  foreach mStructAttributeList do
    ioGeneratedCode .= "(handle fields)\n" ;
  end foreach ;
#--- Invoke incrementation
  ioGeneratedCode .= "GALGAS_" . [mReceiverType identifierRepresentation]
                  . "::decrement_operation (" . mReceiverCppName
                  . ", " . compilerCppName []
                  . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
end method ;

#---------------------------------------------------------------------------*

override method @messageInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @messageInstructionForGeneration\n" ;
#--- Message expression
  @string messageCppVarName ;
  [mExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?messageCppVarName] ;
#--- Invoke 'printMessage' method of C_Compiler
  ioGeneratedCode .= compilerCppName [] . "->printMessage (" . messageCppVarName ;
  ioGeneratedCode .= " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n"  ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
end method ;

#---------------------------------------------------------------------------*

override method @loopInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @loopInstructionForGeneration\n" ;
#--- Variant expression
  @string variantCppVarName ;
  [mVariantExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantCppVarName] ;
  ioGeneratedCode .= "if (NULL != " . variantCppVarName . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  const @string variantVar := "variant_" . [[mInstructionLocation locationIndex] string] ;
  ioGeneratedCode .= "PMUInt32 " . variantVar . " = " . variantCppVarName . "->uintValue () ;\n"
                  . "macroReleaseObject (" . variantCppVarName . ") ;\n" ;
  const @string loopVar := "loop_" . [[mInstructionLocation locationIndex] string] ;
  ioGeneratedCode .= "bool " . loopVar . " = true ;\n"
                  . "while (" . loopVar . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  generateInstructionList !mFirstInstructions !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode ;
  @string loopExpressionVar ;
  [mLoopExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?loopExpressionVar] ;
  ioGeneratedCode .= loopVar . " = NULL != " . loopExpressionVar . " ;\n"
                   . "if (" . loopVar . ") {\n"
                   . "  " . loopVar . " = " . loopExpressionVar . "->boolValue () ;\n"
                   . "  macroReleaseObject (" . loopExpressionVar . ") ;\n"
                   . "}\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= "if (" . loopVar . " && (0 == " . variantVar . ")) {\n"
                     "  " . loopVar . " = false ;\n"
                     "  " . compilerCppName [] . "->loopRunTimeVariantError (SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n"
                     "}\n"
                   . "if (" . loopVar . ") {\n" ;
  ioGeneratedCode .= "  " . variantVar . " -- ;\n" ;
  generateInstructionList !mSecondInstructions !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @readWriteWithInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @readWriteWithInstructionForGeneration\n" ;
  foreach mStructAttributeList do
    ioGeneratedCode .= "(handle fields)\n" ;
  end foreach ;
#--- key expression
  @string keyVarCppName ;
  [mKeyExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?keyVarCppName] ;
#---
  foreach [mReceiverType mCurrentTypedAttributeList] index IDX do
    ioGeneratedCode .= "// index " . [IDX+1 string] . ": attribute '" . mAttributeName . "', type @" . [mAttributeTypeIndex key] . "\n" ;
  end foreach ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverVariableCppName] ;
  ioGeneratedCode .= "GALGAS_root ** " . mObjectArrayCppName . " = readWriteAccessForWithInstruction_" . [mAccessName identifierRepresentation] . " (" . compilerCppName []
                  .  ", " . mReceiverVariableCppName . ", " . keyVarCppName . " COMMA_HERE) ;\n"
                  .  "if (NULL != " . mObjectArrayCppName . ") {\n" ;
  generateInstructionList !mDoBranchInstructions !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode ;
  if [mElseBranchInstructions length] > 0 then
    ioGeneratedCode .= "}else{\n" ;
    generateInstructionList !mElseBranchInstructions !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet !?ioGeneratedCode ;
  end if ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @foreachInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @foreachInstructionForGeneration\n" ;
  @stringlist enumerationVarCppNameList [emptyList] ;
  foreach mEnumeratedObjectList do
    @string enumerationVar ;
    [mEnumeratedExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?enumerationVar] ;
    enumerationVarCppNameList += !enumerationVar ;
  end foreach ;
  foreach mEnumeratedObjectList, enumerationVarCppNameList do
    ioGeneratedCode .= "GALGAS_" . [[mEnumeratedExpression mType] identifierRepresentation] . "::cEnumerator " . mEnumeratorCppName . " (" . mValue . ", "
                    . [mIsAscending cString] . ") ;\n" ;
  end foreach ;
#--- Analyse 'while' expression
  const @bool whileExpressionIsAllwaysTrue := [mWhileExpression isTrueExpression] ;
#--- Has 'before', 'after' or expression ? If yes, generate 'before' instructions
  if (([mBeforeInstructionList length] + [mAfterInstructionList length]) > 0) | not whileExpressionIsAllwaysTrue then
    ioGeneratedCode .= "//--- complex foreach instruction\n" ;
  #--- Index
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "GALGAS_uint * " . mIndexVariableCppName . " = GALGAS_uint::constructor_new (0 COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
    end if ;
    const @string boolVarCppName := "bool_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    if whileExpressionIsAllwaysTrue then
      ioGeneratedCode .= "bool " . boolVarCppName . " = true ;\n" ;
    else
      @string whileVar ;
      [mWhileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVar] ;
      ioGeneratedCode .= "bool " . boolVarCppName . " = (NULL == " . whileVar . ") ? false : " . whileVar . "->boolValue () ;\n" ;
      ioGeneratedCode .= "macroReleaseObject (" . whileVar . ") ;\n" ;
    end if ;
    ioGeneratedCode .= "if (" ;
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject () && " ;
    end foreach ;
    ioGeneratedCode .= boolVarCppName . ") {\n" ;
    generateInstructionList
      !mBeforeInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
    [!?ioGeneratedCode incIndentation !2] ;
    ioGeneratedCode .= "while (" ;
    foreach mEnumeratedObjectList
      do ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject ()" ;
      between ioGeneratedCode .= " && " ;
    end foreach ;
    ioGeneratedCode .= ") {\n" ;
  #--- Generate 'do' instruction
    generateInstructionList
      !mDoInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
  #--- Compute 'while' expression
    if not whileExpressionIsAllwaysTrue then
      @string whileVar ;
      [mWhileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVar] ;
      ioGeneratedCode .= boolVarCppName . " = (NULL == " . whileVar . ") ? false : " . whileVar . "->boolValue () ;\n" ;
      ioGeneratedCode .= "macroReleaseObject (" . whileVar . ") ;\n" ;
    end if ;
  #--- Generate 'between' instruction
    if [mBetweenInstructionList length] > 0 then
      [!?ioGeneratedCode incIndentation !2] ;
      ioGeneratedCode .= "if (" ;
      foreach mEnumeratedObjectList do
        ioGeneratedCode .= mEnumeratorCppName . ".hasNext () && " ;
      end foreach ;
      ioGeneratedCode .= boolVarCppName . ") {\n" ;
      generateInstructionList
        !mBetweenInstructionList
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !?ioGeneratedCode
      ;
      ioGeneratedCode .= "}\n" ;
      [!?ioGeneratedCode decIndentation !2] ;
    end if ;
  #--- End of foreach instruction
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= "  " . mEnumeratorCppName . ".next() ;\n" ;
    end foreach ;
    if mIndexVariableCppName != "" then
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
      ioGeneratedCode .= "GALGAS_uint::increment_operation (" . mIndexVariableCppName . ", " . compilerCppName [] . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
    end if ;
    ioGeneratedCode .= "}\n" ;
  #--- Generate 'after' instruction
    generateInstructionList
      !mBeforeInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "}\n" ;
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "macroReleaseObject (" . mIndexVariableCppName . ") ; // Release foreach index\n" ;
    end if ;
  else #----- foreach instruction without 'before', 'after', while expression
    ioGeneratedCode .= "//--- simple foreach instruction\n" ;
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "GALGAS_uint * " . mIndexVariableCppName . " = GALGAS_uint::constructor_new (0 COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
    end if ;
    ioGeneratedCode .= "while (" ;
    foreach mEnumeratedObjectList
      do ioGeneratedCode .= mEnumeratorCppName . ".hasCurrentObject ()" ;
      between ioGeneratedCode .= " && " ;
    end foreach ;
    ioGeneratedCode .= ") {\n" ;
  #--- Generate 'do' instruction
    generateInstructionList
      !mDoInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
  #--- Generate 'between' instruction
    if [mBetweenInstructionList length] > 0 then
      [!?ioGeneratedCode incIndentation !2] ;
      ioGeneratedCode .= "if (" ;
      foreach mEnumeratedObjectList
        do ioGeneratedCode .= "  " . mEnumeratorCppName . ".hasNext ()" ;
        between ioGeneratedCode .= " && " ;
      end foreach ;
      ioGeneratedCode .= ") {\n" ;
      generateInstructionList
        !mBetweenInstructionList
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !?ioGeneratedCode
      ;
      ioGeneratedCode .= "}\n" ;
      [!?ioGeneratedCode decIndentation !2] ;
    end if ;
  #--- End of foreach instruction
    foreach mEnumeratedObjectList do
      ioGeneratedCode .= "  " . mEnumeratorCppName . ".next() ;\n" ;
    end foreach ;
    if mIndexVariableCppName != "" then
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
      ioGeneratedCode .= "GALGAS_uint::increment_operation (" . mIndexVariableCppName . ", " . compilerCppName [] . " COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
    end if ;
    ioGeneratedCode .= "}\n" ;
    if mIndexVariableCppName != "" then
      ioGeneratedCode .= "macroReleaseObject (" . mIndexVariableCppName . ") ; // Release foreach index\n" ;
    end if ;
  end if ;
#--- Release temporary objects
  foreach enumerationVarCppNameList do
    ioGeneratedCode .= "macroReleaseObject (" . mValue . ") ; // Release enumeration temporary object\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @sendInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "@sendInstructionForGeneration generateInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
