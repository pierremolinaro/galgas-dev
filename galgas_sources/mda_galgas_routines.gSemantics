#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS LL1 routines                                                      *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics mda_galgas_routines :
  import "semanticsCompilation.gSemantics" ;
  import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
  import semantics optionSemantics in "optionSemantics.gSemantics" ;
  import semantics semanticsSemantics in "semanticsSemantics.gSemantics" ;
  import semantics semantics_semantics in "semantics_semantics.gSemantics" ;
  import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
  import semantics optionMetamodel in "optionMetamodel.gSemantics" ;
  import semantics instructionMetamodel in "instructionMetamodel.gSemantics" ;
  import semantics semanticsMetamodel in "semanticsMetamodel.gSemantics" ;
  import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;
  import semantics programMetamodel in "programMetamodel.gSemantics" ;
  import semantics semanticsCompilation in "semanticsCompilation.gSemantics" ;

  import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;
  import grammar optionLL1grammar in "optionLL1grammar.gGrammar" ;
  import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
  import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
  import grammar programSLRgrammar in "programSLRgrammar.gGrammar" ;
  import grammar projectLL1grammar in "projectLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*

routine getOutputDirectory
  ??@lstring inSourceFile
  !@string outOuputDirectory
:
  outOuputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
  outOuputDirectory .= "/GALGAS_OUTPUT_TEMP" ;
end routine ;

#---------------------------------------------------------------------------*

routine checkCategoryDefinitionForClass
  ??@string inClassName
  ??@abstractCategoryMethodList inAbstractCategoryMethodList
  ??@descendantClassListMap inDescendantClassListMap
  ??@overridingCategoryMethodListMap inOverridingCategoryMethodListMap
  ??@location inEndOfSourceFile
:
  @classIndexList descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
  foreach inAbstractCategoryMethodList do
#        log mFormalParameterList ; Vérifier aussi que la classe n'est pas abstraite
    foreach descendantClasses do
      @lstring descendantClassName ; @ACGalgasType t ; [mClassMapindex searchKey ?descendantClassName ?t] ;
      @bool isAbstract ;
      cast t :
      when >= @classGalgasType classType do
        isAbstract := [classType mIsAbstract] ;
      else
        error descendantClassName: "the '@" . descendantClassName . "' type should be a class" -> isAbstract ;
      end cast ;
      if isAbstract then
        checkCategoryDefinitionForClass
          ![descendantClassName string]
          !inAbstractCategoryMethodList
          !inDescendantClassListMap
          !inOverridingCategoryMethodListMap
          !inEndOfSourceFile
        ;
      else
        @overridingCategoryMethodList overridingMethods := [inOverridingCategoryMethodListMap listForKey ![descendantClassName string]] ;
        @bool found := false ;
        foreach overridingMethods while not found do
          found := [mAbstractCategoryMethodName string] == [mOverridingCategoryMethodName string] ;
        end foreach ;
        if not found then
          error inEndOfSourceFile: "an abstract category method '" . mAbstractCategoryMethodName . "' is defined for class '@" . inClassName
          . "', but descendant class '@" . descendantClassName . "' does not implement this method" ; 
        end if ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine performProjectGlobalCheckings
  ??@parsedComponentStruct inParsedComponentStruct
  ??@location inEndOfSourceFile
:
#--- Build all declaration list
  @semanticDeclarationList semanticDeclarationList [emptyList] ;
  foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
    semanticDeclarationList .= [[mRoot mSemanticDeclarations] mSemanticDeclarationList] ;
  end foreach ;
#---- Build semantic context
  @semanticContext semanticContext ;
  buildSemanticContext !semanticDeclarationList !inEndOfSourceFile ?semanticContext ;
#--- Check that for every abstract category method, an overridden category method
#    defined in an concrete subclass
  if [@uint errorCount] == 0 then
    @abstractCategoryMethodListMap abstractCategoryMethodListMap [emptyMap] ;
    @categoryMethodListMap categoryMethodListMap [emptyMap] ;
    @overridingCategoryMethodListMap overridingCategoryMethodListMap [emptyMap];
    foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
      abstractCategoryMethodListMap .= [[mRoot mSemanticDeclarations] mAbstractCategoryMethodListMap] ;
      overridingCategoryMethodListMap .= [[mRoot mSemanticDeclarations] mOverridingCategoryMethodListMap] ;
    end foreach ;
    @descendantClassListMap descendantClassListMap := [semanticContext mDescendantClassListMap] ;
    foreach abstractCategoryMethodListMap do
      checkCategoryDefinitionForClass
        !key
        !object
        !descendantClassListMap
        !overridingCategoryMethodListMap
        !here
      ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;

#---------------------------------------------------------------------------*
