#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS parser component parser definition                                *
#                                                                           *
#  Copyright (C) 1997, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parser_parser :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics parser_semantics in "parser_semantics.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalSymbolsMap
  ?!@productionRuleListForGrammarAnalysis ioProductionRulesListForGrammar
  ?@lstring inSyntaxComponentName
  ?!@EXsemanticContext ioSemanticContext
  ?!@uint ioProductionIndex
label importSyntax
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalSymbolsMap
  ?!@productionRuleListForGrammarAnalysis ioProductionRulesListForGrammar
  ?!@uint ioProductionIndex
label parse
;

nonterminal <parse_lexique_for_importing>
  ??@lstring inFileName
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label parse
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label parse
;

nonterminal <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
label parse
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <input_parameters_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ??@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList

label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@signatureForGrammarAnalysis outSignature
label importGrammarForSemantics
  !@signatureForGrammarAnalysis outSignature
label parse
;

nonterminal <syntax_instructions_list>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
label parse
;
 
nonterminal <syntax_instructions_list_no_verif>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
label parse
;

nonterminal <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
label getLexiqueName
  !@lstring outLexiqueName
label parse
;

extern routine checkLabelSignatures
  ?!@typeAltProductionsMap ioAltProductionMap ;

extern routine checkParseRewindSignatures
  ?!@L_parse_rewind_signature_list ioParseRewindSignature
 ;

#------------------------------------------------------------------------------*
#                                                                              *
#                      SYNTAX COMPONENT                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  @typeEntitiesToGenerateList listeEntitesAengendrer ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
  $syntax$ ;
#--- Get syntax comopnent name
  @lstring componentName ;
  $identifier$ ? componentName ;
  @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS 1.7.5 and later checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
#--- Define lexique
  @M_terminalSymbolsMapForUse tableTerminaux ;
  @lstring  lexiqueName ;
  <get_lexique_infos>
    ?tableTerminaux
    !?ioLexiqueMapForUse
    ?lexiqueName
  ;
  @string defLexique := [lexiqueName string] ;
#--- Parse Inclusions
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  @EXsemanticContext semanticContext [new
    ![@M_filewrappers emptyMap]
    ![@stringset emptySet]
    ![@EXcategoryMethodMap emptyMap]
    ![@EXcategoryReaderMap emptyMap]
    ![@EXcategoryTemplateMap emptyMap]
  ] ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?ioLexiqueMapForUse
    !?ioSemanticsComponentsMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
    !?semanticContext
  ;
  listeEntitesAengendrer := [@typeEntitiesToGenerateList emptyList] ;
  @nonTerminalSymbolMapForGrammarAnalysis nonTerminalSymbolsMapForGrammar [emptyMap] ;
  @productionRuleListForGrammarAnalysis productionRulesListForGrammar [emptyList] ;
  @M_nonTerminalSymbolForSyntax nonTerminalSymbolsMapForSyntax [emptyMap] ;
  @uint productionIndex := 0 ;
  repeat
  while
    <syntax_declaration>
      !defLexique
      !?nonTerminalSymbolsMapForSyntax
      !?entitiesMap
      !ioOptionsComponentsMapForUse
      !?tableEnAvant
      !?listeEntitesAengendrer
      !?tableTerminaux
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
      !componentName
      !?ioSemanticContext
      !?productionIndex
    ;
  while
    <semantics_declaration>
      !?entitiesMap
      !?listeEntitesAengendrer
      !ioOptionsComponentsMapForUse
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
      !?ioSemanticContext
    ;
  end repeat ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees do
    if not [tableRoutinesAimplementer hasKey ![key string]] then
      error key : "the routine '" . [key string] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !componentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
#--- Generate component
  generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
  ;
#--- Fin du fichier
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  $syntax$ ;
  @lstring syntaxComponentName ;
  $identifier$ ? syntaxComponentName ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
#--- Lexique
  @lstring lexiqueName ;
  @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
  <get_lexique_infos>
    ?*
    !?lexiqueMapForUse
    ?lexiqueName
  ;
#--- Import Semantics, Metamodels
  @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
  @M_grammarComponents grammarComponentsMap [emptyMap] ;
  @M_optionComponents optionsComponentsMap [emptyMap] ;  
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?lexiqueMapForUse
    !?semanticsComponentsMap
    !?grammarComponentsMap
    !?optionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
    !?ioSemanticContext
  ;
#--- 
  @productionRuleListForGrammarAnalysis productionRulesListForGrammar [emptyList] ;
  @nonTerminalSymbolMapForGrammarAnalysis nonTerminalSymbolsMapForGrammar [emptyMap] ;
  @uint productionIndex := 0 ;
  repeat
  while
    <syntax_declaration> importSyntax
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
      !?productionIndex
    ;
  while
    <semantics_declaration> parse ;
  end repeat ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !syntaxComponentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                   GET LEXIQUE INFOS                                          *
#                                                                              *
#------------------------------------------------------------------------------*

rule <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
:
#--- Get lexique name
  $import$ ;
  $lexique$ ;
  $identifier$ ?outLexiqueName ;
#--- 'in' clause ?
  @M_lexiqueComponents lexiqueComponentsMap ;
  select
    lexiqueComponentsMap := ioLexiqueMapForUse ;
  or
    $in$ ;
    @lstring fileName ;
    $literal_string$ ? fileName ;
    lexiqueComponentsMap := [@M_lexiqueComponents emptyMap] ;
    <parse_lexique_for_importing>
      !fileName
      !?lexiqueComponentsMap
    ;
  end select ;
#--- Get lexique from lexique components map
  [lexiqueComponentsMap searchKey !outLexiqueName ?tableTerminaux] ;
#----
  if not [ioLexiqueMapForUse hasKey ![outLexiqueName string]] then
    [!?ioLexiqueMapForUse insertKey !outLexiqueName !tableTerminaux] ;
  end if ;
  $;$ ;
label getLexiqueName
  !@lstring outLexiqueName
:
  $import$ ;
  $lexique$ ;
  $identifier$ ? outLexiqueName ;
  select
  or
    $in$ ;
    $literal_string$ ? * ;
    <parse_lexique_for_importing> parse ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                Instruction BLOC                              *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $block$ ;
#--- Nom de la map
  @lstring nomTable ;
  $identifier$ ? nomTable ;
  @AC_galgasType typeEntite ;
  @typeCplusPlusName nomCppVariableTable ;
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?typeEntite ?nomCppVariableTable] ; 
  @typeTableBlocsDeTable tableMethodesBloc :=
   [(cast typeEntite if >=@typeGalgasMapType else error nomTable) aTableMethodesSurcharger] ;
#--- Methode block
  $.$ ;
  @lstring nomMethodeBloc ;
  $identifier$ ? nomMethodeBloc ;
  @L_EXsignature signatureDebut ;
  @L_EXsignature signatureFin ;
  [tableMethodesBloc searchKey !nomMethodeBloc ?signatureDebut ?signatureFin] ;
#--- Analyser la list d'arguments du prologue
  @typeExpressionList prologueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureDebut
    ?prologueExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioEntitiesMap
    !?ioInstructionList
  ;
  $)$ ;
#--- Generate prologue instruction
  @typeInstruction instruction ;
  instruction := [@typeMapBlockPrologueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !prologueExpressionList] ;
  ioInstructionList += !instruction ;
#--- Liste d'instructions incluses
  $:$ ;
  <syntax_instructions_list_no_verif>
    !inLexiqueClassName
    !?ioNonTerminalSymbolMapForSyntax
    !inCheckNonTerminalsAreDeclaredWithParseLabel
    !ioEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    !?ioInstructionList
    !?tableTerminaux
    !?ioSyntaxSignature
    !inIsInvokedWithinParseLoopInstruction
    !inSemanticContext
  ;
  $end$ ;
  $block$ ;
#--- Analyser la list d'arguments de l'epilogue
  @typeExpressionList epilogueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureFin
    ?epilogueExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioEntitiesMap
    !?ioInstructionList
  ;
  $)$ ;
#--- Verifier que la map est toujours accessible en lecture/ecriture
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?* ?*] ;
#--- Generate epilogue instruction
  instruction := [@typeMapBlockEpilogueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !epilogueExpressionList] ;
  ioInstructionList += !instruction ;
  $;$ ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  $block$ ;
  $identifier$ ? * ;
  $.$ ;
  $identifier$ ? * ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $:$ ;
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  $end$ ;
  $block$ ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     N O N T E R M I N A L    D E C L A R A T I O N                           *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalSymbolsMap
  ?!@productionRuleListForGrammarAnalysis unused ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@uint unused ioProductionIndex
:
  $nonterminal$ ;
  @lstring ruleName ;
  $non_terminal_symbol$ ? ruleName ;
  @L_EXsignature listeDeTypesFormels0 ;
  @typeVariablesMap tableArgumentsMethode0 [emptyMap] ;
  @signatureForGrammarAnalysis signatureForGrammar ;
  @nonterminalSymbolLabelMapForGrammarAnalysis parametersMapForGrammar [emptyMap] ;
  @M_nonterminalSymbolAlts parametersMap [emptyMap] ;
  <formal_arguments_list>
    !ioEntitiesMap
    ?listeDeTypesFormels0
    !?tableArgumentsMethode0
    ?*
    !?tableEnAvant
    ?signatureForGrammar
  ;
  @lstring emptyId := [@lstring new !"" !here] ;
  [!?parametersMap insertKey !emptyId !listeDeTypesFormels0] ;
  [!?parametersMapForGrammar insertKey
    !emptyId
    !signatureForGrammar
  ] ;
  repeat
  while
    $label$ ;
    select
      $parse$ ;
      @signatureForGrammarAnalysis signatureForGrammarComponent [emptyList] ;
      @lstring altName [new !"parse" !here] ;
      [!?parametersMap insertKey !altName ![@L_EXsignature emptyList]] ;
      [!?parametersMapForGrammar insertKey
        !altName
        !signatureForGrammarComponent
      ] ;
    or
      @lstring altName ;
      $identifier$ ? altName ;
      @L_EXsignature listeDeTypesFormels ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @signatureForGrammarAnalysis signatureForGrammarComponent ;
      <formal_arguments_list>
        !ioEntitiesMap
        ?listeDeTypesFormels 
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      [!?parametersMap insertKey !altName !listeDeTypesFormels] ;
      [!?parametersMapForGrammar insertKey
        !altName
        !signatureForGrammarComponent
      ] ;
    end select ;
  end repeat ;
  [!?ioNonTerminalSymbolsMap insertKey !ruleName ![ioNonTerminalSymbolsMap count] !parametersMapForGrammar] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !ruleName !parametersMap] ;
  @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !ruleName !parametersMap !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
  $;$ ;
label importSyntax
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalSymbolsMap
  ?!@productionRuleListForGrammarAnalysis unused ioProductionRulesListForGrammar
  ?!@uint unused ioProductionIndex
:
  $nonterminal$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @nonterminalSymbolLabelMapForGrammarAnalysis nonterminalSymbolParametersMap [emptyMap] ;
  @signatureForGrammarAnalysis signature0 ;
  <formal_arguments_list> importGrammarForSemantics ?signature0 ;
  @lstring altName := [@lstring new !"" !here] ;
  [!?nonterminalSymbolParametersMap insertKey
    !altName
    !signature0
  ] ;
  repeat
  while
    $label$ ;
    select
      $parse$ ;
      [!?nonterminalSymbolParametersMap insertKey
        ![@lstring new !"parse" !here] # Label 'parse'
        ![@signatureForGrammarAnalysis emptyList]
      ] ;
    or
      $identifier$ ?altName ;
      @signatureForGrammarAnalysis signature ;
      <formal_arguments_list> importGrammarForSemantics ?signature ;
      [!?nonterminalSymbolParametersMap insertKey
        !altName
        !signature
      ] ;
    end select ; 
  end repeat ;
  [!?ioNonTerminalSymbolsMap insertKey !nonterminalSymbolName ![ioNonTerminalSymbolsMap count] !nonterminalSymbolParametersMap] ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     P A R S I N G   P R O D U C T I O N   R U L E                            *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@nonTerminalSymbolMapForGrammarAnalysis unused ioNonTerminalSymbolsMap
  ?!@productionRuleListForGrammarAnalysis ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?!@EXsemanticContext ioSemanticContext
  ?!@uint ioProductionIndex
:
  $rule$ ;
  @lstring ruleName ;
  $non_terminal_symbol$ ? ruleName ;
  @L_EXsignature listeDeTypesFormels ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammar ;
  <formal_arguments_list>
    !ioEntitiesMap
    ?listeDeTypesFormels 
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammar
  ;
#--- Search non terminal symbol definition
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [ioNonTerminalSymbolMapForSyntax searchKey !ruleName ?nonterminalSymbolAltMap] ;
#--- Verifier la declaration de la rule et la compatibilite des arguments effectifs avec les arguments formels
  @typeAltProductionsMap altProductionsMap [emptyMap] ;
  @lstring altName := [@lstring new !"" !here] ;
#--- Parse label declared ? If Yes, check that called non terminals are also declared with 'parse' label
  @bool hasParseLabel := [nonterminalSymbolAltMap hasKey !"parse"] ;
  @bool checkNonTerminalsAreDeclaredWithParseLabel := hasParseLabel ;
#--- Parse tag ?
  @string productionTagName ;
  select
    productionTagName := "" ;
  or
    $tag$ ;
    @lstring tagName ;
    $literal_string$ ? tagName ;
    productionTagName := [tagName string] ;
  end select ;
  @location firstBranchErrorLocation := here ;
  $:$ ;
#--- Check rule header
  @L_EXsignature signaturePremiereBrancheFournieParPrototype ;
  [nonterminalSymbolAltMap searchKey
    !altName
    ?signaturePremiereBrancheFournieParPrototype
  ] ;
  verifierCompatibiliteSignatures
    !signaturePremiereBrancheFournieParPrototype
    !listeDeTypesFormels
    !firstBranchErrorLocation
  ;
#--- Insert in variable map attributes for returned entity
  @typeInstructionList listeInstructions [emptyList] ;
#--- Parse instructions list
  @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
  <syntax_instructions_list>
    !inLexiqueClassName
    !?ioNonTerminalSymbolMapForSyntax
    !checkNonTerminalsAreDeclaredWithParseLabel
    !ioEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableArgumentsMethode
    !?listeInstructions
    !?tableTerminaux
    !?syntaxSignature
    !false # inIsInvokedWithinParseLoopInstruction
    !ioSemanticContext
  ;
  [!?altProductionsMap insertKey
    !altName
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
  repeat
  while
    $label$ ;
    $identifier$ ?altName ;
    tableArgumentsMethode := [@typeVariablesMap emptyMap] ;
    @signatureForGrammarAnalysis signatureForGrammarComponent ;
    <formal_arguments_list>
      !ioEntitiesMap
      ?listeDeTypesFormels 
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent # unused
    ;
    @location errorLocation := here ;
    $:$ ;
    @L_EXsignature signatureFournieParPrototype ;
    [nonterminalSymbolAltMap searchKey !altName ?signatureFournieParPrototype] ;
    verifierCompatibiliteSignatures
      !signatureFournieParPrototype
      !listeDeTypesFormels
      !errorLocation
    ;
    @typeInstructionList branchInstructionList [emptyList] ;
    @syntaxInstructionListForGrammarAnalysis branchSyntaxSignature [emptyList] ;
    <syntax_instructions_list>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !false
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?tableArgumentsMethode
      !?branchInstructionList
      !?tableTerminaux
      !?branchSyntaxSignature
      !false # inIsInvokedWithinParseLoopInstruction
      !ioSemanticContext
    ;
    [!?altProductionsMap insertKey
      !altName
      !listeTypeEtNomsArguments
      !branchInstructionList
      !branchSyntaxSignature
      !here
    ] ;
  end repeat ;
  $end$ ;
  $rule$ ;
  $;$ ;
#--- Check if all label rules have the same syntax signature
  checkLabelSignatures !?altProductionsMap ;
#--- Check that all label rules are implemented
  foreach nonterminalSymbolAltMap do
    if [key string] != "parse" & not [altProductionsMap hasKey ![key string]] then
      error here : "the '" . [key string] . "' label is not implemented within the rule" ;
    end if ;
  end foreach ;
#--- Generate production
  @typeEntityToGenerate ea := [@typeProductionAengendrer new
    !ruleName
    !altProductionsMap
    !productionTagName
    !inLexiqueClassName
    !hasParseLabel
    !ioProductionIndex
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  @uint ruleIndex := 0 ;
  ioProductionRulesListForGrammar +=
    !ruleName
    !ruleIndex
    !syntaxSignature
    !ioProductionIndex
  ;
  ioProductionIndex ++ ;
label importSyntax
  ?!@nonTerminalSymbolMapForGrammarAnalysis unused ioNonTerminalSymbolsMap
  ?!@productionRuleListForGrammarAnalysis ioProductionRulesListForGrammar
  ?!@uint ioProductionIndex
:
  $rule$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @signatureForGrammarAnalysis signature ;
  <formal_arguments_list> importGrammarForSemantics ?signature ;
  select
  or
    $tag$ ;
    $literal_string$ ? * ;
  end select ;
  $:$ ;
  @syntaxInstructionListForGrammarAnalysis instructionsList [emptyList] ;
  <syntax_instructions_list> importSyntax !?instructionsList ;
  repeat
  while
    $label$ ;
    $identifier$ ? * ;
    <formal_arguments_list> parse ;
    $:$ ;
    <syntax_instructions_list> parse ;
  end repeat ;
  @uint leftNonterminalSymbolIndex := 0 ;
  ioProductionRulesListForGrammar +=
    !nonterminalSymbolName
    !leftNonterminalSymbolIndex
    !instructionsList
    !ioProductionIndex
  ;
  ioProductionIndex ++ ;
  $end$ ;
  $rule$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SYNTAXIQUES D'UNE PRODUCTION             *
#------------------------------------------------------------------------------*

rule <syntax_instructions_list>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  block ioVariablesMap.verifyVariableUsing () :
    <syntax_instructions_list_no_verif>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?tableTerminaux
      !?ioSyntaxSignature
      !inIsInvokedWithinParseLoopInstruction
      !inSemanticContext
    ;
    @location positionErreur := here ;
  end block (!positionErreur) ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
end rule ;

#------------------------------------------------------------------------------*
#          Instruction de verification syntaxique $terminal$ ? ... ;           *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax unused ioNonTerminalSymbolMapForSyntax
  ?@bool unused inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool unused inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext unused inSemanticContext
:
  $terminal$ ?@lstring terminalSymbolName ;
  @typeListeAttributsSemantiques listeDesAttributsFormels ;
  [tableTerminaux searchKey !terminalSymbolName ?listeDesAttributsFormels] ;
  @L_assignedVariables listeTypeEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  <input_parameters_list>
    !inEntitiesMap
    ?listeTypeEffectifs
    ?allVariablesList
    !listeDesAttributsFormels
    !?ioVariablesMap
    !?ioInstructionList
  ;
  ioInstructionList += ![@typeInstructionVerifSyntaxique new
    !terminalSymbolName
    !listeTypeEffectifs
    !inLexiqueClassName
  ] ;
  @uint terminalSymbolIndex := 0 ;
  @abstractSyntaxInstructionForGrammarAnalysis i := [@terminalInstructionForGrammarAnalysis new ![terminalSymbolName location] !terminalSymbolName !terminalSymbolIndex] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  <input_parameters_list> parse ;
  @abstractSyntaxInstructionForGrammarAnalysis instruction := [@terminalInstructionForGrammarAnalysis new
    ![terminalSymbolName location]
    !terminalSymbolName
    !0 # terminalSymbolIndex
  ] ;
  ioInstructionList += ! instruction ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    N O N - T E R M I N A L    C A L L    I N S T R U C T I O N    <p> ...  ; *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string unused inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $parse$ ;
    altName := [@lstring new !"parse" !here] ;
  or
    $identifier$ ?altName ;
  end select ;
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [ioNonTerminalSymbolMapForSyntax searchKey !nonterminalSymbolName ?nonterminalSymbolAltMap] ;
  @L_EXsignature signatureMethode ;
  [nonterminalSymbolAltMap searchKey !altName ?signatureMethode] ;
#--- Check if parse label is declared ?
  if inCheckNonTerminalsAreDeclaredWithParseLabel & ([altName string] != "parse") then
    if not [nonterminalSymbolAltMap hasKey !"parse"] then
      error here : "As current rule has 'parse' label, every invoked non terminal symbol must be declared with 'parse' label" ;
    end if ;
  end if ;
  if inIsInvokedWithinParseLoopInstruction & ([altName string] != "parse") then
    if not [nonterminalSymbolAltMap hasKey !"parse"] then
      error here : "As this nonterminal is invoked within a 'parse loop ...' instruction, it must be declared with 'parse' label" ;
    end if ;
  end if ;
#--- Parse effective parameter list
  @typeExpressionList parametersExpressionList ;
  <actual_parameters_list>
    !signatureMethode
    ?parametersExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioEntitiesMap
    !?ioInstructionList
  ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeInstructionAppelNonTerminal new
    !nonterminalSymbolName
    !parametersExpressionList
    !altName
  ] ;
  ioInstructionList += !instruction ;
  @abstractSyntaxInstructionForGrammarAnalysis i := [@nonTerminalInstructionForGrammarAnalysis new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0
  ] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  select
  or
    $parse$ ;
  or
    $identifier$ ? * ;
  end select ;
  <actual_parameters_list> parse ;
  @abstractSyntaxInstructionForGrammarAnalysis instruction := [@nonTerminalInstructionForGrammarAnalysis new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0 # nonterminalSymbolIndex
  ] ;
  ioInstructionList += ! instruction ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    S E L E C T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $select$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesChoix [emptyList] ;
  @branchListForGrammarAnalysis selectList [emptyList] ;
  block ioVariablesMap.testBloc () :
    block ioVariablesMap.testPart () :
      @typeInstructionList firstBranchInstructionList [emptyList] ;
      @syntaxInstructionListForGrammarAnalysis firstBranchSyntaxSignature [emptyList] ;
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?firstBranchInstructionList
        !?tableTerminaux
        !?firstBranchSyntaxSignature
        !inIsInvokedWithinParseLoopInstruction
        !inSemanticContext
      ;
      listeBranchesChoix += !firstBranchInstructionList ;
      selectList += !firstBranchSyntaxSignature ;
    end block (!here) ;
    $or$ ;
    repeat
      block ioVariablesMap.testPart () :
        @typeInstructionList listeInstructionsBrancheChoix [emptyList] ;
        @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheChoix
          !?tableTerminaux
          !?syntaxSignature
          !inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
        listeBranchesChoix += !listeInstructionsBrancheChoix ;
        selectList += !syntaxSignature ;
      end block (!here) ;
    while
      $or$ ;
    end repeat ;
    $end$ ;
    $select$ ;
    $;$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_select_instruction new !listeBranchesChoix !positionDebut] ;
  ioInstructionList += !instruction ;
  ioSyntaxSignature += ![@selectInstructionForGrammarAnalysis new !positionDebut !selectList !0] ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  $select$ ;
  @location positionDebut := here ;
  @branchListForGrammarAnalysis selectList [emptyList] ;
  @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  selectList += !syntaxSignature ;
  $or$ ;
  repeat
    @syntaxInstructionListForGrammarAnalysis syntaxSignature2 [emptyList] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature2 ;
    selectList += !syntaxSignature2 ;
  while
    $or$ ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  ioInstructionList += ![@selectInstructionForGrammarAnalysis new !positionDebut !selectList !0] ;
end rule ;

#------------------------------------------------------------------------------*
#    R E P E A T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $repeat$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesRepeter [emptyList] ;
  @branchListForGrammarAnalysis whileList [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    @typeInstructionList listeInstructionsPremiereBranche [emptyList] ;
    @syntaxInstructionListForGrammarAnalysis repeatBranchInstructionsList [emptyList] ;
    block ioVariablesMap.repeatPart () :
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?listeInstructionsPremiereBranche
        !?tableTerminaux
        !?repeatBranchInstructionsList
        !inIsInvokedWithinParseLoopInstruction
        !inSemanticContext
      ;
      listeBranchesRepeter += !listeInstructionsPremiereBranche ;
      whileList += !repeatBranchInstructionsList ;
    end block (!here) ;
    $while$ ;
    repeat
      block ioVariablesMap.repeatPart () :
        @typeInstructionList listeInstructionsBrancheRepeter [emptyList];
        @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheRepeter
          !?tableTerminaux
          !?syntaxSignature
          !inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
        listeBranchesRepeter += !listeInstructionsBrancheRepeter ;
        whileList += !syntaxSignature ;
      end block (!here) ;
    while
      $while$ ;
    end repeat ;
    $end$ ;
    $repeat$ ;
  end block () ;
  $;$ ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_repeat_instruction new !listeBranchesRepeter !positionDebut] ;
  ioInstructionList += !instruction ;
  ioSyntaxSignature += ![@repeatInstructionForGrammarAnalysis new !positionDebut !whileList !0] ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  $repeat$ ;
  @location positionDebut := here ;
  @branchListForGrammarAnalysis repeatList [emptyList] ;
  @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  repeatList += !syntaxSignature ;
  $while$ ;
  repeat
    syntaxSignature := [@syntaxInstructionListForGrammarAnalysis emptyList] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
    repeatList += !syntaxSignature ;
  while
    $while$ ;
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  ioInstructionList += ![@repeatInstructionForGrammarAnalysis new !positionDebut !repeatList !0] ;
end rule ;

#------------------------------------------------------------------------------*
#    P A R S E    D O ...    R E W I N D ...    I N S T R U C T I O N          *
#    P A R S E    W H E N   ...    E L S E  ...    I N S T R U C T I O N       *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $parse$ ;
  @typeInstruction instruction ;
  select
    $loop$ ;
  #--- Variant expression
    @typeExpression variantExpression ;
    @AC_galgasType variantResultType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?variantExpression
      ?variantResultType
    ;
    @typeGalgas_uint ui := (cast variantResultType if >= @typeGalgas_uint else error here) ;
    $while$ ;
  #--- Conditionnal expression
    @typeExpression conditionalExpression ;
    @AC_galgasType resultType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?conditionalExpression
      ?resultType
    ;
    @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
    $do$ ;
  #--- Repeated instruction list
    @typeInstructionList instructionList [emptyList] ;
    @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
    block ioVariablesMap.repeatBlock () :
      block ioVariablesMap.repeatPart () :
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionList
          !?tableTerminaux
          !?syntaxSignature
          !true # inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
      end block (!here) ;
    end block () ;
    instruction := [@C_parse_loop_instruction new
      !here
      !variantExpression
      !conditionalExpression
      !instructionList
    ] ;
  or
    $do$ ;
    @L_parse_rewind_signature_list parse_rewind_signature_list [emptyList] ;
    @location instructionStartLocation := here ;
    @typeListeBranchesInstructions branchList [emptyList] ;
  #--- First branch
    @branchListForGrammarAnalysis whileList [emptyList] ;
    @typeInstructionList firstBranchInstructionsList [emptyList] ;
    @syntaxInstructionListForGrammarAnalysis firstBranchSyntaxSignature [emptyList] ;
    <syntax_instructions_list_no_verif>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?firstBranchInstructionsList
      !?tableTerminaux
      !?firstBranchSyntaxSignature
      !inIsInvokedWithinParseLoopInstruction
      !inSemanticContext
    ;
    branchList += !firstBranchInstructionsList ;
    parse_rewind_signature_list += !firstBranchSyntaxSignature !instructionStartLocation ;
    foreach firstBranchSyntaxSignature do
      ioSyntaxSignature += !mInstruction ;
    end foreach ;
  #--- One or more 'rewind' branches
    repeat
      $rewind$ ;
      @location branchStartLocation := here ;
      @typeInstructionList instructionsList [emptyList] ;
      @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionsList
        !?tableTerminaux
        !?syntaxSignature
        !inIsInvokedWithinParseLoopInstruction
        !inSemanticContext
      ;
      branchList += !instructionsList ;
      parse_rewind_signature_list += !syntaxSignature !branchStartLocation ;
    while
    end repeat ;
    instruction := [@C_parse_rewind_instruction new !here !branchList] ;
  #--- Check all branches have the same syntax signature
    checkParseRewindSignatures !?parse_rewind_signature_list ;
  or
    @L_parse_rewind_signature_list parse_rewind_signature_list [emptyList] ;
  #--- Instruction parse when ... when ... else ... end parse ;
    @L_expression_instructionsList_list branchList [emptyList] ;
    block ioVariablesMap.testBloc () :
    #--- 'when' branches
      repeat
        block ioVariablesMap.testPart () :
          $when$ ;
          @typeExpression expression ;
          @AC_galgasType resultType ;
          <expression>
            !ioEntitiesMap
            !inOptionsComponentsMapForUse
            !inSemanticContext
            !?ioVariablesMap
            ?expression
            ?resultType
          ;
          $:$ ;
          @location branchStartLocation := here ;
          @typeInstructionList instructionsList [emptyList] ;
          @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
          <syntax_instructions_list_no_verif>
            !inLexiqueClassName
            !?ioNonTerminalSymbolMapForSyntax
            !inCheckNonTerminalsAreDeclaredWithParseLabel
            !ioEntitiesMap
            !?listeEntitesAengendrer
            !inOptionsComponentsMapForUse
            !?ioVariablesMap
            !?instructionsList
            !?tableTerminaux
            !?syntaxSignature
            !inIsInvokedWithinParseLoopInstruction
            !inSemanticContext
          ;
          branchList += !expression !instructionsList !here ;
          parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        end block (!here) ;
      while
      end repeat ;
      $else$ ;
      block ioVariablesMap.testPart () :
        @location branchStartLocation := here ;
        @typeInstructionList elseInstructionsList [emptyList] ;
        @syntaxInstructionListForGrammarAnalysis syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseInstructionsList
          !?tableTerminaux
          !?syntaxSignature
          !inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
        parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        foreach syntaxSignature do
          ioSyntaxSignature += !mInstruction ;
        end foreach ;
      end block (!here) ;
    end block () ;
    instruction := [@C_parse_when_else_instruction new !branchList !elseInstructionsList] ;
  #--- Check all branches have the same syntax signature
    checkParseRewindSignatures !?parse_rewind_signature_list ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
#--- Generate instruction
  ioInstructionList += !instruction ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  $parse$ ;
  select
    $loop$ ;
    <expression> parse ;
    $while$ ;
    <expression> parse ;
    $do$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  or
    $do$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
    repeat
      $rewind$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
  or
    repeat
      $when$ ;
      <expression> parse ;
      $:$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
    $else$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <syntax_instructions_list_no_verif>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  repeat
  while
    <syntax_instruction>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?tableTerminaux
      !?ioSyntaxSignature
      !inIsInvokedWithinParseLoopInstruction
      !inSemanticContext
    ;
  while
    <semantic_instruction>
      !tableEnAvant
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !inSemanticContext
    ;
  end repeat ;
label importSyntax
  ?!@syntaxInstructionListForGrammarAnalysis ioInstructionList
:
  repeat
  while
    <syntax_instruction> importSyntax !?ioInstructionList ;
  while
    <semantic_instruction> parse ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
