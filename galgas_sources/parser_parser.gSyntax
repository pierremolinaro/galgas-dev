#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS parser component parser definition                                *
#                                                                           *
#  Copyright (C) 1997, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parser_parser :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics parser_semantics in "parser_semantics.gSemantics" ;
import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
label importForGrammarAnalysis
  ?!@syntaxRuleList ioSyntaxRuleList
;

nonterminal <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring inSyntaxComponentName
  ?!@EXsemanticContext ioSemanticContext
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
label importForGrammarAnalysis
  ?!@syntaxRuleList unused ioSyntaxRuleList
label parse
;

nonterminal <parse_lexique_for_importing>
  ??@lstring inFileName
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label parse
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label parse
;

nonterminal <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
label parse
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <input_parameters_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ??@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList

label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

nonterminal <syntax_instructions_list>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
label parse
;
 
nonterminal <syntax_instructions_list_no_verif>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
label parse
;

nonterminal <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
label getLexiqueName
  !@lstring outLexiqueName
label parse
;

extern routine checkLabelSignatures
  ?!@typeAltProductionsMap ioAltProductionMap ;

extern routine checkParseRewindSignatures
  ?!@L_parse_rewind_signature_list ioParseRewindSignature
 ;

#------------------------------------------------------------------------------*
#                                                                              *
#                      SYNTAX COMPONENT                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  @typeEntitiesToGenerateList listeEntitesAengendrer ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
  $syntax$ ;
#--- Get syntax comopnent name
  @lstring componentName ;
  $identifier$ ? componentName ;
  @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS 1.7.5 and later checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
#--- Define lexique
  @M_terminalSymbolsMapForUse tableTerminaux ;
  @lstring  lexiqueName ;
  <get_lexique_infos>
    ?tableTerminaux
    !?ioLexiqueMapForUse
    ?lexiqueName
  ;
  @string defLexique := [lexiqueName string] ;
#--- Parse Inclusions
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  @EXsemanticContext semanticContext [new
    ![@M_filewrappers emptyMap]
    ![@stringset emptySet]
    ![@EXcategoryMethodMap emptyMap]
    ![@EXcategoryReaderMap emptyMap]
    ![@EXcategoryTemplateMap emptyMap]
  ] ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?ioLexiqueMapForUse
    !?ioSemanticsComponentsMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
    !?semanticContext
  ;
  listeEntitesAengendrer := [@typeEntitiesToGenerateList emptyList] ;
  @M_nonTerminalSymbolsForGrammar nonTerminalSymbolsMapForGrammar [emptyMap] ;
  @L_productionRules_ForGrammarComponent productionRulesListForGrammar [emptyList] ;
  @M_nonTerminalSymbolForSyntax nonTerminalSymbolsMapForSyntax [emptyMap] ;
  repeat
  while
    <syntax_declaration>
      !defLexique
      !?nonTerminalSymbolsMapForSyntax
      !?entitiesMap
      !ioOptionsComponentsMapForUse
      !?tableEnAvant
      !?listeEntitesAengendrer
      !?tableTerminaux
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
      !componentName
      !?ioSemanticContext
    ;
  while
    <semantics_declaration>
      !?entitiesMap
      !?listeEntitesAengendrer
      !ioOptionsComponentsMapForUse
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
      !?ioSemanticContext
    ;
  end repeat ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees do
    if not [tableRoutinesAimplementer hasKey ![key string]] then
      error key : "the routine '" . [key string] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !componentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
#--- Generate component
  generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
  ;
#--- Fin du fichier
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  $syntax$ ;
  @lstring syntaxComponentName ;
  $identifier$ ? syntaxComponentName ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
#--- Lexique
  @lstring lexiqueName ;
  @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
  <get_lexique_infos>
    ?*
    !?lexiqueMapForUse
    ?lexiqueName
  ;
#--- Import Semantics, Metamodels
  @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
  @M_grammarComponents grammarComponentsMap [emptyMap] ;
  @M_optionComponents optionsComponentsMap [emptyMap] ;  
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?lexiqueMapForUse
    !?semanticsComponentsMap
    !?grammarComponentsMap
    !?optionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
    !?ioSemanticContext
  ;
#--- 
  @L_productionRules_ForGrammarComponent productionRulesListForGrammar [emptyList] ;
  @M_nonTerminalSymbolsForGrammar nonTerminalSymbolsMapForGrammar [emptyMap] ;
  repeat
  while
    <syntax_declaration> importSyntax
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
    ;
  while
    <semantics_declaration> parse ;
  end repeat ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !syntaxComponentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxRuleList ioSyntaxRuleList
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  select
  or
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end select ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> importForGrammarAnalysis !?ioSyntaxRuleList ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                   GET LEXIQUE INFOS                                          *
#                                                                              *
#------------------------------------------------------------------------------*

rule <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
:
#--- Get lexique name
  $import$ ;
  $lexique$ ;
  $identifier$ ?outLexiqueName ;
#--- 'in' clause ?
  @M_lexiqueComponents lexiqueComponentsMap ;
  select
    lexiqueComponentsMap := ioLexiqueMapForUse ;
  or
    $in$ ;
    @lstring fileName ;
    $literal_string$ ? fileName ;
    lexiqueComponentsMap := [@M_lexiqueComponents emptyMap] ;
    <parse_lexique_for_importing>
      !fileName
      !?lexiqueComponentsMap
    ;
  end select ;
#--- Get lexique from lexique components map
  [lexiqueComponentsMap searchKey !outLexiqueName ?tableTerminaux] ;
#----
  if not [ioLexiqueMapForUse hasKey ![outLexiqueName string]] then
    [!?ioLexiqueMapForUse insertKey !outLexiqueName !tableTerminaux] ;
  end if ;
  $;$ ;
label getLexiqueName
  !@lstring outLexiqueName
:
  $import$ ;
  $lexique$ ;
  $identifier$ ? outLexiqueName ;
  select
  or
    $in$ ;
    $literal_string$ ? * ;
    <parse_lexique_for_importing> parse ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                Instruction BLOC                              *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $block$ ;
#--- Nom de la map
  @lstring nomTable ;
  $identifier$ ? nomTable ;
  @AC_galgasType typeEntite ;
  @typeCplusPlusName nomCppVariableTable ;
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?typeEntite ?nomCppVariableTable] ; 
  @typeTableBlocsDeTable tableMethodesBloc :=
   [(cast typeEntite if >=@typeGalgasMapType else error nomTable) aTableMethodesSurcharger] ;
#--- Methode block
  $.$ ;
  @lstring nomMethodeBloc ;
  $identifier$ ? nomMethodeBloc ;
  @L_EXsignature signatureDebut ;
  @L_EXsignature signatureFin ;
  [tableMethodesBloc searchKey !nomMethodeBloc ?signatureDebut ?signatureFin] ;
#--- Analyser la list d'arguments du prologue
  @typeExpressionList prologueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureDebut
    ?prologueExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioEntitiesMap
    !?ioInstructionList
  ;
  $)$ ;
#--- Generate prologue instruction
  @typeInstruction instruction ;
  instruction := [@typeMapBlockPrologueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !prologueExpressionList] ;
  ioInstructionList += !instruction ;
#--- Liste d'instructions incluses
  $:$ ;
  <syntax_instructions_list_no_verif>
    !inLexiqueClassName
    !?ioNonTerminalSymbolMapForSyntax
    !inCheckNonTerminalsAreDeclaredWithParseLabel
    !ioEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    !?ioInstructionList
    !?tableTerminaux
    !?ioSyntaxSignature
    !inIsInvokedWithinParseLoopInstruction
    !inSemanticContext
  ;
  $end$ ;
  $block$ ;
#--- Analyser la list d'arguments de l'epilogue
  @typeExpressionList epilogueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureFin
    ?epilogueExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioEntitiesMap
    !?ioInstructionList
  ;
  $)$ ;
#--- Verifier que la map est toujours accessible en lecture/ecriture
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?* ?*] ;
#--- Generate epilogue instruction
  instruction := [@typeMapBlockEpilogueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !epilogueExpressionList] ;
  ioInstructionList += !instruction ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $block$ ;
  $identifier$ ? * ;
  $.$ ;
  $identifier$ ? * ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $:$ ;
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  $end$ ;
  $block$ ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  $block$ ;
  $identifier$ ? * ;
  $.$ ;
  $identifier$ ? * ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $:$ ;
  <syntax_instructions_list_no_verif> importForGrammarAnalysis !?ioSyntaxInstructionList ;
  $end$ ;
  $block$ ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     I M P L I C I T    N O N T E R M I N A L    D E C L A R A T I O N        *
#------------------------------------------------------------------------------*

routine implicitDeclaration
  ??@lstring inNonterminalBaseName
  ??@uint inLevel
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
#---
  @M_nonterminalSymbolAlts parametersMapNoArgument [emptyMap] ;
  @M_nonterminalSymbolAltsForGrammar parametersMapForGrammarNoArgument [emptyMap] ;
  [!?parametersMapNoArgument insertKey ![@lstring new !"" !here] ![@L_EXsignature emptyList]] ;
  [!?parametersMapForGrammarNoArgument insertKey
    ![@lstring new !"" !here] # Empty Id
    ![@L_signature emptyList]
  ] ;
#---
  @M_nonterminalSymbolAlts parametersMapOneArgument ;
  @M_nonterminalSymbolAltsForGrammar parametersMapForGrammarOneArgument ;
  parametersMapOneArgument := parametersMapNoArgument ;
  parametersMapForGrammarOneArgument := parametersMapForGrammarNoArgument ;

#--- Nonterminal <Expression__i>
  @lstring actualRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !parametersMapForGrammarNoArgument] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !actualRuleName !parametersMapNoArgument] ;
  @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !actualRuleName !parametersMapNoArgument !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
#--- Nonterminal <Expression__prefix__i>
  @lstring actualPrefixName [new ![inNonterminalBaseName string] . "__prefix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPrefixName !parametersMapForGrammarNoArgument] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !actualPrefixName !parametersMapNoArgument] ;
  ea := [@typeNonterminalToGenerate new !actualPrefixName !parametersMapNoArgument !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
#--- Nonterminal <Expression__infix__i>
  @lstring actualInfixName [new ![inNonterminalBaseName string] . "__infix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualInfixName !parametersMapForGrammarOneArgument] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !actualInfixName !parametersMapOneArgument] ;
  ea := [@typeNonterminalToGenerate new !actualInfixName !parametersMapOneArgument !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
#--- Nonterminal <Expression__postfix__i>
  @lstring actualPostfixName [new ![inNonterminalBaseName string] . "__postfix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPostfixName !parametersMapForGrammarOneArgument] ;
   [!?ioNonTerminalSymbolMapForSyntax insertKey !actualPostfixName !parametersMapOneArgument] ;
   ea := [@typeNonterminalToGenerate new !actualPostfixName !parametersMapOneArgument !inLexiqueClassName] ;
   listeEntitesAengendrer += !ea ;
#------------------------------------------ Rule <Expression__i>
  @typeAltProductionsMap altProductionsMap [emptyMap] ;
  @typeInstructionList listeInstructions [emptyList] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
#--- Building instruction list
  @typeInstruction instruction := [@typeInstructionAppelNonTerminal new
    !actualPrefixName
    ![@typeExpressionList emptyList]
    ![@lstring new !"" !here] #  mAltName
  ] ;
  listeInstructions += !instruction ;

  @typeExpressionList effectiveArguments [emptyList] ;
  instruction := [@typeInstructionAppelNonTerminal new
    !actualInfixName
    !effectiveArguments
    ![@lstring new !"" !here] #  mAltName
  ] ;
  listeInstructions += !instruction ;

  effectiveArguments := [@typeExpressionList emptyList] ;
  instruction := [@typeInstructionAppelNonTerminal new
    !actualPostfixName
    !effectiveArguments
    ![@lstring new !"" !here] #  mAltName
  ] ;
  listeInstructions += !instruction ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    ![@typeListeTypesEtNomsArgMethode emptyList]
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualRuleName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualRuleName
   !0 # Rule Index
   !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__prefix__i>
  altProductionsMap := [@typeAltProductionsMap  emptyMap] ;
  listeInstructions := [@typeInstructionList emptyList] ;
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  @lstring nextRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel + 1 string] ![inNonterminalBaseName location]] ;

  instruction := [@typeInstructionAppelNonTerminal new
    !nextRuleName
    ![@typeExpressionList emptyList]
    ![@lstring new !"" !here] #  mAltName
  ] ;
  listeInstructions += !instruction ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    ![@typeListeTypesEtNomsArgMethode emptyList]
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualPrefixName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualPrefixName
   !0 # Rule Index
   !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__infix__i>
  altProductionsMap := [@typeAltProductionsMap  emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments [emptyList] ;
  listeInstructions := [@typeInstructionList emptyList] ;
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualInfixName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualInfixName
   !0 # Rule Index
   !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__postfix__i>
  altProductionsMap := [@typeAltProductionsMap  emptyMap] ;
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualPostfixName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualPostfixName
   !0 # Rule Index
   !syntaxSignature
  ;
end routine ;

#------------------------------------------------------------------------------*

routine implicitDeclarationImportSyntax
  ??@lstring inNonterminalBaseName
  ??@uint inLevel
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMapNoParameter [emptyMap] ;
  [!?nonterminalSymbolParametersMapNoParameter insertKey
    ![@lstring new !"" !here] # Alt Name
    ![@L_signature emptyList]
  ] ;
#--- Nonterminal <Expression__i>
  @lstring actualRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !nonterminalSymbolParametersMapNoParameter] ;
#--- Nonterminal <Expression__prefix__i>
  @lstring actualPrefixName [new ![inNonterminalBaseName string] . "__prefix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPrefixName !nonterminalSymbolParametersMapNoParameter] ;
#--- Nonterminal <Expression__infix__i>
  @lstring actualInfixName [new ![inNonterminalBaseName string] . "__infix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualInfixName ! nonterminalSymbolParametersMapNoParameter] ;
#--- Nonterminal <Expression__postfix__i>
  @lstring actualPostfixName [new ![inNonterminalBaseName string] . "__postfix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPostfixName ! nonterminalSymbolParametersMapNoParameter] ;
#------------------------------------------ Rule <Expression__i>
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  @AC_instruction_ForGrammar instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![actualPrefixName location]
    !actualPrefixName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;

  instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![actualInfixName location]
    !actualInfixName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;

  instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![actualPostfixName location]
    !actualPostfixName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;

  ioProductionRulesListForGrammar +=
    !actualRuleName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__prefix__i>
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  @lstring nextRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel + 1 string] ![inNonterminalBaseName location]] ;
  instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![nextRuleName location]
    !nextRuleName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;
  ioProductionRulesListForGrammar +=
    !actualPrefixName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__infix__i>
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  ioProductionRulesListForGrammar +=
    !actualInfixName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__postfix__i>
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  ioProductionRulesListForGrammar +=
    !actualPostfixName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
end routine ;

#------------------------------------------------------------------------------*
#     O P E R A T O R    D E C L A R A T I O N                                 *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax unused ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?!@EXsemanticContext unused ioSemanticContext
:
  $operator$ ;
  @lstring operatorAttributes ;
  $literal_string$ ? operatorAttributes ;
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  @lstring nonterminalBaseName ;
  $non_terminal_symbol$ ? nonterminalBaseName ;
  @luint operatorPriority ;
  $unsigned_literal_integer$ ? operatorPriority ;
  $;$ ;

#--- Generate operator
  @typeInstructionList listeInstructions [emptyList] ;
  @typeInstruction instruction :=[@typeInstructionVerifSyntaxique new
    !terminalSymbolName
    ![@L_assignedVariables emptyList]
    !inLexiqueClassName
  ] ;
  listeInstructions += !instruction ;
#---
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments [emptyList] ;
  @lstring leftNonTerminalName ;
  if [operatorAttributes string] == "multiple prefix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__prefix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !calledRuleName
      ![@typeExpressionList emptyList]
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
  elsif [operatorAttributes string] == "simple prefix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__prefix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] + 1 string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !calledRuleName
      ![@typeExpressionList emptyList]
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
  elsif [operatorAttributes string] == "infix" then #--------------------------------------
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__infix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] + 1 string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !calledRuleName
      ![@typeExpressionList emptyList]
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
  elsif [operatorAttributes string] == "right infix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__infix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !calledRuleName
      ![@typeExpressionList emptyList]
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
  elsif [operatorAttributes string] == "left infix" then  #--------------------------------------
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__infix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] + 1 string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !calledRuleName
      ![@typeExpressionList emptyList]
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
    @typeExpressionList effectiveArguments [emptyList] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !leftNonTerminalName
      !effectiveArguments
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
  elsif [operatorAttributes string] == "simple postfix" then  #--------------------------------------
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__postfix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
  elsif [operatorAttributes string] == "multiple postfix" then  #--------------------------------------
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__postfix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@typeInstructionAppelNonTerminal new
      !leftNonTerminalName
      ![@typeExpressionList emptyList]
      ![@lstring new !"" !here] #  mAltName
    ] ;
    listeInstructions += !instruction ;
  else
    error operatorAttributes: "Valid operator attributes are:\n"
      "  - \"multiple prefix\" ;\n"
      "  - \"simple prefix\" ;\n"
      "  - \"multiple postfix\" ;\n"
      "  - \"simple postfix\" ;\n"
      "  - \"left infix\" ;\n"
      "  - \"right infix\" ;\n"
      "  - \"infix\"."
    -> leftNonTerminalName
    ;
  end if ;
#---
  @typeAltProductionsMap altProductionsMap [emptyMap] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
#--- Generate production
  @typeEntityToGenerate ea := [@typeProductionAengendrer new
    !leftNonTerminalName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !leftNonTerminalName
   !0 # Rule Index
   !syntaxSignature
  ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  $operator$ ;
  @lstring operatorAttributes ;
  $literal_string$ ? operatorAttributes ;
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  @lstring nonterminalBaseName ;
  $non_terminal_symbol$ ? nonterminalBaseName ;
  @luint operatorPriority ;
  $unsigned_literal_integer$ ? operatorPriority ;
  $;$ ;
#--- Operator call
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;

  @AC_instruction_ForGrammar instruction := [@T_terminalInstruction_forGrammarComponent new
    ![terminalSymbolName location]
    !terminalSymbolName
    !0 # terminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;
#------------------------------------------ Rule <Expression__prefix__i>
  @lstring leftNonTerminalName ;
  if [operatorAttributes string] == "multiple prefix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__prefix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![calledRuleName location]
      !calledRuleName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
  elsif [operatorAttributes string] == "simple prefix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__prefix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] + 1 string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![calledRuleName location]
      !calledRuleName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
  elsif [operatorAttributes string] == "infix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__infix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] + 1 string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![calledRuleName location]
      !calledRuleName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
  elsif [operatorAttributes string] == "right infix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__infix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![calledRuleName location]
      !calledRuleName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
  elsif [operatorAttributes string] == "left infix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__infix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    @lstring calledRuleName [new
      ![nonterminalBaseName string] . "__" . [[operatorPriority uint] + 1 string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![calledRuleName location]
      !calledRuleName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![leftNonTerminalName location]
      !leftNonTerminalName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
  elsif [operatorAttributes string] == "simple postfix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__postfix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
  elsif [operatorAttributes string] == "multiple postfix" then
    leftNonTerminalName := [@lstring new
      ![nonterminalBaseName string] . "__postfix__" . [[operatorPriority uint] string]
      ![nonterminalBaseName location]
    ] ;
    instruction := [@T_nonterminalInstruction_forGrammarComponent new
      ![leftNonTerminalName location]
      !leftNonTerminalName
      !0 # nonterminalSymbolIndex
    ] ;
    syntaxSignature += ! instruction ;
  else
    error operatorAttributes: "Valid operator attributes are:\n"
      "  - \"multiple prefix\" ;\n"
      "  - \"simple prefix\" ;\n"
      "  - \"multiple postfix\" ;\n"
      "  - \"simple postfix\" ;\n"
      "  - \"left infix\" ;\n"
      "  - \"right infix\" ;\n"
      "  - \"infix\"."
    -> leftNonTerminalName
    ;
  end if ;
  ioProductionRulesListForGrammar +=
    !leftNonTerminalName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
label importForGrammarAnalysis
  ?!@syntaxRuleList unused ioSyntaxRuleList
:
  $operator$ ;
  $literal_string$ ? * ;
  $terminal$ ? * ;
  $non_terminal_symbol$ ? * ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     N O N T E R M I N A L    D E C L A R A T I O N                           *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?!@EXsemanticContext unused ioSemanticContext
:
  $nonterminal$ ;
  @lstring ruleName ;
  $non_terminal_symbol$ ? ruleName ;
  select
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments [emptyList] ;
    @luint levelCount ;
    $unsigned_literal_integer$ ? levelCount ;
    if [levelCount uint] == 0 then
      error levelCount:"the level count should be > 0" ;
    end if ;
    @uint i := 1 ;
    loop [levelCount uint] :
      implicitDeclaration
        !ruleName
        !i
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !?ioNonTerminalSymbolsMap
        !?listeEntitesAengendrer
        !?ioProductionRulesListForGrammar
      ;
      i ++ ;
    while i <= [levelCount uint] do
    end loop ;
    #--- Nonterminal <Expression__n+1>
      @L_signature signatureForGrammar [emptyList] ;
      @M_nonterminalSymbolAlts parametersMap [emptyMap] ;
      @M_nonterminalSymbolAltsForGrammar parametersMapForGrammar [emptyMap] ;
      @lstring emptyId := [@lstring new !"" !here] ;
      [!?parametersMap insertKey !emptyId ![@L_EXsignature emptyList]] ;
      [!?parametersMapForGrammar insertKey
        !emptyId
        !signatureForGrammar
      ] ;
      @lstring actualRuleName [new
        ![ruleName string] . "__" . [[levelCount uint] + 1 string]
        ![ruleName location]
      ] ;
      [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !parametersMapForGrammar] ;
      [!?ioNonTerminalSymbolMapForSyntax insertKey !actualRuleName !parametersMap] ;
      @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !actualRuleName !parametersMap !inLexiqueClassName] ;
      listeEntitesAengendrer += !ea ;
  or
    @L_EXsignature listeDeTypesFormels0 ;
    @typeVariablesMap tableArgumentsMethode0 [emptyMap] ;
    @L_signature signatureForGrammar ;
    @M_nonterminalSymbolAltsForGrammar parametersMapForGrammar [emptyMap] ;
    @M_nonterminalSymbolAlts parametersMap [emptyMap] ;
    <formal_arguments_list>
      !ioEntitiesMap
      ?listeDeTypesFormels0
      !?tableArgumentsMethode0
      ?*
      !?tableEnAvant
      ?signatureForGrammar
    ;
    @lstring emptyId := [@lstring new !"" !here] ;
    [!?parametersMap insertKey !emptyId !listeDeTypesFormels0] ;
    [!?parametersMapForGrammar insertKey
      !emptyId
      !signatureForGrammar
    ] ;
    repeat
    while
      $label$ ;
      select
        $parse$ ;
        @L_signature signatureForGrammarComponent [emptyList] ;
        @lstring altName [new !"parse" !here] ;
        [!?parametersMap insertKey !altName ![@L_EXsignature emptyList]] ;
        [!?parametersMapForGrammar insertKey
          !altName
          !signatureForGrammarComponent
        ] ;
      or
        @lstring altName ;
        $identifier$ ? altName ;
        @L_EXsignature listeDeTypesFormels ;
        @typeVariablesMap tableArgumentsMethode [emptyMap] ;
        @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
        @L_signature signatureForGrammarComponent ;
        <formal_arguments_list>
          !ioEntitiesMap
          ?listeDeTypesFormels 
          !?tableArgumentsMethode
          ?listeTypeEtNomsArguments
          !?tableEnAvant
          ?signatureForGrammarComponent
        ;
        [!?parametersMap insertKey !altName !listeDeTypesFormels] ;
        [!?parametersMapForGrammar insertKey
          !altName
          !signatureForGrammarComponent
        ] ;
      end select ;
    end repeat ;
    [!?ioNonTerminalSymbolsMap insertKey !ruleName !parametersMapForGrammar] ;
    [!?ioNonTerminalSymbolMapForSyntax insertKey !ruleName !parametersMap] ;
    @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !ruleName !parametersMap !inLexiqueClassName] ;
    listeEntitesAengendrer += !ea ;
  end select ;
  $;$ ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  $nonterminal$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  select
    @luint levelCount ;
    $unsigned_literal_integer$ ? levelCount ;
    @uint i := 1 ;
    loop [levelCount uint] :
      implicitDeclarationImportSyntax
        !nonterminalSymbolName
        !i
        !?ioNonTerminalSymbolsMap
        !?ioProductionRulesListForGrammar
      ;
      i ++ ;
    while i <= [levelCount uint] do
    end loop ;
   #--- Nonterminal <Expression__i>
    @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap [emptyMap] ;
    [!?nonterminalSymbolParametersMap insertKey
      ![@lstring new !"" !here] # Alt Name
      ![@L_signature emptyList]
    ] ;
    @lstring actualRuleName [new
      ![nonterminalSymbolName string] . "__" . [[levelCount uint] + 1 string]
      ![nonterminalSymbolName location]
    ] ;
    [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !nonterminalSymbolParametersMap] ;
  or
    @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap [emptyMap] ;
    @L_signature signature0 ;
    <formal_arguments_list> importGrammarForSemantics ?signature0 ;
    @lstring altName := [@lstring new !"" !here] ;
    [!?nonterminalSymbolParametersMap insertKey
      !altName
      !signature0
    ] ;
    repeat
    while
      $label$ ;
      select
        $parse$ ;
        [!?nonterminalSymbolParametersMap insertKey
          ![@lstring new !"parse" !here] # Label 'parse'
          ![@L_signature emptyList]
        ] ;
      or
        $identifier$ ?altName ;
        @L_signature signature ;
        <formal_arguments_list> importGrammarForSemantics ?signature ;
        [!?nonterminalSymbolParametersMap insertKey
          !altName
          !signature
        ] ;
     end select ; 
   end repeat ;
    [!?ioNonTerminalSymbolsMap insertKey !nonterminalSymbolName !nonterminalSymbolParametersMap] ;
  end select ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxRuleList unused ioSyntaxRuleList
:
  $nonterminal$ ;
  $non_terminal_symbol$ ? * ;
  select
    $unsigned_literal_integer$ ? * ;
  or
    <formal_arguments_list> parse ;
    repeat
    while
      $label$ ;
      select
        $parse$ ;
      or
        $identifier$ ?* ;
        @L_signature signature ;
        <formal_arguments_list> parse ;
     end select ; 
   end repeat ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     P A R S I N G   P R O D U C T I O N   R U L E                            *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?!@EXsemanticContext ioSemanticContext
:
  $rule$ ;
  @lstring ruleName ;
  $non_terminal_symbol$ ? ruleName ;
  @L_EXsignature listeDeTypesFormels ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammar ;
  <formal_arguments_list>
    !ioEntitiesMap
    ?listeDeTypesFormels 
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammar
  ;
#--- Search non terminal symbol definition
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [ioNonTerminalSymbolMapForSyntax searchKey !ruleName ?nonterminalSymbolAltMap] ;
#--- Verifier la declaration de la rule et la compatibilite des arguments effectifs avec les arguments formels
  @typeAltProductionsMap altProductionsMap [emptyMap] ;
  @lstring altName := [@lstring new !"" !here] ;
#--- Parse label declared ? If Yes, check that called non terminals are also declared with 'parse' label
  @bool hasParseLabel := [nonterminalSymbolAltMap hasKey !"parse"] ;
  @bool checkNonTerminalsAreDeclaredWithParseLabel := hasParseLabel ;
#--- Parse tag ?
  @string productionTagName ;
  select
    productionTagName := "" ;
  or
    $tag$ ;
    @lstring tagName ;
    $literal_string$ ? tagName ;
    productionTagName := [tagName string] ;
  end select ;
  @location firstBranchErrorLocation := here ;
  $:$ ;
#--- Check rule header
  @L_EXsignature signaturePremiereBrancheFournieParPrototype ;
  [nonterminalSymbolAltMap searchKey
    !altName
    ?signaturePremiereBrancheFournieParPrototype
  ] ;
  verifierCompatibiliteSignatures
    !signaturePremiereBrancheFournieParPrototype
    !listeDeTypesFormels
    !firstBranchErrorLocation
  ;
#--- Insert in variable map attributes for returned entity
  @typeInstructionList listeInstructions [emptyList] ;
#--- Parse instructions list
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  <syntax_instructions_list>
    !inLexiqueClassName
    !?ioNonTerminalSymbolMapForSyntax
    !checkNonTerminalsAreDeclaredWithParseLabel
    !ioEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableArgumentsMethode
    !?listeInstructions
    !?tableTerminaux
    !?syntaxSignature
    !false # inIsInvokedWithinParseLoopInstruction
    !ioSemanticContext
  ;
  [!?altProductionsMap insertKey
    !altName
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
  ] ;
  repeat
  while
    $label$ ;
    $identifier$ ?altName ;
    tableArgumentsMethode := [@typeVariablesMap emptyMap] ;
    @L_signature signatureForGrammarComponent ;
    <formal_arguments_list>
      !ioEntitiesMap
      ?listeDeTypesFormels 
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent # unused
    ;
    @location errorLocation := here ;
    $:$ ;
    @L_EXsignature signatureFournieParPrototype ;
    [nonterminalSymbolAltMap searchKey !altName ?signatureFournieParPrototype] ;
    verifierCompatibiliteSignatures
      !signatureFournieParPrototype
      !listeDeTypesFormels
      !errorLocation
    ;
    @typeInstructionList branchInstructionList [emptyList] ;
    @L_ruleSyntaxSignature branchSyntaxSignature [emptyList] ;
    <syntax_instructions_list>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !false
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?tableArgumentsMethode
      !?branchInstructionList
      !?tableTerminaux
      !?branchSyntaxSignature
      !false # inIsInvokedWithinParseLoopInstruction
      !ioSemanticContext
    ;
    [!?altProductionsMap insertKey
      !altName
      !listeTypeEtNomsArguments
      !branchInstructionList
      !branchSyntaxSignature
      !here
    ] ;
  end repeat ;
  $end$ ;
  $rule$ ;
  $;$ ;
#--- Check if all label rules have the same syntax signature
  checkLabelSignatures !?altProductionsMap ;
#--- Check that all label rules are implemented
  foreach nonterminalSymbolAltMap do
    if [key string] != "parse" & not [altProductionsMap hasKey ![key string]] then
      error here : "the '" . [key string] . "' label is not implemented within the rule" ;
    end if ;
  end foreach ;
#--- Generate production
  @typeEntityToGenerate ea := [@typeProductionAengendrer new
    !ruleName
    !altProductionsMap
    !productionTagName
    !inLexiqueClassName
    !hasParseLabel
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  @uint ruleIndex := 0 ;
  ioProductionRulesListForGrammar +=
   !ruleName
   !ruleIndex
   !syntaxSignature
  ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  $rule$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @L_signature signature ;
  <formal_arguments_list> importGrammarForSemantics ?signature ;
  select
  or
    $tag$ ;
    $literal_string$ ? * ;
  end select ;
  $:$ ;
  @L_ruleSyntaxSignature instructionsList [emptyList] ;
  <syntax_instructions_list> importSyntax !?instructionsList ;
  repeat
  while
    $label$ ;
    $identifier$ ? * ;
    <formal_arguments_list> parse ;
    $:$ ;
    <syntax_instructions_list> parse ;
  end repeat ;
  @uint leftNonterminalSymbolIndex := 0 ;
  ioProductionRulesListForGrammar +=
    !nonterminalSymbolName
    !leftNonterminalSymbolIndex
    !instructionsList
  ;
  $end$ ;
  $rule$ ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxRuleList unused ioSyntaxRuleList
:
  $rule$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
#  @L_signature signature ;
#  <formal_arguments_list> importGrammarForSemantics ?signature ;
  <formal_arguments_list> parse ;
  select
  or
    $tag$ ;
    $literal_string$ ? * ;
  end select ;
  $:$ ;
#  @L_ruleSyntaxSignature instructionsList [emptyList] ;
#  <syntax_instructions_list> importSyntax !?instructionsList ;
  @syntaxInstructionList syntaxInstructionList [emptyList] ;
  <syntax_instructions_list> importForGrammarAnalysis !?syntaxInstructionList ;
  repeat
  while
    $label$ ;
    $identifier$ ? * ;
    <formal_arguments_list> parse ;
    $:$ ;
    @syntaxInstructionList syntaxInstructionList0 [emptyList] ;
    <syntax_instructions_list> importForGrammarAnalysis !?syntaxInstructionList0 ;
  end repeat ;
#  @uint leftNonterminalSymbolIndex := 0 ;
#  ioProductionRulesListForGrammar +=
#    !nonterminalSymbolName
#    !leftNonterminalSymbolIndex
#    !instructionsList
#  ;
  $end$ ;
  $rule$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SYNTAXIQUES D'UNE PRODUCTION             *
#------------------------------------------------------------------------------*

rule <syntax_instructions_list>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  block ioVariablesMap.verifyVariableUsing () :
    <syntax_instructions_list_no_verif>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?tableTerminaux
      !?ioSyntaxSignature
      !inIsInvokedWithinParseLoopInstruction
      !inSemanticContext
    ;
    @location positionErreur := here ;
  end block (!positionErreur) ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  <syntax_instructions_list_no_verif> importForGrammarAnalysis !?ioSyntaxInstructionList ;

end rule ;

#------------------------------------------------------------------------------*
#          Instruction de verification syntaxique $terminal$ ? ... ;           *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax unused ioNonTerminalSymbolMapForSyntax
  ?@bool unused inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool unused inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext unused inSemanticContext
:
  $terminal$ ?@lstring terminalSymbolName ;
  @typeListeAttributsSemantiques listeDesAttributsFormels ;
  [tableTerminaux searchKey !terminalSymbolName ?listeDesAttributsFormels] ;
  @L_assignedVariables listeTypeEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  <input_parameters_list>
    !inEntitiesMap
    ?listeTypeEffectifs
    ?allVariablesList
    !listeDesAttributsFormels
    !?ioVariablesMap
    !?ioInstructionList
  ;
  ioInstructionList += ![@typeInstructionVerifSyntaxique new
    !terminalSymbolName
    !listeTypeEffectifs
    !inLexiqueClassName
  ] ;
  @uint terminalSymbolIndex := 0 ;
  @AC_instruction_ForGrammar i := [@T_terminalInstruction_forGrammarComponent new ![terminalSymbolName location] !terminalSymbolName !terminalSymbolIndex] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  <input_parameters_list> parse ;
  @AC_instruction_ForGrammar instruction := [@T_terminalInstruction_forGrammarComponent new
    ![terminalSymbolName location]
    !terminalSymbolName
    !0 # terminalSymbolIndex
  ] ;
  ioInstructionList += ! instruction ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  <input_parameters_list> parse ;
  ioSyntaxInstructionList += ![@terminalCheckInstruction new
    !terminalSymbolName
    ![@actualInputParameterList emptyList]
  ] ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    N O N - T E R M I N A L    C A L L    I N S T R U C T I O N    <p> ...  ; *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string unused inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $parse$ ;
    altName := [@lstring new !"parse" !here] ;
  or
    $identifier$ ?altName ;
  end select ;
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [ioNonTerminalSymbolMapForSyntax searchKey !nonterminalSymbolName ?nonterminalSymbolAltMap] ;
  @L_EXsignature signatureMethode ;
  [nonterminalSymbolAltMap searchKey !altName ?signatureMethode] ;
#--- Check if parse label is declared ?
  if inCheckNonTerminalsAreDeclaredWithParseLabel & ([altName string] != "parse") then
    if not [nonterminalSymbolAltMap hasKey !"parse"] then
      error here : "As current rule has 'parse' label, every invoked non terminal symbol must be declared with 'parse' label" ;
    end if ;
  end if ;
  if inIsInvokedWithinParseLoopInstruction & ([altName string] != "parse") then
    if not [nonterminalSymbolAltMap hasKey !"parse"] then
      error here : "As this nonterminal is invoked within a 'parse loop ...' instruction, it must be declared with 'parse' label" ;
    end if ;
  end if ;
#--- Parse effective parameter list
  @typeExpressionList parametersExpressionList ;
  <actual_parameters_list>
    !signatureMethode
    ?parametersExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioEntitiesMap
    !?ioInstructionList
  ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeInstructionAppelNonTerminal new
    !nonterminalSymbolName
    !parametersExpressionList
    !altName
  ] ;
  ioInstructionList += !instruction ;
  @AC_instruction_ForGrammar i := [@T_nonterminalInstruction_forGrammarComponent new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0
  ] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  select
  or
    $parse$ ;
  or
    $identifier$ ? * ;
  end select ;
  <actual_parameters_list> parse ;
  @AC_instruction_ForGrammar instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0 # nonterminalSymbolIndex
  ] ;
  ioInstructionList += ! instruction ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  select
  or
    $parse$ ;
  or
    $identifier$ ? * ;
  end select ;
  <actual_parameters_list> parse ;
  ioSyntaxInstructionList += ![@nonterminalCallInstruction new
    !nonterminalSymbolName
    ![@lstring new !"" !here]
    ![@actualParameterList emptyList]
  ] ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    S E L E C T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $select$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesChoix [emptyList] ;
  @L_branchList_ForGrammarComponent selectList [emptyList] ;
  block ioVariablesMap.testBloc () :
    block ioVariablesMap.testPart () :
      @typeInstructionList firstBranchInstructionList [emptyList] ;
      @L_ruleSyntaxSignature firstBranchSyntaxSignature [emptyList] ;
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?firstBranchInstructionList
        !?tableTerminaux
        !?firstBranchSyntaxSignature
        !inIsInvokedWithinParseLoopInstruction
        !inSemanticContext
      ;
      listeBranchesChoix += !firstBranchInstructionList ;
      selectList += !firstBranchSyntaxSignature ;
    end block (!here) ;
    $or$ ;
    repeat
      block ioVariablesMap.testPart () :
        @typeInstructionList listeInstructionsBrancheChoix [emptyList] ;
        @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheChoix
          !?tableTerminaux
          !?syntaxSignature
          !inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
        listeBranchesChoix += !listeInstructionsBrancheChoix ;
        selectList += !syntaxSignature ;
      end block (!here) ;
    while
      $or$ ;
    end repeat ;
    $end$ ;
    $select$ ;
    $;$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_select_instruction new !listeBranchesChoix !positionDebut] ;
  ioInstructionList += !instruction ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_selectInstruction_forGrammarComponent new !positionDebut !selectList !v] ;
  ioSyntaxSignature += !i ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $select$ ;
  @location positionDebut := here ;
  @L_branchList_ForGrammarComponent selectList [emptyList] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  selectList += !syntaxSignature ;
  $or$ ;
  repeat
    @L_ruleSyntaxSignature syntaxSignature2 [emptyList] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature2 ;
    selectList += !syntaxSignature2 ;
  while
    $or$ ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_selectInstruction_forGrammarComponent new !positionDebut !selectList !v] ;
  ioInstructionList += !i ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  $select$ ;
  @location positionDebut := here ;
  @listOfSyntaxInstructionList selectList [emptyList] ;
  @syntaxInstructionList syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importForGrammarAnalysis !?syntaxSignature ;
  selectList += !syntaxSignature ;
  $or$ ;
  repeat
    @syntaxInstructionList syntaxSignature2 [emptyList] ;
    <syntax_instructions_list_no_verif> importForGrammarAnalysis !?syntaxSignature2 ;
    selectList += !syntaxSignature2 ;
  while
    $or$ ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  ioSyntaxInstructionList += ![@selectInstruction new
    !positionDebut
    !selectList
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#    R E P E A T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $repeat$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesRepeter [emptyList] ;
  @L_branchList_ForGrammarComponent whileList [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    @typeInstructionList listeInstructionsPremiereBranche [emptyList] ;
    @L_ruleSyntaxSignature repeatBranchInstructionsList [emptyList] ;
    block ioVariablesMap.repeatPart () :
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?listeInstructionsPremiereBranche
        !?tableTerminaux
        !?repeatBranchInstructionsList
        !inIsInvokedWithinParseLoopInstruction
        !inSemanticContext
      ;
      listeBranchesRepeter += !listeInstructionsPremiereBranche ;
      whileList += !repeatBranchInstructionsList ;
    end block (!here) ;
    $while$ ;
    repeat
      block ioVariablesMap.repeatPart () :
        @typeInstructionList listeInstructionsBrancheRepeter [emptyList];
        @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheRepeter
          !?tableTerminaux
          !?syntaxSignature
          !inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
        listeBranchesRepeter += !listeInstructionsBrancheRepeter ;
        whileList += !syntaxSignature ;
      end block (!here) ;
    while
      $while$ ;
    end repeat ;
    $end$ ;
    $repeat$ ;
  end block () ;
  $;$ ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_repeat_instruction new !listeBranchesRepeter !positionDebut] ;
  ioInstructionList += !instruction ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_repeatInstruction_forGrammarComponent new !positionDebut !whileList !v] ;
  ioSyntaxSignature += !i ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $repeat$ ;
  @location positionDebut := here ;
  @L_branchList_ForGrammarComponent repeatList [emptyList] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  repeatList += !syntaxSignature ;
  $while$ ;
  repeat
    syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
    repeatList += !syntaxSignature ;
  while
    $while$ ;
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_repeatInstruction_forGrammarComponent new !positionDebut !repeatList !v] ;
  ioInstructionList += !i ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  $repeat$ ;
  @location positionDebut := here ;
  @syntaxInstructionList repeatedInstructionList [emptyList] ;
  <syntax_instructions_list_no_verif> importForGrammarAnalysis !?repeatedInstructionList ;
  @listOfSyntaxInstructionList repeatList [emptyList] ;
  $while$ ;
  repeat
    @syntaxInstructionList syntaxSignature [emptyList] ;
    <syntax_instructions_list_no_verif> importForGrammarAnalysis !?syntaxSignature ;
    repeatList += !syntaxSignature ;
  while
    $while$ ;
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  ioSyntaxInstructionList += ![@repeatInstruction new
    !positionDebut
    !repeatedInstructionList
    !repeatList
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#    P A R S E    D O ...    R E W I N D ...    I N S T R U C T I O N          *
#    P A R S E    W H E N   ...    E L S E  ...    I N S T R U C T I O N       *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  $parse$ ;
  @typeInstruction instruction ;
  select
    $loop$ ;
  #--- Variant expression
    @typeExpression variantExpression ;
    @AC_galgasType variantResultType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?variantExpression
      ?variantResultType
    ;
    @typeGalgas_uint ui := (cast variantResultType if >= @typeGalgas_uint else error here) ;
    $while$ ;
  #--- Conditionnal expression
    @typeExpression conditionalExpression ;
    @AC_galgasType resultType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?conditionalExpression
      ?resultType
    ;
    @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
    $do$ ;
  #--- Repeated instruction list
    @typeInstructionList instructionList [emptyList] ;
    @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
    block ioVariablesMap.repeatBlock () :
      block ioVariablesMap.repeatPart () :
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionList
          !?tableTerminaux
          !?syntaxSignature
          !true # inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
      end block (!here) ;
    end block () ;
    instruction := [@C_parse_loop_instruction new
      !here
      !variantExpression
      !conditionalExpression
      !instructionList
    ] ;
  or
    $do$ ;
    @L_parse_rewind_signature_list parse_rewind_signature_list [emptyList] ;
    @location instructionStartLocation := here ;
    @typeListeBranchesInstructions branchList [emptyList] ;
  #--- First branch
    @L_branchList_ForGrammarComponent whileList [emptyList] ;
    @typeInstructionList firstBranchInstructionsList [emptyList] ;
    @L_ruleSyntaxSignature firstBranchSyntaxSignature [emptyList] ;
    <syntax_instructions_list_no_verif>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?firstBranchInstructionsList
      !?tableTerminaux
      !?firstBranchSyntaxSignature
      !inIsInvokedWithinParseLoopInstruction
      !inSemanticContext
    ;
    branchList += !firstBranchInstructionsList ;
    parse_rewind_signature_list += !firstBranchSyntaxSignature !instructionStartLocation ;
    foreach firstBranchSyntaxSignature do
      ioSyntaxSignature += !mInstruction ;
    end foreach ;
  #--- One or more 'rewind' branches
    repeat
      $rewind$ ;
      @location branchStartLocation := here ;
      @typeInstructionList instructionsList [emptyList] ;
      @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionsList
        !?tableTerminaux
        !?syntaxSignature
        !inIsInvokedWithinParseLoopInstruction
        !inSemanticContext
      ;
      branchList += !instructionsList ;
      parse_rewind_signature_list += !syntaxSignature !branchStartLocation ;
    while
    end repeat ;
    instruction := [@C_parse_rewind_instruction new !here !branchList] ;
  #--- Check all branches have the same syntax signature
    checkParseRewindSignatures !?parse_rewind_signature_list ;
  or
    @L_parse_rewind_signature_list parse_rewind_signature_list [emptyList] ;
  #--- Instruction parse when ... when ... else ... end parse ;
    @L_expression_instructionsList_list branchList [emptyList] ;
    block ioVariablesMap.testBloc () :
    #--- 'when' branches
      repeat
        block ioVariablesMap.testPart () :
          $when$ ;
          @typeExpression expression ;
          @AC_galgasType resultType ;
          <expression>
            !ioEntitiesMap
            !inOptionsComponentsMapForUse
            !inSemanticContext
            !?ioVariablesMap
            ?expression
            ?resultType
          ;
          $:$ ;
          @location branchStartLocation := here ;
          @typeInstructionList instructionsList [emptyList] ;
          @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
          <syntax_instructions_list_no_verif>
            !inLexiqueClassName
            !?ioNonTerminalSymbolMapForSyntax
            !inCheckNonTerminalsAreDeclaredWithParseLabel
            !ioEntitiesMap
            !?listeEntitesAengendrer
            !inOptionsComponentsMapForUse
            !?ioVariablesMap
            !?instructionsList
            !?tableTerminaux
            !?syntaxSignature
            !inIsInvokedWithinParseLoopInstruction
            !inSemanticContext
          ;
          branchList += !expression !instructionsList !here ;
          parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        end block (!here) ;
      while
      end repeat ;
      $else$ ;
      block ioVariablesMap.testPart () :
        @location branchStartLocation := here ;
        @typeInstructionList elseInstructionsList [emptyList] ;
        @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseInstructionsList
          !?tableTerminaux
          !?syntaxSignature
          !inIsInvokedWithinParseLoopInstruction
          !inSemanticContext
        ;
        parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        foreach syntaxSignature do
          ioSyntaxSignature += !mInstruction ;
        end foreach ;
      end block (!here) ;
    end block () ;
    instruction := [@C_parse_when_else_instruction new !branchList !elseInstructionsList] ;
  #--- Check all branches have the same syntax signature
    checkParseRewindSignatures !?parse_rewind_signature_list ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
#--- Generate instruction
  ioInstructionList += !instruction ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $parse$ ;
  select
    $loop$ ;
    <expression> parse ;
    $while$ ;
    <expression> parse ;
    $do$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  or
    $do$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
    repeat
      $rewind$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
  or
    repeat
      $when$ ;
      <expression> parse ;
      $:$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
    $else$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  $parse$ ;
  select
    $loop$ ;
    <expression> parse ;
    $while$ ;
    <expression> parse ;
    $do$ ;
    <syntax_instructions_list_no_verif> importForGrammarAnalysis !?ioSyntaxInstructionList ;
  or
    $do$ ;
    <syntax_instructions_list_no_verif> importForGrammarAnalysis !?ioSyntaxInstructionList ;
    repeat
      $rewind$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
  or
    repeat
      $when$ ;
      <expression> parse ;
      $:$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
    $else$ ;
    <syntax_instructions_list_no_verif> importForGrammarAnalysis !?ioSyntaxInstructionList ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <syntax_instructions_list_no_verif>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@bool inIsInvokedWithinParseLoopInstruction
  ??@EXsemanticContext inSemanticContext
:
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  repeat
  while
    <syntax_instruction>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?tableTerminaux
      !?ioSyntaxSignature
      !inIsInvokedWithinParseLoopInstruction
      !inSemanticContext
    ;
  while
    <semantic_instruction>
      !tableEnAvant
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !inSemanticContext
    ;
  end repeat ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  repeat
  while
    <syntax_instruction> importSyntax !?ioInstructionList ;
  while
    <semantic_instruction> parse ;
  end repeat ;
label importForGrammarAnalysis
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  repeat
  while
    <syntax_instruction> importForGrammarAnalysis !?ioSyntaxInstructionList ;
  while
    <semantic_instruction> parse ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
