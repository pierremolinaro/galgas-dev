#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS parser component parser definition                                *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parser_parser :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics parser_semantics in "parser_semantics.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring inSyntaxComponentName
  ?@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
label parse
;

nonterminal <parse_lexique_for_importing>
  ??@lstring inFileName
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label parse
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  !@entityToImplementMap outAllMetamodelClassMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label parse
;

nonterminal <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
label parse
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList

label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

nonterminal <syntax_instructions_list>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
label parse
;
 
nonterminal <syntax_instructions_list_no_verif>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
label parse
;

nonterminal <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
label getLexiqueName
  !@lstring outLexiqueName
label parse
;

extern routine checkLabelSignatures
  ?!@typeAltProductionsMap ioAltProductionMap ;

extern routine checkParseRewindSignatures
  ?!@L_parse_rewind_signature_list ioParseRewindSignature
 ;

#------------------------------------------------------------------------------*
#                                                                              *
#                      SYNTAX COMPONENT                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
:
  @typeEntitiesToGenerateList listeEntitesAengendrer ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
  $syntax$ ;
#--- Get syntax comopnent name
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
#--- Define lexique
  @M_terminalSymbolsMapForUse tableTerminaux ;
  @lstring  lexiqueName ;
  <get_lexique_infos>
    ?tableTerminaux
    !?ioLexiqueMapForUse
    ?lexiqueName
  ;
  @string defLexique := [lexiqueName string] ;
#--- Parse Inclusions
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  @entityToImplementMap allMetamodelClassMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?ioLexiqueMapForUse
    !?ioSemanticsComponentsMap
    !?ioMetamodelComponentMap
    !?ioTreewalkingComponentMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
    ?allMetamodelClassMap
  ;
  listeEntitesAengendrer := [@typeEntitiesToGenerateList emptyList] ;
  @M_nonTerminalSymbolsForGrammar nonTerminalSymbolsMapForGrammar [emptyMap] ;
  @L_productionRules_ForGrammarComponent productionRulesListForGrammar [emptyList] ;
  @M_nonTerminalSymbolForSyntax nonTerminalSymbolsMapForSyntax [emptyMap] ;
  repeat
  while
    <syntax_declaration>
      !defLexique
      !?nonTerminalSymbolsMapForSyntax
      !?entitiesMap
      !ioOptionsComponentsMapForUse
      !?tableEnAvant
      !?listeEntitesAengendrer
      !?tableTerminaux
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
      !componentName
      !allMetamodelClassMap
      !ioTreewalkingComponentMap
    ;
  while
    <semantics_declaration>
      !?entitiesMap
      !?listeEntitesAengendrer
      !ioOptionsComponentsMapForUse
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
      !ioTreewalkingComponentMap
    ;
  end repeat ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees (@lstring nomRoutine) :
    if not [tableRoutinesAimplementer hasKey ![nomRoutine string]] then
      error nomRoutine : "the routine '" . [nomRoutine string] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !componentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
#--- Generate component
  generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
  ;
#--- Fin du fichier
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
:
  $syntax$ ;
  @lstring syntaxComponentName ;
  $identifier$ ? syntaxComponentName ;
  $:$ ;
#--- Lexique
  @lstring lexiqueName ;
  @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
  <get_lexique_infos>
    ?*
    !?lexiqueMapForUse
    ?lexiqueName
  ;
#--- Import Semantics, Metamodels
  @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
  @M_grammarComponents grammarComponentsMap [emptyMap] ;
  @M_optionComponents optionsComponentsMap [emptyMap] ;  
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  @entityToImplementMap allMetamodelClassMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?lexiqueMapForUse
    !?semanticsComponentsMap
    !?ioMetamodelComponentMap
    !?ioTreewalkingComponentMap
    !?grammarComponentsMap
    !?optionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
    ?allMetamodelClassMap
  ;
#--- 
  @L_productionRules_ForGrammarComponent productionRulesListForGrammar [emptyList] ;
  @M_nonTerminalSymbolsForGrammar nonTerminalSymbolsMapForGrammar [emptyMap] ;
  repeat
  while
    <syntax_declaration> importSyntax
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
    ;
  while
    <semantics_declaration> parse ;
  end repeat ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !syntaxComponentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                   GET LEXIQUE INFOS                                          *
#                                                                              *
#------------------------------------------------------------------------------*

rule <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
:
#--- Get lexique name
  $import$ ;
  $lexique$ ;
  $identifier$ ?outLexiqueName ;
#--- 'in' clause ?
  @M_lexiqueComponents lexiqueComponentsMap ;
  select
    lexiqueComponentsMap := ioLexiqueMapForUse ;
  or
    $in$ ;
    @lstring fileName ;
    $literal_string$ ? fileName ;
    lexiqueComponentsMap := [@M_lexiqueComponents emptyMap] ;
    <parse_lexique_for_importing>
      !fileName
      !?lexiqueComponentsMap
    ;
  end select ;
#--- Get lexique from lexique components map
  [lexiqueComponentsMap searchKey !outLexiqueName ?tableTerminaux] ;
#----
  if not [ioLexiqueMapForUse hasKey ![outLexiqueName string]] then
    [!?ioLexiqueMapForUse insertKey !outLexiqueName !tableTerminaux] ;
  end if ;
  $;$ ;
label getLexiqueName
  !@lstring outLexiqueName
:
  $import$ ;
  $lexique$ ;
  $identifier$ ? outLexiqueName ;
  select
  or
    $in$ ;
    $literal_string$ ? * ;
    <parse_lexique_for_importing> parse ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                Instruction BLOC                              *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $block$ ;
#--- Nom de la map
  @lstring nomTable ;
  $identifier$ ? nomTable ;
  @AC_galgasType typeEntite ;
  @typeCplusPlusName nomCppVariableTable ;
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?typeEntite ?nomCppVariableTable] ; 
  @typeTableBlocsDeTable tableMethodesBloc :=
   [(cast typeEntite if >=@typeGalgasMapType else error nomTable) aTableMethodesSurcharger] ;
  # ¤ extract typeEntite->@typeGalgasMapType (?* ?* ?tableMethodesBloc ?* ?*) error nomTable : messageGalgasType ;
#--- Methode block
  $.$ ;
  @lstring nomMethodeBloc ;
  $identifier$ ? nomMethodeBloc ;
  @L_EXsignature signatureDebut ;
  @L_EXsignature signatureFin ;
  [tableMethodesBloc searchKey !nomMethodeBloc ?signatureDebut ?signatureFin] ;
#--- Analyser la list d'arguments du prologue
  @typeExpressionList prologueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureDebut
    ?prologueExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioEntitiesMap
    !?ioInstructionList
  ;
  $)$ ;
#--- Generate prologue instruction
  @typeInstruction instruction ;
  instruction := [@typeMapBlockPrologueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !prologueExpressionList] ;
  ioInstructionList += !instruction ;
#--- Liste d'instructions incluses
  $:$ ;
  <syntax_instructions_list_no_verif>
    !inLexiqueClassName
    !?ioNonTerminalSymbolMapForSyntax
    !inCheckNonTerminalsAreDeclaredWithParseLabel
    !ioEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    !?ioInstructionList
    !?tableTerminaux
    !?ioSyntaxSignature
    !inAllMetamodelClassMap
    !inTreewalkingComponentMap
  ;
  $end$ ;
  $block$ ;
#--- Analyser la list d'arguments de l'epilogue
  @typeExpressionList epilogueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureFin
    ?epilogueExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioEntitiesMap
    !?ioInstructionList
  ;
  $)$ ;
#--- Verifier que la map est toujours accessible en lecture/ecriture
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?* ?*] ;
#--- Generate epilogue instruction
  instruction := [@typeMapBlockEpilogueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !epilogueExpressionList] ;
  ioInstructionList += !instruction ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $block$ ;
  $identifier$ ? * ;
  $.$ ;
  $identifier$ ? * ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $:$ ;
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  $end$ ;
  $block$ ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     I M P L I C I T    N O N T E R M I N A L    D E C L A R A T I O N        *
#------------------------------------------------------------------------------*

routine implicitDeclaration
  ??@lstring inNonterminalBaseName
  ??@uint inLevel
  ??@string inReturnedEntityName
  ??@M_nonterminalSymbolAltsForGrammar parametersMapForGrammar
  ??@M_nonterminalSymbolAlts parametersMap
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
#--- Nonterminal <Expression__i>
  @lstring actualRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !parametersMapForGrammar] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !actualRuleName !parametersMap] ;
  @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !actualRuleName !parametersMap !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
#--- Nonterminal <Expression__prefix__i>
  @lstring actualPrefixName [new ![inNonterminalBaseName string] . "__prefix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPrefixName !parametersMapForGrammar] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !actualPrefixName !parametersMap] ;
  ea := [@typeNonterminalToGenerate new !actualPrefixName !parametersMap !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
#--- Nonterminal <Expression__infix__i>
  @lstring actualInfixName [new ![inNonterminalBaseName string] . "__infix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualInfixName !parametersMapForGrammar] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !actualInfixName !parametersMap] ;
  ea := [@typeNonterminalToGenerate new !actualInfixName !parametersMap !inLexiqueClassName] ;
  listeEntitesAengendrer += !ea ;
#--- Nonterminal <Expression__postfix__i>
  @lstring actualPostfixName [new ![inNonterminalBaseName string] . "__postfix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPostfixName !parametersMapForGrammar] ;
   [!?ioNonTerminalSymbolMapForSyntax insertKey !actualPostfixName !parametersMap] ;
   ea := [@typeNonterminalToGenerate new !actualPostfixName !parametersMap !inLexiqueClassName] ;
   listeEntitesAengendrer += !ea ;
#------------------------------------------ Rule <Expression__i>
  @typeAltProductionsMap altProductionsMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments [emptyList] ;
  @typeInstructionList listeInstructions [emptyList] ;
  @entityPropertyMap allPropertiesMap [emptyMap] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
#--- Building instruction list
  @typeParserInstruction instruction := [@typeInstructionAppelNonTerminal new
    !actualPrefixName
    ![@typeExpressionList emptyList]
    ![@lstring new !"" !here] #  mAltName
    ![@lstring new !"" !here] # Empty if no returned entity
    ![@lstring new !"" !here] # Empty if no returned entity
    !false # mReturnedEntityShouldInsertedInList ;
  ] ;
  listeInstructions += !instruction ;
  instruction := [@typeInstructionAppelNonTerminal new
    !actualInfixName
    ![@typeExpressionList emptyList]
    ![@lstring new !"" !here] #  mAltName
    ![@lstring new !"" !here] # Empty if no returned entity
    ![@lstring new !"" !here] # Empty if no returned entity
    !false # mReturnedEntityShouldInsertedInList ;
  ] ;
  listeInstructions += !instruction ;
  instruction := [@typeInstructionAppelNonTerminal new
    !actualPostfixName
    ![@typeExpressionList emptyList]
    ![@lstring new !"" !here] #  mAltName
    ![@lstring new !"" !here] # Empty if no returned entity
    ![@lstring new !"" !here] # Empty if no returned entity
    !false # mReturnedEntityShouldInsertedInList ;
  ] ;
  listeInstructions += !instruction ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
    !"" # ¤ inReturnedEntityName
    !"" # ¤ "e"
    !allPropertiesMap
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualRuleName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualRuleName
   !0 # Rule Index
   !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__prefix__i>
  altProductionsMap := [@typeAltProductionsMap  emptyMap] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  listeInstructions := [@typeInstructionList emptyList] ;
  allPropertiesMap := [@entityPropertyMap emptyMap] ;
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  @lstring nextRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel + 1 string] ![inNonterminalBaseName location]] ;
  instruction := [@typeInstructionAppelNonTerminal new
    !nextRuleName
    ![@typeExpressionList emptyList]
    ![@lstring new !"" !here] #  mAltName
    ![@lstring new !"" !here] # Empty if no returned entity
    ![@lstring new !"" !here] # Empty if no returned entity
    !false # mReturnedEntityShouldInsertedInList ;
  ] ;
  listeInstructions += !instruction ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
    !"" # ¤ inReturnedEntityName
    !"" # ¤ "e"
    !allPropertiesMap
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualPrefixName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualPrefixName
   !0 # Rule Index
   !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__infix__i>
  altProductionsMap := [@typeAltProductionsMap  emptyMap] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  listeInstructions := [@typeInstructionList emptyList] ;
  allPropertiesMap := [@entityPropertyMap emptyMap] ;
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
    !"" # ¤ inReturnedEntityName
    !"" # ¤ "e"
    !allPropertiesMap
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualInfixName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualInfixName
   !0 # Rule Index
   !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__postfix__i>
  altProductionsMap := [@typeAltProductionsMap  emptyMap] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  listeInstructions := [@typeInstructionList emptyList] ;
  allPropertiesMap := [@entityPropertyMap emptyMap] ;
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  [!?altProductionsMap insertKey
    ![@lstring new !"" !here] # Alt Name
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
    !"" # ¤ inReturnedEntityName
    !"" # ¤ "e"
    !allPropertiesMap
  ] ;
#--- Generate production
  ea := [@typeProductionAengendrer new
    !actualPostfixName
    !altProductionsMap
    !""
    !inLexiqueClassName
    !false
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  ioProductionRulesListForGrammar +=
   !actualPostfixName
   !0 # Rule Index
   !syntaxSignature
  ;
end routine ;

#------------------------------------------------------------------------------*

routine implicitDeclarationImportSyntax
  ??@lstring inNonterminalBaseName
  ??@uint inLevel
  ??@string unused inReturnedEntityName
  ??@M_nonterminalSymbolAltsForGrammar parametersMapForGrammar
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
#--- Nonterminal <Expression__i>
  @lstring actualRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualRuleName ! parametersMapForGrammar] ;
#--- Nonterminal <Expression__prefix__i>
  @lstring actualPrefixName [new ![inNonterminalBaseName string] . "__prefix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPrefixName ! parametersMapForGrammar] ;
#--- Nonterminal <Expression__infix__i>
  @lstring actualInfixName [new ![inNonterminalBaseName string] . "__infix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualInfixName ! parametersMapForGrammar] ;
#--- Nonterminal <Expression__postfix__i>
  @lstring actualPostfixName [new ![inNonterminalBaseName string] . "__postfix__" . [inLevel string] ![inNonterminalBaseName location]] ;
  [!?ioNonTerminalSymbolsMap insertKey !actualPostfixName ! parametersMapForGrammar] ;
#------------------------------------------ Rule <Expression__i>
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  @AC_instruction_ForGrammar instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![actualPrefixName location]
    !actualPrefixName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;

  instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![actualInfixName location]
    !actualInfixName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;

  instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![actualPostfixName location]
    !actualPostfixName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;

  ioProductionRulesListForGrammar +=
    !actualRuleName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__prefix__i>
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  @lstring nextRuleName [new ![inNonterminalBaseName string] . "__" . [inLevel + 1 string] ![inNonterminalBaseName location]] ;
  instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![nextRuleName location]
    !nextRuleName
    !0 # nonterminalSymbolIndex
  ] ;
  syntaxSignature += ! instruction ;
  ioProductionRulesListForGrammar +=
    !actualPrefixName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__infix__i>
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  ioProductionRulesListForGrammar +=
    !actualInfixName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
#------------------------------------------ Rule <Expression__postfix__i>
  syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
  ioProductionRulesListForGrammar +=
    !actualPostfixName
    !0 # leftNonterminalSymbolIndex
    !syntaxSignature
  ;
end routine ;

#------------------------------------------------------------------------------*
#     N O N T E R M I N A L    D E C L A R A T I O N                           *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $nonterminal$ ;
  @lstring ruleName ;
  $non_terminal_symbol$ ? ruleName ;
  select
    @L_EXsignature listeDeTypesFormels [emptyList] ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments [emptyList] ;
    @L_signature signatureForGrammar [emptyList] ;
    @luint levelCount ;
    $unsigned_literal_integer$ ? levelCount ;
    if [levelCount uint] == 0 then
      error levelCount:"the level count should be > 0" ;
    end if ;
    @lstring returnedEntity ;
    select
      returnedEntity := [@lstring new !"" !here] ;
    or
      $->$ ;
      $type_name$ ? returnedEntity ;
      [inAllMetamodelClassMap searchKey !returnedEntity ?8*] ;
    end select ;
    @M_nonterminalSymbolAlts parametersMap [emptyMap] ;
    @M_nonterminalSymbolAltsForGrammar parametersMapForGrammar [emptyMap] ;
    @lstring emptyId := [@lstring new !"" !here] ;
    [!?parametersMap insertKey !emptyId !listeDeTypesFormels !returnedEntity] ;
    [!?parametersMapForGrammar insertKey
      !emptyId
      !signatureForGrammar
      ![@lstring new !"" !here] # ¤ returnedEntity
    ] ;
    @uint i := 1 ;
    loop [levelCount uint] :
      implicitDeclaration
        !ruleName
        !i
        ![returnedEntity string]
        !parametersMapForGrammar
        !parametersMap
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !?ioNonTerminalSymbolsMap
        !?listeEntitesAengendrer
        !?ioProductionRulesListForGrammar
      ;
      i ++ ;
    while i <= [levelCount uint] do
    end loop ;
    #--- Nonterminal <Expression__n+1>
      @lstring actualRuleName [new
        ![ruleName string] . "__" . [[levelCount uint] + 1 string]
        ![ruleName location]
      ] ;
      [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !parametersMapForGrammar] ;
      [!?ioNonTerminalSymbolMapForSyntax insertKey !actualRuleName !parametersMap] ;
      @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !actualRuleName !parametersMap !inLexiqueClassName] ;
      listeEntitesAengendrer += !ea ;
  or
    @L_EXsignature listeDeTypesFormels ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @L_signature signatureForGrammar ;
    @M_nonterminalSymbolAltsForGrammar parametersMapForGrammar [emptyMap] ;
    @M_nonterminalSymbolAlts parametersMap [emptyMap] ;
    <formal_arguments_list>
      !ioEntitiesMap
      ?listeDeTypesFormels 
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammar
    ;
    @lstring returnedEntity ;
    @lstring mdaResultVariableName ;
    select
      returnedEntity := [@lstring new !"" !here] ;
      mdaResultVariableName := [@lstring new !"" !here] ;
    or
      $->$ ;
      $type_name$ ? returnedEntity ;
      [inAllMetamodelClassMap searchKey !returnedEntity ?8*] ;
      select
        mdaResultVariableName := [@lstring new !"" !here] ; # No variable
      or
        $identifier$ ? mdaResultVariableName ;
      end select ;
    end select ;
    @lstring emptyId := [@lstring new !"" !here] ;
    [!?parametersMap insertKey !emptyId !listeDeTypesFormels !returnedEntity] ;
    [!?parametersMapForGrammar insertKey
      !emptyId
      !signatureForGrammar
      !returnedEntity
    ] ;
    repeat
    while
      $label$ ;
      select
        $parse$ ;
        @L_EXsignature listeDeTypesFormels [emptyList] ;
        @L_signature signatureForGrammarComponent [emptyList] ;
        @lstring altName [new !"parse" !here] ;
        [!?parametersMap insertKey !altName !listeDeTypesFormels ![@lstring new !"" !here]] ;
        [!?parametersMapForGrammar insertKey
          !altName
          !signatureForGrammarComponent
          ![@lstring new !"" !here]
        ] ;
      or
        @lstring altName ;
        $identifier$ ? altName ;
        @L_EXsignature listeDeTypesFormels ;
        @typeVariablesMap tableArgumentsMethode [emptyMap] ;
        @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
        @L_signature signatureForGrammarComponent ;
        <formal_arguments_list>
          !ioEntitiesMap
          ?listeDeTypesFormels 
          !?tableArgumentsMethode
          ?listeTypeEtNomsArguments
          !?tableEnAvant
          ?signatureForGrammarComponent
        ;
        @lstring returnedEntity ;
        select
          returnedEntity := [@lstring new !"" !here] ;
        or
          $->$ ;
          $type_name$ ? returnedEntity ;
          @AC_semanticsEntity e ;
          [ioEntitiesMap searchKey !returnedEntity ?e] ;
          @AC_galgasType type :=
            [(cast e if >= @typeEntiteType else error returnedEntity) aDefType] ;
          @typeGalgas_singleReferenceEntity sre :=
            (cast type if >= @typeGalgas_singleReferenceEntity else error returnedEntity) ;
        end select ;
        [!?parametersMap insertKey !altName !listeDeTypesFormels !returnedEntity] ;
        [!?parametersMapForGrammar insertKey
          !altName
          !signatureForGrammarComponent
          !returnedEntity
        ] ;
      end select ;
    end repeat ;
    [!?ioNonTerminalSymbolsMap insertKey !ruleName !parametersMapForGrammar] ;
    [!?ioNonTerminalSymbolMapForSyntax insertKey !ruleName !parametersMap] ;
    @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !ruleName !parametersMap !inLexiqueClassName] ;
    listeEntitesAengendrer += !ea ;
  end select ;
  $;$ ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  $nonterminal$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  select
    @luint levelCount ;
    $unsigned_literal_integer$ ? levelCount ;
    @lstring returnedEntity ;
    select
      returnedEntity := [@lstring new !"" !here] ;
    or
      $->$ ;
      $type_name$ ? returnedEntity ;
    end select ;
    @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap [emptyMap] ;
    @lstring altName := [@lstring new !"" !here] ;
    [!?nonterminalSymbolParametersMap insertKey
      !altName
      ![@L_signature emptyList]
      ![@lstring new !"" !here] # ¤ returnedEntity
    ] ;
    @uint i := 1 ;
    loop [levelCount uint] :
      implicitDeclarationImportSyntax
        !nonterminalSymbolName
        !i
        ![returnedEntity string]
        !nonterminalSymbolParametersMap
        !?ioNonTerminalSymbolsMap
        !?ioProductionRulesListForGrammar
      ;
      i ++ ;
    while i <= [levelCount uint] do
    end loop ;
    #--- Nonterminal <Expression__i>
      @lstring actualRuleName [new
        ![nonterminalSymbolName string] . "__" . [[levelCount uint] + 1 string]
        ![nonterminalSymbolName location]
      ] ;
      [!?ioNonTerminalSymbolsMap insertKey !actualRuleName !nonterminalSymbolParametersMap] ;
  or
    @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap [emptyMap] ;
    @L_signature signature ;
    <formal_arguments_list> importGrammarForSemantics ?signature ;
    @lstring returnedEntity ;
    select
      returnedEntity := [@lstring new !"" !here] ;
    or
      $->$ ;
      $type_name$ ? returnedEntity ;
      select
      or
        $identifier$ ? * ;
      end select ;
    end select ;
    @lstring altName := [@lstring new !"" !here] ;
    [!?nonterminalSymbolParametersMap insertKey
      !altName
      !signature
      !returnedEntity
    ] ;
    repeat
    while
      $label$ ;
      select
        $parse$ ;
        @L_signature signature [emptyList] ;
        @lstring noReturnedEntity := [@lstring new !"" !here] ;
        [!?nonterminalSymbolParametersMap insertKey
          ![@lstring new !"parse" !here] # Label 'parse'
          !signature
          !noReturnedEntity
        ] ;
      or
        $identifier$ ?altName ;
        @L_signature signature ;
        <formal_arguments_list> importGrammarForSemantics ?signature ;
        @lstring returnedEntity ;
        select
          returnedEntity := [@lstring new !"" !here] ;
        or
          $->$ ;
          $type_name$ ? returnedEntity ;
        end select ;
        [!?nonterminalSymbolParametersMap insertKey
          !altName
          !signature
          !returnedEntity
        ] ;
      end select ;
    end repeat ;
    [!?ioNonTerminalSymbolsMap insertKey !nonterminalSymbolName !nonterminalSymbolParametersMap] ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     P A R S I N G   P R O D U C T I O N   R U L E                            *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring unused inSyntaxComponentName
  ?@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $rule$ ;
  @lstring ruleName ;
  $non_terminal_symbol$ ? ruleName ;
  @L_EXsignature listeDeTypesFormels ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammar ;
  <formal_arguments_list>
    !ioEntitiesMap
    ?listeDeTypesFormels 
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammar
  ;
  @lstring returnedEntity ;
  @lstring mdaResultVariableName ;
  select
    returnedEntity := [@lstring new !"" !here] ;
    mdaResultVariableName := [@lstring new !"" !here] ;
  or
    $->$ ;
    $type_name$ ? returnedEntity ;
    [inAllMetamodelClassMap searchKey !returnedEntity ?8*] ;
    select
      mdaResultVariableName := [@lstring new !"" !here] ; # No variable
    or
      $identifier$ ? mdaResultVariableName ;
    end select ;
  end select ;
#--- Search non terminal symbol definition
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [ioNonTerminalSymbolMapForSyntax searchKey !ruleName ?nonterminalSymbolAltMap] ;
#--- Verifier la declaration de la rule et la compatibilite des arguments effectifs avec les arguments formels
  @typeAltProductionsMap altProductionsMap [emptyMap] ;
  @lstring altName := [@lstring new !"" !here] ;
#--- Parse label declared ? If Yes, check that called non terminals are also declared with 'parse' label
  @bool hasParseLabel := [nonterminalSymbolAltMap hasKey !"parse"] ;
  @bool checkNonTerminalsAreDeclaredWithParseLabel := hasParseLabel ;
#--- Parse tag ?
  @string productionTagName ;
  select
    productionTagName := "" ;
  or
    $tag$ ;
    @lstring tagName ;
    $literal_string$ ? tagName ;
    productionTagName := [tagName string] ;
  end select ;
  @location firstBranchErrorLocation := here ;
  $:$ ;
#--- Check rule header
  @L_EXsignature signaturePremiereBrancheFournieParPrototype ;
  @lstring formalReturnedEntity ;
  [nonterminalSymbolAltMap searchKey
    !altName
    ?signaturePremiereBrancheFournieParPrototype
    ?formalReturnedEntity
  ] ;
  verifierCompatibiliteSignatures
    !signaturePremiereBrancheFournieParPrototype
    !listeDeTypesFormels
    !firstBranchErrorLocation
  ;
  if ([formalReturnedEntity string] == "") & ([returnedEntity string] != "") then
    error returnedEntity: "the non terminal declaration does not name any returned entity" ;
  elsif [returnedEntity string] != [formalReturnedEntity string] then
    @typeSuperClassesMap superEntityMap ;
    [inAllMetamodelClassMap searchKey ! returnedEntity ?4* ?superEntityMap ?3*] ;
    if not [superEntityMap hasKey ![formalReturnedEntity string]] then
      # message "superEntityStringSet : " . [superEntityStringSet description] ;
      error returnedEntity: "the '@" . [formalReturnedEntity string] . "' entity or one of its inherited entities is expected here" ;
    end if ;
  end if ;
#--- Insert in variable map attributes for returned entity
  @typeInstructionList listeInstructions [emptyList] ;
  @entityPropertyMap allPropertiesMap [emptyMap] ;
  if [mdaResultVariableName string] != "" then
    @typeListeAttributsSemantiques propertyList ;
    @typeSuperClassesMap superEntityMap ;
    [inAllMetamodelClassMap searchKey
      !returnedEntity
      ?4*
      ?superEntityMap
      ?propertyList
      ?2*
    ] ;
    @AC_galgasType definitionType := [@typeGalgas_singleReferenceEntity new
      !returnedEntity
      !propertyList
      ![superEntityMap allKeys]
    ] ;
    @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![mdaResultVariableName location] ![mdaResultVariableName string]] ;
    [!?tableArgumentsMethode insertSingleEntityLocalVariable !mdaResultVariableName !definitionType !nomCppVariable] ;
    listeInstructions += ![@typeInstructionDeclarationVarLocale new !nomCppVariable !definitionType] ;
  elsif [returnedEntity string] != "" then
    [inAllMetamodelClassMap searchKey !returnedEntity ?allPropertiesMap ?7*] ;
    foreach allPropertiesMap (@lstring kKey @AC_galgasType kPropertyType) :
      cast kPropertyType :
      when >= @typeGalgas_singleReferenceEntity do # § (@lstring kReferenceEntityName 2*) ->
        @lstring nomVariable := [@lstring new ![kKey string] ![returnedEntity location]] ;
        @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![nomVariable location] ! [nomVariable string]] ;
        [!?tableArgumentsMethode insertSingleEntityLocalVariable !nomVariable !kPropertyType !nomCppVariable] ;
        @typeInstruction instruction := [@typeInstructionDeclarationVarLocale new !nomCppVariable !kPropertyType] ;
        listeInstructions += !instruction ;
      when >= @typeGalgas_multipleReferenceEntity e do # § (@lstring kReferenceEntityName 2*) ->
        @lstring nomVariable := [@lstring new ![kKey string] ![returnedEntity location]] ;
        @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![nomVariable location] ! [nomVariable string]] ;
        [!?tableArgumentsMethode insertListOfEntitiesLocalVariable !nomVariable !kPropertyType !nomCppVariable] ;
        @typeExpression sourceExpression := [@typeConstructorExpression new
          !"_list_" . [[e mEntityTypeName] string]
          !"emptyList"
          ![@typeExpressionList emptyList]
        ] ;
        @typeInstruction instruction := [@C_declarationInstructionWithAssignment new
          !kPropertyType
          !nomCppVariable
          !sourceExpression
        ] ;
        listeInstructions += !instruction ;
      else
        @lstring nomVariable := [@lstring new ![kKey string] ![returnedEntity location]] ;
        @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![nomVariable location] ! [nomVariable string]] ;
        [!?tableArgumentsMethode insertEntityAttributeLocalVariable !nomVariable !kPropertyType !nomCppVariable] ;
        @typeInstruction instruction := [@typeInstructionDeclarationVarLocale new !nomCppVariable !kPropertyType] ;
        listeInstructions += !instruction ;
      end cast ;
    end foreach ;
  end if ;
#--- Parse instructions list
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  <syntax_instructions_list>
    !inLexiqueClassName
    !?ioNonTerminalSymbolMapForSyntax
    !checkNonTerminalsAreDeclaredWithParseLabel
    !ioEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableArgumentsMethode
    !?listeInstructions
    !?tableTerminaux
    !?syntaxSignature
    !inAllMetamodelClassMap
    !inTreewalkingComponentMap
  ;
  [!?altProductionsMap insertKey
    !altName
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
    ![returnedEntity string]
    ![mdaResultVariableName string]
    !allPropertiesMap
  ] ;
  repeat
  while
    $label$ ;
    $identifier$ ?altName ;
    tableArgumentsMethode := [@typeVariablesMap emptyMap] ;
    @L_signature signatureForGrammarComponent ;
    <formal_arguments_list>
      !ioEntitiesMap
      ?listeDeTypesFormels 
      !? tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent # unused
    ;
    @lstring returnedEntity ;
    select
      returnedEntity := [@lstring new !"" !here] ;
    or
      $->$ ;
      $type_name$ ? returnedEntity ;
      [inAllMetamodelClassMap searchKey !returnedEntity ?8*] ;
    end select ;
    @location errorLocation := here ;
    $:$ ;
    @L_EXsignature signatureFournieParPrototype ;
    @lstring returnedEntityFromPrototype ;
    [nonterminalSymbolAltMap searchKey !altName ?signatureFournieParPrototype ?returnedEntityFromPrototype] ;
    verifierCompatibiliteSignatures
      !signatureFournieParPrototype
      !listeDeTypesFormels
      !errorLocation
    ;
    @typeInstructionList branchInstructionList [emptyList] ;
    @L_ruleSyntaxSignature branchSyntaxSignature [emptyList] ;
    <syntax_instructions_list>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !false
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !? tableArgumentsMethode
      !?branchInstructionList
      !?tableTerminaux
      !?branchSyntaxSignature
      !inAllMetamodelClassMap
      !inTreewalkingComponentMap
    ;
    [!?altProductionsMap insertKey
      !altName
      !listeTypeEtNomsArguments
      !branchInstructionList
      !branchSyntaxSignature
      !here
      ![returnedEntity string]
      ![mdaResultVariableName string]
      ![@entityPropertyMap emptyMap]
    ] ;
  end repeat ;
  $end$ ;
  $rule$ ;
  $;$ ;
#--- Check if all label rules have the same syntax signature
  checkLabelSignatures !?altProductionsMap ;
#--- Check that all label rules are implemented
  foreach nonterminalSymbolAltMap (@lstring nonTerminalAltName @L_EXsignature altSignature @lstring kReturnedEntity) :
    if [nonTerminalAltName string] != "parse" & not [altProductionsMap hasKey ![nonTerminalAltName string]] then
      error here : "the '" . [nonTerminalAltName string] . "' label is not implemented within the rule" ;
    end if ;
  end foreach ;
#--- Generate production
  @typeEntityToGenerate ea := [@typeProductionAengendrer new
    !ruleName
    !altProductionsMap
    !productionTagName
    !inLexiqueClassName
    !hasParseLabel
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  @uint ruleIndex := 0 ;
  ioProductionRulesListForGrammar +=
   !ruleName
   !ruleIndex
   !syntaxSignature
  ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  $rule$ ;
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @L_signature signature ;
  <formal_arguments_list> importGrammarForSemantics ?signature ;
  @lstring returnedEntity ;
  select
    returnedEntity := [@lstring new !"" !here] ;
  or
    $->$ ;
    $type_name$ ? returnedEntity ;
    select
    or
      $identifier$ ? * ;
    end select ;
  end select ;
  select
  or
    $tag$ ;
    $literal_string$ ? * ;
  end select ;
  $:$ ;
  @L_ruleSyntaxSignature instructionsList [emptyList] ;
  <syntax_instructions_list> importSyntax !?instructionsList ;
  repeat
  while
    $label$ ;
    $identifier$ ? * ;
    <formal_arguments_list> parse ;
    select
    or
      $->$ ;
      $type_name$ ? * ;
    end select ;
    $:$ ;
    <syntax_instructions_list> parse ;
  end repeat ;
  @uint leftNonterminalSymbolIndex := 0 ;
  ioProductionRulesListForGrammar +=
    !nonterminalSymbolName
    !leftNonterminalSymbolIndex
    !instructionsList
  ;
  $end$ ;
  $rule$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SYNTAXIQUES D'UNE PRODUCTION             *
#------------------------------------------------------------------------------*

rule <syntax_instructions_list>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  block ioVariablesMap.verifyVariableUsing () :
    <syntax_instructions_list_no_verif>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?tableTerminaux
      !?ioSyntaxSignature
      !inAllMetamodelClassMap
      !inTreewalkingComponentMap
    ;
    @location positionErreur := here ;
  end block (!positionErreur) ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
end rule ;

#------------------------------------------------------------------------------*
#          Instruction de verification syntaxique $terminal$ ? ... ;           *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax unused ioNonTerminalSymbolMapForSyntax
  ?@bool unused inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap unused inAllMetamodelClassMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  @typeListeAttributsSemantiques listeDesAttributsFormels ;
  [tableTerminaux searchKey !terminalSymbolName ?listeDesAttributsFormels] ;
  @L_assignedVariables listeTypeEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  <input_parameters_list>
    ?listeTypeEffectifs
    ?allVariablesList
    !listeDesAttributsFormels
    !?ioVariablesMap
  ;
  @typeInstruction instruction ;
  instruction := [@typeInstructionVerifSyntaxique new
    !terminalSymbolName
    !listeTypeEffectifs
    !inLexiqueClassName
  ] ;
  ioInstructionList += !instruction ;
  @uint terminalSymbolIndex := 0 ;
  @AC_instruction_ForGrammar i := [@T_terminalInstruction_forGrammarComponent new ![terminalSymbolName location] !terminalSymbolName !terminalSymbolIndex] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  <input_parameters_list> parse ;
  @AC_instruction_ForGrammar i ;
  @uint terminalSymbolIndex := 0 ;
  i := [@T_terminalInstruction_forGrammarComponent new ![terminalSymbolName location] !terminalSymbolName !terminalSymbolIndex] ;
  ioInstructionList += !i ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    N O N - T E R M I N A L    C A L L    I N S T R U C T I O N    <p> ...  ; *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string unused inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $parse$ ;
    altName := [@lstring new !"parse" !here] ;
  or
    $identifier$ ?altName ;
  end select ;
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [ioNonTerminalSymbolMapForSyntax searchKey !nonterminalSymbolName ?nonterminalSymbolAltMap] ;
  @L_EXsignature signatureMethode ;
  @lstring returnedEntityFromSignature ;
  [nonterminalSymbolAltMap searchKey !altName ?signatureMethode ?returnedEntityFromSignature] ;
#--- Check if parse label is declared ?
  if inCheckNonTerminalsAreDeclaredWithParseLabel & ([altName string] != "parse") then
    if not [nonterminalSymbolAltMap hasKey !"parse"] then
      error here : "As current rule has 'parse' label, every invoked non terminal symbol must be declared with 'parse' label" ;
    end if ;
  end if ;
#--- Parse effective parameter list
  @typeExpressionList parametersExpressionList ;
  <actual_parameters_list>
    !signatureMethode
    ?parametersExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioEntitiesMap
    !?ioInstructionList
  ;
#--- Parse returned value
  @lstring returnedEntityVariableName ;
  @bool isMultipleEntity := false ;
  select
    returnedEntityVariableName := [@lstring new !"" !here] ;
  or
    $->$ ;
    $identifier$ ? returnedEntityVariableName ;
  or
    $+>$ ;
    $identifier$ ? returnedEntityVariableName ;
    isMultipleEntity := true ;
  end select ;
  @lstring variableEntityName [new !"" !here] ;
#--- Check returned value
  if ([returnedEntityFromSignature string] == "") & ([returnedEntityVariableName string] != "") then
    error returnedEntityVariableName: "the non terminal symbol is declared with no returned entity" ;
  elsif ([returnedEntityFromSignature string] != "") & ([returnedEntityVariableName string] == "") then
    error returnedEntityVariableName: "the non terminal symbol is declared to return an instance of '@" .  [returnedEntityFromSignature  string] . "' entity" ;
  elsif ([returnedEntityFromSignature string] != "") & ([returnedEntityVariableName string] != "") then
  #--- Check type consistency
    if isMultipleEntity then
      @AC_galgasType type ;
      [!?ioVariablesMap searchForReadWriteAccess !returnedEntityVariableName ?type ?*] ;
      variableEntityName := [(cast type if >= @typeGalgas_multipleReferenceEntity else error returnedEntityVariableName) mEntityTypeName] ;
      #extract type->@typeGalgas_multipleReferenceEntity (?variableEntityName ?2*) error returnedEntityVariableName : messageGalgasType ;
    else
      @AC_galgasType type ;
      [!?ioVariablesMap searchForWriteAccess !returnedEntityVariableName ?type ?*] ;
      variableEntityName :=
          [(cast type if >= @typeGalgas_singleReferenceEntity else error returnedEntityVariableName) mEntityTypeName] ;
      # ¤ extract type->@typeGalgas_singleReferenceEntity (?variableEntityName ?2*) error returnedEntityVariableName : messageGalgasType ;
    end if ;
   #--- The returnedEntityFromSignature entity should be a super class of variableEntityName
    @bool ok := [returnedEntityFromSignature string] == [variableEntityName string] ;
    if not ok then
      @lstring testedClass := returnedEntityFromSignature ;
      loop [inAllMetamodelClassMap count] :
      while (not ok) & ([testedClass length] > 0) do
        @lstring superEntity ;
        [inAllMetamodelClassMap searchKey !testedClass ?3* ?superEntity ?4*] ;
        testedClass := superEntity ;
        ok := [testedClass string] == [variableEntityName string] ;
      end loop ;
    end if ;
    if not ok then
      error returnedEntityVariableName : "the type of this variable is '%" . [variableEntityName string]
       . "' and is not a super class of '%" . [returnedEntityFromSignature string] . "'" ;
    end if ;
  end if ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeInstructionAppelNonTerminal new
    !nonterminalSymbolName
    !parametersExpressionList
    !altName
    !returnedEntityVariableName
    !variableEntityName
    !isMultipleEntity
  ] ;
  ioInstructionList += !instruction ;
  @AC_instruction_ForGrammar i := [@T_nonterminalInstruction_forGrammarComponent new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0
  ] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  @lstring nonterminalSymbolName ;
  $non_terminal_symbol$ ? nonterminalSymbolName ;
  select
  or
    $parse$ ;
  or
    $identifier$ ? * ;
  end select ;
  <actual_parameters_list> parse ;
  @AC_instruction_ForGrammar instruction := [@T_nonterminalInstruction_forGrammarComponent new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0 # nonterminalSymbolIndex
  ] ;
  ioInstructionList += ! instruction ;
  select
  or
    $->$ ;
    $identifier$ ? * ;
  or
    $+>$ ;
    $identifier$ ? * ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    S E L E C T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $select$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesChoix [emptyList] ;
  @L_branchList_ForGrammarComponent selectList [emptyList] ;
  block ioVariablesMap.testBloc () :
    block ioVariablesMap.testPart () :
      @typeInstructionList firstBranchInstructionList [emptyList] ;
      @L_ruleSyntaxSignature firstBranchSyntaxSignature [emptyList] ;
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?firstBranchInstructionList
        !?tableTerminaux
        !?firstBranchSyntaxSignature
        !inAllMetamodelClassMap
        !inTreewalkingComponentMap
      ;
      listeBranchesChoix += !firstBranchInstructionList ;
      selectList += !firstBranchSyntaxSignature ;
    end block (!here) ;
    $or$ ;
    repeat
      block ioVariablesMap.testPart () :
        @typeInstructionList listeInstructionsBrancheChoix [emptyList] ;
        @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheChoix
          !?tableTerminaux
          !?syntaxSignature
          !inAllMetamodelClassMap
          !inTreewalkingComponentMap
        ;
        listeBranchesChoix += !listeInstructionsBrancheChoix ;
        selectList += !syntaxSignature ;
      end block (!here) ;
    while
      $or$ ;
    end repeat ;
    $end$ ;
    $select$ ;
    $;$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_select_instruction new !listeBranchesChoix !positionDebut] ;
  ioInstructionList += !instruction ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_selectInstruction_forGrammarComponent new !positionDebut !selectList !v] ;
  ioSyntaxSignature += !i ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $select$ ;
  @location positionDebut := here ;
  @L_branchList_ForGrammarComponent selectList [emptyList] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  selectList += !syntaxSignature ;
  $or$ ;
  repeat
    @L_ruleSyntaxSignature syntaxSignature2 [emptyList] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature2 ;
    selectList += !syntaxSignature2 ;
  while
    $or$ ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_selectInstruction_forGrammarComponent new !positionDebut !selectList !v] ;
  ioInstructionList += !i ;
end rule ;

#------------------------------------------------------------------------------*
#    R E P E A T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $repeat$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesRepeter [emptyList] ;
  @L_branchList_ForGrammarComponent whileList [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    @typeInstructionList listeInstructionsPremiereBranche [emptyList] ;
    @L_ruleSyntaxSignature repeatBranchInstructionsList [emptyList] ;
    block ioVariablesMap.repeatPart () :
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?listeInstructionsPremiereBranche
        !?tableTerminaux
        !?repeatBranchInstructionsList
        !inAllMetamodelClassMap
        !inTreewalkingComponentMap
       ;
      listeBranchesRepeter += !listeInstructionsPremiereBranche ;
      whileList += !repeatBranchInstructionsList ;
      @location positionErreurPremiereBranche := here ;
    end block (!positionErreurPremiereBranche) ;
    $while$ ;
    repeat
      block ioVariablesMap.repeatPart () :
        @typeInstructionList listeInstructionsBrancheRepeter [emptyList];
        @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheRepeter
          !?tableTerminaux
          !?syntaxSignature
          !inAllMetamodelClassMap
          !inTreewalkingComponentMap
        ;
        listeBranchesRepeter += !listeInstructionsBrancheRepeter ;
        whileList += !syntaxSignature ;
      end block (!here) ;
    while
      $while$ ;
    end repeat ;
    $end$ ;
    $repeat$ ;
  end block () ;
  $;$ ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_repeat_instruction new !listeBranchesRepeter !positionDebut] ;
  ioInstructionList += !instruction ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_repeatInstruction_forGrammarComponent new !positionDebut !whileList !v] ;
  ioSyntaxSignature += !i ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $repeat$ ;
  @location positionDebut := here ;
  @L_branchList_ForGrammarComponent repeatList [emptyList] ;
  @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  repeatList += !syntaxSignature ;
  $while$ ;
  repeat
    syntaxSignature := [@L_ruleSyntaxSignature emptyList] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
    repeatList += !syntaxSignature ;
  while
    $while$ ;
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_repeatInstruction_forGrammarComponent new !positionDebut !repeatList !v] ;
  ioInstructionList += !i ;
end rule ;

#------------------------------------------------------------------------------*
#    P A R S E    D O ...    R E W I N D ...    I N S T R U C T I O N          *
#    P A R S E    W H E N   ...    E L S E  ...    I N S T R U C T I O N       *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $parse$ ;
  @typeInstruction instruction ;
  @L_parse_rewind_signature_list parse_rewind_signature_list [emptyList] ;
  select
    $do$ ;
    @location instructionStartLocation := here ;
    @typeListeBranchesInstructions branchList [emptyList] ;
  #--- First branch
    @L_branchList_ForGrammarComponent whileList [emptyList] ;
    @typeInstructionList firstBranchInstructionsList [emptyList] ;
    @L_ruleSyntaxSignature firstBranchSyntaxSignature [emptyList] ;
    <syntax_instructions_list_no_verif>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?firstBranchInstructionsList
      !?tableTerminaux
      !?firstBranchSyntaxSignature
      !inAllMetamodelClassMap
      !inTreewalkingComponentMap
    ;
    branchList += !firstBranchInstructionsList ;
    parse_rewind_signature_list += !firstBranchSyntaxSignature !instructionStartLocation ;
    foreach firstBranchSyntaxSignature (@AC_instruction_ForGrammar grammarInstruction) :
      ioSyntaxSignature += !grammarInstruction ;
    end foreach ;
  #--- One or more 'rewind' branches
    repeat
      $rewind$ ;
      @location branchStartLocation := here ;
      @typeInstructionList instructionsList [emptyList] ;
      @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
      <syntax_instructions_list_no_verif>
        !inLexiqueClassName
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !ioEntitiesMap
        !?listeEntitesAengendrer
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionsList
        !?tableTerminaux
        !?syntaxSignature
        !inAllMetamodelClassMap
        !inTreewalkingComponentMap
      ;
      branchList += !instructionsList ;
      parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
    while
    end repeat ;
    instruction := [@C_parse_rewind_instruction new !here !branchList] ;
  or
  #--- Instruction parse when ... when ... else ... end parse ;
    @L_expression_instructionsList_list branchList [emptyList] ;
    block ioVariablesMap.testBloc () :
    #--- 'when' branches
      repeat
        block ioVariablesMap.testPart () :
          $when$ ;
          @typeExpression expression ;
          @AC_galgasType resultType ;
          <expression>
            !ioEntitiesMap
            !inOptionsComponentsMapForUse
            !?ioVariablesMap
            ?expression
            ?resultType
          ;
          $:$ ;
          @location branchStartLocation := here ;
          @typeInstructionList instructionsList [emptyList] ;
          @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
          <syntax_instructions_list_no_verif>
            !inLexiqueClassName
            !?ioNonTerminalSymbolMapForSyntax
            !inCheckNonTerminalsAreDeclaredWithParseLabel
            !ioEntitiesMap
            !?listeEntitesAengendrer
            !inOptionsComponentsMapForUse
            !?ioVariablesMap
            !?instructionsList
            !?tableTerminaux
            !?syntaxSignature
            !inAllMetamodelClassMap
            !inTreewalkingComponentMap
          ;
          branchList += !expression !instructionsList ;
          parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        end block (!here) ;
      while
      end repeat ;
      $else$ ;
      block ioVariablesMap.testPart () :
        @location branchStartLocation := here ;
        @typeInstructionList elseInstructionsList [emptyList] ;
        @L_ruleSyntaxSignature syntaxSignature [emptyList] ;
        <syntax_instructions_list_no_verif>
          !inLexiqueClassName
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !ioEntitiesMap
          !?listeEntitesAengendrer
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseInstructionsList
          !?tableTerminaux
          !?syntaxSignature
          !inAllMetamodelClassMap
          !inTreewalkingComponentMap
        ;
        parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        foreach syntaxSignature (@AC_instruction_ForGrammar grammarInstruction) :
          ioSyntaxSignature += !grammarInstruction ;
        end foreach ;
      end block (!here) ;
    end block () ;
    instruction := [@C_parse_when_else_instruction new !branchList !elseInstructionsList] ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
#--- Generate instruction
  ioInstructionList += !instruction ;
#--- Check all branches have the same syntax signature
  checkParseRewindSignatures !?parse_rewind_signature_list ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  $parse$ ;
  select
    $do$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
    repeat
      $rewind$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
  or
    repeat
      $when$ ;
      <expression> parse ;
      $:$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
    $else$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionList ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <syntax_instructions_list_no_verif>
  ??@string inLexiqueClassName
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
  ??@entityToImplementMap inAllMetamodelClassMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  @entityPropertyMap propertyMap [emptyMap] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @treewalkingRoutineHeaderMap treewalkingRoutineHeaderMap [emptyMap] ;
  repeat
  while
    <syntax_instruction>
      !inLexiqueClassName
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !ioEntitiesMap
      !?listeEntitesAengendrer
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?tableTerminaux
      !?ioSyntaxSignature
      !inAllMetamodelClassMap
      !inTreewalkingComponentMap
    ;
  while
    <semantic_instruction>
      !treewalkingRoutineHeaderMap
      !tableEnAvant
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !propertyMap
      !inAllMetamodelClassMap
      !inTreewalkingComponentMap
    ;
  end repeat ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionList
:
  repeat
  while
    <syntax_instruction> importSyntax !?ioInstructionList ;
  while
    <semantic_instruction> parse ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
