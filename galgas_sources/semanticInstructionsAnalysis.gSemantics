#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2010, ..., 2012 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticInstructionsAnalysis :
  import "semanticExpressionAnalysis.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I N S T R U C T I O N    A N A L Y S I S                               *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

list @localConstantList {
  @unifiedTypeMapProxy mType ;
  @lstring mName ;
  @bool mNoWarningIfUnused ;
  @string mCppName ;
}

#---------------------------------------------------------------------------*

list @localInitializedVariableList {
  @unifiedTypeMapProxy mType ;
  @lstring mName ;
  @string mCppName ;
}

#---------------------------------------------------------------------------*

routine analyzeSemanticInstructionList
  ??@analysisContext inAnalysisContext
  ??@localConstantList inLocalConstantList
  ??@localInitializedVariableList inLocalInitializedVariableList
  ??@semanticInstructionListAST inSemanticInstructionListAST
  ??@location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap openBranch] ;
#--- Declare local constants
  foreach inLocalConstantList do
    if mNoWarningIfUnused then
      [!?ioVariableMap insertUsedLocalConstant !mName !mType !mCppName !mCppName] ;
    else
      [!?ioVariableMap insertLocalConstant !mName !mType !mCppName !mCppName] ;
    end if ;
  end foreach ;
#--- Declare local variables
  foreach inLocalInitializedVariableList do
    [!?ioVariableMap insertDefinedLocalVariable !mName !mType !mCppName !mCppName] ;
  end foreach ;
#--- Instruction list
  foreach inSemanticInstructionListAST do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outInstructionListForGeneration
      !?ioVariableMap
    ] ;
  end foreach ;
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithDefaultConstructorAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check variable type
  const targetType := [@unifiedTypeMapProxy searchKey
    !inAnalysisContext->mSemanticContext->mTypeMap
    !mTypeName
  ] ;
#--- Check type accepts default constructor
  if not [targetType mIsConcrete] then
    error mTypeName: "an abstract class does not support the default constructor" ;
  elsif [targetType mDefaultConstructorName] == "" then
    error mTypeName: "this class does not support the default constructor" ;
  end if ;
#--- Declare variable (or constant)
  const targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithDefaultConstructorForGeneration new
    !mInstructionLocation
    !targetType
    !mIsConstant
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze constructor call
  analyzeConstructorInvocation
    !inAnalysisContext
    !?ioVariableMap
    !mTypeName
    !mConstructorName
    !mConstructorExpressions
    ?@unifiedTypeMapProxy returnedType
    ?*
    ?@semanticExpressionListForGeneration constructorEffectiveParameterList
    ?@bool hasCompilerArgument
  ;
#--- Check variable type
  const targetType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  if targetType != returnedType then
    error mConstructorName
    :"this constructor returns an '@" . [returnedType key] ."' object, you should use a constructor that return an '@" . mTypeName . "' object"
    ;
  end if ;
#--- Declare variable (or constant)
  const targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithConstructorCallForGeneration new
    !mInstructionLocation
    !targetType
    !mIsConstant
    !targetVariableCppName
    ![mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationWithAssignmentAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ] ;
#--- Check target variable
#  const targetType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  const targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
#  if mIsConstant then
#    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
#  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName ![expression mType] !targetVariableCppName !targetVariableCppName] ;
#  end if ;
#--- Check assignment type compatibility
#  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithSourceExpressionForGeneration new
    ![expression mType]
    !false
    !targetVariableCppName
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ] ;
#--- Check target variable
  const targetType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  const targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithSourceExpressionForGeneration new
    !targetType
    !mIsConstant
    !targetVariableCppName
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ] ;
#--- Enter target variable
  const targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName ![expression mType] !targetVariableCppName !targetVariableCppName] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithSourceExpressionForGeneration new
    ![expression mType]
    !true
    !targetVariableCppName
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check target variable
  const targetType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  const targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  if mIsUndefinedConstant then
    [!?ioVariableMap insertUndefinedLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  else
    [!?ioVariableMap insertUndefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName] ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableDeclarationForGeneration new
    !targetType
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @assignmentInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  @string nameForCheckingFormalParameterUsing ;
  if [mStructAttributeList length] == 0 then
    [!?ioVariableMap searchForWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName ?nameForCheckingFormalParameterUsing] ;
  else
    [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName ?nameForCheckingFormalParameterUsing] ;
    foreach mStructAttributeList do
      const attributeMap := [targetType mAttributeMap] ;
      [attributeMap searchKey !mValue ?targetType] ;
    end foreach ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@assignmentInstructionForGeneration new
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selfAssignmentInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ??@semanticExpressionForGeneration expression
  ] ;
#--- Analyze "self", as receiver expression
  if [inAnalysisContext->mSelfTypeProxy isNull] then
    error mInstructionLocation: "'self' can be used only in category modifiers" ;
  elsif [inAnalysisContext->mSelfTypeProxy mTypeKindEnum] == [@typeKindEnum classType] then
    error mInstructionLocation: "'self' assignment is not allowed for class instances" ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !inAnalysisContext->mSelfTypeProxy ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@assignmentInstructionForGeneration new
    !inAnalysisContext->mSelfTypeProxy
    !inAnalysisContext->mSelfObjectCppName
    !inAnalysisContext->mSelfObjectCppName
    ![@lstringlist emptyList]
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeErrorOrWarningInstruction
  ??@analysisContext inAnalysisContext
  ??@semanticExpressionAST inLocationExpression
  ??@semanticExpressionAST inMessageExpression
  ??@location inErrorLocation
  ??@string inErrorOrWarningString
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outLocationExpression
  !@semanticExpressionForGeneration outMessageExpression
  !@bool outUseLocationReader
:
#--- Analyze location expression
  [inLocationExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?outLocationExpression
  ] ;
#--- Check location expression type is either @location either has a correct location reader
  outUseLocationReader := [outLocationExpression mType] != inAnalysisContext->mPredefinedTypes->mLocationType ;
  if outUseLocationReader then
    const readerMap := [[outLocationExpression mType] mReaderMap] ;
    with readerMap hasKey !"location" do
      if [mArgumentTypeList length] != 0 then
        error inErrorLocation
        :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
        . "' and defines a 'location' reader with arguments; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
        ;      
      elsif mReturnedType != inAnalysisContext->mPredefinedTypes->mLocationType then
        error inErrorLocation
        :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
        . "' and defines a 'location' reader that returns an '@" . [mReturnedType key]
        . "' object; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
        ;      
      end if ;
    else
      error inErrorLocation
      :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
      . "' and does not define a 'location' reader; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
      ;
    end with ;
  end if ;
#--- Analyze message expression
  [inMessageExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?outMessageExpression
  ] ;
#--- Check message expression type is @string
  if [outMessageExpression mType] != inAnalysisContext->mPredefinedTypes->mStringType then
    error inErrorLocation
    :"the " . inErrorOrWarningString . " message expression type is '@" . [[outMessageExpression mType] key] . "'; it should be of the '@string' type"
    ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @errorInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#---
  @semanticExpressionForGeneration locationExpression ;
  @semanticExpressionForGeneration messageExpression ;
  @bool useLocationReader ;
  analyzeErrorOrWarningInstruction
    !inAnalysisContext
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"error"
    !?ioVariableMap
    ?locationExpression
    ?messageExpression
    ?useLocationReader
  ;
#--- Handle dropped variables
  @stringlist builtVariableCppNameList [emptyList] ;
  foreach mBuiltVariableList do
    @string varCppName ;
    [!?ioVariableMap searchForWriteAccess !mValue ?* ?varCppName ?*] ;
    builtVariableCppNameList += !varCppName ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@errorInstructionForGeneration new
    !mInstructionLocation
    !locationExpression
    !useLocationReader
    !messageExpression
    !builtVariableCppNameList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @warningInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#---
  @semanticExpressionForGeneration locationExpression ;
  @semanticExpressionForGeneration messageExpression ;
  @bool useLocationReader ;
  analyzeErrorOrWarningInstruction
    !inAnalysisContext
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"warning"
    !?ioVariableMap
    ?locationExpression
    ?messageExpression
    ?useLocationReader
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@warningInstructionForGeneration new
    !mInstructionLocation
    !locationExpression
    !useLocationReader
    !messageExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

abstract method @actualParameterAST checkAgainstFormalArgument
  ??@analysisContext inAnalysisContext
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
;

#---------------------------------------------------------------------------*

reader @formalArgumentPassingModeAST correspondingEffectiveParameterString -> @string outResult :
  switch selfcopy
    when argumentConstantIn : outResult := "!" ;
    when argumentIn : outResult := "!" ;
    when argumentOut : outResult := "?" ;
    when argumentInOut : outResult := "!?" ;
  end switch ;
end reader ;


#---------------------------------------------------------------------------*

override method @outputActualParameterAST checkAgainstFormalArgument
  ??@analysisContext inAnalysisContext
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
:
  if (inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentIn])
   & (inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentConstantIn]) then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  else
    @semanticExpressionForGeneration expression ;
    [mOutputActualParameterExpression analyzeSemanticExpression
      !inAnalysisContext
      !?ioVariableMap
      ?expression
    ] ;
  #--- Check effective expression type against formal argument type
    checkAssignmentTypes !inFormalArgumentType ![expression mType] !mEndOfExpressionLocation ;
  #--- Generate actual parameter
    ioActualParameterListForGeneration += ![@outputActualParameterForGeneration new
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @outputInputActualParameterAST checkAgainstFormalArgument
  ??@analysisContext unused inAnalysisContext
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentInOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  end if ;
#--- Analyze input/output variable
  @unifiedTypeMapProxy parameterType ;
  @string variableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mOutputInputActualParameterName ?parameterType ?variableCppName ?*] ;
  foreach mStructAttributeList do
    const attributeMap := [parameterType mAttributeMap] ;
    [attributeMap searchKey !mValue ?parameterType] ;
  end foreach ;
#--- Check type
  if inFormalArgumentType != parameterType then
    error mOutputInputActualParameterName
    :"the parameter object has the '@" . [parameterType key]
    . "', it should be the same as the corresponding formal argument: '@" . [inFormalArgumentType key] . "'"
    ;
  end if ;
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mOutputInputActualParameterName string]] then
    error mOutputInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
    ;
  end if ;
  ioExclusiveVariableSet += ![mOutputInputActualParameterName string] ;
#--- Generate actual parameter
  ioActualParameterListForGeneration += ![@outputInputActualParameterForGeneration new
    !variableCppName
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputActualParameterAST checkAgainstFormalArgument
  ??@analysisContext unused inAnalysisContext
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  end if ;
  [!?ioVariableMap searchForWriteAccess
    !mInputActualParameterName
    ?@unifiedTypeMapProxy parameterType
    ?@string targetVariableCppName
    ?*
  ] ;
#--- Check type
  if inFormalArgumentType != parameterType then
    error mInputActualParameterName
    :"the parameter object has the '@" . [parameterType key]
    . "', it should be the same as the corresponding formal argument: '@" . [inFormalArgumentType key] . "'"
    ;
  end if ;
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mInputActualParameterName string]] then
    error mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
    ;
  end if ;
  ioExclusiveVariableSet += ![mInputActualParameterName string] ;
#--- Generate actual parameter
  ioActualParameterListForGeneration += ![@inputActualParameterForGeneration new
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputJokerActualParameterAST checkAgainstFormalArgument
  ??@analysisContext unused inAnalysisContext
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  else
    const cppVarName := "joker_" . [[mQualifierLocation locationIndex] string] . "_" . [mJokerIndex string] ;
  #--- Generate actual parameter
    ioActualParameterListForGeneration += ![@inputJokerParameterForGeneration new
      !cppVarName
      !inFormalArgumentType
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeRoutineArguments
  ??@analysisContext inAnalysisContext
  ??@lstring inRoutineName
  ??@string inInvokedEntityName
  ??@formalParameterSignature inRoutineSignature
  ??@actualParameterListAST inActualParameterList
  ?!@variableMap ioVariableMap
  !@actualParameterListForGeneration outActualParameterListForGeneration
:
  if [inRoutineSignature length] != [inActualParameterList length] then
    error inRoutineName
    :"the " . inInvokedEntityName . " defines " . [[inRoutineSignature length] string] 
    . " formal argument(s), but this invocation names "
    . [[inActualParameterList length] string] . " argument(s)"
    : outActualParameterListForGeneration
    ;
  else
    outActualParameterListForGeneration := [@actualParameterListForGeneration emptyList] ;
    @stringset exclusiveVariableSet [emptySet] ;
    foreach inRoutineSignature, inActualParameterList do
      [mActualParameter checkAgainstFormalArgument
        !inAnalysisContext
        !mFormalArgumentType
        !mFormalArgumentPassingMode
        !?ioVariableMap
        !?outActualParameterListForGeneration
        !?exclusiveVariableSet
      ] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @routineCallInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Get routine signature
  @formalParameterSignature routineSignature ;
  [inAnalysisContext->mSemanticContext->mRoutineMap searchKey !mRoutineName ?routineSignature] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mRoutineName
    !"'" . mRoutineName . "' routine header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@routineCallInstructionForGeneration new
    !mRoutineName
    !actualParameterListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @typeMethodCallInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Get type method map for the named type
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
#--- Get type method signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[type mClassMethodMap] searchKey !mMethodName ?routineSignature ?hasCompilerArgument] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mMethodName
    !"'" . mMethodName . "' class method header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@typeMethodInstructionForGeneration new
    !mTypeName
    !mMethodName
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @methodCallInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze receiver expression
  @semanticExpressionForGeneration receiverExpression ;
  [mReceiverExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?receiverExpression
  ] ;
#--- Get type method signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  @methodKind kind ;
  @string errorMessage ;
  [[[receiverExpression mType] mInstanceMethodMap] searchKey !mMethodName ?kind ?routineSignature ?* ?hasCompilerArgument ?* ?errorMessage] ;
  if errorMessage != "" then
    error mMethodName : errorMessage ;
  end if ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mMethodName
    !"'" . mMethodName . "' instance method header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@methodCallInstructionForGeneration new
    !mInstructionLocation
    ![receiverExpression mType]
    !receiverExpression
    ![mMethodName string]
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

function checkMethodImplementationInSuperClasses
  ??@lstring inMethodName
  ??@unifiedTypeMapProxy inSuperClass
  -> @string outResult
:
  if [inSuperClass isNull] then
    outResult := "" ;
  else
    @methodQualifier qualifier ;
    [[inSuperClass mInstanceMethodMap] searchKey !inMethodName ?* ?* ?* ?* ?qualifier ?*] ;
    switch qualifier
    when isAbstract :
      outResult := "" ;
    when isBasic, isBasicFinal, isOverriding : # Ok
      outResult := [inSuperClass key] ;
    when isInherited, isOverridingAbstract :
      outResult := checkMethodImplementationInSuperClasses [!inMethodName ![inSuperClass mSuperType]] ;
    end switch ;
  end if ;
end function ;

#---------------------------------------------------------------------------*

override method @modifierCallInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check receiver object
  @unifiedTypeMapProxy receiverType ;
  @string receiverVariableCppName ;
  @string receiverVariableBaseName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?receiverType ?receiverVariableCppName ?receiverVariableBaseName] ;
  foreach mReceiverStructAttributes do
    const attributeMap := [receiverType mAttributeMap] ;
    [attributeMap searchKey !mValue ?receiverType] ;
  end foreach ;
#--- Get modifier signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  @string modifierErrorMessage ;
  @methodKind kind ;
  [[receiverType mModifierMap] searchKey !mModifierName ?kind ?routineSignature ?hasCompilerArgument ?* ?modifierErrorMessage] ;
  if modifierErrorMessage != "" then
    error mModifierName : modifierErrorMessage ;
  end if ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mModifierName
    !"'" . mModifierName . "' modifier header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@modifierCallInstructionForGeneration new
    !receiverVariableCppName
    !receiverVariableBaseName
    !mReceiverStructAttributes
    !receiverType
    !mModifierName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selfModifierCallInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze "self", as receiver expression
  @unifiedTypeMapProxy selfTypeProxy ;
  @string selfObjectCppName ;
  if [inAnalysisContext->mSelfTypeProxy isNull] then
    error mModifierName: "'self' can be used only in category modifiers" : selfObjectCppName, selfTypeProxy ;
  else
    selfObjectCppName := inAnalysisContext->mSelfObjectCppName ;
    selfTypeProxy := inAnalysisContext->mSelfTypeProxy ;
  end if ;
#--- Get modifier signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  @methodKind kind ;
  [[selfTypeProxy mModifierMap] searchKey !mModifierName ?kind ?routineSignature ?hasCompilerArgument ?* ?*] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mModifierName
    !"'" . mModifierName . "' modifier header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@selfModifierCallInstructionForGeneration new
    !selfObjectCppName
    !selfTypeProxy
    !mModifierName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

function checkModifierImplementationInSuperClasses
  ??@lstring inModifierName
  ??@unifiedTypeMapProxy inSuperClass
  -> @string outResult
:
  if [inSuperClass isNull] then
    outResult := "" ;
  else
    @methodQualifier qualifier ;
    [[inSuperClass mModifierMap] searchKey !inModifierName ?3* ?qualifier ?*] ;
    switch qualifier
    when isAbstract :
      outResult := "" ;
    when isBasic, isBasicFinal, isOverriding : # Ok
      outResult := [inSuperClass key] ;
    when isInherited, isOverridingAbstract :
      outResult := checkModifierImplementationInSuperClasses [!inModifierName ![inSuperClass mSuperType]] ;
    end switch ;
  end if ;
end function ;

#---------------------------------------------------------------------------*

override method @concatInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  @string nameForCheckingFormalParameterUsing ;
  [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName ?nameForCheckingFormalParameterUsing] ;
  foreach mStructAttributeList do
    const attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target variable type support '.=' operator
  if ([targetType mHandledOperatorFlags] & dotAssignOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '.=' operator"
    ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@concatInstructionForGeneration new
    !mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selfConcatInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze "self", as receiver expression
  @unifiedTypeMapProxy selfTypeProxy ;
  @string selfObjectCppName ;
  if [inAnalysisContext->mSelfTypeProxy isNull] then
    error mInstructionLocation: "'self' can be used only in category modifiers" : selfObjectCppName, selfTypeProxy ;
  else
    selfObjectCppName := inAnalysisContext->mSelfObjectCppName ;
    selfTypeProxy := inAnalysisContext->mSelfTypeProxy ;
  end if ;
#--- Check target variable type support '.=' operator
  if ([selfTypeProxy mHandledOperatorFlags] & dotAssignOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [selfTypeProxy key] . "' type, but this type does not support the '.=' operator"
    ;
  end if ;
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?expression
  ] ;
#--- Check assignment type compatibility
  checkAssignmentTypes !selfTypeProxy ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@concatInstructionForGeneration new
    !mInstructionLocation
    !selfTypeProxy
    !selfObjectCppName
    !selfObjectCppName
    ![@lstringlist emptyList]
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @plusEqualInstructionAST analyzeSemanticInstruction # +=
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  @string nameForCheckingFormalParameterUsing ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName ?nameForCheckingFormalParameterUsing] ;
  foreach mStructAttributeList do
    const attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target variable type support '+=' operator
  const addAssignOperatorArguments:= [targetType mAddAssignOperatorArguments] ; # Empty list if += operator is not supported
  if [addAssignOperatorArguments length] == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '+=' operator"
    ;
#--- Analyze source expressions
  elsif [mExpressions length] != [addAssignOperatorArguments length] then
    error mInstructionLocation
    : "calling the '+=' operator on an '@" . [targetType key] . "' object requires "
    . [[addAssignOperatorArguments length] string] . " parameter(s), while this invocation has "
    . [[mExpressions length] string] . " parameter(s)" 
    ;
  else
    @semanticExpressionListForGeneration effectiveParameterList [emptyList] ;
    foreach mExpressions, addAssignOperatorArguments do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression
        !inAnalysisContext
        !?ioVariableMap
        ?exp
      ] ;
      checkAssignmentTypes !mType ![exp mType] !mEndOfExpressionLocation ;
      effectiveParameterList += !exp ;
    end foreach ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@plusEqualnstructionForGeneration new
      !targetVariableCppName
      !targetType
      !nameForCheckingFormalParameterUsing
      !mInstructionLocation
      !mStructAttributeList
      !effectiveParameterList
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @selfPlusEqualInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze "self", as receiver expression
  @unifiedTypeMapProxy selfTypeProxy ;
  @string selfObjectCppName ;
  if [inAnalysisContext->mSelfTypeProxy isNull] then
    error mInstructionLocation: "'self' can be used only in category modifiers" : selfObjectCppName, selfTypeProxy ;
  else
    selfObjectCppName := inAnalysisContext->mSelfObjectCppName ;
    selfTypeProxy := inAnalysisContext->mSelfTypeProxy ;
  end if ;
#--- Check target variable type support '+=' operator
  const addAssignOperatorArguments:= [selfTypeProxy mAddAssignOperatorArguments] ; # Empty list if += operator is not supported
  if [addAssignOperatorArguments length] == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [selfTypeProxy key] . "' type, but this type does not support the '+=' operator"
    ;
#--- Analyze source expressions
  elsif [mExpressions length] != [addAssignOperatorArguments length] then
    error mInstructionLocation
    : "calling the '+=' operator on an '@" . [selfTypeProxy key] . "' object requires "
    . [[addAssignOperatorArguments length] string] . " parameter(s), while this invocation has "
    . [[mExpressions length] string] . " parameter(s)" 
    ;
  else
    @semanticExpressionListForGeneration effectiveParameterList [emptyList] ;
    foreach mExpressions, addAssignOperatorArguments do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression
        !inAnalysisContext
        !?ioVariableMap
        ?exp
      ] ;
      checkAssignmentTypes !mType ![exp mType] !mEndOfExpressionLocation ;
      effectiveParameterList += !exp ;
    end foreach ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@plusEqualnstructionForGeneration new
      !selfObjectCppName
      !selfTypeProxy
      !""
      !mInstructionLocation
      ![@lstringlist emptyList]
      !effectiveParameterList
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @incrementInstructionAST analyzeSemanticInstruction
  ??@analysisContext unused inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName ?*] ;
  foreach mStructAttributeList do
    const attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target type accepts incrementation
  if ([targetType mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '++' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@incrementInstructionForGeneration new
    !mInstructionLocation
    !targetVariableCppName
    !targetType
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selfIncrementInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
#--- Analyze "self", as receiver expression
  @unifiedTypeMapProxy selfTypeProxy ;
  @string selfObjectCppName ;
  if [inAnalysisContext->mSelfTypeProxy isNull] then
    error mInstructionLocation: "'self' can be used only in category modifiers" : selfObjectCppName, selfTypeProxy ;
  else
    selfObjectCppName := inAnalysisContext->mSelfObjectCppName ;
    selfTypeProxy := inAnalysisContext->mSelfTypeProxy ;
  end if ;
#--- Check target type accepts incrementation
  if ([selfTypeProxy mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [selfTypeProxy key] . "' type, but this type does not support the '++' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@incrementInstructionForGeneration new
    !mInstructionLocation
    !selfObjectCppName
    !selfTypeProxy
    ![@lstringlist emptyList]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @decrementInstructionAST analyzeSemanticInstruction
  ??@analysisContext unused inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName ?*] ;
  foreach mStructAttributeList do
    const attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target type accepts incrementation
  if ([targetType mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '--' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@decrementInstructionForGeneration new
    !mInstructionLocation
    !targetVariableCppName
    !targetType
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selfDecrementInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
#--- Analyze "self", as receiver expression
  @unifiedTypeMapProxy selfTypeProxy ;
  @string selfObjectCppName ;
  if [inAnalysisContext->mSelfTypeProxy isNull] then
    error mInstructionLocation: "'self' can be used only in category modifiers" : selfObjectCppName, selfTypeProxy ;
  else
    selfObjectCppName := inAnalysisContext->mSelfObjectCppName ;
    selfTypeProxy := inAnalysisContext->mSelfTypeProxy ;
  end if ;
#--- Check target type accepts incrementation
  if ([selfTypeProxy mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [selfTypeProxy key] . "' type, but this type does not support the '--' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@decrementInstructionForGeneration new
    !mInstructionLocation
    !selfObjectCppName
    !selfTypeProxy
    ![@lstringlist emptyList]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @messageInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?expression
  ] ;
#--- Check message type is @string
  if [expression mType] != inAnalysisContext->mPredefinedTypes->mStringType then
    error mInstructionLocation
    :"the expression has the '@" . [[expression mType] key] . "' type, but the 'message' instruction requires an '@string' expression"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@messageInstructionForGeneration new
    !expression
    !mInstructionLocation
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @logInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
  foreach mLogList do
  #--- Analyze source expression
    @semanticExpressionForGeneration expression ;
    [mLogExpression analyzeSemanticExpression
      !inAnalysisContext
      !?ioVariableMap
      ?expression
    ] ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@logInstructionForGeneration new
      !mLogMessage
      !expression
    ] ;  
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @dropInstructionAST analyzeSemanticInstruction
  ??@analysisContext unused inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
  @stringlist cppNameDropList [emptyList] ;
  foreach mDropList do
    @string variableCppName ;
    [!?ioVariableMap searchForDropAccess !mValue ?* ?variableCppName ?*] ;
    cppNameDropList += !variableCppName ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@dropInstructionForGeneration new
     !cppNameDropList
     !"drop instruction"
  ] ;  
end method ;

#---------------------------------------------------------------------------*

routine checkExpressionIsBoolean
  ??@analysisContext inAnalysisContext
  ??@location inErrorLocation
  ??@semanticExpressionForGeneration inExpression
  !@semanticExpressionForGeneration outExpression
:
  const expressionType := [inExpression mType] ;
#--- Boolean type
  const boolType := inAnalysisContext->mPredefinedTypes->mBoolType ;
  if expressionType == boolType then
    outExpression := inExpression ;
  elsif [expressionType mTypeKindEnum] == [@typeKindEnum structType] then
    if [[expressionType mAttributeMap] hasKey !"bool"] then
      @unifiedTypeMapProxy attributeType ;
      [[expressionType mAttributeMap] searchKey ![@lstring new !"bool" !here] ?attributeType] ;
      if attributeType == boolType then
        outExpression := [@structFieldAccessExpressionForGeneration new
          !boolType
          !inErrorLocation
          !inExpression
          !"bool"
        ] ;
      else
        error inErrorLocation
        : "the '@". [expressionType key] . "' struct type defines an attribute named 'bool', but its type is not '@bool'"
        : outExpression
        ;
      end if ;
    else
      error inErrorLocation
      : "the '@". [expressionType key] . "' struct type does not define an attribute named 'bool'"
      : outExpression
      ;
    end if ;
  else
    with [expressionType mReaderMap] hasKey !"bool" do
      if mReturnedType != boolType then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' reader, but it does not return a '@bool' value" : outExpression ;
      elsif [mArgumentTypeList length] > 0 then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' reader that requires argument(s)" : outExpression ;
      elsif mErrorMessage != "" then
        error inErrorLocation : mErrorMessage : outExpression ;
      else
        outExpression := [@readerCallExpressionForGeneration new
          !boolType
          !inErrorLocation
          !mKind
          !inExpression
          ![@stringlist emptyList]
          !"bool"
          ![@semanticExpressionListForGeneration emptyList]
          !mHasCompilerArgument
        ] ;
      end if ;
    else
      if [[expressionType mReaderMap] count] == 0 then
        error inErrorLocation
        : "the expression type is not '@bool', but '@". [expressionType key] . "', and this type does not define the 'bool' reader"
        : outExpression
        ;
      else
        @string s := "" ;
        foreach [expressionType mReaderMap] do
          s .= "\n  - " . lkey ;
          foreach mArgumentTypeList do
            s .= " ?@" . [mType key] ;
          end foreach ;
          s .= " -> @" . [mReturnedType key] ;
        end foreach ;
        error inErrorLocation
        : "the expression type is not '@bool', but '@". [expressionType key] . "', and this type does not define the 'bool' reader; available "
        . if [[expressionType mReaderMap] count] > 1 then "readers are" else "reader is" end
        . ":" . s
        : outExpression
        ;
      end if ;
    end with ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @ifInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Test expression
  @semanticExpressionForGeneration analyzed_if_expression ;
  [m_if_expression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?analyzed_if_expression
  ] ;
  [!?ioVariableMap openOverrideForSelectBlock] ;
#--- Check tested expression type
  @semanticExpressionForGeneration if_expression ;
  checkExpressionIsBoolean
    !inAnalysisContext
    !mEndOf_if_instruction
    !analyzed_if_expression
    ?if_expression
  ;
#--- Then branch
  @semanticInstructionListForGeneration then_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !m_then_instructionList
    !mEndOf_then_branch
    !?ioVariableMap
    ?then_instructionList
  ;
#--- else branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !m_else_instructionList
    !mEndOf_if_instruction
    !?ioVariableMap
    ?else_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_if_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@ifInstructionForGeneration new
    !mEndOf_then_branch
    !if_expression
    !then_instructionList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @forInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Begin override for foreach defined constants
  [!?ioVariableMap openOverrideForSelectBlock] ;
  [!?ioVariableMap openBranch] ;
#--- 'before' branch
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @semanticInstructionListForGeneration before_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mBeforeInstructionList
    !mEndOf_before_branch
    !?ioVariableMap
    ?before_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_before_branch] ;
#--- 'between' branch
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @semanticInstructionListForGeneration between_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mBetweenInstructionList
    !mEndOf_between_branch
    !?ioVariableMap
    ?between_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_between_branch] ;
#--- 'after' branch
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @semanticInstructionListForGeneration after_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mAfterInstructionList
    !mEndOf_after_branch
    !?ioVariableMap
    ?after_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_after_branch] ;
#--- Analyze enumerated objects
  @localInitializedVariableList localConstantListForDoBranch [emptyList] ;
  @foreachInstructionEnumeratedObjectListForGeneration enumerationList [emptyList] ;
  foreach mEnumeratedObjectList do
  #--- Enumeration expression
    @semanticExpressionForGeneration enumerationExpression ;
    [mEnumeratedExpression analyzeSemanticExpression
      !inAnalysisContext
      !?ioVariableMap
      ?enumerationExpression
    ] ;
  #--- Check object can be enumerated
    const enumeratorCppName := "enumerator_" . [[mEndOfEnumerationExpression locationIndex] string] ;
    const enumeratedElementType := [[enumerationExpression mType] mTypeForEnumeratedElement] ;
    if [enumeratedElementType isNull] then
      error mEndOfEnumerationExpression : "an '@" . [[enumerationExpression mType] key] . "' object cannot be enumerated" ;
    else
      localConstantListForDoBranch += !enumeratedElementType !mEnumerationVariable !enumeratorCppName . ".current (HERE)" ;
    end if ;
  #---
    enumerationList +=
      !if mAscending then "up" else "down" end
      !enumerationExpression
      !enumeratorCppName
    ;
  end foreach ;
#--- While expression
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  [!?ioVariableMap openBranch] ;
#--- Declare local constants
  foreach localConstantListForDoBranch do
   [!?ioVariableMap insertUsedLocalConstant !mName !mType !mCppName !mCppName] ;
  end foreach ;
#---
  @semanticExpressionForGeneration uncheckedWhileExpression ;
  [mWhileExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?uncheckedWhileExpression
  ] ;
  @semanticExpressionForGeneration whileExpression ;
  checkExpressionIsBoolean
    !inAnalysisContext
    !mEndOf_while_expression
    !uncheckedWhileExpression
    ?whileExpression
  ;
#---
  [!?ioVariableMap closeBranch !mEndOf_while_expression] ;
  [!?ioVariableMap closeOverride !mEndOf_while_expression] ;
#--- Handle index
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @string indexCppName := "" ;
  @localConstantList indexDeclaration [emptyList] ;
  if [mIndexVariableName string] != "" then
    indexCppName := "index_" . [[mInstructionLocation locationIndex] string] ;
    indexDeclaration +=
      !inAnalysisContext->mPredefinedTypes->mUIntType
      !mIndexVariableName
      !false # Warns if unused
      !indexCppName
    ;
  end if ;
#--- 'do' branch
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    !indexDeclaration
    !localConstantListForDoBranch
    !mDoInstructionList
    !mEndOf_do_branch
    !?ioVariableMap
    ?do_instructionList
  ;
#--- End override
  [!?ioVariableMap closeOverride !mEndOf_foreach_instruction] ;
#--- End override for foreach defined constants
  [!?ioVariableMap closeBranch !mEndOf_foreach_instruction] ;
  [!?ioVariableMap closeOverride !mEndOf_foreach_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@foreachInstructionForGeneration new
    !mInstructionLocation
    !enumerationList
    !indexCppName
    !whileExpression
    !before_instructionList
    !between_instructionList
    !do_instructionList
    !after_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @foreachInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Begin override for foreach defined constants
  [!?ioVariableMap openOverrideForSelectBlock] ;
  [!?ioVariableMap openBranch] ;
#--- 'before' branch
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @semanticInstructionListForGeneration before_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mBeforeInstructionList
    !mEndOf_before_branch
    !?ioVariableMap
    ?before_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_before_branch] ;
#--- 'between' branch
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @semanticInstructionListForGeneration between_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mBetweenInstructionList
    !mEndOf_between_branch
    !?ioVariableMap
    ?between_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_between_branch] ;
#--- 'after' branch
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @semanticInstructionListForGeneration after_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mAfterInstructionList
    !mEndOf_after_branch
    !?ioVariableMap
    ?after_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_after_branch] ;
#--- Analyze enumerated objects
  @foreachInstructionEnumeratedObjectListForGeneration enumerationList [emptyList] ;
  foreach mEnumeratedObjectList do
  #--- Enumeration expression
    @semanticExpressionForGeneration enumerationExpression ;
    [mEnumeratedExpression analyzeSemanticExpression
      !inAnalysisContext
      !?ioVariableMap
      ?enumerationExpression
    ] ;
  #--- Check object can be enumerated
    @string enumerationOrder := [mEnumerationOrder string] ;
    const enumeratorCppName := "enumerator_" . [[mEndOfEnumerationExpression locationIndex] string] ;
    const enumerationDescriptorList := [[enumerationExpression mType] mEnumerationDescriptor] ;
    if [enumerationDescriptorList length] == 0 then
      error mEndOfEnumerationExpression : "an '@" . [[enumerationExpression mType] key] . "' object cannot be enumerated" ;
    else
  #--- Check enumeration variant
      if enumerationOrder == "" then
        enumerationOrder := [[[enumerationExpression mType] mEnumeratorVariants] mValueAtIndex !0] ;
      else
        @bool found := false ;
        @string s := "" ;
        foreach [[enumerationExpression mType] mEnumeratorVariants] while not found do
          found := enumerationOrder == mValue ;
          s .= "\n  \\" . mValue ;
        end foreach ;
        if not found then
          error mEnumerationOrder: "unknown enumeration specifier; available ones are :" . s ;
        end if ;
      end if ;
  #--- Arguments
      if ([mElementList length] == 0) & not mEndsWithEllipsis then
        const currentTypedAttributeList := [[enumerationExpression mType] mEnumerationDescriptor] ;
        foreach currentTypedAttributeList do 
         [!?ioVariableMap insertUsedLocalConstant
           ![@lstring new ![mPrefix string] . mEnumerationName !mEndOfEnumerationExpression]
           !mEnumeratedType
           !enumeratorCppName .".current_" . [mEnumerationName identifierRepresentation] . " (HERE)"
           !enumeratorCppName .".current_" . [mEnumerationName identifierRepresentation] . " (HERE)"
         ] ;
        end foreach ;
      elsif (not mEndsWithEllipsis) & ([mElementList length] != [enumerationDescriptorList length]) then
        error mEndOfElementList
        :"the '@" . [[enumerationExpression mType] key] . "' type requires "
        . [[enumerationDescriptorList length] string] . " argument"
        . if ([enumerationDescriptorList length] > 1) then "s" else "" end
        . " for enumeration: this list provides "
        . [[mElementList length] string]
        ;
      elsif (mEndsWithEllipsis) & ([mElementList length] > [enumerationDescriptorList length]) then
        error mEndOfElementList
        :"the '@" . [[enumerationExpression mType] key] . "' type requires "
        . [[enumerationDescriptorList length] string] . " argument"
        . if ([enumerationDescriptorList length] > 1) then "s" else "" end
        . " or less for enumeration: this list provides "
        . [[mElementList length] string]
        ;
      else
        foreach mElementList, enumerationDescriptorList do
          if [mConstantName string] != "" then # Empty string if joker
            const foundType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
            if foundType != mEnumeratedType then
              error mTypeName : "incorrect '@" . [foundType key] . "' type: '@" . [mEnumeratedType key] . "' type required here" ;
            end if ;
            [!?ioVariableMap insertUsedLocalConstant
              !mConstantName
              !mEnumeratedType
              !enumeratorCppName .".current_" . [mEnumerationName identifierRepresentation]. " (HERE)"
              !enumeratorCppName .".current_" . [mEnumerationName identifierRepresentation]. " (HERE)"
            ] ;
          end if ;
        end foreach ;
      end if ;
    end if ;
  #---
    enumerationList += !enumerationOrder !enumerationExpression !enumeratorCppName ;
  end foreach ;
#--- While expression
  @semanticExpressionForGeneration uncheckedWhileExpression ;
  [mWhileExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?uncheckedWhileExpression
  ] ;
  @semanticExpressionForGeneration whileExpression ;
  checkExpressionIsBoolean
    !inAnalysisContext
    !mEndOf_while_expression
    !uncheckedWhileExpression
    ?whileExpression
  ;
#--- Handle index
  [!?ioVariableMap openOverrideForRepeatBlock] ;
  @string indexCppName := "" ;
  @localConstantList indexDeclaration [emptyList] ;
  if [mIndexVariableName string] != "" then
    indexCppName := "index_" . [[mInstructionLocation locationIndex] string] ;
    indexDeclaration +=
      !inAnalysisContext->mPredefinedTypes->mUIntType
      !mIndexVariableName
      !false # Warns if unused
      !indexCppName
    ;
  end if ;
#--- 'do' branch
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    !indexDeclaration
    ![@localInitializedVariableList emptyList]
    !mDoInstructionList
    !mEndOf_do_branch
    !?ioVariableMap
    ?do_instructionList
  ;
#--- End override
  [!?ioVariableMap closeOverride !mEndOf_foreach_instruction] ;
#--- End override for foreach defined constants
  [!?ioVariableMap closeBranch !mEndOf_foreach_instruction] ;
  [!?ioVariableMap closeOverride !mEndOf_foreach_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@foreachInstructionForGeneration new
    !mInstructionLocation
    !enumerationList
    !indexCppName
    !whileExpression
    !before_instructionList
    !between_instructionList
    !do_instructionList
    !after_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @loopInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Variant expression
  @semanticExpressionForGeneration variantExpression ;
  [mVariantExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?variantExpression
  ] ;
#--- Check variant expression type is @uint
  if [variantExpression mType] != inAnalysisContext->mPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    : "the variant expression type should be '@" . [inAnalysisContext->mPredefinedTypes->mUIntType key] . "', but it has '@" . [[variantExpression mType] key] . "' type" ;
  end if ;
#--- Loop expression
  @semanticExpressionForGeneration loopExpression ;
  [mLoopExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?loopExpression
  ] ;
#--- Check loop expression type is @bool
  if [loopExpression mType] != inAnalysisContext->mPredefinedTypes->mBoolType then
    error mEndOfLoopExpression
    : "the loop expression type should be '@" . [inAnalysisContext->mPredefinedTypes->mBoolType key] . "', but it has '@" . [[loopExpression mType] key] . "' type" ;
  end if ;
#--- Begin override for analyze loop instruction list
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- First branch
  @semanticInstructionListForGeneration first_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mFirstInstructions
    !mEndOfFirstInstructions
    !?ioVariableMap
    ?first_instructionList
  ;
#--- Second branch
  @semanticInstructionListForGeneration second_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mSecondInstructions
    !mEndOfSecondInstructions
    !?ioVariableMap
    ?second_instructionList
  ;
#--- End override
  [!?ioVariableMap closeOverride !mEndOfLoopInstruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@loopInstructionForGeneration new
    !mInstructionLocation
    !variantExpression
    !first_instructionList
    !loopExpression
    !second_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @structuredCastInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Expression
  @semanticExpressionForGeneration castExpression ;
  [mCastExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?castExpression
  ] ;
#--- Begin override for analyze loop instruction list
  [!?ioVariableMap openOverrideForSelectBlock] ;
#--- Branches
  @castInstructionBranchListForGeneration castBranchList [emptyList] ;
  foreach mCastInstructionBranchList do
  #--- Get named type
    const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  #--- Check named type is a descendant of receiver type
    @unifiedTypeMapProxy t := type ;
    @bool found := t == [castExpression mType] ;
    loop [inAnalysisContext->mSemanticContext->mTypeMap count] + 1 :
    while (not found) & not [[t mSuperType] isNull] do
      t := [t mSuperType] ;
      found := t == [castExpression mType] ;
    end loop ;
    if not found then
      error mTypeName
      :"the '@" . mTypeName . "' is not a descendant of the '@" . [[castExpression mType] key] . "' type of the cast expression"
      ;
    end if ;
  #--- Declare a local constant ?
    @string localConstantName ;
    @localConstantList localConstantList [emptyList] ;
    if [mConstantVarName length] > 0 then
      localConstantName := "cast_" . [[[mConstantVarName location] locationIndex] string] . "_" . mConstantVarName ;
      localConstantList +=
        !type
        !mConstantVarName
        !true # Warns if unused
        !localConstantName
      ;
    else
      localConstantName := "" ; # No constant
    end if ;
  #--- Analyze instruction list
    @semanticInstructionListForGeneration instructionList ;
    analyzeSemanticInstructionList
      !inAnalysisContext
      !localConstantList
      ![@localInitializedVariableList emptyList]
      !mInstructionList
      !mEndOfInstructions
      !?ioVariableMap
      ?instructionList
    ;
    castBranchList += !mTypeComparisonKind !type !localConstantName !instructionList ;
  end foreach ;
#--- else or default branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mElseInstructionList
    !mEndOfCastInstruction
    !?ioVariableMap
    ?else_instructionList
  ;
#--- End override
  [!?ioVariableMap closeOverride !mEndOfCastInstruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@structuredCastInstructionForGeneration new
    !castExpression
    !castBranchList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeGrammarInstructionSDT
  ??@analysisContext unused inAnalysisContext
  ??@bool unused inHasTranslateFeature
  ??@string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@variableMap unused ioVariableMap
:
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeGrammarInstructionSDT
  ??@analysisContext unused inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@variableMap unused ioVariableMap
:
  if not inHasTranslateFeature then
    error mLocation : "the ':>' construct requires the grammar to be declared with 'translate' feature" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeGrammarInstructionSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature" ;
  end if ;
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ??@unifiedTypeMapProxy type ??@string cppName ?*] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioAssignementList += !cppName . " = GALGAS_string (" . inSyntaxDirectedTranslationResultVarName . ") ;" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeGrammarInstructionSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature" ;
  end if ;
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioAssignementList += !"GALGAS_string " . cppName . " (" . inSyntaxDirectedTranslationResultVarName . ") ;" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeGrammarInstructionSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature" ;
  end if ;
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioAssignementList += !"const GALGAS_string " . cppName . " (" . inSyntaxDirectedTranslationResultVarName . ") ;" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Search grammar in grammar map
  [inAnalysisContext->mSemanticContext->mGrammarMap searchKey
    !mGrammarComponentName
    ??@grammarLabelMap grammarLabelMap
    ?*
    ??@bool hasTranslateFeature
  ] ;
#--- Search label
  [grammarLabelMap searchKey
    !mLabelName
    ??@formalParameterSignature labelSignature
  ] ;
#--- Check actual parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mLabelName
    !"label of the " . mGrammarComponentName . " grammar"
    !labelSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Parse source expression
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ??@semanticExpressionForGeneration sourceExpression
  ] ;
#--- Check source expression type: @lstring for file, @string for source string itself
  if mSourceExpressionIsFile then
    if [sourceExpression mType] != inAnalysisContext->mPredefinedTypes->mLStringType then
      error mEndOfSourceExpression
      :"this expression is the source file path and its type should be '@lstring', but it is '@" . [[sourceExpression mType] key] . "'"
      ;
    end if ;
  elsif [sourceExpression mType] != inAnalysisContext->mPredefinedTypes->mStringType then
    error mEndOfSourceExpression
    :"this expression is the source string and its type should be '@string', but it is '@" . [[sourceExpression mType] key] . "'"
    ;
  end if ;
#--- Check syntax directed translation result parameter
  const syntaxDirectedTranslationResultVarName := "syntaxDirectedTranslationResult_" . [mGrammarComponentName->location locationIndex] ;
  @stringlist assignementList [emptyList] ;
  [mAbstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
    !inAnalysisContext
    !hasTranslateFeature
    !syntaxDirectedTranslationResultVarName
    !?assignementList
    !?ioVariableMap
  ] ;
#--- Generate instruction
  if mSourceExpressionIsFile then
    ioInstructionListForGeneration += ![@grammarInstructionWithSourceFileForGeneration new
      !mInstructionLocation
      ![mGrammarComponentName string]
      ![mLabelName string]
      !sourceExpression
      !actualParameterListForGeneration
      !hasTranslateFeature
      !assignementList
      !syntaxDirectedTranslationResultVarName
    ] ;
  else
    ioInstructionListForGeneration += ![@grammarInstructionWithSourceExpressionForGeneration new
      !mInstructionLocation
      ![mGrammarComponentName string]
      ![mLabelName string]
      !sourceExpression
      !actualParameterListForGeneration
      !hasTranslateFeature
      !assignementList
      !syntaxDirectedTranslationResultVarName
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

#! With instruction

#---------------------------------------------------------------------------*

override method @readWriteAccessWithInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  [mKeyExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ??@semanticExpressionForGeneration keyExpression
  ] ;
#--- Object Array cpp name
  const objectArrayCppName := "objectArray_" . [[mInstructionLocation locationIndex] string] ;
#--- Read/write access to receiver variable
  @unifiedTypeMapProxy targetType ;
  @string receiverVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?receiverVariableCppName ?*] ;
  foreach mFieldList do
    const attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check this type handle 'with' access
  const withAccessorMap := [targetType mWithAccessorMap] ;
  @unifiedTypeMapProxyList argumentTypeList ;
  with withAccessorMap hasKey ![mAccessName string] do
    argumentTypeList := [@unifiedTypeMapProxyList listWithValue !mArgumentType] ;
  else
    if [withAccessorMap count] == 0 then
      error mAccessName
      : "the '@". [targetType key] . "' type cannot be used in a 'with' instruction"
      : argumentTypeList
      ;
    else
      @string s := "" ;
      foreach withAccessorMap do
        s .= "\n  - " . lkey ." ?@" . [mArgumentType key] ;
      end foreach ;
      error mAccessName
      : "the '@". [targetType key] . "' type does not define the '" . mAccessName . "' accessor for the 'with' instruction; available "
      . if [withAccessorMap count] > 1 then "accessors are" else "accessor is" end
      . ":" . s
      : argumentTypeList
      ;
    end if ;
  end with ;
#--- Check parameter list
  const effectiveExpressionList := [@semanticExpressionListForGeneration listWithValue !keyExpression]  ;
  if [effectiveExpressionList length] != [argumentTypeList length] then
    error mAccessName: "calling the '" . mAccessName . "' accessor of '@" . [targetType key] . "' requires "
    . [[argumentTypeList length] string] . " parameter(s), while this call has "
    . [[effectiveExpressionList length] string] . " parameter(s)" ;
  else
    foreach effectiveExpressionList, argumentTypeList do
      checkAssignmentTypes !mType ![mExpression mType] ![mAccessName location] ;
    end foreach ;
  end if ;
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock] ;
#--- 'do' branch
  @localInitializedVariableList localInitializedVariableList [emptyList] ;
  foreach [targetType mCurrentTypedAttributeList] do
    localInitializedVariableList +=
      !mAttributeTypeProxy
      ![@lstring new ![mPrefix string] . mAttributeName ![mAccessName location]]
      !objectArrayCppName . "->mAttribute_" . [mAttributeName identifierRepresentation]
    ;
  end foreach ;
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    !localInitializedVariableList
    !m_do_Instructions
    !mEndOf_do_instructions
    !?ioVariableMap
    ?do_instructionList
  ;
#--- else branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !m_else_Instructions
    !mEndOf_else_instructions
    !?ioVariableMap
    ?else_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_else_instructions] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@readWriteWithInstructionForGeneration new
    !mInstructionLocation
    !receiverVariableCppName
    !targetType
    !mFieldList
    ![mAccessName string]
    !objectArrayCppName
    !keyExpression
    !do_instructionList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @readAccessWithInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze receiver expression
  @semanticExpressionForGeneration receiverExpression ;
  [mReceiverExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?receiverExpression
  ] ;
  const receiverType := [receiverExpression mType] ;
#--- Analyze key expression
  @semanticExpressionForGeneration keyExpression ;
  [mKeyExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?keyExpression
  ] ;
#--- Object Array cpp name
  const objectArrayCppName := "objectArray_" . [[mInstructionLocation locationIndex] string] ;
#--- Check this type handle 'with' access
  const withAccessorMap := [receiverType mWithAccessorMap] ;
  @unifiedTypeMapProxyList argumentTypeList ;
  with withAccessorMap hasKey ![mSearchMethodName string] do
    argumentTypeList := [@unifiedTypeMapProxyList listWithValue !mArgumentType] ;
  else
    if [withAccessorMap count] == 0 then
      error mSearchMethodName
      : "the '@". [receiverType key] . "' type cannot be used in a 'with' instruction"
      : argumentTypeList
      ;
    else
      @string s := "" ;
      foreach withAccessorMap do
        s .= "\n  - " . lkey ." ?@" . [mArgumentType key] ;
      end foreach ;
      error mSearchMethodName
      : "the '@". [receiverType key] . "' type does not define the '" . mSearchMethodName . "' accessor for the 'with' instruction; available "
      . if [withAccessorMap count] > 1 then "accessors are" else "accessor is" end
      . ":" . s
      : argumentTypeList
      ;
    end if ;
  end with ;
#--- Check parameter list
  const effectiveExpressionList := [@semanticExpressionListForGeneration listWithValue !keyExpression]  ;
  if [effectiveExpressionList length] != [argumentTypeList length] then
    error mSearchMethodName: "calling the '" . mSearchMethodName . "' accessor of '@" . [receiverType key] . "' requires "
    . [[argumentTypeList length] string] . " parameter(s), while this call has "
    . [[effectiveExpressionList length] string] . " parameter(s)" ;
  else
    foreach effectiveExpressionList, argumentTypeList do
      checkAssignmentTypes !mType ![mExpression mType] ![mSearchMethodName location] ;
    end foreach ;
  end if ;
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock] ;
#--- 'do' branch
  @localConstantList localConstantList [emptyList] ;
  foreach [receiverType mCurrentTypedAttributeList] do
    localConstantList +=
      !mAttributeTypeProxy
      ![@lstring new ![mPrefix string] . mAttributeName ![mSearchMethodName location]]
      !true # Do not warn if unused
      !objectArrayCppName . "->mAttribute_" . [mAttributeName identifierRepresentation]
    ;
  end foreach ;
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    !localConstantList
    ![@localInitializedVariableList emptyList]
    !mDoBranchInstructions
    !mEndOf_do_instructions
    !?ioVariableMap
    ?do_instructionList
  ;
#--- else branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inAnalysisContext
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mElseBranchInstructions
    !mEndOf_else_instructions
    !?ioVariableMap
    ?else_instructionList
  ;
  [!?ioVariableMap closeOverride !mEndOf_else_instructions] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@readOnlyWithInstructionForGeneration new
    !mInstructionLocation
    !receiverExpression
    ![mSearchMethodName string]
    !objectArrayCppName
    !keyExpression
    !do_instructionList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @switchInstructionAST analyzeSemanticInstruction
  ??@analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze switch expression
  @semanticExpressionForGeneration switchExpression ;
  [mSwitchExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?switchExpression
  ] ;
#--- Check switch expression type is and enum instance
  if [[switchExpression mType] mTypeKindEnum] != [@typeKindEnum enumType] then
    error mEndOfSwitchExpression
    : "the switch expression type should be an instance of an enumeration type (the '@" . [[switchExpression mType] key] . "' type is not an enumeration type)" ;
  end if ;
#--- Enum constant stringset
  const enumConstantStringSet := [[switchExpression mType] mEnumConstantSet] ;
  @stringset constantsNamedInSwitchInstruction [emptySet] ;
#--- Analyze branches
  [!?ioVariableMap openOverrideForSelectBlock] ;
  @switchBranchesForGeneration switchBranchesForGeneration [emptyList] ;
  foreach mBranches do
    foreach mSwitchConstantList do
      if [enumConstantStringSet hasKey ![mValue string]] then
        if [constantsNamedInSwitchInstruction hasKey ![mValue string]] then
          error mValue
          :"the '" . mValue . "' constant is already named in this switch instruction"
          ;
        end if ;
        constantsNamedInSwitchInstruction += ![mValue string] ;
      else
        error mValue
        :"'" . mValue . "' is not a constant of '@" . [[switchExpression mType] key] . "' enumeration type"
        ;
      end if ;
    end foreach ;
    @semanticInstructionListForGeneration instructionList ;
    analyzeSemanticInstructionList
      !inAnalysisContext
      ![@localConstantList emptyList]
      ![@localInitializedVariableList emptyList]
      !mInstructions
      !mEndOfBranch
      !?ioVariableMap
      ?instructionList
    ;
    switchBranchesForGeneration += !mSwitchConstantList !instructionList ;
  end foreach ;
  [!?ioVariableMap closeOverride !mEndOf_switch_instruction] ;
#--- Check all constants have been named
  const forgottenConstants := enumConstantStringSet - constantsNamedInSwitchInstruction ;
  if [forgottenConstants count] > 0 then
    @string s := "" ;
    foreach forgottenConstants do
      s .= "\n  - " . key ;
    end foreach ;
    error mEndOf_switch_instruction
    : "the switch instruction should name all enumeration constants; missing constants are:" . s
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@switchInstructionForGeneration new
    !switchExpression
    !switchBranchesForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
