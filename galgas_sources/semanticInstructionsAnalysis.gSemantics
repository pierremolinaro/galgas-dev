#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticInstructionsAnalysis :
  import "semanticExpressionAnalysis.gSemantics" ;
  import semantics semanticExpressionAnalysis in "semanticExpressionAnalysis.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I N S T R U C T I O N    A N A L Y S I S                               *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze constructor call
  @unifiedTypeMapProxy returnedType ;
  @semanticExpressionListForGeneration constructorEffectiveParameterList ;
  analyzeConstructorInvocation
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    !mTypeName
    !mConstructorName
    !mConstructorExpressions
    ?returnedType
    ?constructorEffectiveParameterList
  ;
#--- Check variable type
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  if targetType != returnedType then
    error mConstructorName
    :"this constructor returns an '@" . [returnedType key] ."' object, you should use a constructor that return an '@" . mTypeName . "' object"
    ;
  end if ;
#--- Declare variable (or constant)
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithConstructorCallForGeneration new
    !targetType
    !mIsConstant
    !targetVariableCppName
    ![mConstructorName string]
    !constructorEffectiveParameterList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithSourceExpressionForGeneration new
    !targetType
    !mIsConstant
    !targetVariableCppName
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Check target variable
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  [!?ioVariableMap insertUndefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableDeclarationForGeneration new
    !targetType
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @assignmentInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  if [mStructAttributeList length] == 0 then
    [!?ioVariableMap searchForWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
  else
    [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
    foreach mStructAttributeList do
      const @attributeMap attributeMap := [targetType mAttributeMap] ;
      [attributeMap searchKey !mValue ?targetType] ;
    end foreach ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@assignmentInstructionForGeneration new
    !targetVariableCppName
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @appendInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mTargetVariableName
  : "unhandled instruction @appendInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @sendInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @sendInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @foreachInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @foreachInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @ifInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @ifInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @errorInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @errorInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @warningInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @warningInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @routineCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mRoutineName
  : "unhandled instruction @routineCallInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @matchInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @matchInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @castInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @castInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @addInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mReceiverName
  : "unhandled instruction @addInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @removeInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mReceiverName
  : "unhandled instruction @removeInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @incrementInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mReceiverName
  : "unhandled instruction @incrementInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @decrementInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mReceiverName
  : "unhandled instruction @decrementInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @loopInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @loopInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @messageInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @messageInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @logInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @logInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mGrammarComponentName
  : "unhandled instruction @grammarInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @withInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mTargetObjectName
  : "unhandled instruction @withInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @switchInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mInstructionLocation
  : "unhandled instruction @switchInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @typeMethodCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mTypeName
  : "unhandled instruction @typeMethodCallInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @methodCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mMethodName
  : "unhandled instruction @methodCallInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @modifierCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
:
  error mReceiverName
  : "unhandled instruction @modifierCallInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
