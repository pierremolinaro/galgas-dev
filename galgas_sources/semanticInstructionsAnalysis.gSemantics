#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticInstructionsAnalysis :
  import "semanticExpressionAnalysis.gSemantics" ;
  import semantics semanticExpressionAnalysis in "semanticExpressionAnalysis.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I N S T R U C T I O N    A N A L Y S I S                               *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
;

#---------------------------------------------------------------------------*

list @localConstantList {
  @unifiedTypeMapProxy mType ;
  @lstring mName ;
  @bool mNoWarningIfUnused ;
  @string mCppName ;
}

#---------------------------------------------------------------------------*

list @localInitializedVariableList {
  @unifiedTypeMapProxy mType ;
  @lstring mName ;
  @string mCppName ;
}

#---------------------------------------------------------------------------*

routine analyzeSemanticInstructionList
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@localConstantList inLocalConstantList
  ??@localInitializedVariableList inLocalInitializedVariableList
  ??@semanticInstructionListAST inSemanticInstructionListAST
  ??@location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap beginBranch] ;
#--- Declare local constants
  foreach inLocalConstantList do
    if mNoWarningIfUnused then
      [!?ioVariableMap insertUsedLocalConstant !mName !mType !mCppName] ;
    else
      [!?ioVariableMap insertLocalConstant !mName !mType !mCppName] ;
    end if ;
  end foreach ;
#--- Declare local variables
  foreach inLocalInitializedVariableList do
    [!?ioVariableMap insertDefinedLocalVariable !mName !mType !mCppName] ;
  end foreach ;
#--- Instruction list
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSemanticInstructionListAST do
    [mInstruction analyzeSemanticInstruction
      !inSemanticContext
      !inPredefinedTypes
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?localVariableCppNameList
    ] ;
  end foreach ;
#--- Branch end
  [!?ioVariableMap endBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
:
#--- Analyze constructor call
  @unifiedTypeMapProxy returnedType ;
  @semanticExpressionListForGeneration constructorEffectiveParameterList ;
  @bool hasCompilerArgument ;
  analyzeConstructorInvocation
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    !mTypeName
    !mConstructorName
    !mConstructorExpressions
    ?returnedType
    ?constructorEffectiveParameterList
    ?hasCompilerArgument
  ;
#--- Check variable type
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  if targetType != returnedType then
    error mConstructorName
    :"this constructor returns an '@" . [returnedType key] ."' object, you should use a constructor that return an '@" . mTypeName . "' object"
    ;
  end if ;
#--- Declare variable (or constant)
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  ioLocalVariableCppNameList += !targetVariableCppName ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithConstructorCallForGeneration new
    !mInstructionLocation
    !targetType
    !mIsConstant
    !targetVariableCppName
    ![mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  ioLocalVariableCppNameList += !targetVariableCppName ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithSourceExpressionForGeneration new
    !targetType
    !mIsConstant
    !targetVariableCppName
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
:
#--- Check target variable
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  ioLocalVariableCppNameList += !targetVariableCppName ;
  [!?ioVariableMap insertUndefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableDeclarationForGeneration new
    !targetType
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @assignmentInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  if [mStructAttributeList length] == 0 then
    [!?ioVariableMap searchForWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
  else
    [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
    foreach mStructAttributeList do
      const @attributeMap attributeMap := [targetType mAttributeMap] ;
      [attributeMap searchKey !mValue ?targetType] ;
    end foreach ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@assignmentInstructionForGeneration new
    !targetVariableCppName
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @sendInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check source expression type is @string
  if [expression mType] != inPredefinedTypes->mStringType then
    error mInstructionLocation
    :"the send expression type is '@" . [[expression mType] key] . "'; it should be of the '@string' type"
    ;
  end if ;
  ioInstructionListForGeneration += ![@sendInstructionForGeneration new !expression] ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeErrorOrWarningInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@semanticExpressionAST inLocationExpression
  ??@semanticExpressionAST inMessageExpression
  ??@location inErrorLocation
  ??@string inErrorOrWarningString
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outLocationExpression
  !@semanticExpressionForGeneration outMessageExpression
  !@bool outUseLocationReader
:
#--- Analyze location expression
  [inLocationExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?outLocationExpression
  ] ;
#--- Check location expression type is either @location either has a correct location reader
  outUseLocationReader := [outLocationExpression mType] != inPredefinedTypes->mLocationType ;
  if outUseLocationReader then
    const @readerMap readerMap := [[outLocationExpression mType] mReaderMap] ;
    with readerMap hasKey !"location" do
      if [mArgumentTypeList length] != 0 then
        error inErrorLocation
        :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
        . "' and defines a 'location' reader with arguments; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
        ;      
      elsif mReturnedType != inPredefinedTypes->mLocationType then
        error inErrorLocation
        :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
        . "' and defines a 'location' reader that returns an '@" . [mReturnedType key]
        . "' object; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
        ;      
      end if ;
    else
      error inErrorLocation
      :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
      . "' and does not define a 'location' reader; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
      ;
    end with ;
  end if ;
#--- Analyze message expression
  [inMessageExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?outMessageExpression
  ] ;
#--- Check message expression type is @string
  if [outMessageExpression mType] != inPredefinedTypes->mStringType then
    error inErrorLocation
    :"the " . inErrorOrWarningString . " message expression type is '@" . [[outMessageExpression mType] key] . "'; it should be of the '@string' type"
    ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @errorInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#---
  @semanticExpressionForGeneration locationExpression ;
  @semanticExpressionForGeneration messageExpression ;
  @bool useLocationReader ;
  analyzeErrorOrWarningInstruction
    !inSemanticContext
    !inPredefinedTypes
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"error"
    !?ioVariableMap
    ?locationExpression
    ?messageExpression
    ?useLocationReader
  ;
#--- Handle dropped variables
  @stringlist builtVariableCppNameList [emptyList] ;
  foreach mBuiltVariableList do
    @string varCppName ;
    [!?ioVariableMap searchForWriteAccess !mValue ?* ?varCppName] ;
    builtVariableCppNameList += !varCppName ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@errorInstructionForGeneration new
    !mInstructionLocation
    !locationExpression
    !useLocationReader
    !messageExpression
    !builtVariableCppNameList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @warningInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#---
  @semanticExpressionForGeneration locationExpression ;
  @semanticExpressionForGeneration messageExpression ;
  @bool useLocationReader ;
  analyzeErrorOrWarningInstruction
    !inSemanticContext
    !inPredefinedTypes
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"warning"
    !?ioVariableMap
    ?locationExpression
    ?messageExpression
    ?useLocationReader
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@warningInstructionForGeneration new
    !mInstructionLocation
    !locationExpression
    !useLocationReader
    !messageExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

abstract method @actualParameterAST checkAgainstFormalArgument
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
;

#---------------------------------------------------------------------------*

override method @outputActualParameterAST checkAgainstFormalArgument
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
:
  if (inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentIn])
   & (inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentConstantIn]) then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  else
    @semanticExpressionForGeneration expression ;
    [mOutputActualParameterExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?expression
    ] ;
  #--- Check effective expression type against formal argument type
    checkAssignmentTypes !inFormalArgumentType ![expression mType] !mEndOfExpressionLocation ;
  #--- Generate actual parameter
    ioActualParameterListForGeneration += ![@outputActualParameterForGeneration new
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @outputInputActualParameterAST checkAgainstFormalArgument
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentInOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  end if ;
#--- Analyze input/output variable
  @unifiedTypeMapProxy parameterType ;
  @string variableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mOutputInputActualParameterName ?parameterType ?variableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [parameterType mAttributeMap] ;
    [attributeMap searchKey !mValue ?parameterType] ;
  end foreach ;
#--- Check type
  if inFormalArgumentType != parameterType then
    error mOutputInputActualParameterName
    :"the parameter object has the '@" . [parameterType key]
    . "', it should be the same as the corresponding formal argument: '@" . [inFormalArgumentType key] . "'"
    ;
  end if ;
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mOutputInputActualParameterName string]] then
    error mOutputInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
    ;
  end if ;
  ioExclusiveVariableSet += ![mOutputInputActualParameterName string] ;
#--- Generate actual parameter
  ioActualParameterListForGeneration += ![@outputInputActualParameterForGeneration new
    !variableCppName
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputActualParameterAST checkAgainstFormalArgument
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  end if ;
  @unifiedTypeMapProxy parameterType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForWriteAccess !mInputActualParameterName ?parameterType ?targetVariableCppName] ;
#--- Check type
  if inFormalArgumentType != parameterType then
    error mInputActualParameterName
    :"the parameter object has the '@" . [parameterType key]
    . "', it should be the same as the corresponding formal argument: '@" . [inFormalArgumentType key] . "'"
    ;
  end if ;
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mInputActualParameterName string]] then
    error mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
    ;
  end if ;
  ioExclusiveVariableSet += ![mInputActualParameterName string] ;
#--- Generate actual parameter
  ioActualParameterListForGeneration += ![@inputActualParameterForGeneration new
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputJokerActualParameterAST checkAgainstFormalArgument
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  else
    const @string cppVarName := "joker_" . [[mQualifierLocation locationIndex] string] . "_" . [mJokerIndex string] ;
  #--- Generate actual parameter
    ioActualParameterListForGeneration += ![@inputJokerParameterForGeneration new
      !cppVarName
      !inFormalArgumentType
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeRoutineArguments
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@lstring inRoutineName
  ??@string inInvokedEntityName
  ??@formalParameterSignature inRoutineSignature
  ??@actualParameterListAST inActualParameterList
  ?!@variableMap ioVariableMap
  !@actualParameterListForGeneration outActualParameterListForGeneration
:
  if [inRoutineSignature length] != [inActualParameterList length] then
    error inRoutineName
    :"the " . inInvokedEntityName . " defines " . [[inRoutineSignature length] string] 
    . " formal argument(s), but this invocation names "
    . [[inActualParameterList length] string] . " argument(s)"
    : outActualParameterListForGeneration
    ;
  else
    outActualParameterListForGeneration := [@actualParameterListForGeneration emptyList] ;
    @stringset exclusiveVariableSet [emptySet] ;
    foreach inRoutineSignature, inActualParameterList do
      [mActualParameter checkAgainstFormalArgument
        !inSemanticContext
        !inPredefinedTypes
        !mFormalArgumentType
        !mFormalArgumentPassingMode
        !?ioVariableMap
        !?outActualParameterListForGeneration
        !?exclusiveVariableSet
      ] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @routineCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Get routine signature
  @formalParameterSignature routineSignature ;
  [inSemanticContext->mRoutineMap searchKey !mRoutineName ?routineSignature] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mRoutineName
    !"'" . mRoutineName . "' routine header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@routineCallInstructionForGeneration new
    !mRoutineName
    !actualParameterListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @typeMethodCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Get type method map for the named type
  const @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Get type method signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[type mClassMethodMap] searchKey !mMethodName ?routineSignature ?hasCompilerArgument] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mMethodName
    !"'" . mMethodName . "' class method header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@typeMethodInstructionForGeneration new
    !mTypeName
    !mMethodName
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @methodCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Analyze receiver expression
  @semanticExpressionForGeneration receiverExpression ;
  [mReceiverExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?receiverExpression
  ] ;
#--- Get type method signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[[receiverExpression mType] mInstanceMethodMap] searchKey !mMethodName ?routineSignature ?* ?hasCompilerArgument ?*] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mMethodName
    !"'" . mMethodName . "' instance method header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@methodCallInstructionForGeneration new
    !mInstructionLocation
    !receiverExpression
    ![mMethodName string]
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @modifierCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Check receiver object
  @unifiedTypeMapProxy receiverType ;
  @string receiverVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?receiverType ?receiverVariableCppName] ;
  foreach mReceiverStructAttributes do
    const @attributeMap attributeMap := [receiverType mAttributeMap] ;
    [attributeMap searchKey !mValue ?receiverType] ;
  end foreach ;
#--- Get modifier signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[receiverType mModifierMap] searchKey !mModifierName ?routineSignature ?hasCompilerArgument ?*] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mModifierName
    !"'" . mModifierName . "' modifier header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@modifierCallInstructionForGeneration new
    !receiverVariableCppName
    !mReceiverStructAttributes
    !receiverType
    !mModifierName
    !actualParameterListForGeneration
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @appendInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target variable type support '.=' operator
  if ([targetType mHandledOperatorFlags] & dotAssignOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '.=' operator"
    ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@appendInstructionForGeneration new
    !mInstructionLocation
    !targetType
    !targetVariableCppName
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @addInstructionAST analyzeSemanticInstruction # +=
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target variable type support '+=' operator
  const @unifiedTypeMapProxyList addAssignOperatorArguments:= [targetType mAddAssignOperatorArguments] ; # Empty list if += operator is not supported
  if [addAssignOperatorArguments length] == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '+=' operator"
    ;
#--- Analyze source expressions
  elsif [mExpressions length] != [addAssignOperatorArguments length] then
    error mInstructionLocation
    : "calling the '+=' operator on an '@" . [targetType key] . "' object requires "
    . [[addAssignOperatorArguments length] string] . " parameter(s), while this invocation has "
    . [[mExpressions length] string] . " parameter(s)" 
    ;
  else
    @semanticExpressionListForGeneration effectiveParameterList [emptyList] ;
    foreach mExpressions, addAssignOperatorArguments do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression
        !inSemanticContext
        !inPredefinedTypes
        !?ioVariableMap
        ?exp
      ] ;
      checkAssignmentTypes !mType ![exp mType] !mEndOfExpressionLocation ;
      effectiveParameterList += !exp ;
    end foreach ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@addAssignInstructionForGeneration new
      !targetVariableCppName
      !targetType
      !mInstructionLocation
      !mStructAttributeList
      !effectiveParameterList
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @incrementInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target type accepts incrementation
  if ([targetType mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '++' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@incrementInstructionForGeneration new
    !mInstructionLocation
    !targetVariableCppName
    !targetType
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @decrementInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target type accepts incrementation
  if ([targetType mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '--' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@decrementInstructionForGeneration new
    !mInstructionLocation
    !targetVariableCppName
    !targetType
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @messageInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
  ] ;
#--- Check message type is @string
  if [expression mType] != inPredefinedTypes->mStringType then
    error mInstructionLocation
    :"the expression has the '@" . [[expression mType] key] . "' type, but the 'message' instruction requires an '@string' expression"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@messageInstructionForGeneration new
    !expression
    !mInstructionLocation
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @logInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  foreach mLogList do
  #--- Analyze source expression
    @semanticExpressionForGeneration expression ;
    [mLogExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?expression
    ] ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@logInstructionForGeneration new
      !mLogMessage
      !expression
    ] ;  
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @dropInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  @stringlist cppNameDropList [emptyList] ;
  foreach mDropList do
    @string variableCppName ;
    [!?ioVariableMap searchForDropAccess !mValue ?* ?variableCppName] ;
    cppNameDropList += !variableCppName ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@dropInstructionForGeneration new
     !cppNameDropList
     !"drop instruction"
  ] ;  
end method ;

#---------------------------------------------------------------------------*

override method @ifInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Test expression
  @semanticExpressionForGeneration if_expression ;
  [m_if_expression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?if_expression
  ] ;
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- Then branch
  @semanticInstructionListForGeneration then_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !m_then_instructionList
    !mEndOf_then_branch
    !?ioVariableMap
    ?then_instructionList
  ;
#--- else branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !m_else_instructionList
    !mEndOf_if_instruction
    !?ioVariableMap
    ?else_instructionList
  ;
  [!?ioVariableMap endOverride !mEndOf_if_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@ifInstructionForGeneration new
    !mEndOf_then_branch
    !if_expression
    !then_instructionList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @foreachInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Begin override for foreach defined constants
  [!?ioVariableMap beginOverrideForSelectBlock] ;
  [!?ioVariableMap beginBranch] ;
#--- Analyze enumerated objects
  @foreachInstructionEnumeratedObjectListForGeneration enumerationList [emptyList] ;
  foreach mEnumeratedObjectList do
  #--- Enumeration expression
    @semanticExpressionForGeneration enumerationExpression ;
    [mEnumeratedExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?enumerationExpression
    ] ;
  #--- Check object can be enumerated
    const @string enumeratorCppName := "enumerator_" . [[mEndOfEnumerationExpression locationIndex] string] ;
    const @enumerationDescriptorList enumerationDescriptorList := [[enumerationExpression mType] mEnumerationDescriptor] ;
    if [enumerationDescriptorList length] == 0 then
      error mEndOfEnumerationExpression : "an '@" . [[enumerationExpression mType] key] . "' object cannot be enumerated" ;
  #--- Arguments
    elsif ([mElementList length] == 0) & not mEndsWithEllipsis then
      const @enumerationDescriptorList currentTypedAttributeList := [[enumerationExpression mType] mEnumerationDescriptor] ;
      foreach currentTypedAttributeList do 
       [!?ioVariableMap insertUsedLocalConstant
         ![@lstring new ![mPrefix string] . mEnumerationName !mEndOfEnumerationExpression]
         !mEnumeratedType
         !enumeratorCppName .".attribute_" . [mEnumerationName identifierRepresentation]
       ] ;
      end foreach ;
    elsif (not mEndsWithEllipsis) & ([mElementList length] != [enumerationDescriptorList length]) then
      error mEndOfElementList
      :"the '@" . [[enumerationExpression mType] key] . "' type requires "
      . [[enumerationDescriptorList length] string] . " argument"
      . if ([enumerationDescriptorList length] > 1) then "s" else "" end
      . " for enumeration: this list provides "
      . [[mElementList length] string]
      ;
    elsif (mEndsWithEllipsis) & ([mElementList length] > [enumerationDescriptorList length]) then
      error mEndOfElementList
      :"the '@" . [[enumerationExpression mType] key] . "' type requires "
      . [[enumerationDescriptorList length] string] . " argument"
      . if ([enumerationDescriptorList length] > 1) then "s" else "" end
      . " or less for enumeration: this list provides "
      . [[mElementList length] string]
      ;
    else
      foreach mElementList, enumerationDescriptorList do
        if [mConstantName string] != "" then # Empty string if joker
          const @unifiedTypeMapProxy foundType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
          if foundType != mEnumeratedType then
            error mTypeName : "incorrect '@" . [foundType key] . "' type: '@" . [mEnumeratedType key] . "' type required here" ;
          end if ;
          [!?ioVariableMap insertUsedLocalConstant !mConstantName !mEnumeratedType !enumeratorCppName .".attribute_" . [mEnumerationName identifierRepresentation]] ;
        end if ;
      end foreach ;
    end if ;
  #---
    enumerationList += !mIsAscending !enumerationExpression !enumeratorCppName ;
  end foreach ;
#--- While expression
  @semanticExpressionForGeneration whileExpression ;
  [mWhileExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?whileExpression
  ] ;
#--- Begin override for analyze foreach instruction list
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- 'before' branch
  @semanticInstructionListForGeneration before_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mBeforeInstructionList
    !mEndOf_before_branch
    !?ioVariableMap
    ?before_instructionList
  ;
#--- Handle index
  @string indexCppName := "" ;
  @localConstantList indexDeclaration [emptyList] ;
  if [mIndexVariableName string] != "" then
    indexCppName := "index_" . [[mInstructionLocation locationIndex] string] ;
    indexDeclaration +=
      !inPredefinedTypes->mUIntType
      !mIndexVariableName
      !false # Warns if unused
      !indexCppName
    ;
  end if ;
#--- 'do' branch
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !indexDeclaration
    ![@localInitializedVariableList emptyList]
    !mDoInstructionList
    !mEndOf_do_branch
    !?ioVariableMap
    ?do_instructionList
  ;
#--- 'between' branch
  @semanticInstructionListForGeneration between_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mBetweenInstructionList
    !mEndOf_between_branch
    !?ioVariableMap
    ?between_instructionList
  ;
#--- 'after' branch
  @semanticInstructionListForGeneration after_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mAfterInstructionList
    !mEndOf_after_branch
    !?ioVariableMap
    ?after_instructionList
  ;
#--- End override
  [!?ioVariableMap endOverride !mEndOf_foreach_instruction] ;
#--- End override for foreach defined constants
  [!?ioVariableMap endBranch !mEndOf_foreach_instruction] ;
  [!?ioVariableMap endOverride !mEndOf_foreach_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@foreachInstructionForGeneration new
    !mInstructionLocation
    !enumerationList
    !indexCppName
    !whileExpression
    !before_instructionList
    !between_instructionList
    !do_instructionList
    !after_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @loopInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Variant expression
  @semanticExpressionForGeneration variantExpression ;
  [mVariantExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?variantExpression
  ] ;
#--- Check variant expression type is @uint
  if [variantExpression mType] != inPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    : "the variant expression type should be '@" . [inPredefinedTypes->mUIntType key] . "', but it has '@" . [[variantExpression mType] key] . "' type" ;
  end if ;
#--- Loop expression
  @semanticExpressionForGeneration loopExpression ;
  [mLoopExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?loopExpression
  ] ;
#--- Check loop expression type is @bool
  if [loopExpression mType] != inPredefinedTypes->mBoolType then
    error mEndOfLoopExpression
    : "the loop expression type should be '@" . [inPredefinedTypes->mBoolType key] . "', but it has '@" . [[loopExpression mType] key] . "' type" ;
  end if ;
#--- Begin override for analyze loop instruction list
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- First branch
  @semanticInstructionListForGeneration first_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mFirstInstructions
    !mEndOfFirstInstructions
    !?ioVariableMap
    ?first_instructionList
  ;
#--- Second branch
  @semanticInstructionListForGeneration second_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mSecondInstructions
    !mEndOfSecondInstructions
    !?ioVariableMap
    ?second_instructionList
  ;
#--- End override
  [!?ioVariableMap endOverride !mEndOfLoopInstruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@loopInstructionForGeneration new
    !mInstructionLocation
    !variantExpression
    !first_instructionList
    !loopExpression
    !second_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @structuredCastInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Expression
  @semanticExpressionForGeneration castExpression ;
  [mCastExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?castExpression
  ] ;
#--- Begin override for analyze loop instruction list
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- Branches
  @castInstructionBranchListForGeneration castBranchList [emptyList] ;
  foreach mCastInstructionBranchList do
  #--- Get named type
    const @unifiedTypeMapProxy type := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  #--- Check named type is a descendant of receiver type
    @unifiedTypeMapProxy t := type ;
    @bool found := t == [castExpression mType] ;
    loop [inSemanticContext->mTypeMap count] + 1 :
    while (not found) & not [[t mSuperType] isNull] do
      t := [t mSuperType] ;
      found := t == [castExpression mType] ;
    end loop ;
    if not found then
      error mTypeName
      :"the '@" . mTypeName . "' is not a descendant of the '@" . [[castExpression mType] key] . "' type of the cast expression"
      ;
    end if ;
  #--- Declare a local constant ?
    @string localConstantName ;
    @localConstantList localConstantList [emptyList] ;
    if [mConstantVarName length] > 0 then
      localConstantName := "cast_" . [[[mConstantVarName location] locationIndex] string] . "_" . mConstantVarName ;
      localConstantList +=
        !type
        !mConstantVarName
        !false # Warns id not used
        !localConstantName
      ;
    else
      localConstantName := "" ; # No constant
    end if ;
  #--- Analyze instruction list
    @semanticInstructionListForGeneration instructionList ;
    analyzeSemanticInstructionList
      !inSemanticContext
      !inPredefinedTypes
      !localConstantList
      ![@localInitializedVariableList emptyList]
      !mInstructionList
      !mEndOfInstructions
      !?ioVariableMap
      ?instructionList
    ;
    castBranchList += !mUseKindOfClass !type !localConstantName !instructionList ;
  end foreach ;
#--- else or default branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !mElseInstructionList
    !mEndOfCastInstruction
    !?ioVariableMap
    ?else_instructionList
  ;
#--- End override
  [!?ioVariableMap endOverride !mEndOfCastInstruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@structuredCastInstructionForGeneration new
    !castExpression
    !castBranchList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Search grammar in grammar map
  @grammarLabelMap grammarLabelMap ;
  [inSemanticContext->mGrammarMap searchKey
    !mGrammarComponentName
    ?grammarLabelMap
  ] ;
#--- Search label
  @formalParameterSignature labelSignature ;
  [grammarLabelMap searchKey
    !mLabelName
    ?labelSignature
  ] ;
#--- Check actual parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mLabelName
    !"label of the " . mGrammarComponentName . " grammar"
    !labelSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#--- Parse source expression
  @semanticExpressionForGeneration sourceExpression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?sourceExpression
  ] ;
#--- Check source expression type: @lstring for file, @string for source string itself
  if mSourceExpressionIsFile then
    if [sourceExpression mType] != inPredefinedTypes->mLStringType then
      error mEndOfSourceExpression
      :"this expression is the source file path and its type should be '@lstring', but it is '@" . [[sourceExpression mType] key] . "'"
      ;
    end if ;
  elsif [sourceExpression mType] != inPredefinedTypes->mStringType then
    error mEndOfSourceExpression
    :"this expression is the source string and its type should be '@string', but it is '@" . [[sourceExpression mType] key] . "'"
    ;
  end if ;
#--- Generate instruction
  if mSourceExpressionIsFile then
    ioInstructionListForGeneration += ![@grammarInstructionWithSourceFileForGeneration new
      !mInstructionLocation
      ![mGrammarComponentName string]
      ![mLabelName string]
      !sourceExpression
      !actualParameterListForGeneration
    ] ;
  else
    ioInstructionListForGeneration += ![@grammarInstructionWithSourceExpressionForGeneration new
      !mInstructionLocation
      ![mGrammarComponentName string]
      ![mLabelName string]
      !sourceExpression
      !actualParameterListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @readWriteAccessWithInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Analyze source expression
  @semanticExpressionForGeneration keyExpression ;
  [mKeyExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?keyExpression
  ] ;
#--- Object Array cpp name
  const @string objectArrayCppName := "objectArray_" . [[mInstructionLocation locationIndex] string] ;
#--- Read/write access to receiver variable
  @unifiedTypeMapProxy targetType ;
  @string receiverVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?receiverVariableCppName] ;
  foreach mFieldList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check this type handle 'with' access
  const @withAccessorMap withAccessorMap := [targetType mWithAccessorMap] ;
  @unifiedTypeMapProxyList argumentTypeList ;
  with withAccessorMap hasKey ![mAccessName string] do
    argumentTypeList := [@unifiedTypeMapProxyList listWithValue !mArgumentType] ;
  else
    if [withAccessorMap count] == 0 then
      error mAccessName
      : "the '@". [targetType key] . "' type cannot be used in a 'with' instruction"
      : argumentTypeList
      ;
    else
      @string s := "" ;
      foreach withAccessorMap do
        s .= "\n  - " . lkey ." ?@" . [mArgumentType key] ;
      end foreach ;
      error mAccessName
      : "the '@". [targetType key] . "' type does not define the '" . mAccessName . "' accessor for the 'with' instruction; available "
      . if [withAccessorMap count] > 1 then "accessors are" else "accessor is" end
      . ":" . s
      : argumentTypeList
      ;
    end if ;
  end with ;
#--- Check parameter list
  const @semanticExpressionListForGeneration effectiveExpressionList [listWithValue !keyExpression]  ;
  if [effectiveExpressionList length] != [argumentTypeList length] then
    error mAccessName: "calling the '" . mAccessName . "' accessor of '@" . [targetType key] . "' requires "
    . [[argumentTypeList length] string] . " parameter(s), while this call has "
    . [[effectiveExpressionList length] string] . " parameter(s)" ;
  else
    foreach effectiveExpressionList, argumentTypeList do
      checkAssignmentTypes !mType ![mExpression mType] ![mAccessName location] ;
    end foreach ;
  end if ;
#--- Enter in a select block
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- 'do' branch
  @localInitializedVariableList localInitializedVariableList [emptyList] ;
  foreach [targetType mCurrentTypedAttributeList] index IDX do
    localInitializedVariableList +=
      !mAttributeTypeIndex
      ![@lstring new ![mPrefix string] . mAttributeName ![mAccessName location]]
      !"* ((GALGASap_" . [mAttributeTypeIndex identifierRepresentation] . " *) " . objectArrayCppName . "->pointerAtIndex (" . [IDX+1 string] . " /* " . [mAttributeName identifierRepresentation] . " */ COMMA_HERE))"
    ;
  end foreach ;
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    !localInitializedVariableList
    !m_do_Instructions
    !mEndOf_do_instructions
    !?ioVariableMap
    ?do_instructionList
  ;
#--- else branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    ![@localConstantList emptyList]
    ![@localInitializedVariableList emptyList]
    !m_else_Instructions
    !mEndOf_else_instructions
    !?ioVariableMap
    ?else_instructionList
  ;
  [!?ioVariableMap endOverride !mEndOf_else_instructions] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@readWriteWithInstructionForGeneration new
    !receiverVariableCppName
    !targetType
    !mFieldList
    ![mAccessName string]
    !objectArrayCppName
    !keyExpression
    !do_instructionList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @readAccessWithInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  error mSearchMethodName
  : "unhandled instruction @readAccessWithInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @switchInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  error mInstructionLocation
  : "unhandled instruction @switchInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @matchInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  error mInstructionLocation
  : "unhandled instruction @matchInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
