#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticInstructionsAnalysis :
  import "semanticExpressionAnalysis.gSemantics" ;
  import semantics semanticExpressionAnalysis in "semanticExpressionAnalysis.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I N S T R U C T I O N    A N A L Y S I S                               *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
;

#---------------------------------------------------------------------------*

routine analyzeSemanticInstructionList
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@semanticInstructionListAST inSemanticInstructionListAST
  ??@location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
  ?!@bool ioUsesCompilerArgument
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap beginBranch] ;
#--- Instruction list
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSemanticInstructionListAST do
    [mInstruction analyzeSemanticInstruction
      !inSemanticContext
      !inPredefinedTypes
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?localVariableCppNameList
      !?ioUsesCompilerArgument
    ] ;
  end foreach ;
#--- Drop local variables
  if [localVariableCppNameList length] > 0 then
    outInstructionListForGeneration += ![@dropInstructionForGeneration new
      !localVariableCppNameList
      !"end of scope"
    ] ;  
  end if ;
#--- Branch end
  [!?ioVariableMap endBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze constructor call
  @unifiedTypeMapProxy returnedType ;
  @semanticExpressionListForGeneration constructorEffectiveParameterList ;
  @bool hasCompilerArgument ;
  analyzeConstructorInvocation
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    !mTypeName
    !mConstructorName
    !mConstructorExpressions
    ?returnedType
    ?constructorEffectiveParameterList
    ?hasCompilerArgument
    !?ioUsesCompilerArgument
  ;
  if hasCompilerArgument then
    ioUsesCompilerArgument := true ;
  end if ;
#--- Check variable type
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  if targetType != returnedType then
    error mConstructorName
    :"this constructor returns an '@" . [returnedType key] ."' object, you should use a constructor that return an '@" . mTypeName . "' object"
    ;
  end if ;
#--- Declare variable (or constant)
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  ioLocalVariableCppNameList += !targetVariableCppName ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithConstructorCallForGeneration new
    !targetType
    !mIsConstant
    !targetVariableCppName
    ![mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
    !?ioUsesCompilerArgument
  ] ;
#--- Check target variable
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  ioLocalVariableCppNameList += !targetVariableCppName ;
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName] ;
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableOrConstantDeclarationWithSourceExpressionForGeneration new
    !targetType
    !mIsConstant
    !targetVariableCppName
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
#--- Check target variable
  const @unifiedTypeMapProxy targetType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  const @string targetVariableCppName := "var_" . [mVariableName identifierRepresentation] ;
  ioLocalVariableCppNameList += !targetVariableCppName ;
  [!?ioVariableMap insertUndefinedLocalVariable !mVariableName !targetType !targetVariableCppName] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@localVariableDeclarationForGeneration new
    !targetType
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @assignmentInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
    !?ioUsesCompilerArgument
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  if [mStructAttributeList length] == 0 then
    [!?ioVariableMap searchForWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
  else
    [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
    foreach mStructAttributeList do
      const @attributeMap attributeMap := [targetType mAttributeMap] ;
      [attributeMap searchKey !mValue ?targetType] ;
    end foreach ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@assignmentInstructionForGeneration new
    !targetVariableCppName
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @sendInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
    !?ioUsesCompilerArgument
  ] ;
#--- Check source expression type is @string
  if [expression mType] != inPredefinedTypes->mStringType then
    error mInstructionLocation
    :"the send expression type is '@" . [[expression mType] key] . "'; it should be of the '@string' type"
    ;
  end if ;
  ioInstructionListForGeneration += ![@sendInstructionForGeneration new !expression] ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeErrorOrWarningInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@semanticExpressionAST inLocationExpression
  ??@semanticExpressionAST inMessageExpression
  ??@location inErrorLocation
  ??@string inErrorOrWarningString
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outLocationExpression
  !@semanticExpressionForGeneration outMessageExpression
  !@bool outUseLocationReader
:
#--- Analyze location expression
  @bool useless := false ; 
  [inLocationExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?outLocationExpression
    !?useless # Useless because 'warning' and 'error' instruction do use compiler argument
  ] ;
#--- Check location expression type is either @location either has a correct location reader
  outUseLocationReader := [outLocationExpression mType] != inPredefinedTypes->mLocationType ;
  if outUseLocationReader then
    const @readerMap readerMap := [[outLocationExpression mType] mReaderMap] ;
    with readerMap hasKey !"location" do
      if [mArgumentTypeList length] != 0 then
        error inErrorLocation
        :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
        . "' and defines a 'location' reader with arguments; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
        ;      
      elsif mReturnedType != inPredefinedTypes->mLocationType then
        error inErrorLocation
        :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
        . "' and defines a 'location' reader that returns an '@" . [mReturnedType key]
        . "' object; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
        ;      
      end if ;
    else
      error inErrorLocation
      :"the " . inErrorOrWarningString . " location expression type is '@" . [[outLocationExpression mType] key]
      . "' and does not define a 'location' reader; it should be either of the '@location' type, either defines a 'location' reader without argument that returns an '@location' object"
      ;
    end with ;
  end if ;
#--- Analyze message expression
  [inMessageExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?outMessageExpression
    !?useless
  ] ;
#--- Check message expression type is @string
  if [outMessageExpression mType] != inPredefinedTypes->mStringType then
    error inErrorLocation
    :"the " . inErrorOrWarningString . " message expression type is '@" . [[outMessageExpression mType] key] . "'; it should be of the '@string' type"
    ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @errorInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
  ioUsesCompilerArgument := true ;
#---
  @semanticExpressionForGeneration locationExpression ;
  @semanticExpressionForGeneration messageExpression ;
  @bool useLocationReader ;
  analyzeErrorOrWarningInstruction
    !inSemanticContext
    !inPredefinedTypes
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"error"
    !?ioVariableMap
    ?locationExpression
    ?messageExpression
    ?useLocationReader
  ;
#--- Handle dropped variables
  @stringlist builtVariableCppNameList [emptyList] ;
  foreach mBuiltVariableList do
    @string varCppName ;
    [!?ioVariableMap searchForWriteAccess !mValue ?* ?varCppName] ;
    builtVariableCppNameList += !varCppName ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@errorInstructionForGeneration new
    !locationExpression
    !useLocationReader
    !messageExpression
    !builtVariableCppNameList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @warningInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
  ioUsesCompilerArgument := true ;
#---
  @semanticExpressionForGeneration locationExpression ;
  @semanticExpressionForGeneration messageExpression ;
  @bool useLocationReader ;
  analyzeErrorOrWarningInstruction
    !inSemanticContext
    !inPredefinedTypes
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"warning"
    !?ioVariableMap
    ?locationExpression
    ?messageExpression
    ?useLocationReader
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@warningInstructionForGeneration new
    !locationExpression
    !useLocationReader
    !messageExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

abstract method @actualParameterAST checkAgainstFormalArgument
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@temporaryInputVariableForRoutineInvocationForGeneration ioTemporaryInputVariableForRoutineInvocationForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@bool ioUsesCompilerArgument
;

#---------------------------------------------------------------------------*

override method @outputActualParameterAST checkAgainstFormalArgument
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@temporaryInputVariableForRoutineInvocationForGeneration unused ioTemporaryInputVariableForRoutineInvocationForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@bool ioUsesCompilerArgument
:
  if (inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentIn])
   & (inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentConstantIn]) then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  else
    @semanticExpressionForGeneration expression ;
    [mOutputActualParameterExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?expression
      !?ioUsesCompilerArgument
    ] ;
  #--- Check effective expression type against formal argument type
    checkAssignmentTypes !inFormalArgumentType ![expression mType] !mEndOfExpressionLocation ;
  #--- Generate actual parameter
    ioActualParameterListForGeneration += ![@outputActualParameterForGeneration new
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @outputInputActualParameterAST checkAgainstFormalArgument
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@temporaryInputVariableForRoutineInvocationForGeneration unused ioTemporaryInputVariableForRoutineInvocationForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@bool unused ioUsesCompilerArgument
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentInOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  end if ;
#--- Analyze input/output variable
  @unifiedTypeMapProxy parameterType ;
  @string variableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mOutputInputActualParameterName ?parameterType ?variableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [parameterType mAttributeMap] ;
    [attributeMap searchKey !mValue ?parameterType] ;
  end foreach ;
#--- Check type
  if inFormalArgumentType != parameterType then
    error mOutputInputActualParameterName
    :"the parameter object has the '@" . [parameterType key]
    . "', it should be the same as the corresponding formal argument: '@" . [inFormalArgumentType key] . "'"
    ;
  end if ;
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mOutputInputActualParameterName string]] then
    error mOutputInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
    ;
  end if ;
  ioExclusiveVariableSet += ![mOutputInputActualParameterName string] ;
#--- Generate actual parameter
  ioActualParameterListForGeneration += ![@outputInputActualParameterForGeneration new
    !variableCppName
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputActualParameterAST checkAgainstFormalArgument
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@temporaryInputVariableForRoutineInvocationForGeneration unused ioTemporaryInputVariableForRoutineInvocationForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@bool unused ioUsesCompilerArgument
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  end if ;
  @unifiedTypeMapProxy parameterType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForWriteAccess !mInputActualParameterName ?parameterType ?targetVariableCppName] ;
#--- Check type
  if inFormalArgumentType != parameterType then
    error mInputActualParameterName
    :"the parameter object has the '@" . [parameterType key]
    . "', it should be the same as the corresponding formal argument: '@" . [inFormalArgumentType key] . "'"
    ;
  end if ;
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mInputActualParameterName string]] then
    error mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
    ;
  end if ;
  ioExclusiveVariableSet += ![mInputActualParameterName string] ;
#--- Generate actual parameter
  ioActualParameterListForGeneration += ![@inputActualParameterForGeneration new
    !targetVariableCppName
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @inputJokerActualParameterAST checkAgainstFormalArgument
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@unifiedTypeMapProxy inFormalArgumentType
  ??@formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@temporaryInputVariableForRoutineInvocationForGeneration ioTemporaryInputVariableForRoutineInvocationForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@bool unused ioUsesCompilerArgument
:
  if inFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
    error mQualifierLocation
    :"the corresponding formal argument has the '" . [inFormalArgumentPassingMode string]
    . "' passing mode: this parameter should be passed with '" . [inFormalArgumentPassingMode correspondingEffectiveParameterString] . "'"
    ;
  else
    const @string cppVarName := "joker_" . [[mQualifierLocation locationIndex] string] . "_" . [mJokerIndex string] ;
  #--- Add temporary variable
    ioTemporaryInputVariableForRoutineInvocationForGeneration += !inFormalArgumentType !cppVarName ;
  #--- Generate actual parameter
    ioActualParameterListForGeneration += ![@inputActualParameterForGeneration new
      !cppVarName
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeRoutineArguments
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@lstring inRoutineName
  ??@string inInvokedEntityName
  ??@formalParameterSignature inRoutineSignature
  ??@actualParameterListAST inActualParameterList
  ?!@variableMap ioVariableMap
  !@actualParameterListForGeneration outActualParameterListForGeneration
  !@temporaryInputVariableForRoutineInvocationForGeneration outTemporaryInputVariableForRoutineInvocationForGeneration
  ?!@bool ioUsesCompilerArgument
:
  if [inRoutineSignature length] != [inActualParameterList length] then
    error inRoutineName
    :"the '" . inRoutineName . "' " . inInvokedEntityName . " header defines " . [[inRoutineSignature length] string] 
    . " formal argument(s), but this invocation names "
    . [[inActualParameterList length] string] . " argument(s)"
    : outActualParameterListForGeneration, outTemporaryInputVariableForRoutineInvocationForGeneration
    ;
  else
    outActualParameterListForGeneration := [@actualParameterListForGeneration emptyList] ;
    outTemporaryInputVariableForRoutineInvocationForGeneration := [@temporaryInputVariableForRoutineInvocationForGeneration emptyList] ;
    @stringset exclusiveVariableSet [emptySet] ;
    foreach inRoutineSignature, inActualParameterList do
      [mActualParameter checkAgainstFormalArgument
        !inSemanticContext
        !inPredefinedTypes
        !mFormalArgumentType
        !mFormalArgumentPassingMode
        !?ioVariableMap
        !?outActualParameterListForGeneration
        !?outTemporaryInputVariableForRoutineInvocationForGeneration
        !?exclusiveVariableSet
        !?ioUsesCompilerArgument
      ] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @routineCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
  ioUsesCompilerArgument := true ;
#--- Get routine signature
  @formalParameterSignature routineSignature ;
  [inSemanticContext->mRoutineMap searchKey !mRoutineName ?routineSignature] ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  @temporaryInputVariableForRoutineInvocationForGeneration temporaryInputVariableForRoutineInvocationForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mRoutineName
    !"routine"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
    ?temporaryInputVariableForRoutineInvocationForGeneration
    !?ioUsesCompilerArgument
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@routineCallInstructionForGeneration new
    !mRoutineName
    !actualParameterListForGeneration
    !temporaryInputVariableForRoutineInvocationForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @typeMethodCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Get type method map for the named type
  const @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Get type method signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[type mClassMethodMap] searchKey !mMethodName ?routineSignature ?hasCompilerArgument] ;
  if hasCompilerArgument then
    ioUsesCompilerArgument := true ;
  end if ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  @temporaryInputVariableForRoutineInvocationForGeneration temporaryInputVariableForRoutineInvocationForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mMethodName
    !"class method"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
    ?temporaryInputVariableForRoutineInvocationForGeneration
    !?ioUsesCompilerArgument
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@typeMethodInstructionForGeneration new
    !mTypeName
    !mMethodName
    !actualParameterListForGeneration
    !hasCompilerArgument
    !temporaryInputVariableForRoutineInvocationForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @methodCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze receiver expression
  @semanticExpressionForGeneration receiverExpression ;
  [mReceiverExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?receiverExpression
    !?ioUsesCompilerArgument
  ] ;
#--- Get type method signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[[receiverExpression mType] mInstanceMethodMap] searchKey !mMethodName ?routineSignature ?* ?hasCompilerArgument ?*] ;
  if hasCompilerArgument then
    ioUsesCompilerArgument := true ;
  end if ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  @temporaryInputVariableForRoutineInvocationForGeneration temporaryInputVariableForRoutineInvocationForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mMethodName
    !"instance method"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
    ?temporaryInputVariableForRoutineInvocationForGeneration
    !?ioUsesCompilerArgument
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@methodCallInstructionForGeneration new
    !receiverExpression
    ![mMethodName string]
    !actualParameterListForGeneration
    !hasCompilerArgument
    !temporaryInputVariableForRoutineInvocationForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @modifierCallInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Check receiver object
  @unifiedTypeMapProxy receiverType ;
  @string receiverVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?receiverType ?receiverVariableCppName] ;
  foreach mReceiverStructAttributes do
    const @attributeMap attributeMap := [receiverType mAttributeMap] ;
    [attributeMap searchKey !mValue ?receiverType] ;
  end foreach ;
#--- Get modifier signature
  @formalParameterSignature routineSignature ;
  @bool hasCompilerArgument ;
  [[receiverType mModifierMap] searchKey !mModifierName ?routineSignature ?hasCompilerArgument] ;
  if hasCompilerArgument then
    ioUsesCompilerArgument := true ;
  end if ;
#--- Check effective parameters
  @actualParameterListForGeneration actualParameterListForGeneration ;
  @temporaryInputVariableForRoutineInvocationForGeneration temporaryInputVariableForRoutineInvocationForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mModifierName
    !"modifier"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
    ?temporaryInputVariableForRoutineInvocationForGeneration
    !?ioUsesCompilerArgument
  ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@modifierCallInstructionForGeneration new
    !receiverVariableCppName
    !mReceiverStructAttributes
    !mModifierName
    !actualParameterListForGeneration
    !hasCompilerArgument
    !temporaryInputVariableForRoutineInvocationForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @appendInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mSourceExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
    !?ioUsesCompilerArgument
  ] ;
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mTargetVariableName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target variable type support '.=' operator
  if ([targetType mHandledOperatorFlags] & dotAssignOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '.=' operator"
    ;
  end if ;
#--- Check assignment type compatibility
  checkAssignmentTypes !targetType ![expression mType] !mInstructionLocation ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@appendInstructionForGeneration new
    !targetVariableCppName
    !mStructAttributeList
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @addInstructionAST analyzeSemanticInstruction # +=
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool  ioUsesCompilerArgument
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target variable type support '+=' operator
  const @unifiedTypeMapProxyList addAssignOperatorArguments:= [targetType mAddAssignOperatorArguments] ; # Empty list if += operator is not supported
  if [addAssignOperatorArguments length] == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '+=' operator"
    ;
#--- Analyze source expressions
  elsif [mExpressions length] != [addAssignOperatorArguments length] then
    error mInstructionLocation
    : "calling the '+=' operator on an '@" . [targetType key] . "' object requires "
    . [[addAssignOperatorArguments length] string] . " parameter(s), while this invocation has "
    . [[mExpressions length] string] . " parameter(s)" 
    ;
  else
    @semanticExpressionListForGeneration effectiveParameterList [emptyList] ;
    foreach mExpressions, addAssignOperatorArguments do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression
        !inSemanticContext
        !inPredefinedTypes
        !?ioVariableMap
        ?exp
        !?ioUsesCompilerArgument
      ] ;
      checkAssignmentTypes !mType ![exp mType] !mEndOfExpressionLocation ;
      effectiveParameterList += !exp ;
    end foreach ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@addAssignInstructionForGeneration new
      !targetVariableCppName
      !mStructAttributeList
      !effectiveParameterList
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @incrementInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target type accepts incrementation
  if ([targetType mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '++' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@incrementInstructionForGeneration new
    !targetVariableCppName
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @decrementInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
#--- Check target variable
  @unifiedTypeMapProxy targetType ;
  @string targetVariableCppName ;
  [!?ioVariableMap searchForReadWriteAccess !mReceiverName ?targetType ?targetVariableCppName] ;
  foreach mStructAttributeList do
    const @attributeMap attributeMap := [targetType mAttributeMap] ;
    [attributeMap searchKey !mValue ?targetType] ;
  end foreach ;
#--- Check target type accepts incrementation
  if ([targetType mHandledOperatorFlags] & incDecOperator []) == 0 then
    error mInstructionLocation
    :"the target object has the '@" . [targetType key] . "' type, but this type does not support the '++' operator"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@decrementInstructionForGeneration new
    !targetVariableCppName
    !mStructAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @messageInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze source expression
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?expression
    !?ioUsesCompilerArgument
  ] ;
#--- Check message type is @string
  if [expression mType] != inPredefinedTypes->mStringType then
    error mInstructionLocation
    :"the expression has the '@" . [[expression mType] key] . "' type, but the 'message' instruction requires an '@string' expression"
    ;
  end if ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@messageInstructionForGeneration new
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @logInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
  foreach mLogList do
  #--- Analyze source expression
    @semanticExpressionForGeneration expression ;
    [mLogExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?expression
      !?ioUsesCompilerArgument
    ] ;
  #--- Generate instruction
    ioInstructionListForGeneration += ![@logInstructionForGeneration new
      !mLogMessage
      !expression
    ] ;  
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @dropInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
  @stringlist cppNameDropList [emptyList] ;
  foreach mDropList do
    @string variableCppName ;
    [!?ioVariableMap searchForDropAccess !mValue ?* ?variableCppName] ;
    cppNameDropList += !variableCppName ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@dropInstructionForGeneration new
     !cppNameDropList
     !"drop instruction"
  ] ;  
end method ;

#---------------------------------------------------------------------------*

override method @ifInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Test expression
  @semanticExpressionForGeneration if_expression ;
  [m_if_expression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?if_expression
    !?ioUsesCompilerArgument
  ] ;
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- Then branch
  @semanticInstructionListForGeneration then_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !m_then_instructionList
    !mEndOf_then_branch
    !?ioVariableMap
    ?then_instructionList
    !?ioUsesCompilerArgument
  ;
#--- else branch
  @semanticInstructionListForGeneration else_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !m_else_instructionList
    !mEndOf_if_instruction
    !?ioVariableMap
    ?else_instructionList
    !?ioUsesCompilerArgument
  ;
  [!?ioVariableMap endOverride !mEndOf_if_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@ifInstructionForGeneration new
    !if_expression
    !mEndOf_then_branch
    !then_instructionList
    !else_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @foreachInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Analyze enumerated objects
  @foreachInstructionEnumeratedObjectListForGeneration enumerationList [emptyList] ;
  foreach mEnumeratedObjectList do
  #--- Enumeration expression
    @semanticExpressionForGeneration enumerationExpression ;
    [mEnumeratedExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?enumerationExpression
      !?ioUsesCompilerArgument
    ] ;
  #--- Check object can be enumerated
    const @string enumeratorCppName := "enumerator_" . [[mEndOfEnumerationExpression locationIndex] string] ;
    const @enumerationDescriptorList enumerationDescriptorList := [[enumerationExpression mType] mEnumerationDescriptor] ;
    if [enumerationDescriptorList length] == 0 then
      error mEndOfEnumerationExpression : "an '@" . [[enumerationExpression mType] key] . "' object cannot be enumerated" ;
  #--- Arguments
    elsif ([mElementList length] == 0) & not mEndsWithEllipsis then
      error mEndOfEnumerationExpression : "TO DO !" ;
    elsif (not mEndsWithEllipsis) & ([mElementList length] != [enumerationDescriptorList length]) then
      error mEndOfElementList
      :"the '@" . [[enumerationExpression mType] key] . "' type requires "
      . [[enumerationDescriptorList length] string] . " argument"
      . if ([enumerationDescriptorList length] > 1) then "s" else "" end
      . " for enumeration: this list provides "
      . [[mElementList length] string]
      ;
    elsif (mEndsWithEllipsis) & ([mElementList length] > [enumerationDescriptorList length]) then
      error mEndOfElementList
      :"the '@" . [[enumerationExpression mType] key] . "' type requires "
      . [[enumerationDescriptorList length] string] . " argument"
      . if ([enumerationDescriptorList length] > 1) then "s" else "" end
      . " or less for enumeration: this list provides "
      . [[mElementList length] string]
      ;
    else
      foreach mElementList, enumerationDescriptorList do
        if [mConstantName string] != "" then # Empty string if joker
          const @unifiedTypeMapProxy foundType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
          if foundType != mEnumeratedType then
            error mTypeName : "incorrect '@" . [foundType key] . "' type: '@" . [mEnumeratedType key] . "' type required here" ;
          end if ;
          [!?ioVariableMap insertUsedLocalConstant !mConstantName !mEnumeratedType !enumeratorCppName .".attribute_" . [mEnumerationName identifierRepresentation]. " ()"] ;
        end if ;
      end foreach ;
    end if ;
  #---
    enumerationList += !mIsAscending !enumerationExpression !enumeratorCppName ;
  end foreach ;
#--- While expression
  @semanticExpressionForGeneration whileExpression ;
  [mWhileExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?whileExpression
    !?ioUsesCompilerArgument
  ] ;
#--- Begin override for analyze foreach instruction list
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- 'before' branch
  @semanticInstructionListForGeneration before_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !mBeforeInstructionList
    !mEndOf_before_branch
    !?ioVariableMap
    ?before_instructionList
    !?ioUsesCompilerArgument
  ;
#--- Handle index
  @string indexCppName := "" ; # Empty string if no index
  if [mIndexVariableName string] != "" then
    indexCppName := "index_" . [[mInstructionLocation locationIndex] string] ;
    [!?ioVariableMap insertLocalConstant !mIndexVariableName !inPredefinedTypes->mUIntType !indexCppName] ;
  end if ;
#--- 'do' branch
  if [mIndexVariableName length] > 0 then
    error mIndexVariableName : "TO DO: handle index in foreach instruction" ;
  end if ;
  @semanticInstructionListForGeneration do_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !mDoInstructionList
    !mEndOf_do_branch
    !?ioVariableMap
    ?do_instructionList
    !?ioUsesCompilerArgument
  ;
#--- Remove index
  if [mIndexVariableName string] != "" then
    [!?ioVariableMap removeKey !mIndexVariableName ?* ?*] ;
  end if ;
#--- 'between' branch
  @semanticInstructionListForGeneration between_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !mBetweenInstructionList
    !mEndOf_between_branch
    !?ioVariableMap
    ?between_instructionList
    !?ioUsesCompilerArgument
  ;
#--- 'after' branch
  @semanticInstructionListForGeneration after_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !mAfterInstructionList
    !mEndOf_after_branch
    !?ioVariableMap
    ?after_instructionList
    !?ioUsesCompilerArgument
  ;
#--- End override
  [!?ioVariableMap endOverride !mEndOf_foreach_instruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@foreachInstructionForGeneration new
    !enumerationList
    !indexCppName
    !whileExpression
    !before_instructionList
    !between_instructionList
    !do_instructionList
    !after_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @loopInstructionAST analyzeSemanticInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool ioUsesCompilerArgument
:
#--- Variant expression
  @semanticExpressionForGeneration variantExpression ;
  [mVariantExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?variantExpression
    !?ioUsesCompilerArgument
  ] ;
#--- Check variant expression type is @uint
  if [variantExpression mType] != inPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    : "the variant expression type should be '@" . [inPredefinedTypes->mUIntType key] . "', but it has '@" . [[variantExpression mType] key] . "' type" ;
  end if ;
#--- Loop expression
  @semanticExpressionForGeneration loopExpression ;
  [mLoopExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?loopExpression
    !?ioUsesCompilerArgument
  ] ;
#--- Check loop expression type is @bool
  if [loopExpression mType] != inPredefinedTypes->mBoolType then
    error mEndOfLoopExpression
    : "the loop expression type should be '@" . [inPredefinedTypes->mBoolType key] . "', but it has '@" . [[loopExpression mType] key] . "' type" ;
  end if ;
#--- Begin override for analyze loop instruction list
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- First branch
  @semanticInstructionListForGeneration first_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !mFirstInstructions
    !mEndOfFirstInstructions
    !?ioVariableMap
    ?first_instructionList
    !?ioUsesCompilerArgument
  ;
#--- Second branch
  @semanticInstructionListForGeneration second_instructionList ;
  analyzeSemanticInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !mSecondInstructions
    !mEndOfSecondInstructions
    !?ioVariableMap
    ?second_instructionList
    !?ioUsesCompilerArgument
  ;
#--- End override
  [!?ioVariableMap endOverride !mEndOfLoopInstruction] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@loopInstructionForGeneration new
    !variantExpression
    !first_instructionList
    !loopExpression
    !second_instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @castInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
  error mInstructionLocation
  : "unhandled instruction @castInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @withInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
  error mTargetObjectName
  : "unhandled instruction @withInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @switchInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
  error mInstructionLocation
  : "unhandled instruction @switchInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @matchInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
  error mInstructionLocation
  : "unhandled instruction @matchInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionAST analyzeSemanticInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
  ?!@bool unused ioUsesCompilerArgument
:
  error mGrammarComponentName
  : "unhandled instruction: @grammarInstructionAST"
  ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
