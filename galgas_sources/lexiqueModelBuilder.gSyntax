#---------------------------------------------------------------------------*
#                                                                           *
#  'option' component parser, as model builder                              *
#                                                                           *
#  Copyright (C) 2007, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax lexiqueModelBuilder :
import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics lexiqueMetamodel in "lexiqueMetamodel.gSemantics" ;

nonterminal <lexique_component_start_symbol> !@lexiqueComponentRoot outLexiqueComponentRoot;

nonterminal <lexical_attribute_declaration> ?!@lexicalAttributeList ioLexicalAttributeList ;

nonterminal <style_declaration> ?!@lexicalStyleList ioLexicalStyleList ;

nonterminal <terminal_declaration> ?!@terminalDeclarationList ioTerminalDeclarationList ;

nonterminal <lexical_list_declaration> ?!@lexicalListDeclarationList ioLexicalListDeclarationList ;

nonterminal <lexical_list_entry> ?!@lexicalListEntryList ioLexicalListEntryList ;

nonterminal <lexical_explicit_rule> ?!@lexicalExplicitRuleList ioLexicalExplicitRuleList ;

nonterminal <lexical_implicit_rule> ?!@lexicalImplicitRuleList ioLexicalImplicitRuleList ;

nonterminal <lexical_error_message_declaration> ?!@lexicalErrorMessageDeclarationList ioLexicalErrorMessageDeclaration ;

nonterminal <lexical_instruction> ?!@lexicalInstructionList ioInstructionList ;

nonterminal <lexical_send_instruction> !@lexicalInstruction outInstruction ;

nonterminal <function_call_or_attribute> ??@lstring inIdf !@lexicalActualArgument outArgument ;

nonterminal <lexical_action_effective_argument> ?!@lexicalActualArgumentList ioLexicalActualArgumentList ;

nonterminal <lexical_expression> !@lexicalExpression outExpression ;

nonterminal <lexical_term> !@lexicalExpression outExpression ;

nonterminal <lexical_factor> !@lexicalExpression outExpression ;

nonterminal <repeat_while_branch> ?!@lexicalWhileBranchList ioLexicalWhileBranchList ;

nonterminal <template_delimitor> ?!@templateDelimitorList ioTemplateDelimitorList ;

nonterminal <template_replacement> ?!@templateReplacementList ioTemplateReplacementList ;

#---------------------------------------------------------------------------*

rule <lexique_component_start_symbol> !@lexiqueComponentRoot outLexiqueComponentRoot :
  @lstring lexiqueComponentName ;
  @bool isTemplate ;
  @templateDelimitorList templateDelimitorList [emptyList] ;
  @templateReplacementList templateReplacementList [emptyList] ;
  @lexicalAttributeList lexicalAttributeList [emptyList] ;
  @lexicalStyleList lexicalStyleList [emptyList] ;
  @terminalDeclarationList terminalDeclarationList [emptyList] ;
  @lexicalErrorMessageDeclarationList lexicalErrorMessageDeclarationList [emptyList] ;
  @lexicalListDeclarationList lexicalListDeclarationList [emptyList] ;
  @lexicalImplicitRuleList lexicalImplicitRuleList [emptyList] ;
  @lexicalExplicitRuleList lexicalExplicitRuleList [emptyList] ;
  select
    isTemplate := true ;
    $template$ ;
  or
    isTemplate := false ;
  end select ;
  $lexique$ ;
#--- Lexique Component Name
  $identifier$ ? lexiqueComponentName ;
  $:$ ;
#--- Parse the option list
  repeat
  while 
    <template_delimitor> !? templateDelimitorList ;
  while 
    <template_replacement> !? templateReplacementList ;
  while 
    <lexical_attribute_declaration> !? lexicalAttributeList ;
  while 
    <style_declaration> !? lexicalStyleList ;
  while 
    <terminal_declaration> !? terminalDeclarationList ;
  while 
    <lexical_list_declaration> !? lexicalListDeclarationList ;
  while
    $rule$ ;
    select
      <lexical_explicit_rule> !? lexicalExplicitRuleList ;
    or
      <lexical_implicit_rule> !? lexicalImplicitRuleList ;
    end select ;
    $;$ ;
  while
    <lexical_error_message_declaration> !? lexicalErrorMessageDeclarationList ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
  outLexiqueComponentRoot := [@lexiqueComponentRoot new
    !lexiqueComponentName
    !isTemplate
    !templateDelimitorList
    !templateReplacementList
    !lexicalAttributeList
    !lexicalStyleList
    !terminalDeclarationList
    !lexicalErrorMessageDeclarationList
    !lexicalListDeclarationList
    !lexicalImplicitRuleList
    !lexicalExplicitRuleList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_delimitor> ?!@templateDelimitorList ioTemplateDelimitorList :
  $template$ ;
  @lstring startString ;
  $literal_string$ ? startString ;
  $...$ ;
  @lstring endString ;
  $literal_string$ ? endString ;
  $;$ ;
  ioTemplateDelimitorList += !startString !endString ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_replacement> ?!@templateReplacementList ioTemplateReplacement :
  $replace$ ;
  @lstring matchString ;
  $literal_string$ ? matchString ;
  $->$ ;
  @lstring replacementString ;
  $literal_string$ ? replacementString ;
  $;$ ;
  ioTemplateReplacement += !matchString !replacementString ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_error_message_declaration>
  ?!@lexicalErrorMessageDeclarationList ioLexicalErrorMessageDeclarationList
:
  $message$ ;
  @lstring messageName ;
  $identifier$ ?messageName ;
  $:$ ;
  @lstring messageValue ;
  $literal_string$ ?messageValue ;
  $;$ ;
  ioLexicalErrorMessageDeclarationList += !messageName !messageValue ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_implicit_rule> ?!@lexicalImplicitRuleList ioLexicalImplicitRuleList :
  $list$ ;
  @lstring listName ;
  $identifier$ ? listName ;
  ioLexicalImplicitRuleList += !listName ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_explicit_rule> ?!@lexicalExplicitRuleList ioLexicalExplicitRuleList :
  @lexicalExpression lexicalRuleExpression ;
  <lexical_expression> ?lexicalRuleExpression ;
  $:$ ;
  @lexicalInstructionList instructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?instructionList ;
  end repeat ;
  $end$ ;
  $rule$ ;
  ioLexicalExplicitRuleList += !lexicalRuleExpression !instructionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $send$ ;
  @lexicalInstruction instruction ;
  <lexical_send_instruction> ?instruction ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_send_instruction> !@lexicalInstruction outInstruction :
  @lstring sentTerminal ;
  $terminal$ ? sentTerminal ;
  outInstruction := [@lexicalSimpleSendInstruction new !sentTerminal] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_send_instruction> !@lexicalInstruction outInstruction :
  @lexicalSendSearchList lexicalSendSearchList [emptyList] ;
  repeat
    $search$ ;
    @lstring attributeName ;
    $identifier$ ? attributeName ;
    $in$ ;
    @lstring searchListName ;
    $identifier$ ? searchListName ;
    lexicalSendSearchList += !attributeName !searchListName ;
  while
  end repeat ;
  $default$ ;
  @lexicalSendDefaultAction lexicalSendDefaultAction ;
  select
    @lstring defaultSentTerminal ;
    $terminal$ ? defaultSentTerminal ;
    lexicalSendDefaultAction := [@lexicalSendTerminalByDefault new !defaultSentTerminal] ;
  or
    $error$ ;
    @lstring defaultErrorMessageName ;
    $identifier$ ? defaultErrorMessageName ;
    lexicalSendDefaultAction := [@lexicalErrorByDefault new !defaultErrorMessageName] ;
  end select ;
  outInstruction := [@lexicalStructuredSendInstruction new
    !lexicalSendSearchList
    !lexicalSendDefaultAction
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $repeat$ ;
  @lexicalInstructionList repeatedInstructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?repeatedInstructionList ;
  end repeat ;
  @lexicalWhileBranchList lexicalWhileBranchList [emptyList] ;
  repeat
    <repeat_while_branch> !?lexicalWhileBranchList ;
  while
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  @lexicalInstruction i := [@lexicalRepeatInstruction new
    !repeatedInstructionList
    !lexicalWhileBranchList
  ] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*

rule <repeat_while_branch> ?!@lexicalWhileBranchList ioLexicalWhileBranchList :
  $while$ ;
  @lexicalExpression whileExpression ;
  <lexical_expression> ?whileExpression ;
  $:$ ;
  @lexicalInstructionList whileInstructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?whileInstructionList ;
  end repeat ;
  ioLexicalWhileBranchList += !whileExpression !whileInstructionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $select$ ;
  @lexicalSelectBranchList lexicalWhileBranchList [emptyList] ;
  repeat
    @lexicalExpression selectExpression ;
    $when$ ;
    <lexical_expression> ?selectExpression ;
    $:$ ;
    @lexicalInstructionList selectInstructionList [emptyList] ;
    repeat
    while
      <lexical_instruction> !?selectInstructionList ;
    end repeat ;
    lexicalWhileBranchList += !selectExpression !selectInstructionList ;
  while
  end repeat ;
  $default$ ;
  @lexicalInstructionList defaultInstructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?defaultInstructionList ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  @lexicalInstruction i := [@lexicalSelectInstruction new
    !lexicalWhileBranchList
    !defaultInstructionList
  ] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  @lstring actionName ;
  $identifier$ ? actionName ;
  $($ ;
  @lexicalActualArgumentList actualArgumentList [emptyList] ;
  repeat
    <lexical_action_effective_argument> !?actualArgumentList ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  @lstringlist errorMessageList := [@lstringlist emptyList] ;
  select
  or
    $error$ ;
    repeat
      @lstring errorMessageName ;
      $identifier$ ? errorMessageName ;
      errorMessageList += ! errorMessageName ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $;$ ;
  @lexicalInstruction i := [@lexicalActionInstruction new
    !actionName
    !actualArgumentList
    !errorMessageList
  ] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_action_effective_argument> ?!@lexicalActualArgumentList ioLexicalActualArgumentList :
  @lchar character ;
  $literal_char$ ? character ;
  ioLexicalActualArgumentList += ![@lexicalCharacterArgument new !character] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_action_effective_argument> ?!@lexicalActualArgumentList ioLexicalActualArgumentList :
  $*$ ;
  ioLexicalActualArgumentList += ![@lexicalCurrentCharacterArgument new] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_action_effective_argument> ?!@lexicalActualArgumentList ioLexicalActualArgumentList :
  @lstring idf ;
  $identifier$ ? idf ;
  @lexicalActualArgument argument ;
  <function_call_or_attribute> !idf ?argument ;
  ioLexicalActualArgumentList += !argument ;
end rule ;

#---------------------------------------------------------------------------*

rule <function_call_or_attribute> ??@lstring inIdf !@lexicalActualArgument outArgument :
  outArgument := [@lexicalAttributeArgument new !inIdf] ;
end rule ;

#---------------------------------------------------------------------------*

rule <function_call_or_attribute> ??@lstring inIdf !@lexicalActualArgument outArgument :
  $($ ;
  @lexicalActualArgumentList functionActualArgumentList [emptyList] ;
  repeat
    <lexical_action_effective_argument> !?functionActualArgumentList ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  outArgument := [@lexicalFunctionArgument new !inIdf !functionActualArgumentList] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $error$ ;
  @lstring errorMessageName ;
  $identifier$ ? errorMessageName ;
  $;$ ;
  ioInstructionList += ![@lexicalErrorInstruction new !errorMessageName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $drop$ ;
  @lstring terminalName ;
  $terminal$ ? terminalName ;
  $;$ ;
  ioInstructionList += ![@lexicalDropInstruction new !terminalName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $tag$ ;
  @lstring tagName ;
  $identifier$ ? tagName ;
  $;$ ;
  ioInstructionList += ![@lexicalTagInstruction new !tagName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $rewind$ ;
  @lstring tagName ;
  $identifier$ ? tagName ;
  $send$ ;
  @lstring terminalName ;
  $terminal$ ? terminalName ;
  $;$ ;
  ioInstructionList += ![@lexicalRewindInstruction new !tagName !terminalName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionList ioInstructionList :
  $log$ ;
  $;$ ;
  ioInstructionList += ![@lexicalLogInstruction new] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_expression> !@lexicalExpression outExpression :
  <lexical_term> ?outExpression ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_term> !@lexicalExpression outExpression :
  <lexical_factor> ?outExpression ;
  repeat
  while
    $|$ ;
    @lexicalExpression rightExpression ;
    <lexical_factor> ?rightExpression ;
    outExpression := [@lexicalOrExpression new !outExpression !rightExpression] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor>!@lexicalExpression outExpression :
  @lstring string ;
  $literal_string$ ? string ;
  outExpression := [@lexicalStringMatch new !string] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor> !@lexicalExpression outExpression :
  $~$ ;
  @lstring string ;
  $literal_string$ ? string ;
  $error$ ;
  @lstring errorMessage ;
  $identifier$ ?errorMessage ;
  outExpression := [@lexicalStringNotMatch new !string !errorMessage] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor> !@lexicalExpression outExpression :
  @lchar character ;
  $literal_char$ ?character ;
  select
    outExpression := [@lexicalCharacterMatch new !character] ;
  or
    $->$ ;
    @lchar upperBound ;
    $literal_char$ ? upperBound ;
    outExpression := [@lexicalCharacterIntervalMatch new !character !upperBound] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_list_declaration> ?!@lexicalListDeclarationList ioLexicalListDeclarationList :
  @lstring name ;
  $list$ ;
  $identifier$ ? name ;
  @lstringlist sentAttributeList [emptyList] ;
  repeat
  while
    $!$ ;
    @lstring sentAttribute ;
    $identifier$ ?sentAttribute ;
    sentAttributeList += ! sentAttribute ;
  end repeat ;
  $error$ ;
  $message$ ;
  @lstring errorMessage ;
  $literal_string$ ? errorMessage ;
  @lstring theStyle ; # Empty string if no style
  select
    $style$ ;
    $identifier$ ? theStyle ;
  or
    theStyle := [@lstring new !"" !here] ;
  end select ;
  $:$ ;
  @lexicalListEntryList entryList [emptyList] ;
  repeat
    <lexical_list_entry> !?entryList ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioLexicalListDeclarationList += !name !theStyle !errorMessage !sentAttributeList !entryList ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_list_entry> ?!@lexicalListEntryList ioLexicalListEntryList :
  @lstring entrySpelling ;
  @lstring terminalSpelling ;
  $literal_string$ ? entrySpelling ;
  select
    $->$ ;
    $literal_string$ ? terminalSpelling ;
  or
    terminalSpelling := entrySpelling ;
  end select ;
  ioLexicalListEntryList += !entrySpelling !terminalSpelling ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_attribute_declaration> ?!@lexicalAttributeList ioLexicalAttributeList :
  @lstring typeName ;
  $type_name$ ? typeName  ;
  @lstring name ;
  $identifier$ ? name ;
  $;$ ;
  ioLexicalAttributeList += !typeName !name ;
end rule ;

#---------------------------------------------------------------------------*

rule <terminal_declaration> ?!@terminalDeclarationList ioTerminalDeclarationList :
  @lstring name ;
  $terminal$ ? name  ;
  @lstringlist sentAttributeList [emptyList] ;
  repeat
  while
    $!$ ;
    @lstring sentAttribute ;
    $identifier$ ?sentAttribute ;
    sentAttributeList += ! sentAttribute ;
  end repeat ;
  $error$ ;
  $message$ ;
  @lstring errorMessage ;
  $literal_string$ ? errorMessage ;
  @lstring theStyle ; # Empty string if no style
  select
    $style$ ;
    $identifier$ ? theStyle ;
  or
    theStyle := [@lstring new !"" !here] ;
  end select ;
  $;$ ;
  ioTerminalDeclarationList += !name !sentAttributeList !errorMessage !theStyle ;
end rule ;

#---------------------------------------------------------------------------*

rule <style_declaration> ?!@lexicalStyleList ioLexicalStyleList :
  $style$ ;
  @lstring name ;
  $identifier$ ? name  ;
  $->$ ;
  @lstring comment ;
  $literal_string$ ? comment ;
  $;$ ;
  ioLexicalStyleList += !name !comment ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
