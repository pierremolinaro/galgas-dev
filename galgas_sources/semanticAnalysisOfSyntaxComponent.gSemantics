#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component semantic analysis                                       *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysisOfSyntaxComponent :
import "semanticsCompilation.gSemantics" ;
import "lexiqueCompilation.gSemantics" ;

import semantics lexiqueCompilation in "lexiqueCompilation.gSemantics" ;
import semantics semanticsCompilation in "semanticsCompilation.gSemantics" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    D E C L A R A T I O N S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal label is not declared" ;
}

#---------------------------------------------------------------------------*

map @nonterminalMap {
  @nonterminalLabelMap mLabelMap ;
  @bool mHasParseLabel ;
  insert insertKey error message "the '%K' nonterminal has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName ;
  @uint mRuleIndex ;
  @nonterminalLabelMap mLabelMap ;
  @bool mHasParseLabel ;
}

#---------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration extends @semanticDeclarationForGeneration {
  @string mComponentName ;
  @string mLexiqueName ;
  @nonterminalMap mNonterminalDeclarationMap ;
  @ruleDeclarationList mRuleDeclarationList ;
  @uint mSelectMethodCount ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
} {
  template syntaxFileHeader "syntax-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
    ?@lstringlist TYPE_PREDECLARATION_LIST
  ;

  template syntaxFileImplementation "syntax-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
  ;
}

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration appendDeclaration -> @string outHeader :
  @uintlist selectMethodList [emptyList] ;
  @uint idx := 0 ;
  loop mSelectMethodCount + 1 :
  while idx < mSelectMethodCount do
    selectMethodList += !idx ;
    idx ++ ;
  end loop ;
  outHeader := [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !mComponentName
    !mLexiqueName
    !mNonterminalDeclarationMap
    !mRuleDeclarationList
    !selectMethodList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    N O N T E R M I N A L    M A P                     *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterNonterminalNonTerminalInMapAndCheck
  ??@lstring inNonTerminalName
  ??@nonterminalLabelMap inNonterminalLabelMap
  ??@bool inHasParseLabel
  ?!@nonterminalMap ioNonterminalDeclarationMap 
:
  with ioNonterminalDeclarationMap hasKey ![inNonTerminalName string] do
    if mHasParseLabel != inHasParseLabel then
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' is redeclared "
      . if mHasParseLabel then "with" else "without" end
      . " 'parse' label, but first declaration declares it "
      . if inHasParseLabel then "with" else "without" end
      . " 'parse' label"
      ;
    end if ;
    const @stringset firstDeclarationLabelSet := [mLabelMap allKeys] ;
    const @stringset reDeclarationLabelSet := [inNonterminalLabelMap allKeys] ;
    const @stringset missingLabelSet := firstDeclarationLabelSet - reDeclarationLabelSet ;
    if [missingLabelSet count] > 0 then
      @string s := "" ;
      foreach missingLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared without the following label(s):" . s
      ;
    end if ;
    const @stringset newLabelSet := reDeclarationLabelSet - firstDeclarationLabelSet ;
    if [newLabelSet count] > 0 then
      @string s := "" ;
      foreach newLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared with the new label(s):" . s
      ;
    end if ;
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      foreach mLabelMap, inNonterminalLabelMap prefixedby new_ do
        @formalParameterSignature newSignature [emptyList] ;
        foreach new_mSignature do
          newSignature += !mFormalArgumentType !mFormalArgumentPassingMode ;
        end foreach ;
        checkMethodSignatures
          !mSignatureForGeneration
          !mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        ;
      end foreach ;
    end if ;
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap !inHasParseLabel] ;
  end with ;
end routine ;

#---------------------------------------------------------------------------*

routine buildNonterminalDeclarationsMap
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap
:
  outNonterminalDeclarationMap := [@nonterminalMap emptyMap] ;
#--- Nonterminal declaration list
  foreach inNonterminalDeclarationList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabels do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArgumentList do
        const @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string] ;
        signature += !t !mFormalArgumentPassingMode ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !mHasParseLabel !?outNonterminalDeclarationMap ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  ?!@stringlist ioLocalVariableCppNameList
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ??@nonterminalMap unused inNonterminalMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
  ?!@stringlist ioLocalVariableCppNameList
:
  @semanticInstructionAST t := self ; # Bug in GALGAS 1
  [t analyzeSemanticInstruction
    !inSemanticContext
    !inPredefinedTypes
    !?ioInstructionListForGeneration
    !?ioVariableMap
    !?ioLocalVariableCppNameList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
  ?!@stringlist unused ioLocalVariableCppNameList
:
  @nonterminalLabelMap labelMap ;
  @bool hasParseLabel ;
  [inNonterminalMap searchKey !mNonterminalName ?labelMap ?hasParseLabel] ;
  @formalParameterSignature signature ;
  if [mLabelName string] == "parse" then
    if not hasParseLabel then
      error mLabelName
      : "the '<" . mNonterminalName . ">' nonterminal does not declare the 'parse' label"
      : signature
      ;
    else
      signature := [@formalParameterSignature emptyList] ;
    end if ;
  else
    [labelMap searchKey !mLabelName ?* ?signature ?*] ;
  end if ;
#--- call arguments
  @actualParameterListForGeneration actualParameterListForGeneration ;
  @temporaryInputVariableForRoutineInvocationForGeneration temporaryInputVariableForRoutineInvocationForGeneration ;
  analyzeRoutineArguments
    !inSemanticContext
    !inPredefinedTypes
    !mNonterminalName
    !"'<" . mNonterminalName . ">' nonterminal declaration"
    !signature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
    ?temporaryInputVariableForRoutineInvocationForGeneration
  ;

end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap unused inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
  ?!@stringlist ioLocalVariableCppNameList
:
  @lexicalSentValueList sentAttributeList ;
  [inTerminalMap searchKey !mTerminalName ?sentAttributeList] ;
#---
  if [mActualInputParameterList length] != [sentAttributeList length] then
    error mTerminalName
    : "naming the '$" . mTerminalName . "$' requires " . [[sentAttributeList length] string]
    . "parameter" . if [sentAttributeList length] > 0 then "s" else "" end
    . ", but this instruction names "
    . [[mActualInputParameterList length] string] . " parameter" 
    . if [mActualInputParameterList length] > 0 then "s" else "" end
    ;
  end if ;
#---
  foreach mActualInputParameterList, sentAttributeList do
    if [mActualParameterName length] > 0 then # Empty string if joker
      @unifiedTypeMapProxy type ;
      @string cppName ;
      if [mActualParameterTypeName length] > 0 then
        cppName := "var_" . [mActualParameterName identifierRepresentation] ;
        type := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mActualParameterTypeName] ;
        [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName] ;
        ioLocalVariableCppNameList += !cppName ;
      else
        [!?ioVariableMap searchForWriteAccess !mActualParameterName ?type ?cppName] ;
      end if ;
      @unifiedTypeMapProxy expectedType ;
      switch mLexicalType
      when lexicalType_string : expectedType := inPredefinedTypes->mStringType ;
      when lexicalType_char : expectedType := inPredefinedTypes->mCharType ;
      when lexicalType_uint : expectedType := inPredefinedTypes->mUIntType ;
      when lexicalType_uint64 : expectedType := inPredefinedTypes->mUInt64Type ;
      when lexicalType_sint : expectedType := inPredefinedTypes->mSIntType ;
      when lexicalType_sint64 : expectedType := inPredefinedTypes->mSInt64Type ;
      when lexicalType_double : expectedType := inPredefinedTypes->mDoubleType ;
      end switch ;
      if expectedType != type then
        error mActualParameterName
        : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
        . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
        ;
      end if ;
    end if ;
  end foreach ;
#---
end method ;

#---------------------------------------------------------------------------*

routine analyzeSyntaxInstructionList
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ??@syntaxInstructionList inSemanticInstructionListAST
  ??@location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap beginBranch] ;
#--- Instruction list
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSemanticInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !inNonterminalMap
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
      !?localVariableCppNameList
    ] ;
  end foreach ;
#--- Drop local variables
  if [localVariableCppNameList length] > 0 then
    outInstructionListForGeneration += ![@dropInstructionForGeneration new
      !localVariableCppNameList
      !"end of scope"
    ] ;  
  end if ;
#--- Branch end
  [!?ioVariableMap endBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @repeatInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  ?!@stringlist unused ioLocalVariableCppNameList
:
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- Repeated instructions
  @semanticInstructionListForGeneration repeated_instructionList ;
  analyzeSyntaxInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !inTerminalMap
    !inNonterminalMap
    !mRepeatedInstructionList
    !mEndOf_repeated_instructions_branch
    !?ioVariableMap
    !?ioSelectMethodCount
    ?repeated_instructionList
  ;
#--- 'while' blocks
  foreach mRepeatBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !inNonterminalMap
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOf_repeat_instruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  ?!@stringlist unused ioLocalVariableCppNameList
:
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- 'or' blocks
  foreach mSelectBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !inNonterminalMap
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOf_select_instruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap  inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Begin block
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- 'or' blocks
  foreach mParseDoBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !inNonterminalMap
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOfParseDoInstruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Variant expression
  @semanticExpressionForGeneration variant_expression ;
  [mVariantExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?variant_expression
  ] ;
  if [variant_expression mType] != inPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    :"the variant expression type is '@" . [[variant_expression mType] key]
    . "', but it should be '@" . [inPredefinedTypes->mUIntType key] . "' type"
    ;
  end if ;
#--- While expression
  @semanticExpressionForGeneration while_expression ;
  [mWhileExpression analyzeSemanticExpression
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    ?while_expression
  ] ;
  if [while_expression mType] != inPredefinedTypes->mBoolType then
    error mEndOfWhileExpression
    :"the variant expression type is '@" . [[variant_expression mType] key]
    . "', but it should be '@" . [inPredefinedTypes->mBoolType key] . "' type"
    ;
  end if ;
#--- 'do' instructions
#--- Begin block
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- 'or' blocks
  @semanticInstructionListForGeneration instructionList ;
  analyzeSyntaxInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !inTerminalMap
    !inNonterminalMap
    !mDoInstructionList
    !mEndOfInstructionList
    !?ioVariableMap
    !?ioSelectMethodCount
    ?instructionList
  ;
#--- End block
  [!?ioVariableMap endOverride !mEndOfInstructionList] ;
#---

end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  ?!@stringlist ioLocalVariableCppNameList
:
  @uint localSelectMethodCount := ioSelectMethodCount ;
  foreach mWhenBranchList do
    localSelectMethodCount := ioSelectMethodCount ;
    @semanticExpressionForGeneration when_expression ;
    [mWhenExpression analyzeSemanticExpression
      !inSemanticContext
      !inPredefinedTypes
      !?ioVariableMap
      ?when_expression
    ] ;
    @semanticInstructionListForGeneration instructionListForGeneration [emptyList] ;
    foreach mParseDoBranchList do
      [mInstruction analyzeSyntaxInstruction
        !inSemanticContext
        !inPredefinedTypes
        !inTerminalMap
        !inNonterminalMap
        !?instructionListForGeneration
        !?ioVariableMap
        !?localSelectMethodCount
        !?ioLocalVariableCppNameList
      ] ;
    end foreach ;
  end foreach ;
  ioSelectMethodCount := localSelectMethodCount ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction analyzeSyntaxInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ??@nonterminalMap unused inNonterminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@uint unused ioSelectMethodCount
  ?!@stringlist unused ioLocalVariableCppNameList
:
  message "@blockInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    C O N T E X T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfRuleLabel
  ??@formalParameterListAST inFormalArguments
  ??@syntaxInstructionList inSyntaxInstructionList
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@nonterminalMap inNonterminalMap
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
:
  @variableMap variableMap [emptyMap] ;
  buildLocalVariableMapAndSignature
    !inSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  ;
#---
  outSignature := [@formalParameterSignature emptyList] ;
  foreach outSignatureForGeneration do
    outSignature += !mFormalArgumentType !mFormalArgumentPassingMode ;

  end foreach ;
#--- Semantic analysis of instruction list
  @semanticInstructionListForGeneration instructionListForGeneration [emptyList] ;
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !inNonterminalMap
      !?instructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
      !?localVariableCppNameList
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           S E M A N T I C    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfSyntaxComponent
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@syntaxRuleListAST inRuleList
  ??@string inComponentName
  ??@string inLexiqueName
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
:
#------------ Build nonterminal map
  @nonterminalMap nonterminalMap [emptyMap] ;
  buildNonterminalDeclarationsMap
    !inNonterminalDeclarationList
    !inSemanticContext
    ?nonterminalMap
  ;
#------------ Build nonterminal map from rule headers
  foreach inRuleList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabelList do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArguments do
        const @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalArgumentPassingMode !type !mFormalArgumentName !"argument_" . mFormalArgumentName ;
        signature += !type !mFormalArgumentPassingMode ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    with nonterminalMap hasKey ![mNonterminalName string] do
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !mHasParseLabel !?nonterminalMap ;
    else
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !false !?nonterminalMap ;
    end with ;
  end foreach ;
#--- Rule list
  @uint selectMethodCount := 0 ;
  @ruleDeclarationList ruleDeclarationList [emptyList] ;
  @uint newRuleIndex := 0 ;
  foreach inRuleList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    @uint localSelectMethodCount := selectMethodCount ;
    foreach mLabelList do
      localSelectMethodCount := selectMethodCount ;
      @formalParameterListForGeneration signatureForGeneration ;
      @formalParameterSignature signature ;
      semanticAnalysisOfRuleLabel
        !mFormalArguments
        !mSyntaxInstructionList
        !inSemanticContext
        !inPredefinedTypes
        !inTerminalMap
        !nonterminalMap
        !?localSelectMethodCount
        ?signatureForGeneration
        ?signature
      ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    selectMethodCount := localSelectMethodCount ;
    @bool hasParseLabel ;
    [nonterminalMap searchKey !mNonterminalName ?* ?hasParseLabel] ;
    ruleDeclarationList += ![mNonterminalName string] !newRuleIndex !nonterminalLabelMap !hasParseLabel ;
    newRuleIndex ++ ;
  end foreach ;
#---
  outSyntaxDeclarationForGeneration := [@syntaxDeclarationForGeneration new
    !inComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
  ] ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
