#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component semantic analysis                                       *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysisOfSyntaxComponent :
import "syntaxSignature.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    D E C L A R A T I O N S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal label is not declared" ;
}

#---------------------------------------------------------------------------*

map @nonterminalMap {
  @nonterminalLabelMap mLabelMap ;
  insert insertKey error message "the '%K' nonterminal has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @ruleLabelImplementationList {
  @lstring mLabelName ;
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  @semanticInstructionListForGeneration mInstructionListForGeneration ;
#  feature "first";
}

#---------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName ;
  @uint mRuleIndex ;
  @ruleLabelImplementationList mLabelImplementationList ;
}

#---------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration extends @semanticDeclarationForGeneration {
  @string mComponentName ;
  @string mLexiqueName ;
  @nonterminalMap mNonterminalDeclarationMap ;
  @ruleDeclarationList mRuleDeclarationList ;
  @uint mSelectMethodCount ;
  @bool mHasIndexing ;
  @bool mHasTranslateFeature ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
}{
}{
  template syntaxFileHeader "syntax-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
    ?@lstringlist TYPE_PREDECLARATION_LIST
  ;

  template syntaxFileImplementation "syntax-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
    ?@bool HAS_INDEXING
    ?@bool HAS_TRANSLATE_FEATURE
  ;
}

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration appendDeclaration1 -> @string outHeader
:
  @uintlist selectMethodList [emptyList] ;
  @uint idx := 0 ;
  loop mSelectMethodCount + 1 :
  while idx < mSelectMethodCount do
    selectMethodList += !idx ;
    idx ++ ;
  end loop ;
  outHeader := [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !mComponentName
    !mLexiqueName
    !mNonterminalDeclarationMap
    !mRuleDeclarationList
    !selectMethodList
    !mHasIndexing
    !mHasTranslateFeature
  ] ; 
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    N O N T E R M I N A L    M A P                     *
#                                                                           *
#---------------------------------------------------------------------------*

local routine enterNonterminalNonTerminalInMapAndCheck
  ??@lstring inNonTerminalName
  ??@nonterminalLabelMap inNonterminalLabelMap
  ?!@nonterminalMap ioNonterminalDeclarationMap 
:
  with ioNonterminalDeclarationMap hasKey ![inNonTerminalName string] do
    const @stringset firstDeclarationLabelSet := [mLabelMap keySet] ;
    const @stringset reDeclarationLabelSet := [inNonterminalLabelMap keySet] ;
    const @stringset missingLabelSet := firstDeclarationLabelSet - reDeclarationLabelSet ;
    if [missingLabelSet count] > 0 then
      @string s := "" ;
      foreach missingLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared without the following label(s):" . s
      ;
    end if ;
    const @stringset newLabelSet := reDeclarationLabelSet - firstDeclarationLabelSet ;
    if [newLabelSet count] > 0 then
      @string s := "" ;
      foreach newLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared with the new label(s):" . s
      ;
    end if ;
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      foreach mLabelMap, inNonterminalLabelMap : new_ do
        @formalParameterSignature newSignature [emptyList] ;
        foreach new_mSignature do
          newSignature += !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName ;
        end foreach ;
        checkMethodSignatures
          !mSignatureForGeneration
          !mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        ;
      end foreach ;
    end if ;
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap] ;
  end with ;
end routine ;

#---------------------------------------------------------------------------*

local routine buildNonterminalDeclarationsMap
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap
:
  outNonterminalDeclarationMap := [@nonterminalMap emptyMap] ;
#--- Nonterminal declaration list
  foreach inNonterminalDeclarationList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabels do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArgumentList do
        const t := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string] ;
        signature += !t !mFormalArgumentPassingMode !mFormalArgumentName->string ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !?outNonterminalDeclarationMap ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool unused inHasTranslateFeature
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ??@stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  [selfcopy analyzeSemanticInstruction
    !inAnalysisContext
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string unused inComponentName
  ??@stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
#  message "Analyze <" . mNonterminalName . "> " . mLabelName . "\n" ;
  @nonterminalLabelMap labelMap ;
  [inNonterminalMap searchKey !mNonterminalName ?labelMap] ;
  @formalParameterSignature signature ;
  if [mLabelName string] == "parse" then
    signature := [@formalParameterSignature emptyList] ;
  else
    [labelMap searchKey !mLabelName ?* ?signature ?*] ;
  end if ;
#--- call arguments
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mNonterminalName
    !"'<" . mNonterminalName . ">' nonterminal declaration"
    !signature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#---
  ioInstructionListForGeneration += ![@nonterminalInstructionForGeneration new
    !mInstructionLocation
    ![mNonterminalName string]
    ![mLabelName string]
    !actualParameterListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?inputVariableList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  ioGeneratedCode .= "nt_" . [mNonterminalName identifierRepresentation] . "_" . [mLabelName identifierRepresentation] . " (" ;
  foreach parameterCppNameList do
    ioGeneratedCode .= mValue . ", " ;
  end foreach ;
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode .= syntaxDirectedTranslationResultVarName[] . ", " ;
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName []] ;
  end if ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .=  compilerCppName [] . ") ;\n" ;
#---
  if inGenerateCheckValid then
    ioGeneratedCode .= "#ifndef DO_NOT_GENERATE_CHECKINGS\n" ;
    foreach inputVariableList do
      ioGeneratedCode .= "  " . mValue . ".checkIsValid (HERE) ;\n" ;
    end foreach ;
    ioGeneratedCode .= "#endif\n" ;
  end if ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= mValue . ".drop () ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

#! Terminal instruction

#---------------------------------------------------------------------------*

abstract method @abstractInputParameter analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

override method @inputParameterAnonymousVariable analyzeInputParameter
  ??@analysisContext unused inAnalysisContext
  ??@lexicalTypeEnum unused inRequiredLexicalType
  ??@string unused inLexicalAttributeName
  ?!@terminalCheckAssignementList unused ioTerminalCheckAssignementList
  ?!@variableMap unused ioVariableMap
:
end method ;

#---------------------------------------------------------------------------*

override method @inputParameterVariable analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
:
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ??@unifiedTypeMapProxy type ??@string cppName ?*] ;
  @unifiedTypeMapProxy expectedType ;
  switch inRequiredLexicalType
  when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
  when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
  when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
  when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
  when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
  when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
  when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
  end switch ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioTerminalCheckAssignementList +=
    !"" # Do not declare variable
    !cppName
    !inLexicalAttributeName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @inputParameterDeclaredVariable analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName] ;
  @unifiedTypeMapProxy expectedType ;
  switch inRequiredLexicalType
  when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
  when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
  when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
  when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
  when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
  when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
  when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
  end switch ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioTerminalCheckAssignementList +=
    ![mActualParameterTypeName string]
    !cppName
    !inLexicalAttributeName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @inputParameterDeclaredConstant analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName] ;
  @unifiedTypeMapProxy expectedType ;
  switch inRequiredLexicalType
  when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
  when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
  when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
  when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
  when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
  when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
  when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
  end switch ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioTerminalCheckAssignementList +=
    ![mActualParameterTypeName string]
    !cppName
    !inLexicalAttributeName
  ;
end method ;

#---------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeSDT
  ??@analysisContext unused inAnalysisContext
  ??@bool unused inHasTranslateFeature
  ?!@variableMap unused ioVariableMap
:
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeSDT
  ??@analysisContext unused inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap unused ioVariableMap
:
  if not inHasTranslateFeature then
    error mLocation : "the ':>' construct requires the syntax component to be declared with 'translate' feature" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature" ;
  end if ;
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ??@unifiedTypeMapProxy type ?* ?*] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature" ;
  end if ;
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature" ;
  end if ;
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult generateCode
  ??@bool inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone generateCode
  ??@bool inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode .= syntaxDirectedTranslationResultVarName[] . " << inCompiler->" . inAccessMethodName . " () ;\n" ;
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName []] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string unused inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string unused ioGeneratedCode
:
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  ioGeneratedCode .= cppName . " := GALGAS_string (inCompiler->" . inAccessMethodName . " ()) ;\n" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  ioGeneratedCode .= "GALGAS_string " . cppName . " (inCompiler->" . inAccessMethodName . " ()) ;\n" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  ioGeneratedCode .= "const GALGAS_string " . cppName . " (inCompiler->" . inAccessMethodName . " ()) ;\n" ; 
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  [inTerminalMap searchKey !mTerminalName ??@lexicalSentValueList sentAttributeList] ;
#---
  if [mActualInputParameterList length] != [sentAttributeList length] then
    error mTerminalName
    : "naming the '$" . mTerminalName . "$' requires " . [[sentAttributeList length] string]
    . "parameter" . if [sentAttributeList length] > 0 then "s" else "" end
    . ", but this instruction names "
    . [[mActualInputParameterList length] string] . " parameter" 
    . if [mActualInputParameterList length] > 0 then "s" else "" end
    ;
  end if ;
#---
  @terminalCheckAssignementList terminalCheckAssignementList [emptyList] ;
  foreach mActualInputParameterList, sentAttributeList do
    [mInputParameter analyzeInputParameter
      !inAnalysisContext
      !mLexicalType
      !mLexicalAttributeName
      !?terminalCheckAssignementList
      !?ioVariableMap
    ] ;
  end foreach ;
#---
  foreach mIndexingKeyList do
    if not [inIndexNameSet hasKey ![mValue string]] then
      @string s := "" ;
      foreach inIndexNameSet do
        s .= "\n  - " . key  ;
      end foreach ;
      error mValue : "the '" . mValue . "' indexing name is not declared by the lexique; available names are:" . s ;
    end if ;
  end foreach ;
#--- Check syntax directed translation destination variable
  [mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ] ;
  [mGrammarInstructionSyntaxDirectedTranslationToken analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ] ;
#---
  ioInstructionListForGeneration += ![@terminalCheckInstructionForGeneration new
    !mInstructionLocation
    !mTerminalName
    !inLexiqueName
    !terminalCheckAssignementList
    !mIndexingKeyList
    !mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor
    !mGrammarInstructionSyntaxDirectedTranslationToken
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Get synthetized attributes
  foreach mTerminalCheckAssignementList do
    if mTypeName != "" then
      ioGeneratedCode .= "GALGAS_" . [mTypeName identifierRepresentation] . " " ;
    else
    end if ;
    ioGeneratedCode .= mTargetVarCppName . " = " . compilerCppName [] . "->synthetizedAttribute_"
                    . [mSourceLexicalAttributeName identifierRepresentation]
                    . " () ;\n" ;
  end foreach ;
#--- Indexing
  foreach mIndexingKeyList do
    ioGeneratedCode .= compilerCppName [] . "->enterIndexing (C_Lexique_" . mLexiqueIdentifier . "::kIndexing_" . [mValue identifierRepresentation] . ") ;\n" ;
  end foreach ;
#--- Syntax directed translation
  [mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor generateCode
    !inGenerateSyntaxDirectedTranslationString
    !"preceedingSeparatorString"
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ] ;
  [mGrammarInstructionSyntaxDirectedTranslationToken generateCode
    !inGenerateSyntaxDirectedTranslationString
    !"tokenString"
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ] ;

#  for s in mAssignementList do
#    ioGeneratedCode .= s->mValue . "\n" ;
#  end for ;
#  if inGenerateSyntaxDirectedTranslationString then
##    ioGeneratedCode .= syntaxDirectedTranslationResultVarName [] . " << inCompiler->preceedingSeparatorString () ;\n" ;
##    ioGeneratedCode .= syntaxDirectedTranslationResultVarName [] . " << inCompiler->tokenString () ;\n" ;
#    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName []] ;
#  end if ;
#--- Check terminal symbol
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->acceptTerminal (ACCEPT_TERMINAL (C_Lexique_"
                  . mLexiqueIdentifier . "::kToken_" . [mTerminalName identifierRepresentation]
                  . ") COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
#---
  if inGenerateCheckValid then
    ioGeneratedCode .= "#ifndef DO_NOT_GENERATE_CHECKINGS\n" ;
    foreach mTerminalCheckAssignementList do
      ioGeneratedCode .= "  " . mTargetVarCppName . ".checkIsValid (HERE) ;\n" ;
    end foreach ;
    ioGeneratedCode .= "#endif\n" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeSyntaxInstructionList
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string  inComponentName
  ??@syntaxInstructionList inSyntaxInstructionListAST
  ??@location inEndOfBranchLocation
  ??@stringset inIndexNameSet
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap openBranch] ;
#--- Instruction list
  foreach inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ] ;
  end foreach ;
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @repeatInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
  const @uint choiceIndex := ioSelectMethodCount ;
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- Repeated instructions
  @semanticInstructionListForGeneration repeated_instructionList ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mRepeatedInstructionList
    !mEndOf_repeated_instructions_branch
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?repeated_instructionList
  ;
#--- 'while' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mRepeatBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !inIndexNameSet
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOf_repeat_instruction] ;
#---
  ioInstructionListForGeneration += ![@repeatInstructionForGeneration new
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !repeated_instructionList
    !mEndOf_repeat_instruction
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//-------- @repeatInstructionForGeneration\n" ;
  const @string repeatFlagCppName := "repeatFlag_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "bool " . repeatFlagCppName . " = true ;\n" ;
  ioGeneratedCode .= "while (" . repeatFlagCppName . ") {\n" ;
  generateInstructionList
    !inGenerateCheckValid
    !m_repeated_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= "switch (select_" . [mSyntaxComponentName identifierRepresentation] . "_" . [mChoiceIndex string] . " (" . compilerCppName [] . ")) {\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX do
    ioGeneratedCode .= "case " . [IDX + 2 string] . ": {\n" ;
    generateInstructionList
      !inGenerateCheckValid
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "default:\n" ;
  ioGeneratedCode .= "  " . repeatFlagCppName . " = false ;\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string  inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
  const @uint choiceIndex := ioSelectMethodCount ;
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap openOverrideForSelectBlock] ;
#--- 'or' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mSelectBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !inIndexNameSet
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOf_select_instruction] ;
  ioInstructionListForGeneration += ![@selectInstructionForGeneration new
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !listOfSemanticInstructionListForGeneration
 ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//-------- @selectInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= "switch (select_" . [mSyntaxComponentName identifierRepresentation] . "_" . [mChoiceIndex string] . " (" . compilerCppName [] . ")) {\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX do
    ioGeneratedCode .= "case " . [IDX + 1 string] . ": {\n" ;
    generateInstructionList
      !inGenerateCheckValid
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "default:\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap  inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- 'Rewind' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  const @uint referenceSelectMethodCount := ioSelectMethodCount ;
  foreach mParseRewindBranchList do
    ioSelectMethodCount := referenceSelectMethodCount ;
    @semanticInstructionListForGeneration instructionList [emptyList] ;
    foreach mSyntaxInstructionList do
      [mInstruction analyzeSyntaxInstruction
        !inAnalysisContext
        !inHasTranslateFeature
        !inTerminalMap
        !inLexiqueName
        !inNonterminalMap
        !inComponentName
        !inIndexNameSet
        !?instructionList
        !?ioVariableMap
        !?ioSelectMethodCount
      ] ;
    end foreach ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- Check syntax signature of branches
  @listOfSemanticInstructionListForGeneration tempListOfBranches := listOfSemanticInstructionListForGeneration ;
  @semanticInstructionListForGeneration instructionList ;
  [!?tempListOfBranches popFirst ?instructionList ?*] ;
  const @semanticInstructionListForGeneration referenceSignature := syntaxSignatureOfInstructionList [!"parse" !instructionList] ;
  @bool ok := true ;
  foreach tempListOfBranches while ok do
    ok := compareSyntaxSignature [
      !referenceSignature
      !syntaxSignatureOfInstructionList [!"parse" !mInstructionList]
      !mEndOfInstructionList
    ] ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@parseRewindInstructionForGeneration new
    !mInstructionLocation
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//-------- @parseRewindInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  const @string parsingContextVar := "parsingContext_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "const C_parsingContext " . parsingContextVar . " = " . compilerCppName [] . "->parsingContext () ;\n" ;
  foreach mListOfSemanticInstructionListForGeneration
  do
    generateInstructionList
      !inGenerateCheckValid
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  between 
    ioGeneratedCode .= compilerCppName [] . "->setParsingContext (" . parsingContextVar . ") ; // rewind\n" ;
  end foreach ;
  ioGeneratedCode .= "//-------- END OF @parseRewindInstructionForGeneration\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- Variant expression
  @semanticExpressionForGeneration variant_expression ;
  [mVariantExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?variant_expression
  ] ;
  if [variant_expression mType] != inAnalysisContext->mPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    :"the variant expression type is '@" . [[variant_expression mType] key]
    . "', but it should be '@" . [inAnalysisContext->mPredefinedTypes->mUIntType key] . "' type"
    ;
  end if ;
#--- While expression
  @semanticExpressionForGeneration while_expression ;
  [mWhileExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?while_expression
  ] ;
  if [while_expression mType] != inAnalysisContext->mPredefinedTypes->mBoolType then
    error mEndOfWhileExpression
    :"the variant expression type is '@" . [[variant_expression mType] key]
    . "', but it should be '@" . [inAnalysisContext->mPredefinedTypes->mBoolType key] . "' type"
    ;
  end if ;
#--- 'do' instructions
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- 'or' blocks
  @semanticInstructionListForGeneration instructionList ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mDoInstructionList
    !mEndOfInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?instructionList
  ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOfInstructionList] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@parseLoopInstructionForGeneration new
    !mInstructionLocation
    !variant_expression
    !while_expression
    !instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
#  ioGeneratedCode .= "//-------- @parseLoopInstructionForGeneration\n" ;
#--- Variant
  @string variantVarCppName ;
  [mVariantExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantVarCppName] ;
#--- Loop variable
  ioGeneratedCode .= "if (" . variantVarCppName . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  const @string variantVar := "variant_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "uint32_t " . variantVar . " = " . variantVarCppName . ".uintValue () ;\n" ;
#--- loop
  const @string loopVar := "loop_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "bool " . loopVar . " = true ;\n" ;
  ioGeneratedCode .= "while (" . loopVar . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= loopVar . " = false ;\n" ;
  @string whileVarCppName ;
  [mWhileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVarCppName] ;
  ioGeneratedCode .= "if (" . whileVarCppName . ".isValidAndTrue ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= loopVar . " = true ;\n" ;
  ioGeneratedCode .= variantVar . " -- ; // Decrement variant\n" ;
  ioGeneratedCode .= "const C_parsingContext parsingContext = " . compilerCppName [] . "->parsingContext () ;\n" ;
  generateInstructionList
    !inGenerateCheckValid
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= compilerCppName [] . "->setParsingContext (parsingContext) ;\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
#--- Execute 'parse' part
  ioGeneratedCode .= "//--- 'parse'\n" ;
  generateInstructionList
    !inGenerateCheckValid
    !syntaxSignatureOfInstructionList [!"parse" !mInstructionList]
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= compilerCppName [] . "->resetTemplateString () ;\n" ;
  ioGeneratedCode .= "//-------- END OF @parseLoopInstructionForGeneration\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- When expression
  @semanticExpressionForGeneration when_expression ;
  [mWhenExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?when_expression
  ] ;
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- 'when' branch
  @uint localSelectMethodCount := ioSelectMethodCount ;
  @semanticInstructionListForGeneration when_instructionListForGeneration ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mWhenInstructionList
    !mEndOfWhenInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?localSelectMethodCount
    ?when_instructionListForGeneration
  ;
#--- 'else' branch
  @semanticInstructionListForGeneration else_instructionListForGeneration ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mElseInstructionList
    !mEndOfElseInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?else_instructionListForGeneration
  ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOfElseInstructionList] ;
#--- Check syntax signature
  const @bool ok := compareSyntaxSignature [
    !syntaxSignatureOfInstructionList [!"parse" !when_instructionListForGeneration]
    !syntaxSignatureOfInstructionList [!"parse" !else_instructionListForGeneration]
    !mEndOfElseInstructionList
  ] ;
#--- Generate instruction
  if ok then
    ioInstructionListForGeneration += ![@parseWhenInstructionForGeneration new
      !mInstructionLocation
      !when_expression
      !when_instructionListForGeneration
      !else_instructionListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstructionForGeneration generateInstruction
  ??@bool inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//--------- @parseWhenInstructionForGeneration\n" ;
  @string sourceVar ;
  [mWhenExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  ioGeneratedCode .= "if (" . sourceVar . ".isValidAndTrue ()) {\n" ;
  generateInstructionList
    !inGenerateCheckValid
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}else{\n" ;
  generateInstructionList
    !inGenerateCheckValid
    !mElseInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @syntaxSendInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ??@stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  if not inHasTranslateFeature then
    error mInstructionLocation : "'send' instruction is only allowed when syntax componant has 'translate' feature" ;
  end if ;
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ??@semanticExpressionForGeneration expression
  ] ;
#--- Check expression type
  if [expression mType] != inAnalysisContext->mPredefinedTypes->mStringType  then
    error mInstructionLocation: "'send' expresion should be an @string expression" ;
  end if ;
#---
  ioInstructionListForGeneration += ![@syntaxSendInstructionForGeneration new
    !mInstructionLocation
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @syntaxSendInstructionForGeneration generateInstruction
  ??@bool unused inGenerateCheckValid
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string sourceVar] ;
#---
  [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName []] ;
  ioGeneratedCode .= "if (" . sourceVar . ".isValid ()) {\n"
                   . "  " . syntaxDirectedTranslationResultVarName [] . " << " . sourceVar . ".stringValue () ;\n"
                   . "}\n" ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    C O N T E X T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfRuleLabel
  ??@formalParameterListAST inFormalArguments
  ??@syntaxInstructionList inSyntaxInstructionList
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@bool inHasTranslateFeature
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@location inEndOfInstructionList
  ??@stringset inIndexNameSet
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  @variableMap variableMap [emptyMap] ;
  buildLocalVariableMapAndSignature
    !inAnalysisContext->mSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  ;
#---
  outSignature := [@formalParameterSignature emptyList] ;
  foreach outSignatureForGeneration do
    outSignature += !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName->string ;
  end foreach ;
#--- Semantic analysis of instruction list
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ] ;
  end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfInstructionList] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           S E M A N T I C    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfSyntaxComponent
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@syntaxRuleListAST inRuleList
  ??@string inComponentName
  ??@string inLexiqueName
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@stringset inIndexNameSet
  ??@bool inHasIndexing
  ??@bool inHasTranslateFeature
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
:
#------------ Build nonterminal map
  @nonterminalMap nonterminalMap [emptyMap] ;
  buildNonterminalDeclarationsMap
    !inNonterminalDeclarationList
    !inSemanticContext
    ?nonterminalMap
  ;
#------------ Build nonterminal map from rule headers
  foreach inRuleList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabelList do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArguments do
        const type := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalArgumentPassingMode !type !mFormalArgumentName !"argument_" . mFormalArgumentName ;
        signature += !type !mFormalArgumentPassingMode !mFormalArgumentName->string ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
#    with nonterminalMap hasKey ![mNonterminalName string] do
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !?nonterminalMap ;
#    else
#      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !?nonterminalMap ;
#    end with ;
  end foreach ;
#--- Analysis context
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
#--- Rule list
  @uint selectMethodCount := 0 ;
  @ruleDeclarationList ruleDeclarationList [emptyList] ;
  @uint newRuleIndex := 0 ;
  foreach inRuleList do
    @ruleLabelImplementationList ruleLabelImplementationList [emptyList] ;
    @uint localSelectMethodCount := selectMethodCount ;
    [nonterminalMap searchKey !mNonterminalName ?*] ;
    foreach mLabelList do
      localSelectMethodCount := selectMethodCount ;
      @formalParameterListForGeneration signatureForGeneration ;
      @formalParameterSignature signature ;
      @semanticInstructionListForGeneration instructionListForGeneration ;
      semanticAnalysisOfRuleLabel
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !inTerminalMap
        !inHasTranslateFeature
        !inLexiqueName
        !nonterminalMap
        !inComponentName
        !mEndOfInstructionList
        !inIndexNameSet
        !?localSelectMethodCount
        ?signatureForGeneration
        ?signature
        ?instructionListForGeneration
      ;
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
      ;
    end foreach ;
    selectMethodCount := localSelectMethodCount ;
    [nonterminalMap searchKey !mNonterminalName ?*] ;
    ruleDeclarationList +=
      ![mNonterminalName string]
      !newRuleIndex
      !ruleLabelImplementationList
    ;
    newRuleIndex ++ ;
  end foreach ;
#---
  outSyntaxDeclarationForGeneration := [@syntaxDeclarationForGeneration new
    !true # is Global
    !inComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
    !inHasIndexing
    !inHasTranslateFeature
  ] ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
