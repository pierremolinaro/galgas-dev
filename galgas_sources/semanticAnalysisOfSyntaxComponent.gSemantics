#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component semantic analysis                                       *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysisOfSyntaxComponent :
import "semanticsCompilation.gSemantics" ;
import "lexiqueCompilation.gSemantics" ;

import semantics lexiqueCompilation in "lexiqueCompilation.gSemantics" ;
import semantics semanticsCompilation in "semanticsCompilation.gSemantics" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    D E C L A R A T I O N S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignature ;
  @location mEndOfArgumentLocation ;
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal label is not declared" ;
}

#---------------------------------------------------------------------------*

map @ruleIndexMap {
  @uint mRuleIndex ;
  insert insertKey error message "the '%K' rule has been already declared [INTERNAL ERROR]" ;
}

#---------------------------------------------------------------------------*

map @nonterminalDeclarationMap {
  @nonterminalLabelMap mLabelMap ;
  @bool mHasParseLabel ;
  insert insertKey error message "the '%K' nonterminal has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName ;
  @uint mRuleIndex ;
  @nonterminalLabelMap mLabelMap ;
}

#---------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration extends @semanticDeclarationForGeneration {
  @string mComponentName ;
  @string mLexiqueName ;
  @nonterminalDeclarationMap mNonterminalDeclarationMap ;
  @ruleDeclarationList mRuleDeclarationList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
} {
  template syntaxFileHeader "syntax-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@lstringlist IMPORTED_COMPONENT_LIST
    ?@lstringlist TYPE_PREDECLARATION_LIST
  ;

  template syntaxFileImplementation "syntax-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
  ;

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalDeclarationMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
  ;
}

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration appendDeclaration -> @string outHeader :
  outHeader := [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !mComponentName
    !mLexiqueName
    !mNonterminalDeclarationMap
    !mRuleDeclarationList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    N O N T E R M I N A L    M A P                     *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterNonterminalNonTerminalInMapAndCheck
  ??@lstring inNonTerminalName
  ??@nonterminalLabelMap inNonterminalLabelMap
  ??@bool inHasParseLabel
  ?!@nonterminalDeclarationMap ioNonterminalDeclarationMap 
:
  with ioNonterminalDeclarationMap hasKey ![inNonTerminalName string] do
    if mHasParseLabel != inHasParseLabel then
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' is redeclared "
      . if mHasParseLabel then "with" else "without" end
      . " 'parse' label, but first declaration declares it "
      . if inHasParseLabel then "with" else "without" end
      . " 'parse' label"
      ;
    end if ;
    const @stringset firstDeclarationLabelSet := [mLabelMap allKeys] ;
    const @stringset reDeclarationLabelSet := [inNonterminalLabelMap allKeys] ;
    const @stringset missingLabelSet := firstDeclarationLabelSet - reDeclarationLabelSet ;
    if [missingLabelSet count] > 0 then
      @string s := "" ;
      foreach missingLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared without the following label(s):" . s
      ;
    end if ;
    const @stringset newLabelSet := reDeclarationLabelSet - firstDeclarationLabelSet ;
    if [newLabelSet count] > 0 then
      @string s := "" ;
      foreach newLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared with the new label(s):" . s
      ;
    end if ;
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      foreach mLabelMap, inNonterminalLabelMap prefixedby new_ do
        @formalParameterSignature newSignature [emptyList] ;
        foreach new_mSignature do
          newSignature += !mFormalArgumentType !mFormalArgumentPassingMode ;
        end foreach ;
        checkMethodSignatures
          !mSignature
          !mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        ;
      end foreach ;
    end if ;
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap !inHasParseLabel] ;
  end with ;
end routine ;

#---------------------------------------------------------------------------*

routine buildNonterminalDeclarationsMap
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@semanticContext inSemanticContext
  !@nonterminalDeclarationMap outNonterminalDeclarationMap
:
  outNonterminalDeclarationMap := [@nonterminalDeclarationMap emptyMap] ;
#--- Nonterminal declaration list
  foreach inNonterminalDeclarationList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabels do
      @formalParameterListForGeneration signature [emptyList] ;
      foreach mFormalArgumentList do
        const @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signature += !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string] ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signature !mEndOfArgumentLocation] ;
    end foreach ;
    enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !mHasParseLabel !?outNonterminalDeclarationMap ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
:
  @semanticInstructionAST t := self ; # Bug in GALGAS 1
  [t analyzeSemanticInstruction
    !inSemanticContext
    !inPredefinedTypes
    !?ioInstructionListForGeneration
    !?ioVariableMap
    !?ioLocalVariableCppNameList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction analyzeSyntaxInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  message "@nonterminalCallInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist ioLocalVariableCppNameList
:
  @lexicalSentValueList sentAttributeList ;
  [inTerminalMap searchKey !mTerminalName ?sentAttributeList] ;
#---
  if [mActualInputParameterList length] != [sentAttributeList length] then
    error mTerminalName
    : "naming the '$" . mTerminalName . "$' requires " . [[sentAttributeList length] string]
    . "parameter" . if [sentAttributeList length] > 0 then "s" else "" end
    . ", but this instruction names "
    . [[mActualInputParameterList length] string] . " parameter" 
    . if [mActualInputParameterList length] > 0 then "s" else "" end
    ;
  end if ;
#---
  foreach mActualInputParameterList, sentAttributeList do
    if [mActualParameterName length] > 0 then # Empty string if joker
      @unifiedTypeMapProxy type ;
      @string cppName ;
      if [mActualParameterTypeName length] > 0 then
        cppName := "var_" . [mActualParameterName identifierRepresentation] ;
        type := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mActualParameterTypeName] ;
        [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName] ;
        ioLocalVariableCppNameList += !cppName ;
      else
        [!?ioVariableMap searchForWriteAccess !mActualParameterName ?type ?cppName] ;
      end if ;
      @unifiedTypeMapProxy expectedType ;
      switch mLexicalType
      when lexicalType_string : expectedType := inPredefinedTypes->mStringType ;
      when lexicalType_char : expectedType := inPredefinedTypes->mCharType ;
      when lexicalType_uint : expectedType := inPredefinedTypes->mUIntType ;
      when lexicalType_uint64 : expectedType := inPredefinedTypes->mUInt64Type ;
      when lexicalType_sint : expectedType := inPredefinedTypes->mSIntType ;
      when lexicalType_sint64 : expectedType := inPredefinedTypes->mSInt64Type ;
      when lexicalType_double : expectedType := inPredefinedTypes->mDoubleType ;
      end switch ;
      if expectedType != type then
        error mActualParameterName
        : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
        . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
        ;
      end if ;
    end if ;
  end foreach ;
#---
end method ;

#---------------------------------------------------------------------------*

routine analyzeSyntaxInstructionList
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@syntaxInstructionList inSemanticInstructionListAST
  ??@location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap beginBranch] ;
#--- Instruction list
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSemanticInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?localVariableCppNameList
    ] ;
  end foreach ;
#--- Drop local variables
  if [localVariableCppNameList length] > 0 then
    outInstructionListForGeneration += ![@dropInstructionForGeneration new
      !localVariableCppNameList
      !"end of scope"
    ] ;  
  end if ;
#--- Branch end
  [!?ioVariableMap endBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @repeatInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Begin block
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- Repeated instructions
  @semanticInstructionListForGeneration repeated_instructionList ;
  analyzeSyntaxInstructionList
    !inSemanticContext
    !inPredefinedTypes
    !inTerminalMap
    !mRepeatedInstructionList
    !mEndOf_repeated_instructions_branch
    !?ioVariableMap
    ?repeated_instructionList
  ;
#--- 'while' blocks
  foreach mRepeatBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      ?instructionList
    ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOf_repeat_instruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction analyzeSyntaxInstruction
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
#--- Begin block
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- 'or' blocks
  foreach mSelectBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      ?instructionList
    ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOf_select_instruction] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction analyzeSyntaxInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  message "@parseDoInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction analyzeSyntaxInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  message "@parseLoopInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction analyzeSyntaxInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  message "@parseWhenInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction analyzeSyntaxInstruction
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ??@terminalMap unused inTerminalMap
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@stringlist unused ioLocalVariableCppNameList
:
  message "@blockInstruction\n" ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    C O N T E X T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfRuleLabel
  ??@formalParameterListAST inFormalArguments
  ??@syntaxInstructionList inSyntaxInstructionList
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  !@formalParameterListForGeneration outSignature
:
  @variableMap variableMap [emptyMap] ;
  buildLocalVariableMapAndSignature
    !inSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignature
  ;
#--- Semantic analysis of instruction list
  @semanticInstructionListForGeneration instructionListForGeneration [emptyList] ;
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inSemanticContext
      !inPredefinedTypes
      !inTerminalMap
      !?instructionListForGeneration
      !?variableMap
      !?localVariableCppNameList
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           S E M A N T I C    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfSyntaxComponent
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@syntaxRuleListAST inRuleList
  ??@string inComponentName
  ??@string inLexiqueName
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
:
  @nonterminalDeclarationMap nonterminalDeclarationMap [emptyMap] ;
  buildNonterminalDeclarationsMap
    !inNonterminalDeclarationList
    !inSemanticContext
    ?nonterminalDeclarationMap
  ;
#--- Rule list
  @ruleIndexMap ruleIndexMap [emptyMap] ;
  @ruleDeclarationList ruleDeclarationList [emptyList] ;
  foreach inRuleList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabelList do
      @formalParameterListForGeneration signature ;
      semanticAnalysisOfRuleLabel
        !mFormalArguments
        !mSyntaxInstructionList
        !inSemanticContext
        !inPredefinedTypes
        !inTerminalMap
        ?signature
      ;
      [!?nonterminalLabelMap insertKey !mLabelName !signature !mEndOfArgumentLocation] ;
    end foreach ;
    @uint ruleIndex ;
    with !?ruleIndexMap hasKey ![mNonterminalName string] do
      ruleIndex := mRuleIndex ;
      mRuleIndex ++ ;
    else
      [!?ruleIndexMap insertKey !mNonterminalName !0] ;
      ruleIndex := 0 ;
    end with ;
    with nonterminalDeclarationMap hasKey ![mNonterminalName string] do
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !mHasParseLabel !?nonterminalDeclarationMap ;
    else
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !false !?nonterminalDeclarationMap ;
    end with ;
    ruleDeclarationList += ![mNonterminalName string] !ruleIndex !nonterminalLabelMap ;
  end foreach ;
#---
  outSyntaxDeclarationForGeneration := [@syntaxDeclarationForGeneration new
    !inComponentName
    !inLexiqueName
    !nonterminalDeclarationMap
    !ruleDeclarationList
  ] ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
