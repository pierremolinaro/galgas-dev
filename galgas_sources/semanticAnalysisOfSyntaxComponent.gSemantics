#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component semantic analysis                                       *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysisOfSyntaxComponent :
import "syntaxSignature.gSemantics" ;

import semantics syntaxSignature in "syntaxSignature.gSemantics" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    D E C L A R A T I O N S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal label is not declared" ;
}

#---------------------------------------------------------------------------*

map @nonterminalMap {
  @nonterminalLabelMap mLabelMap ;
  @bool mHasParseLabel ;
  insert insertKey error message "the '%K' nonterminal has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @ruleLabelImplementationList {
  @lstring mLabelName ;
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  @semanticInstructionListForGeneration mInstructionListForGeneration ;
}

#---------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName ;
  @uint mRuleIndex ;
  @ruleLabelImplementationList mLabelImplementationList ;
  @bool mHasParseLabel ;
}

#---------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration extends @semanticDeclarationForGeneration {
  @string mComponentName ;
  @string mLexiqueName ;
  @nonterminalMap mNonterminalDeclarationMap ;
  @ruleDeclarationList mRuleDeclarationList ;
  @uint mSelectMethodCount ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
} {
  template syntaxFileHeader "syntax-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
    ?@lstringlist TYPE_PREDECLARATION_LIST
  ;

  template syntaxFileImplementation "syntax-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
  ;
}

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration appendDeclaration1 -> @string outHeader :
  @uintlist selectMethodList [emptyList] ;
  @uint idx := 0 ;
  loop mSelectMethodCount + 1 :
  while idx < mSelectMethodCount do
    selectMethodList += !idx ;
    idx ++ ;
  end loop ;
  outHeader := [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !mComponentName
    !mLexiqueName
    !mNonterminalDeclarationMap
    !mRuleDeclarationList
    !selectMethodList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    N O N T E R M I N A L    M A P                     *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterNonterminalNonTerminalInMapAndCheck
  ??@lstring inNonTerminalName
  ??@nonterminalLabelMap inNonterminalLabelMap
  ??@bool inHasParseLabel
  ?!@nonterminalMap ioNonterminalDeclarationMap 
:
  with ioNonterminalDeclarationMap hasKey ![inNonTerminalName string] do
    if mHasParseLabel != inHasParseLabel then
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' is redeclared "
      . if mHasParseLabel then "with" else "without" end
      . " 'parse' label, but first declaration declares it "
      . if inHasParseLabel then "with" else "without" end
      . " 'parse' label"
      ;
    end if ;
    const @stringset firstDeclarationLabelSet := [mLabelMap allKeys] ;
    const @stringset reDeclarationLabelSet := [inNonterminalLabelMap allKeys] ;
    const @stringset missingLabelSet := firstDeclarationLabelSet - reDeclarationLabelSet ;
    if [missingLabelSet count] > 0 then
      @string s := "" ;
      foreach missingLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared without the following label(s):" . s
      ;
    end if ;
    const @stringset newLabelSet := reDeclarationLabelSet - firstDeclarationLabelSet ;
    if [newLabelSet count] > 0 then
      @string s := "" ;
      foreach newLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared with the new label(s):" . s
      ;
    end if ;
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      foreach mLabelMap, inNonterminalLabelMap prefixedby new_ do
        @formalParameterSignature newSignature [emptyList] ;
        foreach new_mSignature do
          newSignature += !mFormalArgumentType !mFormalArgumentPassingMode ;
        end foreach ;
        checkMethodSignatures
          !mSignatureForGeneration
          !mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        ;
      end foreach ;
    end if ;
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap !inHasParseLabel] ;
  end with ;
end routine ;

#---------------------------------------------------------------------------*

routine buildNonterminalDeclarationsMap
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap
:
  outNonterminalDeclarationMap := [@nonterminalMap emptyMap] ;
#--- Nonterminal declaration list
  foreach inNonterminalDeclarationList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabels do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArgumentList do
        const @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string] ;
        signature += !t !mFormalArgumentPassingMode ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !mHasParseLabel !?outNonterminalDeclarationMap ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  @semanticInstructionAST t := selfcopy ; # Bug in GALGAS 1
  [t analyzeSemanticInstruction
    !inAnalysisContext
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string unused inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
#  message "Analyze <" . mNonterminalName . "> " . mLabelName . "\n" ;
  @nonterminalLabelMap labelMap ;
  @bool hasParseLabel ;
  [inNonterminalMap searchKey !mNonterminalName ?labelMap ?hasParseLabel] ;
  @formalParameterSignature signature ;
  if [mLabelName string] == "parse" then
    if not hasParseLabel then
      error mLabelName
      : "the '<" . mNonterminalName . ">' nonterminal does not declare the 'parse' label"
      : signature
      ;
    else
      signature := [@formalParameterSignature emptyList] ;
    end if ;
  else
    [labelMap searchKey !mLabelName ?* ?signature ?*] ;
  end if ;
#--- call arguments
  @actualParameterListForGeneration actualParameterListForGeneration ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mNonterminalName
    !"'<" . mNonterminalName . ">' nonterminal declaration"
    !signature
    !mActualParameterList
    !?ioVariableMap
    ?actualParameterListForGeneration
  ;
#---
  ioInstructionListForGeneration += ![@nonterminalInstructionForGeneration new
    !mInstructionLocation
    ![mNonterminalName string]
    ![mLabelName string]
    !actualParameterListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @nonterminalInstructionForGeneration\n" ;
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  foreach mActualParameterList do
    @string parameterCppName ;
    [mActualParameter generateActualParameter !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?ioUnusedVariableCppNameSet ?parameterCppName] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  ioGeneratedCode .= "nt_" . [mNonterminalName identifierRepresentation] . "_" . [mLabelName identifierRepresentation] . " (" ;
  foreach parameterCppNameList do
    ioGeneratedCode .= mValue . ", " ;
  end foreach ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .=  compilerCppName [] . ") ;\n" ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= mValue . ".drop () ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  @lexicalSentValueList sentAttributeList ;
  [inTerminalMap searchKey !mTerminalName ?sentAttributeList] ;
#---
  if [mActualInputParameterList length] != [sentAttributeList length] then
    error mTerminalName
    : "naming the '$" . mTerminalName . "$' requires " . [[sentAttributeList length] string]
    . "parameter" . if [sentAttributeList length] > 0 then "s" else "" end
    . ", but this instruction names "
    . [[mActualInputParameterList length] string] . " parameter" 
    . if [mActualInputParameterList length] > 0 then "s" else "" end
    ;
  end if ;
#---
  @terminalCheckAssignementList terminalCheckAssignementList [emptyList] ;
  foreach mActualInputParameterList, sentAttributeList do
    if [mActualParameterName length] > 0 then # Empty string if joker
      @unifiedTypeMapProxy type ;
      @string cppName ;
      if [mActualParameterTypeName length] > 0 then
        cppName := "var_" . [mActualParameterName identifierRepresentation] ;
        type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
        [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName] ;
      else
        [!?ioVariableMap searchForWriteAccess !mActualParameterName ?type ?cppName ?*] ;
      end if ;
      @unifiedTypeMapProxy expectedType ;
      switch mLexicalType
      when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
      when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
      when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
      when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
      when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
      when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
      when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
      end switch ;
      if expectedType != type then
        error mActualParameterName
        : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
        . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
        ;
      end if ;
      terminalCheckAssignementList +=
        ![mActualParameterTypeName string]
        !cppName
        !mLexicalAttributeName
      ;
    end if ;
  end foreach ;
#---
  ioInstructionListForGeneration += ![@terminalCheckInstructionForGeneration new
    !mInstructionLocation
    !mTerminalName
    !inLexiqueName
    !terminalCheckAssignementList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstructionForGeneration generateInstruction
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @terminalCheckInstructionForGeneration\n" ;
#--- Get synthetized attributes
  foreach mTerminalCheckAssignementList do
    if mTypeName != "" then
      ioGeneratedCode .= "GALGAS_" . [mTypeName identifierRepresentation] . " " ;
    else
    end if ;
    ioGeneratedCode .= mTargetVarCppName . " = " . compilerCppName [] . "->synthetizedAttribute_"
                    . [mSourceLexicalAttributeName identifierRepresentation]
                    . " () ;\n" ;
  end foreach ;
#--- Check terminal symbol
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->acceptTerminal (ACCEPT_TERMINAL (C_Lexique_"
                  . mLexiqueIdentifier . "::kToken_" . [mTerminalName identifierRepresentation]
                  . ") COMMA_SOURCE_FILE_AT_LINE (" . [[mInstructionLocation line] string] . ")) ;\n" ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeSyntaxInstructionList
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string  inComponentName
  ??@syntaxInstructionList inSyntaxInstructionListAST
  ??@location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap beginBranch] ;
#--- Instruction list
  foreach inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ] ;
  end foreach ;
#--- Branch end
  [!?ioVariableMap endBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @repeatInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
  const @uint choiceIndex := ioSelectMethodCount ;
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- Repeated instructions
  @semanticInstructionListForGeneration repeated_instructionList ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mRepeatedInstructionList
    !mEndOf_repeated_instructions_branch
    !?ioVariableMap
    !?ioSelectMethodCount
    ?repeated_instructionList
  ;
#--- 'while' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mRepeatBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inAnalysisContext
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOf_repeat_instruction] ;
#---
  ioInstructionListForGeneration += ![@repeatInstructionForGeneration new
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !repeated_instructionList
    !mEndOf_repeat_instruction
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @repeatInstructionForGeneration\n" ;
  const @string repeatFlagCppName := "repeatFlag_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "bool " . repeatFlagCppName . " = true ;\n" ;
  ioGeneratedCode .= "while (" . repeatFlagCppName . ") {\n" ;
  generateInstructionList
    !m_repeated_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= "switch (select_" . [mSyntaxComponentName identifierRepresentation] . "_" . [mChoiceIndex string] . " (" . compilerCppName [] . ")) {\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX do
    ioGeneratedCode .= "case " . [IDX + 2 string] . ": {\n" ;
    generateInstructionList
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "default:\n" ;
  ioGeneratedCode .= "  " . repeatFlagCppName . " = false ;\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string  inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
  const @uint choiceIndex := ioSelectMethodCount ;
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap beginOverrideForSelectBlock] ;
#--- 'or' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mSelectBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inAnalysisContext
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- End block
  [!?ioVariableMap endOverride !mEndOf_select_instruction] ;
  ioInstructionListForGeneration += ![@selectInstructionForGeneration new
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !listOfSemanticInstructionListForGeneration
 ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @selectInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= "switch (select_" . [mSyntaxComponentName identifierRepresentation] . "_" . [mChoiceIndex string] . " (" . compilerCppName [] . ")) {\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX do
    ioGeneratedCode .= "case " . [IDX + 1 string] . ": {\n" ;
    generateInstructionList
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "default:\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap  inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- 'Rewind' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  const @uint referenceSelectMethodCount := ioSelectMethodCount ;
  foreach mParseRewindBranchList do
    ioSelectMethodCount := referenceSelectMethodCount ;
    @semanticInstructionListForGeneration instructionList [emptyList] ;
    foreach mSyntaxInstructionList do
      [mInstruction analyzeSyntaxInstruction
        !inAnalysisContext
        !inTerminalMap
        !inLexiqueName
        !inNonterminalMap
        !inComponentName
        !?instructionList
        !?ioVariableMap
        !?ioSelectMethodCount
      ] ;
    end foreach ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- Check syntax signature of branches
  @listOfSemanticInstructionListForGeneration tempListOfBranches := listOfSemanticInstructionListForGeneration ;
  @semanticInstructionListForGeneration instructionList ;
  [!?tempListOfBranches popFirst ?instructionList ?*] ;
  const @semanticInstructionListForGeneration referenceSignature := syntaxSignatureOfInstructionList [!instructionList] ;
  @bool ok := true ;
  foreach tempListOfBranches while ok do
    ok := compareSyntaxSignature [
      !referenceSignature
      !syntaxSignatureOfInstructionList [!mInstructionList]
      !mEndOfInstructionList
    ] ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@parseRewindInstructionForGeneration new
    !mInstructionLocation
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//-------- @parseRewindInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  const @string parsingContextVar := "parsingContext_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "const C_parsingContext " . parsingContextVar . " = " . compilerCppName [] . "->parsingContext () ;\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX
  do
    generateInstructionList
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioGeneratedCode
    ;
  between 
    ioGeneratedCode .= compilerCppName [] . "->setParsingContext (" . parsingContextVar . ") ; // rewind " . [IDX + 1 string] . "\n" ;
  end foreach ;
  ioGeneratedCode .= "//-------- END OF @parseRewindInstructionForGeneration\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- Variant expression
  @semanticExpressionForGeneration variant_expression ;
  [mVariantExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?variant_expression
  ] ;
  if [variant_expression mType] != inAnalysisContext->mPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    :"the variant expression type is '@" . [[variant_expression mType] key]
    . "', but it should be '@" . [inAnalysisContext->mPredefinedTypes->mUIntType key] . "' type"
    ;
  end if ;
#--- While expression
  @semanticExpressionForGeneration while_expression ;
  [mWhileExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?while_expression
  ] ;
  if [while_expression mType] != inAnalysisContext->mPredefinedTypes->mBoolType then
    error mEndOfWhileExpression
    :"the variant expression type is '@" . [[variant_expression mType] key]
    . "', but it should be '@" . [inAnalysisContext->mPredefinedTypes->mBoolType key] . "' type"
    ;
  end if ;
#--- 'do' instructions
#--- Begin block
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- 'or' blocks
  @semanticInstructionListForGeneration instructionList ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mDoInstructionList
    !mEndOfInstructionList
    !?ioVariableMap
    !?ioSelectMethodCount
    ?instructionList
  ;
#--- End block
  [!?ioVariableMap endOverride !mEndOfInstructionList] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@parseLoopInstructionForGeneration new
    !mInstructionLocation
    !variant_expression
    !while_expression
    !instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

#override method @parseLoopInstructionForGeneration generateInstruction
#  ?!@uint ioTemporaryVariableIndex
#  ?!@stringset ioUnusedVariableCppNameSet
#  ?!@string ioGeneratedCode
#:
#  ioGeneratedCode .= "//-------- @parseLoopInstructionForGeneration\n" ;
##--- Variant
#  @string variantVarCppName ;
#  [mVariantExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantVarCppName] ;
##--- Loop variable
#  const @string executeParseVar := "executeParse_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
#  ioGeneratedCode .= "bool " . executeParseVar . " = ! " . variantVarCppName . ".isValid () ;\n" ;
#  ioGeneratedCode .= "if (! " . executeParseVar . ") {\n" ;
#  [!?ioGeneratedCode incIndentation !2] ;
#  const @string variantVar := "variant_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
#  ioGeneratedCode .= "PMUInt32 " . variantVar . " = " . variantVarCppName . ".uintValue () ;\n" ;
#  ioGeneratedCode .= variantVarCppName . ".drop () ; // Release 'parse loop' variant\n" ;
##--- Condition (at the beginning of the loop)
#  @string whileVarCppName ;
#  [mWhileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVarCppName] ;
#  ioGeneratedCode .= executeParseVar . " = (! " . whileVarCppName . ".isValid ()) || ! " . whileVarCppName . ".boolValue () ;\n" ;
#  ioGeneratedCode .= whileVarCppName . ".drop () ; // Release 'parse loop' first evaluation of 'while' expression\n" ;
#  ioGeneratedCode .= "if (! " . executeParseVar . ") {\n" ;
#  [!?ioGeneratedCode incIndentation !2] ;
#  const @string loopVar := "loop_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
#  ioGeneratedCode .= "bool " . loopVar . " = true ;\n" ;
#  ioGeneratedCode .= "while (" . loopVar . ") {\n" ;
#  [!?ioGeneratedCode incIndentation !2] ;
#  ioGeneratedCode .= loopVar . " = false ;\n" ;
#  ioGeneratedCode .= executeParseVar . " = 0 == " . variantVar . " ;\n" ;
#  ioGeneratedCode .= "if (! " . executeParseVar . ") {\n" ;
#  ioGeneratedCode .= "  " . variantVar . " -- ; // Decrement variant\n" ;
#  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
#  ioGeneratedCode .= "  const C_parsingContext parsingContext = " . compilerCppName [] . "->parsingContext () ;\n" ;
#  generateInstructionList
#    !mInstructionList
#    !?ioTemporaryVariableIndex
#    !?ioUnusedVariableCppNameSet
#    !?ioGeneratedCode
#  ;
##--- Condition (at the end of the loop)
#  [!?ioGeneratedCode incIndentation !2] ;
#  ioGeneratedCode .= compilerCppName [] . "->setParsingContext (parsingContext) ;\n" ;
#  [mWhileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVarCppName] ;
#  ioGeneratedCode .= loopVar . " = " . whileVarCppName . ".isValid () && " . whileVarCppName . ".boolValue () ;\n" ;
#  ioGeneratedCode .= whileVarCppName . ".drop () ; // Release 'parse loop' evaluation of 'while' expression\n" ;
#  ioGeneratedCode .= executeParseVar . " = true ;\n" ;
#  [!?ioGeneratedCode decIndentation !2] ;
#  ioGeneratedCode .= "}\n" ;
#  [!?ioGeneratedCode decIndentation !2] ;
#  ioGeneratedCode .= "}\n" ;
#  [!?ioGeneratedCode decIndentation !2] ;
#  ioGeneratedCode .= "}\n" ;
#  [!?ioGeneratedCode decIndentation !2] ;
#  ioGeneratedCode .= "}\n" ;
##--- Execute 'parse' part
#  ioGeneratedCode .= "if (" . executeParseVar . ") {\n" ;
#  generateInstructionList
#    !syntaxSignatureOfInstructionList [!mInstructionList]
#    !?ioTemporaryVariableIndex
#    !?ioUnusedVariableCppNameSet
#    !?ioGeneratedCode
#  ;
#  ioGeneratedCode .= "  inCompiler->resetTemplateString () ;\n" ;
#  ioGeneratedCode .= "}\n" ;
#end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= "//-------- @parseLoopInstructionForGeneration\n" ;
#--- Variant
  @string variantVarCppName ;
  [mVariantExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantVarCppName] ;
#--- Loop variable
  ioGeneratedCode .= "if (" . variantVarCppName . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  const @string variantVar := "variant_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "PMUInt32 " . variantVar . " = " . variantVarCppName . ".uintValue () ;\n" ;
#--- loop
  const @string loopVar := "loop_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "bool " . loopVar . " = true ;\n" ;
  ioGeneratedCode .= "while (" . loopVar . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= loopVar . " = false ;\n" ;
  @string whileVarCppName ;
  [mWhileExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVarCppName] ;
  ioGeneratedCode .= "if (" . whileVarCppName . ".isValidAndTrue ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= loopVar . " = true ;\n" ;
  ioGeneratedCode .= variantVar . " -- ; // Decrement variant\n" ;
  ioGeneratedCode .= "const C_parsingContext parsingContext = " . compilerCppName [] . "->parsingContext () ;\n" ;
  generateInstructionList
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= compilerCppName [] . "->setParsingContext (parsingContext) ;\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
#--- Execute 'parse' part
  ioGeneratedCode .= "//--- 'parse'\n" ;
  generateInstructionList
    !syntaxSignatureOfInstructionList [!mInstructionList]
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= compilerCppName [] . "->resetTemplateString () ;\n" ;
  ioGeneratedCode .= "//-------- END OF @parseLoopInstructionForGeneration\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- When expression
  @semanticExpressionForGeneration when_expression ;
  [mWhenExpression analyzeSemanticExpression
    !inAnalysisContext
    !?ioVariableMap
    ?when_expression
  ] ;
#--- Begin block
  [!?ioVariableMap beginOverrideForRepeatBlock] ;
#--- 'when' branch
  @uint localSelectMethodCount := ioSelectMethodCount ;
  @semanticInstructionListForGeneration when_instructionListForGeneration ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mWhenInstructionList
    !mEndOfWhenInstructionList
    !?ioVariableMap
    !?localSelectMethodCount
    ?when_instructionListForGeneration
  ;
#--- 'else' branch
  @semanticInstructionListForGeneration else_instructionListForGeneration ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mElseInstructionList
    !mEndOfElseInstructionList
    !?ioVariableMap
    !?ioSelectMethodCount
    ?else_instructionListForGeneration
  ;
#--- End block
  [!?ioVariableMap endOverride !mEndOfElseInstructionList] ;
#--- Check syntax signature
  const @bool ok := compareSyntaxSignature [
    !syntaxSignatureOfInstructionList [!when_instructionListForGeneration]
    !syntaxSignatureOfInstructionList [!else_instructionListForGeneration]
    !mEndOfElseInstructionList
  ] ;
#--- Generate instruction
  if ok then
    ioInstructionListForGeneration += ![@parseWhenInstructionForGeneration new
      !mInstructionLocation
      !when_expression
      !when_instructionListForGeneration
      !else_instructionListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstructionForGeneration generateInstruction
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  ioGeneratedCode .= "//--------- @parseWhenInstructionForGeneration\n" ;
  @string sourceVar ;
  [mWhenExpression generateExpression !?ioGeneratedCode !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  ioGeneratedCode .= "if (" . sourceVar . ".isValidAndTrue ()) {\n" ;
  generateInstructionList
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}else{\n" ;
  generateInstructionList
    !mElseInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction analyzeSyntaxInstruction
  ??@analysisContext unused inAnalysisContext
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  ?!@variableMap unused ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  error mBlockMethodName
  : "'block' instruction is not handled in GALGAS 2\n" ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    C O N T E X T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfRuleLabel
  ??@formalParameterListAST inFormalArguments
  ??@syntaxInstructionList inSyntaxInstructionList
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@location inEndOfInstructionList
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  @variableMap variableMap [emptyMap] ;
  buildLocalVariableMapAndSignature
    !inAnalysisContext->mSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  ;
#---
  outSignature := [@formalParameterSignature emptyList] ;
  foreach outSignatureForGeneration do
    outSignature += !mFormalArgumentType !mFormalArgumentPassingMode ;
  end foreach ;
#--- Semantic analysis of instruction list
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ] ;
  end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfInstructionList] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           S E M A N T I C    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfSyntaxComponent
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@syntaxRuleListAST inRuleList
  ??@string inComponentName
  ??@string inLexiqueName
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
:
#------------ Build nonterminal map
  @nonterminalMap nonterminalMap [emptyMap] ;
  buildNonterminalDeclarationsMap
    !inNonterminalDeclarationList
    !inSemanticContext
    ?nonterminalMap
  ;
#------------ Build nonterminal map from rule headers
  foreach inRuleList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabelList do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArguments do
        const @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalArgumentPassingMode !type !mFormalArgumentName !"argument_" . mFormalArgumentName ;
        signature += !type !mFormalArgumentPassingMode ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    with nonterminalMap hasKey ![mNonterminalName string] do
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !mHasParseLabel !?nonterminalMap ;
    else
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !false !?nonterminalMap ;
    end with ;
  end foreach ;
#--- Analysis context
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
  ] ;
#--- Rule list
  @uint selectMethodCount := 0 ;
  @ruleDeclarationList ruleDeclarationList [emptyList] ;
  @uint newRuleIndex := 0 ;
  foreach inRuleList do
    @ruleLabelImplementationList ruleLabelImplementationList [emptyList] ;
    @uint localSelectMethodCount := selectMethodCount ;
    foreach mLabelList do
      localSelectMethodCount := selectMethodCount ;
      @formalParameterListForGeneration signatureForGeneration ;
      @formalParameterSignature signature ;
      @semanticInstructionListForGeneration instructionListForGeneration ;
      semanticAnalysisOfRuleLabel
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !inTerminalMap
        !inLexiqueName
        !nonterminalMap
        !inComponentName
        !mEndOfInstructionList
        !?localSelectMethodCount
        ?signatureForGeneration
        ?signature
        ?instructionListForGeneration
      ;
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
      ;
    end foreach ;
    selectMethodCount := localSelectMethodCount ;
    @bool hasParseLabel ;
    [nonterminalMap searchKey !mNonterminalName ?* ?hasParseLabel] ;
    ruleDeclarationList +=
      ![mNonterminalName string]
      !newRuleIndex
      !ruleLabelImplementationList
      !hasParseLabel
    ;
    newRuleIndex ++ ;
  end foreach ;
#---
  outSyntaxDeclarationForGeneration := [@syntaxDeclarationForGeneration new
    !inComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
  ] ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
