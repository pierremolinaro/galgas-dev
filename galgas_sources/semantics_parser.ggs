#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component parser definition                             *
#                                                                           *
#  Copyright (C) 1997-2004 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax semantics_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#---------------------------------------------------------------------------*
#                                                                           *
#          Rules prototypes                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_states>
  ?!@stateMap ioStateValues
  !@string outFirstStateName
  !@lastStateList outLastStateList
  !@transitionStatusMap  outTransitionStatusMap
label parse
;

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
label parse
;

rule <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
label parse
;

rule <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label parse
;

rule <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
label parse
;

rule <attributes_definition_list>
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  !@L_nameWithType listeTypeeAttributsExternesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <type_parsing>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType definitionType
  !@lstring outTypeName
label parse
;

rule <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionsList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@M_optionComponents ioOptionsComponentsMapForUse
label parse
;

rule <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool estAbstraite
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
label parse
;

rule <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
label parse
;

rule <abstract_method>
  ?!@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
label parse
;

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
label parse
;

rule <semantic_instructions_list_no_verif>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
label parse
;

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
label parse
;

rule <extract_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
label parse
;

rule <expression>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

rule <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionsList ioInstructionsList
label parse
;

rule <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <target_entity>
  !@typeCible typeEntiteDestination
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <read_access>
  !@lstring nomAttribut
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring nomVarDest
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
label parse
;

rule <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
label parse
;

rule <message_pattern>
  !@L_stringList outMessageList
label parse
;

rule <formal_arguments_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

rule <output_expression_list>
  !@typeExpressionList outExpressionList 
  ??@typeListeAttributsSemantiques inAttributesList
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
label parse
;

rule <drop_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
label parse
;

rule <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
label parse
;

rule <parse_match_case>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outTypeName
label parse
;

rule <parse_effective_input_parameters_list>
  ?!@typeVariablesMap ioVariablesMap
  ?@typeListeAttributsSemantiques inFormalArgumentsList
  ?@location inVarLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
label parse
;

action buildFileNameWithPath
  !@lstring outFileNameWithPath
  ?@lstring inPath
  ??@lstring inCppClassName
  ??@lstring inExtension
;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C S    C O M P O N E N T                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
:
  $semantics$ ;
#--- Obtenir le nom du component semantique
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
#--- No lexique
  @string defLexique := "" ;
#--- Import semantics
  @ModelMap modelMap [empty] ;
  @ActionMap actionMap [empty] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_optionComponents optionsComponentsMapForUse [empty] ;
  @M_semanticsEntitiesForUse componentEntitiesMap ;
  @stringset classNamesSet [empty] ;
  @typeTableEnAvant tableEnAvant [empty] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?ioSemanticsComponentsMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMapForUse
    ?modelMap
    ?actionMap

    ?componentEntitiesMap
    ?tableEnAvant
  ;
#-------------- Semantic Declarations
  parse
  #--- First pass on semantic declarations
  start
    @typeTableRoutinesAimplementer UNUSED_tableRoutinesAimplementer [empty] ;
    @typeTableNomRoutinesDeclarees UNUSED_tableNomRoutinesDeclarees [empty] ;
    @typeTableEnAvant UNUSED_tableEnAvant := tableEnAvant ;
    @M_semanticsEntitiesForUse UNUSED_componentSemanticsEntitiesMap := componentEntitiesMap ;
    repeat
    while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap
      !?UNUSED_componentSemanticsEntitiesMap
      !?UNUSED_tableNomRoutinesDeclarees
      !?UNUSED_tableEnAvant
      !?UNUSED_tableRoutinesAimplementer
    ;
    end repeat ;
  #--- Second pass on semantic declarations
  rewind
    @typeTableRoutinesAimplementer tableRoutinesAimplementer [empty] ;
    @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [empty] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [empty] ;
    repeat
    while
      <semantics_declaration>
        !?componentEntitiesMap
        !?listeEntitesAengendrer
        !?optionsComponentsMapForUse
        !?tableNomRoutinesDeclarees
        !?tableEnAvant
        !?tableRoutinesAimplementer
      ; 
    end repeat ;
  end parse ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName value]] then
    @M_optionComponents optionsComponentsMap [empty] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentEntitiesMap
    ] ;
  end if ;
#--- End of file
  $end$ ;
  $semantics$ ;
  $;$ ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees (??@lstring nomRoutine) :
    if not [tableRoutinesAimplementer hasKey ![nomRoutine value]] then
      error nomRoutine : "the routine '" . [nomRoutine value] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Generate component
  action generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
   ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
:
  $semantics$ ;
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap ;
  enterBuiltinTypes ?componentSemanticsEntitiesMap ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;

  <import_headers_semantics_and_grammars> importSemantics
    !?ioSemanticsComponentsMap
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?modelMap
    ?actionMap
    !?componentSemanticsEntitiesMap
  ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [empty] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [empty] ;
  @typeTableEnAvant tableEnAvant [empty] ;
  repeat
  while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap

      !?componentSemanticsEntitiesMap
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
    ;
  end repeat ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName value]] then
    @M_optionComponents optionsComponentsMap [empty] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentSemanticsEntitiesMap
    ] ;
  end if ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# I M P O R T  H E A D E R S,  S E M A N T I C S  A N D  G R A M M A R S    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <import_headers_semantics_and_grammars>
  !@stringset outImportedSemanticsComponents
  !@stringset outImportedOptionComponents
  !@stringset outImportedGrammarComponents
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
:
  outActionMap := [@ActionMap empty] ;
  outInclusionsForHeaderFile := [@stringset empty] ;
  outInclusionsForImplementationFile := [@stringset empty] ;
  outImportedSemanticsComponents := [@stringset empty] ;
  outImportedOptionComponents := [@stringset empty] ;
  outImportedGrammarComponents := [@stringset empty] ;
  tableEnAvant := [@typeTableEnAvant empty] ;
  ioOptionsComponentsMapForUse := [@M_optionComponents empty] ;
#--- Create model map, and enter builtin types
  outModelMap := [@ModelMap empty] ;
  @lstring key [new !"char" ! here] ;
  @TypeModel t := [@CharModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"string" ! here] ;
  t := [@StringModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"uint" ! here] ;
  t := [@UIntModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"sint" ! here] ;
  t := [@SIntModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"bool" ! here] ;
  t := [@BoolModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"double" ! here] ;
  t := [@DoubleModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"lchar" ! here] ;
  t := [@LCharModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"lstring" ! here] ;
  t := [@LStringModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"luint" ! here] ;
  t := [@LUIntModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"lsint" ! here] ;
  t := [@LSIntModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"lbool" ! here] ;
  t := [@LBoolModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"ldouble" ! here] ;
  t := [@LDoubleModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"location" ! here] ;
  t := [@LocationModel new] ;
  [!?outModelMap insertKey !key !t] ;
  key := [@lstring new !"stringset" ! here] ;
  t := [@StringsetModel new] ;
  [!?outModelMap insertKey !key !t] ;
#--- enter in semantics entities map the galgas types corresponding to keywords
  enterBuiltinTypes ?ioComponentSemanticsEntitiesMap ;
  @stringset alreadyImportedSemanticsComponents [empty] ;
#--- Loop on import instructions
  repeat
  while
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outImportedOptionComponents += ![optionComponentName value] ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [!?ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [empty] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [!?importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      [!?ioOptionsComponentsMapForUse insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
    or
      $grammar$ ;
      @lstring grammarComponentName ;
      $identifier$ ? grammarComponentName ;
      outImportedGrammarComponents += ![grammarComponentName value] ;
      @M_grammarComponents grammarComponentsMap ;
      select
        grammarComponentsMap := ioGrammarComponentsMap ;
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ? sourceFile ;
        grammarComponentsMap := [@M_grammarComponents empty] ;
        <parse_grammar_component_for_importing> 
          !sourceFile
          !?grammarComponentsMap
        ;
      end select ;
      @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap ;
      [!?grammarComponentsMap searchKey !grammarComponentName ?nonterminalSymbolParametersMap ?* ?*] ;
      @M_nonterminalSymbolAlts grammarAltMap [empty] ;
      foreach nonterminalSymbolParametersMap (??@lstring altName ??@L_signature signature) :
        @L_EXsignature formalParametersList [empty] ;
        foreach signature (??@formalArgumentPassingMode passingMode ??@lstring typeName) :
          @AC_semanticsEntity entity ;
          [!?ioComponentSemanticsEntitiesMap searchKey !typeName ?entity] ;
          @AC_galgasType type ;
          extract entity->@typeEntiteType (?type) error typeName : messageTypeEntite ;
          formalParametersList += !type !passingMode ;
        end foreach ;
        [!?grammarAltMap insertKey !altName !formalParametersList] ;
      end foreach ;
      @AC_semanticsEntity entity := [@C_grammarForSemantics new !grammarAltMap] ;
      [!?ioComponentSemanticsEntitiesMap insertKey !grammarComponentName !entity] ;
      @lstring path := [@lstring new !"" !here] ;
      @lstring extension := [@lstring new !"h" !here] ;
      @lstring fileNameWithPath ;
      action buildFileNameWithPath ?fileNameWithPath !path !grammarComponentName !extension ;
      outInclusionsForImplementationFile += ![fileNameWithPath value] ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
        ;
      end select ;
      if not [outImportedSemanticsComponents hasKey ![componentName value]] then
        @M_semanticsEntitiesForUse importedEntities ;
        @M_optionComponents importedOptionsComponentsMap ;
        [!?ioSemanticsComponentsMap searchKey !componentName ?* ?* ?* ?* ?importedOptionsComponentsMap ?importedEntities] ;
        foreach importedEntities (??@lstring entityName ??@AC_semanticsEntity entityType) :
          if not [ioComponentSemanticsEntitiesMap hasKey ![entityName value]] then
            [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
          end if ;
        end foreach ;
        outInclusionsForHeaderFile += ![componentName value] ;
      #--- Check that every used option component is already declared
        foreach importedOptionsComponentsMap (??@lstring optionComponentMap ...) :
          if not [ioOptionsComponentsMapForUse hasKey ![optionComponentMap value]] then
            error here: "the '" . [optionComponentMap value] . "' option component must have been imported" ;
          end if ;
        end foreach ;
      end if ;
    #--- Import semantics component
      importSemanticsComponent !?ioSemanticsComponentsMap !?outModelMap !?outActionMap !?alreadyImportedSemanticsComponents !componentName ;
    #---
      outInclusionsForHeaderFile += ![componentName value] ;
      outImportedSemanticsComponents += ![componentName value] ;
    end select ;
    $;$ ;
  end repeat ;
#--- Check that every option component used by an imported component is declared here

label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  outActionMap := [@ActionMap empty] ;
  outModelMap := [@ModelMap empty] ;
  outIncludedSemanticsComponents := [@stringset empty] ;
  outIncludedOptionComponents := [@stringset empty] ;
  @stringset alreadyImportedSemanticsComponents [empty] ;
  repeat
  while
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outIncludedOptionComponents += ![optionComponentName value] ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
     end select ;
    or
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_grammar_component_for_importing> parse ;
      end select ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      outIncludedSemanticsComponents += ![componentName value] ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ? sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
        ;
      end select ;
      @M_semanticsEntitiesForUse importedEntities ;
      [!?ioSemanticsComponentsMap searchKey !componentName ?* ?* ?* ?* ?* ?importedEntities] ;
      foreach importedEntities (??@lstring entityName ??@AC_semanticsEntity entityType) :
        if not [ioComponentSemanticsEntitiesMap hasKey ![entityName value]] then
          [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
        end if ;
      end foreach ;
    #--- Import semantics component
      importSemanticsComponent !?ioSemanticsComponentsMap !?outModelMap !?outActionMap !?alreadyImportedSemanticsComponents !componentName ;
    end select ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  R O U T I N E    D E C L A R A T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [empty] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName value]] then
    @L_EXsignature listeDeTypesPrecedenteDeclaration ;
    @AC_semanticsEntity entite ;
    [!?ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    extract entite->@typeEntiteRoutine (?listeDeTypesPrecedenteDeclaration) error routineName : messageTypeEntite ;
    verifierCompatibiliteSignatures
      !listeDeTypesPrecedenteDeclaration
      !listeDeTypes
      !here
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey ! routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionsList ioInstructionsList [empty] ;
    <semantic_instructions_list>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?tableArgumentsMethode
      !?ioInstructionsList
    ;
    $end$ ;
    $routine$ ;
    $;$ ;
  #--- Inserer la routine dans la map des routines a implementer
    @typeEntityToGenerate ea := [@typeRoutineAengendrer new ! routineName
                                                              !listeTypeEtNomsArguments
                                                              !ioInstructionsList] ;
    listeEntitesAengendrer += !ea ;
    [!?tableRoutinesAimplementer insertKey ! routineName] ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [empty] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signature ;
  @M_optionComponents optionsComponentsMapForUse [empty] ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ? signature
  ;
  [!?ioExternActionMap insertKey !routineName !signature !false] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName value]] then
    @L_EXsignature listeDeTypesPrecedenteDeclaration ;
    @AC_semanticsEntity entite ;
    [!?ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    extract entite->@typeEntiteRoutine (?listeDeTypesPrecedenteDeclaration) error routineName : messageTypeEntite ;
    verifierCompatibiliteSignatures
      !listeDeTypesPrecedenteDeclaration
      !listeDeTypes
      !here
    ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey ! routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionsList ioInstructionsList [empty] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [empty] ;
    <semantic_instructions_list>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?optionsComponentsMapForUse
      !?tableArgumentsMethode
      !?ioInstructionsList
    ;
    $end$ ;
    $routine$ ;
    $;$ ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                        ANALYSE D'UNE CLASSE MERE                          *
#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques empty] ;
  tableDesClassesAncetres := [@typeSuperClassesMap empty] ;
  tableDesMethodes := [@typeTableMethodes empty] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap empty] ;
  tableAttributs := [@typeSemanticAttributesMap empty] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques empty] ;
  tableDesClassesAncetres := [@typeSuperClassesMap empty] ;
  tableDesMethodes := [@typeTableMethodes empty] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap empty] ;
  tableAttributs := [@typeSemanticAttributesMap empty] ;
#---
  outMessageMap := [@classMessageMap empty] ;
  outSuperClasses := [@stringset empty] ;
  outAttributeList := [@typeListModel empty] ;
end rule ;

#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
#--- Parse super class name
  $extends$ ;
  @lstring superClassName ;
  $type_name$ ? superClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_galgasType typeUtilisateur ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !superClassName ?entite] ;
  extract entite->@typeEntiteType (?typeUtilisateur) error superClassName : messageTypeEntite ;
  extract typeUtilisateur->@typeGalgasClassType (?*
                                    ?tableDesMethodes
                                    ?listeTousAttributsSemantiques
                                    ?tableDesClassesAncetres
                                    ?tableMessagesAbstraits
                                    ?tableAttributs
                                    ?*)
             error superClassName : messageGalgasType ;
#--- Le Parse super class name est la derniere inseree en fin de la liste des ancetres 
  [!?tableDesClassesAncetres insertKey !superClassName] ;
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
#--- Parse super class name
  $extends$ ;
  @lstring superClassName ;
  $type_name$ ? superClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_galgasType typeUtilisateur ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !superClassName ?entite] ;
  extract entite->@typeEntiteType (?typeUtilisateur) error superClassName : messageTypeEntite ;
  extract typeUtilisateur->@typeGalgasClassType (?*
                                    ?tableDesMethodes
                                    ?listeTousAttributsSemantiques
                                    ?tableDesClassesAncetres
                                    ?tableMessagesAbstraits
                                    ?tableAttributs
                                    ?*)
             error superClassName : messageGalgasType ;
#--- The direct super class is last inserted one 
  [!?tableDesClassesAncetres insertKey !superClassName] ;
#---
  @TypeModel type ;
  [!?ioModelMap searchKey !superClassName ?type] ;
  extract type :
  when @ClassModel (??* ??@stringset superClasses ??@typeListModel attributeList ??@classMessageMap messageMap) ->
    outSuperClasses := superClasses ;
    outAttributeList := attributeList ;
    outMessageMap := messageMap ;
  else
    error superClassName: "the '@" . [superClassName value] . "' type is not a class"
     -> outSuperClasses, outAttributeList, outMessageMap ;
  end extract ;
  outSuperClasses += ![superClassName value] ;

  outMessageMap := [@classMessageMap empty] ;
  outSuperClasses := [@stringset empty] ;
  outAttributeList := [@typeListModel empty] ;

end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     A B S T R A C T    C L A S S                                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $abstract$ ;
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName value]] |
          [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName value]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    <parent_class>
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
    ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeAttributsExternesCourants ;
    @typeListModel attributeListModel [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @bool estAbstraite := true ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [empty] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [empty] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [empty] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    repeat
    while
      $message$ ;
      @lstring messageName ;
      $identifier$ ? messageName ;
    #--- Chaine definissant le message d'erreur
      @lstring messageText ;
      $literal_string$ ? messageText ;
    #--- Entrer le message dans la map
      if not [inheritedMessageMap hasKey ![messageName value]] then
        [!?messageMapForHeirs insertKey !messageName] ;
      end if ; 
      [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      $;$ ;
    while
      <abstract_method> !?listeAttributsSemantiquesCourants
                       !?listeEntitesAengendrer
                       !?ioComponentSemanticsEntitiesMap
                       !?tableDesMethodes
                       !?tableMethodesAimplementer
                       !?tableEnAvant ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?ioOptionsComponentsMapForUse
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?ioOptionsComponentsMapForUse
     ;
    end repeat ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
      if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait value]] then
        error here : "the message '" . [nomMessageAbstrait value] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
                                            !abstractClassName
                                             !tableDesMethodes
                                             !listeTousAttributsSemantiques
                                             !tableDesClassesAncetres
                                             !messageMapForHeirs
                                             !tableAttributs
                                             !estAbstraite] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
  #--- Inserer dans la map des classes definies dans ce fichier (a implementer)
    @typeEntityToGenerate def := [@typeDefClasseAbstraiteAimplementer new 
                                            !abstractClassName
                                             !listeTousAttributsSemantiques
                                             !tableDesMethodes
                                             !tableMethodesAimplementer
                                             !listeAttributsSemantiquesCourants
                                             !listeAttributsExternesCourants
                                             !tableDesClassesAncetres
                                             !tableMessagesClasseConcrete] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $abstract$ ;
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName value]] |
            [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName value]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    @stringset superClasses ;
    @typeListModel attributeList ;
    @classMessageMap messageMap ;
    <parent_class> importSemantics
      !?ioModelMap
      ?superClasses
      ?attributeList
      ?messageMap
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
    ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeAttributsExternesCourants ;
    <attributes_definition_list>
      !?attributeList
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @bool estAbstraite := true ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [empty] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [empty] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [empty] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [empty] ;
    @M_optionComponents optionsComponentsMapForUse [empty] ;
    repeat
    while
      $message$ ;
      @lstring messageName ;
      $identifier$ ? messageName ;
####      [!?messageMap insertKey !messageName] ;
    #--- Chaine definissant le message d'erreur
      @lstring messageText ;
      $literal_string$ ? messageText ;
    #--- Entrer le message dans la map
      if not [inheritedMessageMap hasKey ![messageName value]] then
        [!?messageMapForHeirs insertKey !messageName] ;
      end if ; 
      [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      $;$ ;
    while
      <abstract_method>
        !?listeAttributsSemantiquesCourants
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableDesMethodes
        !?tableMethodesAimplementer
        !?tableEnAvant ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?optionsComponentsMapForUse
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?optionsComponentsMapForUse
     ;
    end repeat ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
      if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait value]] then
        error here : "the message '" .  [nomMessageAbstrait value] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
                                             !abstractClassName
                                             !tableDesMethodes
                                             !listeTousAttributsSemantiques
                                             !tableDesClassesAncetres
                                             !messageMapForHeirs
                                             !tableAttributs
                                             !estAbstraite] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
    $}$ ;
    @TypeModel t := [@ClassModel new !true !superClasses !attributeList !messageMap] ;
    [!?ioModelMap insertKey !abstractClassName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     N O T    A B S T R A C T    C L A S S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $class$ ;
#--- Nom de la classe
  @lstring concreteClassName ;
  $type_name$ ? concreteClassName ;
#--- Verifier que cette classe n'a pas ete predeclaree
  if [tableEnAvant hasKey ![concreteClassName value]] then
    error concreteClassName : "a non abstract class cannot be predeclared" ; 
  end if ;
#--- Parse super class name
  $extends$ ;
  @lstring superClassName ;
  $type_name$ ? superClassName ;
  ${$ ;
#--- Verifications semantiques sur le Parse super class name
  @AC_galgasType definitionClasseMere ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !superClassName ?entite] ;
  extract entite->@typeEntiteType (?definitionClasseMere) error superClassName : messageTypeEntite ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
  @typeSuperClassesMap tableDesClassesAncetres ;  
  @typeTableMethodes ancestorClassMethodsMap ;
  @typeClassInheritedMessagesMap inheritedMessageMap ;
  @typeSemanticAttributesMap tableAttributs ;
  extract definitionClasseMere->@typeGalgasClassType (?*
                                    ?ancestorClassMethodsMap
                                    ?listeTousAttributsSemantiques
                                    ?tableDesClassesAncetres
                                    ?inheritedMessageMap
                                    ?tableAttributs
                                    ?*)
           error superClassName : messageGalgasType ;
  [!?tableDesClassesAncetres insertKey !superClassName] ;
#------------------- list des attributs de la classe -------------------
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
  @L_nameWithType listeTypeeAttributsExternesCourants ;
  @typeListModel attributeListModel [empty] ;
  <attributes_definition_list>
    !?attributeListModel
    !?tableAttributs
    !?listeTousAttributsSemantiques
    ?listeAttributsSemantiquesCourants
    ?listeTypeeAttributsExternesCourants
    !?ioComponentSemanticsEntitiesMap
  ;
  @bool estAbstraite := false ;
#--------------------- Methodes de la classe ----------------------------
  @typeTableMethodesAimplementer tableMethodesAimplementer [empty] ;
  @typeClassMessagesMap tableMessagesClasseConcrete [empty] ;
  @typeClassInheritedMessagesMap messageMapForHeirs [empty] ;
  @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
  block tableDesMethodes.definitionClasseNonAbstraite () :
    repeat
    while
      <overrided_method>
        !concreteClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?ioOptionsComponentsMapForUse
      ;
    while
      $message$ ;
    #--- Nom du message
      @lstring messageName ;
      $identifier$ ? messageName ;
    #--- Chaine definissant le message d'erreur
      @lstring messageText ;
      $literal_string$ ? messageText ;
    #--- Entrer le message dans la map
      if not [inheritedMessageMap hasKey ![messageName value]] then
        [!?messageMapForHeirs insertKey !messageName] ;
      end if ; 
      [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ; 
      $;$ ;
    while
      <non_abstract_method>
        !concreteClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?ioOptionsComponentsMapForUse
      ;
    end repeat ;
  end block () ;
#--- Verify that all inherited messages are defined
  foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
    if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait value]] then
      error here : "the message '" . [nomMessageAbstrait value] . "' is not defined" ;
    end if ;
  end foreach ;
#--- Insertion dans la tables des classes utilisables
  @AC_galgasType c := [@typeGalgasClassType new 
                        !concreteClassName
                        !tableDesMethodes
                        !listeTousAttributsSemantiques
                        !tableDesClassesAncetres
                        !messageMapForHeirs
                        !tableAttributs
                        !estAbstraite] ;
  entite := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !concreteClassName !entite] ;
#--- Insertion dans la map des classes a implementer
  @typeEntityToGenerate def := [@typeDefClasseNonAbstraiteAimplementer new 
                                                !concreteClassName
                                                !listeTousAttributsSemantiques
                                                !tableDesMethodes
                                                !tableMethodesAimplementer
                                                !listeAttributsSemantiquesCourants
                                                !listeTypeeAttributsExternesCourants
                                                !tableDesClassesAncetres
                                                !tableMessagesClasseConcrete] ;
  listeEntitesAengendrer += !def ;
  $}$ ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $class$ ;
#--- Nom de la classe
  @lstring concreteClassName ;
  $type_name$ ? concreteClassName ;
#--- Verifier que cette classe n'a pas ete predeclaree
  if [tableEnAvant hasKey ![concreteClassName value]] then
    error concreteClassName : "a non abstract class cannot be predeclared" ; 
  end if ;
#--- Parse super class name
  $extends$ ;
  @lstring superClassName ;
  $type_name$ ? superClassName ;
#--- Get super class infos
  @typeListModel attributeList ;
  @classMessageMap messageMap ;
  @stringset superClasses ;
  attributeList := [@typeListModel  empty] ;
  messageMap := [@classMessageMap empty] ;
  superClasses := [@stringset empty] ;
#  @TypeModel type ;
#  [!?ioModelMap searchKey !superClassName ?type] ;
#  extract type :
#  when @ClassModel (??* ??@stringset kSuperClasses ??@typeListModel kAttributeList ??@classMessageMap kMessageMap) ->
#    superClasses := kSuperClasses ;
#    attributeList := kAttributeList ;
#    messageMap := kMessageMap ;
#  else
#    error superClassName: "the '@" . [superClassName value] . "' type is not a class"
#     -> superClasses, attributeList, messageMap ;
#  end extract ;
#  superClasses += ![superClassName value] ;
  ${$ ;
#--- Check super class name
  @AC_galgasType definitionClasseMere ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !superClassName ?entite] ;
  extract entite->@typeEntiteType (?definitionClasseMere) error superClassName : messageTypeEntite ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
  @typeSuperClassesMap tableDesClassesAncetres ;  
  @typeTableMethodes ancestorClassMethodsMap ;
  @typeClassInheritedMessagesMap inheritedMessageMap ;
  @typeSemanticAttributesMap tableAttributs ;
  extract definitionClasseMere->@typeGalgasClassType (?*
                                    ?ancestorClassMethodsMap
                                    ?listeTousAttributsSemantiques
                                    ?tableDesClassesAncetres
                                    ?inheritedMessageMap
                                    ?tableAttributs
                                    ?*)
           error superClassName : messageGalgasType ;
  [!?tableDesClassesAncetres insertKey !superClassName] ;
#------------------- list des attributs de la classe -------------------
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
  @L_nameWithType listeTypeeAttributsExternesCourants ;
  @typeListModel attributeListModel [empty] ;
  <attributes_definition_list>
    !?attributeListModel
    !?tableAttributs
    !?listeTousAttributsSemantiques
    ?listeAttributsSemantiquesCourants
    ?listeTypeeAttributsExternesCourants
    !?ioComponentSemanticsEntitiesMap
  ;
  @bool estAbstraite := false ;
#--------------------- Methodes de la classe ----------------------------
  @typeTableMethodesAimplementer tableMethodesAimplementer [empty] ;
  @typeClassMessagesMap tableMessagesClasseConcrete [empty] ;
  @typeClassInheritedMessagesMap messageMapForHeirs [empty] ;
  @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
  @M_optionComponents optionsComponentsMapForUse [empty] ;
  block tableDesMethodes.definitionClasseNonAbstraite () :
    repeat
    while
      @typeEntitiesToGenerateList listeEntitesAengendrer [empty] ;
      <overrided_method>
        !concreteClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?optionsComponentsMapForUse
      ;
    while
      $message$ ;
    #--- Nom du message
      @lstring messageName ;
      $identifier$ ? messageName ;
      @lstring messageText ;
      $literal_string$ ?messageText ;
    #--- Entrer le message dans la map
      if not [inheritedMessageMap hasKey ![messageName value]] then
        [!?messageMapForHeirs insertKey !messageName] ;
      end if ; 
      [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ; 
      $;$ ;
    while
      @typeEntitiesToGenerateList listeEntitesAengendrer [empty] ;
      <non_abstract_method>
        !concreteClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?optionsComponentsMapForUse
      ;
    end repeat ;
  end block () ;
#--- Verify that all inherited messages are defined
  foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
    if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait value]] then
      error here : "the message '" . [nomMessageAbstrait value] . "' is not defined" ;
    end if ;
  end foreach ;
#--- Insertion dans la tables des classes utilisables
  @AC_galgasType c := [@typeGalgasClassType new 
                        !concreteClassName
                        !tableDesMethodes
                        !listeTousAttributsSemantiques
                        !tableDesClassesAncetres
                        !messageMapForHeirs
                        !tableAttributs
                        !estAbstraite] ;
  entite := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !concreteClassName !entite] ;
  @TypeModel t := [@ClassModel new !false !superClasses !attributeList !messageMap] ;
  [!?ioModelMap insertKey !concreteClassName !t] ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                 Methode abstract                          *
#---------------------------------------------------------------------------*

rule <abstract_method>
  ?!@typeListeAttributsSemantiques unused listeAttributsSemantiquesCourants
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
:
  $abstract$ ;
  $reader$ ;
  @lstring nomMethode ;
  $identifier$ ? nomMethode ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [empty] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  [!?tableDesMethodes insertAbstract !nomMethode !listeDeTypes] ;
  @typeInstructionsList listeInstructions [empty] ;
  [!?tableMethodesAimplementer insertAbstract !nomMethode !listeDeTypes !listeTypeEtNomsArguments !listeInstructions] ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionsList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@M_optionComponents ioOptionsComponentsMapForUse
:
#--- Get reader name
  $identifier$ ? outMethodName ;
#--- Create local variable map
  @typeVariablesMap methodLocalVariablesMap [empty]  ;
#--- Insert the predefined "self" variable
  @lstring me_Constant := [@lstring new !"self" !here] ;
  @typeCplusPlusName me_constantCppName := [@typeCppThisName new] ;
  @AC_galgasType typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !tableDesMethodes
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributs
           !inClassIsAbstract] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument !me_Constant !typeDefinition !me_constantCppName] ;
#--- Insert the predefined "super" variable
  @lstring super_Constant := [@lstring new !"super" !here] ;
  @typeCplusPlusName super_constantCppName := [@typeCppInheritedName new] ;
  typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !inAncestorClassMethodsMap
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributs
           !inClassIsAbstract] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument !super_Constant !typeDefinition !super_constantCppName] ;
#--- Parse formal arguments
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?outMethodSignature
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  $:$ ;
#--- Build local attributes table
  foreach listeAttributsSemantiquesCourants (??@AC_galgasType typeAttribut ??@lstring nomAttribut) :
    @typeCplusPlusName nomCpp := [@typeDirectName new !nomAttribut] ;
    [!?methodLocalVariablesMap insertUsedConstInArgument !nomAttribut !typeAttribut !nomCpp] ;
  end foreach ;
#--- Parse reader instruction list
  outInstructionsList := [@typeInstructionsList empty] ;
  <semantic_instructions_list>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !?ioOptionsComponentsMapForUse
    !?methodLocalVariablesMap
    !?outInstructionsList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
:
  $reader$ ;
  @lstring methodName ;
  @typeInstructionsList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !listeAttributsSemantiquesCourants
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?listeEntitesAengendrer
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !?ioOptionsComponentsMapForUse
 ;
  [!?tableDesMethodes insertNotAbstract !methodName !methodSignature] ;
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  $reader$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
:
  $override$ ;
  $reader$ ;
  @lstring methodName ;
  @typeInstructionsList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !listeAttributsSemantiquesCourants
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?listeEntitesAengendrer
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !?ioOptionsComponentsMapForUse
  ;
#--- Verify reader signature is compatible with overriden reader signature
  @L_EXsignature listeDeTypesMethodeOriginale ;
  [!?tableDesMethodes searchForOverride !methodName ?listeDeTypesMethodeOriginale] ;
  verifierCompatibiliteSignatures
    !listeDeTypesMethodeOriginale 
    !methodSignature
    !here
  ;
#--- Insert reader into reader table
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  $reader$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#               Analyse des arguments formels d'une methode                 *
#                     (entree, sortie, or entree/sortie)                    *
#---------------------------------------------------------------------------*

rule <formal_arguments_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignatureForGrammar
:
  listeDeTypes := [@L_EXsignature empty] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode empty] ;
  outSignatureForGrammar := [@L_signature empty] ;
  repeat
  while
    $??$ ; # '??'  : constant input formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    @bool modeIn := true ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertConstInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?$ ; # '?'  : input formal parameter (must be dropped)
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
    @bool modeIn := true ;
    listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
    [!?tableArgumentsMethode insertInArgument !nomArgument !type_semantique !natureNom] ;
  while
    $?!$ ; # '?!' : input/output formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentInOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @bool modeIn := false ;
    @lstring nomArgument ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertUnusedInOutArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertInOutArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $!$ ; # '!' : output formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
    @bool modeIn := false ;
    listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
    [!?tableArgumentsMethode insertOutArgument !nomArgument !type_semantique !natureNom] ;
  end repeat ;
label importGrammarForSemantics
  !@L_signature outSignature
:
  outSignature := [@L_signature empty] ;
  repeat
  while
    $??$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    $identifier$ ? * ;
  while
    $?!$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentInOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $!$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    $identifier$ ? * ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#            Parse type name and check it is defined                        *
#---------------------------------------------------------------------------*

rule <type_parsing>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType definitionType
  !@lstring outTypeName
:
  $type_name$ ? outTypeName ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
  extract entite->@typeEntiteType (?definitionType) error outTypeName : messageTypeEntite ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A S S I G N M E N T     I N S T R U C T I O N     idf := ... ;           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring inTargetVarName
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Get target entity infos
  @AC_galgasType targetVarType ;
  @typeCplusPlusName targetVarCppName ;
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?targetVarType ?targetVarCppName] ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !targetVarType !sourceType !here ;
#--- Generate instruction
  @typeInstruction instruction := [@C_assignmentInstruction new !targetVarCppName !sourceExpression] ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#        Liste d'arguments effectifs en entree : ( ?<entite dest> ? * ...)  *
#---------------------------------------------------------------------------*

rule <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
:
  @typeListeCibles listeCibles [empty] ;
  repeat
  while
    $?$ ;
    @typeCible typeEntiteDestination ;
    <target_entity> ?typeEntiteDestination !?ioVariablesMap ;
    listeCibles += !typeEntiteDestination ;
  end repeat ;
  @bool ellipsis ;
  select
    $...$ ;
    ellipsis := true ;
  or
    ellipsis := false ;
  end select ;
#--- Verifier la compatibilite des list et construire la list des affectations
  if [listeAttributsSemantiques length] < [listeCibles length] then
    error here : "too much arguments: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found" 
      -> outAllVariablesList, listeAffectationParametresEffectifs ;
  elsif ([listeAttributsSemantiques length] > [listeCibles length]) & not ellipsis then
    error here : "argument(s) missing: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found"
      -> outAllVariablesList, listeAffectationParametresEffectifs ;
  else
    listeAffectationParametresEffectifs := [@L_assignedVariables empty] ;
    outAllVariablesList := [@typeCplusPlusNameList empty] ;
    foreach listeAttributsSemantiques (??@AC_galgasType attTypeAttribut ??@lstring attNomAttribut),
            listeCibles (??@typeCible attCible) :
      @lstring nomAttributSource := attNomAttribut ;
      [attCible verifierType !attTypeAttribut !?nomAttributSource !?listeAffectationParametresEffectifs !?outAllVariablesList] ;
    end foreach ;
  end if ;
#--- Append Jojker if needed
  @typeCplusPlusName nullName := [@typeNullName new] ;
  action appendJokersIfNeeded
   !?outAllVariablesList
   ![listeCibles length]
   ![listeAttributsSemantiques length]
   !nullName
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <target_entity>
  !@typeCible typeEntiteDestination
  ?!@typeVariablesMap ioVariablesMap
:
  @lstring nomVariableDest ;
  $identifier$ ? nomVariableDest ;
  @AC_galgasType typeVarDest ;
  @typeCplusPlusName nomCppDest ;
  [!?ioVariablesMap searchForWriteAccess !nomVariableDest ?typeVarDest ?nomCppDest] ;
  typeEntiteDestination := [@typeEntiteDest new !typeVarDest !nomCppDest !here] ;
end rule ;

#---------------------------------------------------------------------------*

rule <target_entity>
  !@typeCible typeEntiteDestination
  ?!@typeVariablesMap unused ioVariablesMap
:
  $*$ ;
  typeEntiteDestination := [@typeJoker new] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   A D D    I N S T R U C T I O N                                          *
#                                                                           *
#  variable += !source_exp !... !source_exp ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $+=$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  @bool accept_uint_assignment ;
  [targetVariableType handleAddAssignOperatorCall !here ?formalParametersList ?accept_uint_assignment] ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList empty] ;
  @typeExpressionList expressionList [empty] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !?ioComponentSemanticsEntitiesMap
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList (??@AC_galgasType formalType ??@lstring formalName),
            typeList (??@AC_galgasType effectiveType ??@location kErrorLocation) :
      verifierCompatibiliteTypesSemantiques !formalType !effectiveType !kErrorLocation ;
    end foreach ;
  end if ;
  @typeInstruction instruction ;
  select
    $?$ ;
    @lstring uint_assigned_var ;
    $identifier$ ? uint_assigned_var ;
    if not accept_uint_assignment then
      error nomVarDest : "The type of target object does not accept '?' parameter" ;
    end if ;
    @AC_galgasType targetVariableType ;
    @typeCplusPlusName uint_assigned_cppVarName ;
    [!?ioVariablesMap searchForWriteAccess !uint_assigned_var ?targetVariableType ?uint_assigned_cppVarName] ;
    extract targetVariableType->@typeGalgas_uint () error uint_assigned_var : messageGalgasType ;
    instruction := [@typeAppendInstructionWithAssignment new !nomCppVariableSource !expressionList !uint_assigned_cppVarName] ;
  or
    instruction := [@typeAppendInstruction new !nomCppVariableSource !expressionList] ;
  end select ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   I N C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable ++ ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  $++$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the ++ operator ?
  [targetVariableType handleIncrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeIncrementInstruction new !nomCppVariableSource] ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#---------------------------------------------------------------------------*

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionsList ioInstructionsList
:
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?outExpressionList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
#--- Verifier la correction des arguments effectifs
  verifierCompatibiliteArgEffectifsSignature
    !listeTypesParametresFormels
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionsList
    !?outExpressionList
  ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#                          sans verification de type                        *
#---------------------------------------------------------------------------*

rule <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  outExpressionList := [@typeExpressionList empty] ;
  listeTypesParametresEffectifs := [@L_actualParametersSignature empty] ;
  repeat
  while
    $!$ ;
    @AC_galgasType expressionType ;
    @typeExpression expressionValue ;
    <expression>
      !?ioComponentSemanticsEntitiesMap
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expressionValue
      ?expressionType ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterOut] ;
    listeTypesParametresEffectifs += !expressionType !parameterPassingMode ;
    outExpressionList += !expressionValue ;
  while
    $?$ ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterIn] ;
    select
      $*$ ;
      @AC_galgasType typeArgument := [@typeGalgas_jokerInParameterList new] ;
      listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
      @typeExpression e := [@typeJokerInExpression new !here] ;
      outExpressionList += !e ;
    or
      @AC_galgasType typeArgument ;
      @typeCplusPlusName nomCppArgument ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      [!?ioVariablesMap searchForWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
      listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
      @typeExpression e := [@typeVarInExpression new !nomCppArgument] ;
      outExpressionList += !e ;
    end select ;
  while
    $!?$ ;
    @AC_galgasType typeArgument ;
    @typeCplusPlusName nomCppArgument ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    [!?ioVariablesMap searchForReadWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterOutIn] ;
    listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
    @typeExpression e := [@typeVarInExpression new !nomCppArgument] ;
    outExpressionList += !e ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SEMANTIQUES D'UNE METHODE             *
#---------------------------------------------------------------------------*

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  block ioVariablesMap.verifyVariableUsing () :
    <semantic_instructions_list_no_verif>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionsList
    ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      extract instruction                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
 $extract$ ;
#--- Source variable
  @AC_galgasType typeVarSource ;
  @typeCplusPlusName sourceVarCppName ;
  @lstring nomVarSource ;
  <read_access> ?nomVarSource ?sourceVarCppName ?typeVarSource !?ioVariablesMap ;
#--- Check variable has class type
  @lstring nomTypeSource ;
  @typeClassInheritedMessagesMap tableMessagesAbstraits ;
  extract typeVarSource->@typeGalgasClassType
           (?nomTypeSource ?* ?* ?* ?tableMessagesAbstraits ?* ?*)
           error nomVarSource : messageGalgasType ;
#--- Parse simple or structured extract instruction
  @typeInstruction instruction ;
  <extract_instruction>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    !sourceVarCppName
    !nomTypeSource
    !tableMessagesAbstraits
    ?instruction
  ;
  ioInstructionsList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#       Simple extract instruction                                          *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
:
#--- Nom de la classe pour la conversion
  $->$ ;
  @lstring nomClasse ;
  $type_name$ ? nomClasse ;
#--- Obtenir les caracteristiques de la classe nommee
  @AC_galgasType leType ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !nomClasse ?entite] ;
  extract entite->@typeEntiteType (?leType) error nomClasse : messageTypeEntite ;
  @typeListeAttributsSemantiques listeAttributsSemantiques ;
  @typeSuperClassesMap tableDesClassesAncetres ;
  extract leType->@typeGalgasClassType
               (?*
                ?*
                ?listeAttributsSemantiques
                ?tableDesClassesAncetres
                ?*
                ?*
                ?*)
             error nomClasse : messageGalgasType ;
#--- Verify class is an heir of variable type
  if not [tableDesClassesAncetres hasKey ![nomTypeSource value]] then
    error nomClasse : "This class does not inherit from '@" . [nomTypeSource value] . "'" ;
  end if ;
#--- Arguments
  @L_assignedVariables listeAffectationParametresEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  $($ ;
  <input_parameters_list>
    ?listeAffectationParametresEffectifs
    ?allVariablesList
    !listeAttributsSemantiques
    !?ioVariablesMap
  ;
  $)$ ;
#------------------------------------------------- Error message
  $error$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
  @lstring messageName ;
  $identifier$ ? messageName ;
  [!?tableMessagesAbstraits searchKey !messageName] ;
#------------------------------------------------- Generate instruction
  outInstruction := [@typeSimpleExtractInstruction new !inSourceVarCppName
                                                       !nomClasse
                                                       !listeAffectationParametresEffectifs
                                                       !errorExpression
                                                       !messageName] ;
end rule ;

#---------------------------------------------------------------------------*
#       Structured extract instruction                                      *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
:
  @typeStructuredExtractCasesList casesList [empty] ;
  $:$ ;
  $when$ ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @location indicatif1 := here ;
      #--- Nom du type 1
        @lstring nomType1 ;
        $type_name$ ? nomType1 ;
      #--- Verifier que la classe 'nomType1' est declaree
        @AC_galgasType definitionClasse1 ;
        @AC_semanticsEntity entite ;
        [!?ioComponentSemanticsEntitiesMap searchKey !nomType1 ?entite] ;
        extract entite->@typeEntiteType (?definitionClasse1) error nomType1 : messageTypeEntite ;
      #--- Verifier que la classe 'nomType1' herite de la classe 'nomTypeBase1'
        @typeSuperClassesMap tableDesClassesAncetresType1 ;
        @typeListeAttributsSemantiques listeAttributs1 ;
        extract definitionClasse1->@typeGalgasClassType
                  (?*
                   ?*
                   ?listeAttributs1
                   ?tableDesClassesAncetresType1
                   ?*
                   ?*
                   ?*)
              error nomType1 : messageGalgasType ;
      #--- Verify class is an heir of variable type
        if not [tableDesClassesAncetresType1 hasKey ![nomTypeSource value]] then
          error nomType1 : "This class does not inherit from '@" . [nomTypeSource value] . "'" ;
        end if ;
      #--- Arguments du type 1
        $($ ;
        @L_nameWithType elementsList [empty] ;
        @bool noUsedParameter := true ;
        repeat
        while
          $??$ ;
          @lstring typeName ;
          @lstring constantName ;
          select
            noUsedParameter := false ;
            $type_name$ ? typeName ;
            $identifier$ ? constantName ;
          or
            $*$ ;
            typeName := [@lstring new !"" !here] ;
            constantName := [@lstring new !"" !here] ;
          end select ;
          elementsList += ! typeName ! constantName ;
        end repeat ;
      #--- Ellipsis ?
        @bool ellipsisFound ;
        select
          ellipsisFound := false ;
        or
          $...$ ;
          ellipsisFound := true ;
        end select ;
        $)$ ;
        buildMapWithLocalConstants
          !elementsList
          !listeAttributs1
          !?ioVariablesMap
          !indicatif1
          ![@localConstantBuildStyleEnum listStyle]
          !ellipsisFound
        ;
      #--- Liste des instructions
        $->$ ;
        @typeInstructionsList instructionsList [empty] ;
        <semantic_instructions_list>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
        ;
        casesList += !nomType1 !indicatif1 !instructionsList !noUsedParameter ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  #---------------------  Default error -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionsList elseInstructionList [empty] ;
      <semantic_instructions_list>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elseInstructionList
      ;
      outInstruction := [@typeStructuredExtractInstructionWithElse new
        !inSourceVarCppName !casesList !elseInstructionList
      ] ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $extract$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# Local variable declaration                                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
#--- Type name
  @AC_galgasType definitionType ;
  @lstring typeName ;
  <type_parsing> !?ioComponentSemanticsEntitiesMap ?definitionType ?typeName ;
#--- Type can be used for instanciation ?
  [definitionType typeCanBeUsedInObjectDeclaration] ;
#--- Variable name
  @lstring nomVariable ;
  $identifier$ ? nomVariable ;
  @typeCplusPlusName nomCppVariable := [@typeAutomaticName new !nomVariable] ;
  [!?ioVariablesMap insertLocalVariable !nomVariable !definitionType !nomCppVariable] ;
#--- Assignment ?
  <optional_assignment>
    !typeName
    !nomVariable
    !nomCppVariable
    !definitionType
    !?ioVariablesMap
    !?ioInstructionsList
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction drop nomVariable, ... ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $drop$ ;
  <drop_instruction>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !?ioVariablesMap
    !?ioInstructionsList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <drop_instruction>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  repeat
    @lstring nom ;
    $identifier$ ? nom ;
    @typeCplusPlusName nomCppVar ;
    [!?ioVariablesMap searchForDestructiveReadAccess !nom ?* ?nomCppVar] ;
    @typeInstruction instruction := [@typeDropInstruction new !nomCppVar] ;
    ioInstructionsList += !instruction ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#            R O U T I N E    C A L L    I N S T R U C T I O N              *
#                                                                           *
#                          routine_name ... ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
#--- Verifier que le nom est bien un nom de routine
  @L_EXsignature signatureRoutine ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !nomVarDest ?entite] ;
  extract entite->@typeEntiteRoutine (?signatureRoutine) error nomVarDest : messageTypeEntite ;
#--- Arguments effectifs
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !signatureRoutine
    ?expressionsList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
    !?ioInstructionsList
  ;
#--- Generate instruction
  @typeInstruction instruction := [@typeRoutineCallInstruction new !nomVarDest !expressionsList] ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#           E X T E R N    C A L L    I N S T R U C T I O N                 *
#                                                                           *
#                         action extern_action ... ;                        *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
#--- Action name
  $action$ ;
  @lstring nomAction ;
  $identifier$ ? nomAction ;
#--- Search action in action map
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !nomAction ?entite] ;
  @L_EXsignature listeTypesParametresFormels ;
  extract entite->@typeEntiteActionExterne (?listeTypesParametresFormels) error nomAction : messageTypeEntite ;
#--- Check argument list types
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !listeTypesParametresFormels
    ?expressionsList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
    !?ioInstructionsList
  ;
  $;$ ;
#--- Generate instruction
  @typeInstruction instruction :=
        [@typeInstructionAppelActionExterne new !nomAction
                                               !expressionsList
                                               !listeTypesParametresFormels] ;

  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R E A D E R    C A L L   I N S T R U C T I O N                         *
#               [object reader_method !... !?... ?...] ;                    *
#                                                                           *
#    M O D I F I E R    C A L L   I N S T R U C T I O N                     *
#               [!?var modifier_method !... !?... ?...] ;                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $[$ ;
#--- Get source identity characteristics
  @typeInstruction instruction ;
  select
    @lstring variableName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    <read_access> ?variableName ?cppVariableName ?variableType !?ioVariablesMap ;
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    [variableType handleReaderInstructionCall !methodName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !?ioOptionsComponentsMapForUse
      !?ioComponentSemanticsEntitiesMap
      !?ioInstructionsList
    ;
  #--- Generate instruction
    instruction := [@typeReaderCallInstruction new !cppVariableName !methodName !expressionsList] ;
  or
    $!?$ ;
    @lstring variableName ;
    $identifier$ ? variableName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    [!?ioVariablesMap searchForReadWriteAccess !variableName ?variableType ?cppVariableName] ; 
  #--- Get method name
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    [variableType handleModifierCall !methodName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !?ioOptionsComponentsMapForUse
      !?ioComponentSemanticsEntitiesMap
      !?ioInstructionsList
    ;
  #--- Generate instruction
    instruction := [@typeModifierCallInstruction new !cppVariableName !methodName !expressionsList] ;
  end select ;
  ioInstructionsList += !instruction ;
  $]$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#             I N S T R U C T I O N   B E G I N N I N G                     *
#               W I T H    A N    I D E N T I F I E R                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  @lstring nomVarDest ;
  $identifier$ ? nomVarDest ;
  <instruction_beginning_with_identifier>
    !nomVarDest
    !?ioVariablesMap 
    !?ioInstructionsList
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'warning ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $warning$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Warning message
  @typeExpression warningMessageExpression ;
  @AC_galgasType warningMessageExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?warningMessageExpression
    ?warningMessageExpressionType
  ;
#--- Check that error message is a @string instance
  extract warningMessageExpressionType->@typeGalgas_string () error here : messageGalgasType ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeWarningInstruction new !errorExpression !warningMessageExpression] ;
  ioInstructionsList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           Instruction 'error ... ;'                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $error$ ;
  @typeExpression errorLocationExpression ;
  @AC_galgasType errorLocationExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorLocationExpression
    ?errorLocationExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Error message
  @typeExpression errorMessageExpression ;
  @AC_galgasType errorMessageExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorMessageExpression
    ?errorMessageExpressionType
  ;
#--- Check that error message is a @string instance
  extract errorMessageExpressionType->@typeGalgas_string () error here : messageGalgasType ;
#--- Build instruction and append it to instructions list
  @typeInstruction instruction := [@typeErrorInstruction new !errorLocationExpression !errorMessageExpression] ;
  ioInstructionsList += !instruction ;
#--- Valuations fictives
  select
  or
    $->$ ;
    repeat
      @lstring nomVariable ;
      $identifier$ ? nomVariable ;
      [!?ioVariablesMap searchForWriteAccess !nomVariable ?* ?*] ;
    while
      $,$ ;
   end repeat ;
  end select ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'message ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $message$ ;
#--- Message
  @typeExpression messageExpression ;
  @AC_galgasType messageExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?messageExpression
    ?messageExpressionType
  ;
#--- Check that error message is a @string instance
  extract messageExpressionType->@typeGalgas_string () error here : messageGalgasType ;
#--- Construire l'instruction
  @typeInstruction instruction := [@typeMessageInstruction new !messageExpression] ;
  ioInstructionsList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction 'if ... then ... elsif ... else ... end if ;'               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $if$ ;
  @L_expression_instructionsList_list listeBranchesTest [empty] ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @typeExpression testBranche ;
        @AC_galgasType resultType ;
        <expression>
          !?ioComponentSemanticsEntitiesMap
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          ?testBranche
          ?resultType
        ;
        extract resultType ->@typeGalgas_bool () error here : messageGalgasType ;
        $then$ ;
        @typeInstructionsList listeInstructionsBrancheTest [empty] ;
        <semantic_instructions_list_no_verif>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheTest
        ;
        listeBranchesTest += !testBranche !listeInstructionsBrancheTest ;
      end block (!here) ;
    while
      $elsif$ ;
    end repeat ;
    @typeInstructionsList listeInstructionsBrancheAutre [empty] ;
    block ioVariablesMap.testPart () :
      select
      or
        $else$ ;
        <semantic_instructions_list_no_verif>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheAutre
        ;
      end select ; 
    end block (!here) ;
    $end$ ;
    $if$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_if_instruction new !listeBranchesTest !listeInstructionsBrancheAutre] ;
  ioInstructionsList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    G R A M M A R    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $grammar$ ;
#--- Nom du fichier is
  @lstring grammarName ;
  $identifier$ ? grammarName ;
#--- Alt option ?
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $label$ ;
    $identifier$ ? altName ;
  end select ;
#--- Parse file name
  $in$ ;
  @lstring nomFichierSource ;
  @typeCplusPlusName nomCppFichierSource ;
  @AC_galgasType typeNomFichierSource ;
  <read_access> ?nomFichierSource ?nomCppFichierSource ?typeNomFichierSource !?ioVariablesMap ;
  extract typeNomFichierSource ->@typeGalgas_lstring () error nomFichierSource : messageGalgasType ;
#--- Analyse des arguments effectifs
  @typeExpressionList expressionsList ;
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?expressionsList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
#--- Look for grammar
  @AC_semanticsEntity entity  ;
  [!?ioComponentSemanticsEntitiesMap searchKey !grammarName ?entity] ;
  @M_nonterminalSymbolAlts startSymbolAltMap ;
  extract entity->@C_grammarForSemantics (?startSymbolAltMap) error grammarName : messageTypeEntite ;
  @L_EXsignature startSymbolSignature ;
  [!?startSymbolAltMap searchKey !altName ?startSymbolSignature] ;
#--- Verifier la coherence avec la declaration
  verifierCompatibiliteArgEffectifsSignature 
    !startSymbolSignature
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionsList
    !?expressionsList
  ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_grammarInstruction new !nomCppFichierSource
                                           !grammarName
                                           !expressionsList
                                           !altName] ;
  ioInstructionsList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     Instruction 'foreach ... ;'                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $foreach$ ;
  @typeInstruction instruction ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Parse enumerated variables
      @foreachEnumerationList foreachEnumerationList [empty] ;
      repeat
      #--- Enumerated variable
        @lstring variableName ;
        @typeCplusPlusName cppName ;
        @AC_galgasType variableType ;
        <read_access>
          ?variableName
          ?cppName
          ?variableType
          !?ioVariablesMap
        ;
      #--- Check this variable can be enumerated
        @typeListeAttributsSemantiques formalEnumerationList ;
        @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
        [variableType acceptForeachInstruction !variableName ?formalEnumerationList ?localConstantBuildStyleEnum] ;
      #--- Extract type name
        @string typeName ;
        [variableType getTypeName ?typeName] ;
      #--- Parse effective input attribute list
        @location magicNumber := here ;
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !formalEnumerationList
          !magicNumber
          !localConstantBuildStyleEnum
        ;
        foreachEnumerationList += !cppName !magicNumber !typeName ;
      while
        $,$ ;
      end repeat ;
    #--- While expression
      @typeExpression whileExpression ;
      select
        whileExpression := [@typeTrueBool new] ;
      or
        $while$ ;
        @AC_galgasType resultType ;
        <expression>
          !?ioComponentSemanticsEntitiesMap
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          ?whileExpression
          ?resultType
         ;
      end select ;
    #--- Repeated instruction list
      $:$ ;
    #--- Liste d'instructions
      @typeInstructionsList instructionList [empty] ;
      <semantic_instructions_list_no_verif>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList
      ;
    end block (!here) ;
  end block () ;
  instruction := [@typeForeachInstruction new
    !foreachEnumerationList
    !whileExpression
    !instructionList
  ] ;
  $end$ ;
  $foreach$ ;
  $;$ ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ' M A T C H '    I N S T R U C T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
:
  @lstring variableName ;
  @AC_galgasType type ;
  <read_access>
    ?variableName
    ?outCppName
    ?type
    !?ioVariablesMap
  ;
  outVarLocation := here ;
  extract type :
  when @typeGalgasClassType (??@lstring baseTypeName ??* ??* ??* ??* ??* ??*) ->
    outBaseTypeName := baseTypeName ;
    outIsEnumeration := false ;
    outEnumMessageMap := [@enumConstantMap empty] ;
  when @typeGalgas_enum (??@lstring typeName ??@enumConstantMap enumMessageMap ??*) ->
    outBaseTypeName := typeName ;
    outIsEnumeration := true ;
    outEnumMessageMap := enumMessageMap ;
  else
    @string actualTypeName ;
    [type getTypeName ?actualTypeName] ; 
    error variableName : "the type of this variable is '@" . actualTypeName
      . "' ; I was expected an enumeration type or an abstract type" 
      -> outBaseTypeName, outIsEnumeration, outEnumMessageMap ;
  end extract ;
end rule ;


#---------------------------------------------------------------------------*

rule <parse_match_case>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outTypeName
:
#--- Nom du type 1
  $type_name$ ? outTypeName ;
#--- Verifier que la classe 'outTypeName' est declaree
  @AC_galgasType definitionClasse1 ;
  @AC_semanticsEntity entite ;
  [!?ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
  extract entite->@typeEntiteType (?definitionClasse1) error outTypeName : messageTypeEntite ;
#--- Verifier que la classe 'outTypeName' herite de la classe 'baseTypeName1'
  @typeSuperClassesMap tableDesClassesAncetresType1 ;
  @typeListeAttributsSemantiques listeAttributs1 ;
  @bool isAbstract ;
  extract definitionClasse1->@typeGalgasClassType
                 (?*
                   ?*
                   ?listeAttributs1
                   ?tableDesClassesAncetresType1
                   ?*
                   ?*
                   ?isAbstract)
              error outTypeName : messageGalgasType ;
#--- Check class is not abstract
  if isAbstract then
    error outTypeName : "an abstract class is not allowed here" ;
  end if ;
#--- Verify class is an heir of variable type
  if inIsEnumeration then
    error outTypeName : "a constant of '@" . [inTypeName value] . "' enumeration type is expected here" ;
  elsif not [tableDesClassesAncetresType1 hasKey ![inTypeName value]] then
    error outTypeName : "This type does not inherit from '" . [inTypeName value] . "'" ;
  end if ;
#--- Arguments
  <parse_effective_input_parameters_list>
    !?ioVariablesMap
    !listeAttributs1
    !inVarLocation
    ![@localConstantBuildStyleEnum listStyle]
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_match_case>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap unused ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outEnumConstantName
:
#--- Enumeration constant
  $identifier$ ? outEnumConstantName ;
#--- Verify constant belongs to constants map
  if inIsEnumeration then
    [!?inEnumMessageMap searchKey !outEnumConstantName] ;
  else
    error outEnumConstantName : "a class that inherit from '@" . [inTypeName value] . "' abstract class is expected here" ;
  end if ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  $match$ ;
#--- Get first operand
  @typeCplusPlusName operand1_cppName ;
  @lstring operand1_typeName ;
  @location operand1_location ;
  @bool operand1_isEnumeration ;
  @enumConstantMap operand1_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand1_cppName
    ?operand1_typeName
    ?operand1_location
    ?operand1_isEnumeration
    ?operand1_enumMessageMap
  ;
#--- Get second operand
  $::$ ;
  @typeCplusPlusName operand2_cppName ;
  @lstring operand2_typeName ;
  @location operand2_location ;
  @bool operand2_isEnumeration ;
  @enumConstantMap operand2_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand2_cppName
    ?operand2_typeName
    ?operand2_location
    ?operand2_isEnumeration
    ?operand2_enumMessageMap
  ;
#---  Cases list
  $:$ ;
  @L_matchInstructionCasesList casesList [empty] ;
  block ioVariablesMap.testBloc () :
    repeat
    while
      $when$ ;
      block ioVariablesMap.testPart () :
        @lstring case1_name ;
      #--- First case 
       <parse_match_case>
          !?ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand1_typeName
          !operand1_location
          !operand1_isEnumeration
          !operand1_enumMessageMap
          ?case1_name
        ;
      #--- Separator
        $::$ ;
      #--- Second case
        @lstring case2_name ;
        <parse_match_case>
          !?ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand2_typeName
          !operand2_location
          !operand2_isEnumeration
          !operand2_enumMessageMap
          ?case2_name
        ;
      #--- Instructions list
        $:$ ;
        @typeInstructionsList instructionsList [empty] ;
        <semantic_instructions_list>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
        ;
        casesList += !case1_name !case2_name !instructionsList ;
      end block (!here) ;
    end repeat ;
  #---------------------  E L S E    P A R T -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionsList elsePartInstructionsList [empty] ;
      <semantic_instructions_list>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elsePartInstructionsList
      ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $match$ ;
  $;$ ;
#--- Insert instruction
  @typeInstruction instruction := [@typeMatchInstruction new !operand1_location
                                                             !operand2_location
                                                             !operand1_cppName
                                                             !operand2_cppName
                                                             !operand1_typeName
                                                             !operand2_typeName
                                                             !operand1_isEnumeration
                                                             !operand2_isEnumeration
                                                             !casesList
                                                             !elsePartInstructionsList] ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instructions_list_no_verif>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
:
  repeat
  while
    <semantic_instruction>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionsList
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                 Affection optionnelle dans une declaration                *
#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring unused nomVarDest
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  @typeInstruction instruction := [@typeInstructionDeclarationVarLocale new !inVariableCppName !inVariableType] ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $:=$ ;
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !inVariableType !sourceType !here ;
#--- Generate instruction
  @typeInstruction instruction := [@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !sourceExpression] ;
  ioInstructionsList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
  $[$ ;
#--- Class method name
  @lstring constructorName ;
  $identifier$ ? constructorName ;
  @typeListeAttributsSemantiques listeAttributsSemantiques ;
  [inVariableType handleConstructorCall !constructorName ?listeAttributsSemantiques] ;
#--- Actual arguments
  @typeExpressionList expressionList ;
  <output_expression_list>
    ?expressionList
    !listeAttributsSemantiques
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
  ;
  $]$ ;
#--- Generate instruction
  @typeExpression  e := [@typeConstructorExpression new !inTypeName !constructorName !expressionList] ;
  @typeInstruction i := [@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !e] ;
  ioInstructionsList += !i ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A P    T Y P E    D E C L A R A T I O N                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <parse_states>
  ?!@stateMap ioStateValues
  !@string outFirstStateName
  !@lastStateList outLastStateList
  !@transitionStatusMap  outTransitionStatusMap
:
#--- First state
  select
    $firststate$ ;
    @lstring firstStateName ;
    $identifier$ ? firstStateName ;
    [!?ioStateValues searchKey !firstStateName] ;
    outFirstStateName := [firstStateName value] ;
  or
    outFirstStateName := "" ;
    if [ioStateValues count] != 0 then 
      error here : "since you have declared states, you must define a first state" ;
    end if ;
  end select ;
#--- Transitions
  outTransitionStatusMap := [@transitionStatusMap  empty] ;
  repeat
  while
    $transition$ ;
    @lstring transitionName ;
    $identifier$ ? transitionName ;
    @lastStateEnum status ;
    @L_stringList messageList ;
    select
      status := [@lastStateEnum acceptedState] ;
      messageList := [@L_stringList empty] ;
    or
      $warning$ ;
      status := [@lastStateEnum warningState] ;
      <message_pattern> ? messageList ;
    or
      $error$ ;
      status := [@lastStateEnum errorState] ;
      <message_pattern> ? messageList ;
    end select ;
    [!?outTransitionStatusMap insertKey !transitionName !status !messageList] ;
  end repeat ;
#--- Last state(s)
  outLastStateList := [@lastStateList empty] ;
  repeat
  while
    $laststate$ ;
    @lstring lastStateName ;
    $identifier$ ? lastStateName ;
    [!?ioStateValues searchKey !lastStateName] ;
    @lastStateEnum status ;
    @L_stringList messageList ;
    select
      status := [@lastStateEnum acceptedState] ;
      messageList := [@L_stringList empty] ;
    or
      $warning$ ;
      status := [@lastStateEnum warningState] ;
      <message_pattern> ? messageList ;
    or
      $error$ ;
      status := [@lastStateEnum errorState] ;
      <message_pattern> ? messageList ;
    end select ;
    outLastStateList += !lastStateName !status !messageList ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    D E C L A R A T I O N                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapTypeName value]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName value]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [empty] ;
    @insertOrSearchMethodList searchMethodList [empty] ;
    @typeTableBlocsDeTable tableMethodesBloc [empty] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      @string emptyString := "" ;
      @lastStateList emptyLastStateList [empty] ;
      @transitionStatusMap  transitionStatusMap [empty] ;
      insertMethodList += !nomMethode ![errorMessage value] !emptyString !emptyLastStateList !transitionStatusMap !true ; # Last parameter has any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      @string emptyString := "" ;
      @lastStateList emptyLastStateList [empty] ;
      @transitionStatusMap  transitionStatusMap [empty] ;
      searchMethodList += !nomMethode ![errorMessage value] !emptyString !emptyLastStateList !transitionStatusMap !true ; # Last parameter has any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [empty] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [empty] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [empty] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [empty] ;
    @typeListModel attributeListModel [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapMethodMap mapMethodMap [empty] ;
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList (??@lstring kKey ...) :
    #--- Insert Methods
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !kKey !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature empty] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey value] . "GetIndex" ![kKey location]] ;
      [!?mapMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList (??@lstring kKey ...) :
   #--- insert method
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !kKey !methodSignature] ;
   #--- insert method GetIndex
      methodSignature := [@L_EXsignature empty] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey value] . "GetIndex" ![kKey location]] ;
      [!?mapMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new !mapTypeName
                                                !listeTousAttributsSemantiques
                                                !tableMethodesBloc
                                                !mapMethodMap] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@typeDefinitionTableAimplementer new !mapTypeName
                                                                       !listeTousAttributsSemantiques
                                                                       !listeTypeeAttributsExternesCourants
                                                                       !cppClassName
                                                                       !insertMethodList
                                                                       !searchMethodList
                                                                       !tableMethodesBloc] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  or
    ${$ ;
  #--- Parse Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [empty] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [empty] ;
    @typeListModel attributeListModel [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declare state enumeration values
    @stateMap stateValues [empty] ;
    select
    or
      $state$ ;
      repeat
        @lstring idf ;
        $identifier$ ? idf ;
        [!?stateValues insertKey !idf] ;
      while
        $,$ ;
      end repeat ;
      $;$ ; 
    end select ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [empty] ;
    @insertOrSearchMethodList searchMethodList [empty] ;
    @typeTableBlocsDeTable tableMethodesBloc [empty] ;
  #--- Build insert and search method map
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapMethodMap mapMethodMap [empty] ;
    repeat
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      action check_KL_escapeCharacters !errorMessage ;
      @string firstStateName ;
      @lastStateList emptyLastStateList ;
      @transitionStatusMap  transitionStatusMap [empty] ;
      <parse_states> !?stateValues ?firstStateName ?emptyLastStateList ?transitionStatusMap  ;
      $;$ ;
    #--- Insert method
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !methodName !methodSignature] ;
      insertMethodList += !methodName ![errorMessage value] !firstStateName !emptyLastStateList !transitionStatusMap !false ;
   #-- Insert And Get Index Method
      if [getIndexMethodName value] != "" then
        @L_EXsignature getIndexMethodSignature [empty] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !inPassingMode ;      
        end foreach ;
        [!?mapMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        insertMethodList += !getIndexMethodName ![errorMessage value] !firstStateName !emptyLastStateList !transitionStatusMap !true ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      action check_K_escapeCharacters !errorMessage ;
      @string firstStateName ;
      @lastStateList emptyLastStateList ;
      @transitionStatusMap  transitionStatusMap [empty] ;
      <parse_states> !?stateValues ?firstStateName ?emptyLastStateList ?transitionStatusMap;
      $;$ ;
    #--- Insert search method in modifier map
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !methodName !methodSignature] ;
      searchMethodList += !methodName ![errorMessage value] !firstStateName !emptyLastStateList !transitionStatusMap !false ;
    #--- Insert 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName value] != "" then
        @L_EXsignature getIndexMethodSignature [empty] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
         getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        searchMethodList += !getIndexMethodName ![errorMessage value] !firstStateName !emptyLastStateList !transitionStatusMap !true ;
      end if ;
    end repeat ;
  #--- Check that insert method transition names correspond to search methods
    if [stateValues count] > 0 then
      foreach insertMethodList (??@lstring kInsertMethod ??* ??* ??* ??@transitionStatusMap kTransitionStatusMap ...) :
        foreach insertMethodList (??@lstring kSearchMethod ...) :
          if not [kTransitionStatusMap hasKey ![kSearchMethod value]] then
            error kInsertMethod : "This insert method does not define the '" . [kSearchMethod value] . "' transition" ;
          end if ;
        end foreach ;
      end foreach ;
    end if ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new !mapTypeName
                                                !listeTousAttributsSemantiques
                                                !tableMethodesBloc
                                                !mapMethodMap] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@C_mapToImplement new !stateValues
                                                        !mapTypeName
                                                        !listeTousAttributsSemantiques
                                                        !listeTypeeAttributsExternesCourants
                                                        !insertMethodList
                                                        !searchMethodList] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not([tableEnAvant hasKey ![mapTypeName value]] | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName value]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [empty] ;
    @insertOrSearchMethodList searchMethodList [empty] ;
    @typeTableBlocsDeTable tableMethodesBloc [empty] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      @string emptyString := "" ;
      @lastStateList emptyLastStateList [empty] ;
      @transitionStatusMap  transitionStatusMap [empty] ;
      insertMethodList += !nomMethode ![errorMessage value] !emptyString !emptyLastStateList !transitionStatusMap !true ; #last parameter can have any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      @string emptyString := "" ;
      @lastStateList emptyLastStateList [empty] ;
      @transitionStatusMap  transitionStatusMap [empty] ;
      searchMethodList += !nomMethode ![errorMessage value] !emptyString !emptyLastStateList !transitionStatusMap !true ; #last parameter can have any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [empty] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [empty] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [empty] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [empty] ;
    @typeListModel attributeListModel [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapMethodMap mapMethodMap [empty] ;
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList (??@lstring kKey ...) :
    #--- Insert Methods
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !kKey !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature empty] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey value] . "GetIndex" ![kKey location]] ;
      [!?mapMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList (??@lstring kKey ...) :
    #--- Search Methods
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !kKey !methodSignature] ;
    #--- Search Get Index Methods
      methodSignature := [@L_EXsignature empty] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey value] . "GetIndex" ![kKey location]] ;
      [!?mapMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new !mapTypeName
                                                !listeTousAttributsSemantiques
                                                !tableMethodesBloc
                                                !mapMethodMap] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  or
    ${$ ;
  #--- Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [empty] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [empty] ;
    @typeListModel attributeListModel [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- States
    select
    or
      $state$ ;
      repeat
        $identifier$ ? * ;
      while
        $,$ ;
      end repeat ;
      $;$ ; 
    end select ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @typeTableBlocsDeTable tableMethodesBloc [empty] ;
  #--- Build insert and search method map
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapMethodMap mapMethodMap [empty] ;
    repeat
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      <parse_states> parse ;
      $;$ ;
    #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'GetIndex' insert method in modifier map (if any)
      if [getIndexMethodName value] != "" then
        @L_EXsignature getIndexMethodSignature [empty] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !inPassingMode ;      
        end foreach ;
        [!?mapMethodMap insertKey !getIndexMethodName ! getIndexMethodSignature] ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      <parse_states> parse ;
      $;$ ;
    #--- Enter search method in modifier map
      @L_EXsignature methodSignature [empty] ;
      methodSignature += !lstringType !inPassingMode ; # Key
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName value] != "" then
        @L_EXsignature getIndexMethodSignature := [@L_EXsignature empty] ;
        getIndexMethodSignature += !lstringType !inPassingMode ; # Key
        getIndexMethodSignature += !luintType !outPassingMode ; # Returned Index
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
      end if ;
    end repeat ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new !mapTypeName
                                                !listeTousAttributsSemantiques
                                                !tableMethodesBloc
                                                !mapMethodMap] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
:
  $identifier$ ? nomMethode ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*

rule <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
:
  $identifier$ ?methodName ;
  select
    getIndexMethodName := [@lstring new !"" !here] ;
  or
    $,$ ;
    $identifier$ ?getIndexMethodName ;
  end select ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*

rule <message_pattern>
  !@L_stringList outMessageList
:
  outMessageList := [@L_stringList empty] ;
  repeat
    select
      @lstring messageText ;
      $literal_string$ ? messageText ;
      if [messageText value] != "" then
        outMessageList += ![messageText value] ;
      end if ;
    or
      $*$ ;
      outMessageList += !"" ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     L I S T   T Y P E   D E C L A R A T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName value]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName value]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [empty] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [empty] ;
    @typeListModel attributeListModel [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new ! listTypeName !listeTousAttributsSemantiques] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @typeEntityToGenerate def := [@C_listTypeToImplement new !listTypeName !listeTousAttributsSemantiques !listeTypeeAttributsExternesCourants] ;
    listeEntitesAengendrer += !def ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName value]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName value]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListModel attributeListModel [empty] ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [empty] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [empty] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new ! listTypeName !listeTousAttributsSemantiques] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @TypeModel t := [@ListModel new !attributeListModel] ;
    [!?ioModelMap insertKey !listTypeName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                 LISTE DE DEFINITION DES ATTRIBUTS SEMANTIQUES             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <attributes_definition_list>
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  !@L_nameWithType listeTypeeAttributsExternesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  listeTypeeAttributsExternesCourants := [@L_nameWithType empty] ;
  listeAttributsSemantiquesCourants := [@typeListeAttributsSemantiques empty] ;
  outAttributeListModel := [@typeListModel empty] ;
  repeat
  while
  #--- Type name
    @AC_galgasType definitionType ;
    @lstring typeName ;
    <type_parsing>
      !?ioComponentSemanticsEntitiesMap
      ?definitionType
      ?typeName
     ;
  #--- Type can be used for instanciation ?
    [definitionType typeCanBeUsedInObjectDeclaration] ;
  #--- Formal argument
    @lstring attributeName ;
    $identifier$ ? attributeName ;
    [!?tableAttributs insertKey ! attributeName !definitionType] ;
    listeTousAttributsSemantiques += !definitionType ! attributeName ;
    listeAttributsSemantiquesCourants += !definitionType ! attributeName ;
    outAttributeListModel += !typeName ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     E X T E R N   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $extern$ ;
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
  $:$ ;
#--- Parse C++ class name
  $class$ ;
  @lstring cppClassName ;
  $identifier$ ? cppClassName ;
  $in$ ;
  @lstring path ;
  $literal_string$ ? path ; 
  $;$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes modifiersMap [empty] ;
  @typeTableMethodes readersInInstructionMap [empty] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [empty] ;
  @M_externTypeConstructorMap constructorsMap [empty] ;
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [empty] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !?ioComponentSemanticsEntitiesMap
        ?type_semantique
        !?tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
    end repeat ;
    $;$ ;
    [!?constructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
  while
    $reader$ ;
  #--- Method name
    @lstring methodName ;
    $identifier$ ? methodName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [empty] ;
    @L_signature signatureForGrammarComponent ; # Not used here
    <formal_arguments_list>
      !?ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent
    ;
    $;$ ;
    [!?readersInInstructionMap insertNotAbstract !methodName !listeDeTypes] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring methodName ;
      $identifier$ ? methodName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [empty] ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      [!?modifiersMap insertNotAbstract !methodName !listeDeTypes] ;
    or
      $+=$ ;
      @location errorLocation := here ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ; # Not used here
        <formal_argument_type>
          !?ioComponentSemanticsEntitiesMap
          ?type_semantique
          !?tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
      end repeat ;
      if acceptAddAssignOperatorCall then
        error errorLocation : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
    end select ;
    $;$ ;
  end repeat ;
#--- enter the new type into the list of entities to be generated
  @typeEntityToGenerate t := [@typeExternTypeToGenerate new !externTypeName !cppClassName !path] ;
  listeEntitesAengendrer += !t ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new !externTypeName
                                                 !cppClassName
                                                 !constructorsMap
                                                 !modifiersMap
                                                 !readersInInstructionMap
                                                 !acceptAddAssignOperatorCall
                                                 !addAssignOperatorCallTypeList] ;
  @AC_semanticsEntity entity := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !entity] ;
  $end$ ;
  $extern$ ;
  $;$ ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $extern$ ;
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
  $:$ ;
#--- Parse C++ class name
  $class$ ;
  @lstring cppClassName ;
  $identifier$ ? cppClassName ;
  $in$ ;
  $literal_string$ ? * ; 
  $;$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes EXmodifiersMap [empty] ;
  @typeTableMethodes readersInInstructionMap [empty] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [empty] ;
  @M_externTypeConstructorMap EXconstructorsMap [empty] ;
  @constructorMap constructorMap [empty] ;
  @readerMap readerMap [empty] ;
  @modifierMap modifierMap [empty] ;
  @typeListModel addAssignFormalInputArgumentList [empty] ; # List is empty if += operator is not defined
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [empty] ;
    @typeListModel formalInputArgumentList [empty] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !?ioComponentSemanticsEntitiesMap
        ?type_semantique
        !?tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
      formalInputArgumentList += !galgasTypeName ;
    end repeat ;
    $;$ ;
    [!?EXconstructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
    [!?constructorMap insertKey !constructorName ! formalInputArgumentList] ;
  while
    $reader$ ;
  #--- Reader name
    @lstring readerName ;
    $identifier$ ? readerName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [empty] ;
    @L_signature signature ;
    <formal_arguments_list>
      !?ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signature
    ;
    $;$ ;
    [!?readersInInstructionMap insertNotAbstract ! readerName !listeDeTypes] ;
    [!?readerMap insertKey !readerName !signature] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring modifierName ;
      $identifier$ ? modifierName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [empty] ;
      @L_signature signature ;
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signature
      ;
      [!?EXmodifiersMap insertNotAbstract ! modifierName !listeDeTypes] ;
      [!?modifierMap insertKey !modifierName !signature] ;
    or
      $+=$ ;
      if [addAssignFormalInputArgumentList length] > 0 then
        error here : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ;
        <formal_argument_type>
          !?ioComponentSemanticsEntitiesMap
          ?type_semantique
          !?tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
        addAssignFormalInputArgumentList += !galgasTypeName ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new !externTypeName
                                                 !cppClassName
                                                 !EXconstructorsMap
                                                 !EXmodifiersMap
                                                 !readersInInstructionMap
                                                 !acceptAddAssignOperatorCall
                                                 !addAssignOperatorCallTypeList] ;
  @AC_semanticsEntity entity := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !entity] ;
  @TypeModel t := [@ExternTypeModel new !constructorMap !readerMap !modifierMap !addAssignFormalInputArgumentList] ;
  [!? ioModelMap insertKey !externTypeName !t] ;
  $end$ ;
  $extern$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                            Type d'un argument                             *
#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName value]] then
    @AC_semanticsEntity entite ;
    [!?ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [!?tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName value]] then
    @AC_semanticsEntity entite ;
    [!?ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [!?tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    extract type_semantique->@typeGalgasUndefinedListType (?*) error outGalgasTypeName : messageGalgasType ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName value]] then
    @AC_semanticsEntity entite ;
    [!?ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [!?tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    extract type_semantique->@typeGalgasUndefinedMapType (?*) error outGalgasTypeName : messageGalgasType ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName value]] then
    @AC_semanticsEntity entite ;
    [!?ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [!?tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    extract type_semantique->@typeGalgasUndefinedClassType (?*) error outGalgasTypeName : messageGalgasType ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                   DECLARATION D'UNE ACTION EXTERNE                        *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $action$ ;
  @lstring nomAction ;
  $identifier$ ?nomAction ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [empty] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ; # Not used here
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  @AC_semanticsEntity entite := [@typeEntiteActionExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !nomAction !entite] ;
  @typeEntityToGenerate ea := [@typeActionExterneAengendrer new !nomAction !listeDeTypes] ;
  listeEntitesAengendrer += !ea ;
  $;$ ;    
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $action$ ;
  @lstring actionName ;
  $identifier$ ? actionName ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [empty] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signature ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;
  @AC_semanticsEntity entite := [@typeEntiteActionExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ! actionName !entite] ;
  [!?ioExternActionMap insertKey !actionName !signature !true] ;
  $;$ ;    
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [empty] ;
#--- Messages map
  @typeEnumMessageMap enumMessageMap [empty] ;
  repeat
    @lstring constantName ;
    $identifier$ ? constantName ;
    [!?constantMap insertKey !constantName] ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
#--- Enum messages
  repeat
  while
    $message$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
    $:$ ;
    @typeEnumCstMessageStringMap cstMessageStringMap [empty] ;
    repeat
      @lstring cstName ;
      $identifier$ ? cstName ;
      $->$ ;
      @lstring cstString ;
      $literal_string$ ? cstString ;
      [!?cstMessageStringMap insertKey !cstName !cstString] ;
      $;$ ;
    while
    end repeat ;
    $end$ ;
  #--- Build message string list
    @L_lstringList messageStringList [empty] ;
    foreach constantMap (??@lstring constantName) :
      @lstring name := [@lstring new ![constantName value] !here] ; #--- For best error location
      @lstring cstString ;
      [!?cstMessageStringMap searchKey !name ?cstString] ;
      messageStringList += !cstString ;
    end foreach ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName !messageStringList] ;
    $message$ ;
    $;$ ;
  end repeat ;
#--- End type definition end
  $}$ ;
#---- Enter enum datas into the list of entities to generate
  @typeEntityToGenerate e := [@enumGalgasType new !enumTypeName !constantMap !enumMessageMap] ;
  listeEntitesAengendrer += !e ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new !enumTypeName !constantMap !enumMessageMap] ;
  @AC_semanticsEntity entity := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !entity] ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [empty] ;
  repeat
    @lstring constantName ;
    $identifier$ ? constantName ;
    [!?constantMap insertKey !constantName] ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
#--- Messages map
  @typeEnumMessageMap exEnumMessageMap [empty] ;
  @enumMessageMap enumMessageMap [empty] ;
  repeat
  while
    $message$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName] ;
    @L_lstringList messageStringList [empty] ;
    [!? exEnumMessageMap insertKey !messageName !messageStringList] ;
    $:$ ;
    repeat
      $identifier$ ? * ;
      $->$ ;
      $literal_string$ ? * ;
      $;$ ;
    while
    end repeat ;
    $end$ ;
    $message$ ;
    $;$ ;
  end repeat ;
  $}$ ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new !enumTypeName !constantMap !exEnumMessageMap] ;
  @AC_semanticsEntity e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !e] ;
  @TypeModel type := [@EnumModel new !constantMap !enumMessageMap] ;
  [!?ioModelMap insertKey !enumTypeName !type] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
