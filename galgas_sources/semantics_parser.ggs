#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component parser definition                             *
#                                                                           *
#  Copyright (C) 1997-2004 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax semantics_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#---------------------------------------------------------------------------*
#                                                                           *
#          Rules prototypes                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label parse
;

rule <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
label parse
;

rule <attributes_definition_list>
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  !@L_nameWithType listeTypeeAttributsExternesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <type_parsing>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType definitionType
  !@lstring outTypeName
label parse
;

rule <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@M_optionComponents ioOptionsComponentsMapForUse
label parse
;

rule <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool estAbstraite
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
label parse
;

rule <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
label parse
;

rule <abstract_method>
  ?!@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
label parse
;

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

rule <semantic_instructions_list_no_verif>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

rule <extract_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

rule <expression>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

rule <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

rule <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <target_entity>
  !@typeCible typeEntiteDestination
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <read_access>
  !@lstring nomAttribut
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring nomVarDest
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

rule <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
label parse
;

rule <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
label parse
;

rule <message_pattern>
  !@L_stringList outMessageList
label parse
;

rule <formal_arguments_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

rule <output_expression_list>
  !@typeExpressionList outExpressionList 
  ??@typeListeAttributsSemantiques inAttributesList
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
label parse
;

rule <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
label parse
;

rule <parse_match_case>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outTypeName
label parse
;

rule <parse_effective_input_parameters_list>
  ?!@typeVariablesMap ioVariablesMap
  ?@typeListeAttributsSemantiques inFormalArgumentsList
  ?@location inVarLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  !@bool outNoUsedParameter
label parse
;

action buildFileNameWithPath
  !@lstring outFileNameWithPath
  ?@lstring inPath
  ??@lstring inCppClassName
  ??@lstring inExtension
;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C S    C O M P O N E N T                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  $semantics$ ;
#--- Obtenir le nom du component semantique
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
#--- No lexique
  @string defLexique := "" ;
#--- Import semantics
  @ModelMap modelMap [emptyMap] ;
  @ActionMap actionMap [emptyMap] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @M_semanticsEntitiesForUse componentEntitiesMap ;
  @stringset classNamesSet [emptySet] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedGrammarComponents ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedMetamodelComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?ioSemanticsComponentsMap
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMapForUse
    ?modelMap
    ?actionMap

    ?componentEntitiesMap
    ?tableEnAvant
  ;
#-------------- Semantic Declarations
  parse
  #--- First pass on semantic declarations
  do
    @typeTableRoutinesAimplementer UNUSED_tableRoutinesAimplementer [emptyMap] ;
    @typeTableNomRoutinesDeclarees UNUSED_tableNomRoutinesDeclarees [emptyMap] ;
    @typeTableEnAvant UNUSED_tableEnAvant := tableEnAvant ;
    @M_semanticsEntitiesForUse UNUSED_componentSemanticsEntitiesMap := componentEntitiesMap ;
    repeat
    while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap
      !?UNUSED_componentSemanticsEntitiesMap
      !?UNUSED_tableNomRoutinesDeclarees
      !?UNUSED_tableEnAvant
      !?UNUSED_tableRoutinesAimplementer
    ;
    end repeat ;
  #--- Second pass on semantic declarations
  rewind
    @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
    @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    repeat
    while
      <semantics_declaration>
        !?componentEntitiesMap
        !?listeEntitesAengendrer
        !?optionsComponentsMapForUse
        !?tableNomRoutinesDeclarees
        !?tableEnAvant
        !?tableRoutinesAimplementer
      ; 
    end repeat ;
  end parse ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName string]] then
    @M_optionComponents optionsComponentsMap [emptyMap] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedMetamodelComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentEntitiesMap
    ] ;
  end if ;
#--- End of file
  $end$ ;
  $semantics$ ;
  $;$ ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees (??@lstring nomRoutine) :
    if not [tableRoutinesAimplementer hasKey ![nomRoutine string]] then
      error nomRoutine : "the routine '" . [nomRoutine string] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Generate component
  action generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
   ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  $semantics$ ;
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap ;
  enterBuiltinTypes ?componentSemanticsEntitiesMap ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents [emptySet] ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;

  <import_headers_semantics_and_grammars> importSemantics
    !?ioSemanticsComponentsMap
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?modelMap
    ?actionMap
    !?componentSemanticsEntitiesMap
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  repeat
  while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap

      !?componentSemanticsEntitiesMap
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
    ;
  end repeat ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName string]] then
    @M_optionComponents optionsComponentsMap [emptyMap] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedMetamodelComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentSemanticsEntitiesMap
    ] ;
  end if ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# I M P O R T  H E A D E R S,  S E M A N T I C S  A N D  G R A M M A R S    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <import_headers_semantics_and_grammars>
  !@stringset outImportedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outImportedOptionComponents
  !@stringset outImportedGrammarComponents
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
:
  outActionMap := [@ActionMap emptyMap] ;
  outInclusionsForHeaderFile := [@stringset emptySet] ;
  outInclusionsForImplementationFile := [@stringset emptySet] ;
  outImportedSemanticsComponents := [@stringset emptySet] ;
  outIncludedMetamodelComponents := [@stringset emptySet] ;
  outImportedOptionComponents := [@stringset emptySet] ;
  outImportedGrammarComponents := [@stringset emptySet] ;
  tableEnAvant := [@typeTableEnAvant emptyMap] ;
  ioOptionsComponentsMapForUse := [@M_optionComponents emptyMap] ;
#--- Create model map, and enter builtin types
  outModelMap := [@ModelMap emptyMap] ;

  [!?outModelMap insertKey ![@lstring new !"char" ! here] ![@CharModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"string" ! here] ![@StringModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"uint" ! here] ![@UIntModel new]] ;
 
  [!?outModelMap insertKey ![@lstring new !"sint" ! here] ![@SIntModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"uint64" ! here] ![@UInt64Model new]] ;
 
  [!?outModelMap insertKey ![@lstring new !"sint64" ! here] ![@SInt64Model new]] ;

  [!?outModelMap insertKey ![@lstring new !"bool" ! here] ![@BoolModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"double" ! here] ![@DoubleModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"lchar" ! here] ![@LCharModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"lstring" ! here] ![@LStringModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"luint" ! here] ![@LUIntModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"lsint" ! here] ![@LSIntModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"luint64" ! here] ![@LUInt64Model new] ] ;

  [!?outModelMap insertKey ![@lstring new !"lsint64" ! here] ![@LSInt64Model new]] ;

  [!?outModelMap insertKey ![@lstring new !"lbool" ! here] ![@LBoolModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"ldouble" ! here] ![@LDoubleModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"location" ! here] ![@LocationModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"stringset" ! here] ![@StringsetModel new]] ;
#--- enter in semantics entities map the galgas types corresponding to keywords
  enterBuiltinTypes ?ioComponentSemanticsEntitiesMap ;
  @stringset alreadyImportedSemanticsComponents [emptySet] ;
  @stringset alreadyImportedMetamodelComponents [emptySet] ;
#--- Loop on import instructions
  repeat
  while
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outImportedOptionComponents += ![optionComponentName string] ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [emptyMap] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      [!?ioOptionsComponentsMapForUse insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
    or
      $grammar$ ;
      @lstring grammarComponentName ;
      $identifier$ ? grammarComponentName ;
      outImportedGrammarComponents += ![grammarComponentName string] ;
      @M_grammarComponents grammarComponentsMap ;
      select
        grammarComponentsMap := ioGrammarComponentsMap ;
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ? sourceFile ;
        grammarComponentsMap := [@M_grammarComponents emptyMap] ;
        <parse_grammar_component_for_importing> 
          !sourceFile
          !?grammarComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap ;
      [grammarComponentsMap searchKey !grammarComponentName ?nonterminalSymbolParametersMap ?* ?*] ;
      @M_nonterminalSymbolAlts grammarAltMap [emptyMap] ;
      foreach nonterminalSymbolParametersMap (??@lstring altName ??@L_signature signature ??@lstring kReturnedEntity) :
        @L_EXsignature formalParametersList [emptyList] ;
        foreach signature (??@formalArgumentPassingMode passingMode ??@lstring typeName) :
          @AC_semanticsEntity e ;
          [ioComponentSemanticsEntitiesMap searchKey !typeName ?e] ;
          @AC_galgasType type ;
          extract e->@typeEntiteType (?type) error typeName : messageTypeEntite ;
          formalParametersList += !type !passingMode ;
        end foreach ;
        [!?grammarAltMap insertKey !altName !formalParametersList !kReturnedEntity] ;
      end foreach ;
      @AC_semanticsEntity e := [@C_grammarForSemantics new !grammarAltMap] ;
      [!?ioComponentSemanticsEntitiesMap insertKey !grammarComponentName !e] ;
      @lstring path := [@lstring new !"" !here] ;
      @lstring extension := [@lstring new !"h" !here] ;
      @lstring fileNameWithPath ;
      action buildFileNameWithPath ?fileNameWithPath !path !grammarComponentName !extension ;
      outInclusionsForImplementationFile += ![fileNameWithPath string] ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      if not [outImportedSemanticsComponents hasKey ![componentName string]] then
        @M_semanticsEntitiesForUse importedEntities ;
        @M_optionComponents importedOptionsComponentsMap ;
        [ioSemanticsComponentsMap searchKey !componentName ?* ?* ?* ?* ?* ?importedOptionsComponentsMap ?importedEntities] ;
        foreach importedEntities (??@lstring entityName ??@AC_semanticsEntity entityType) :
          if not [ioComponentSemanticsEntitiesMap hasKey ![entityName string]] then
            [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
          end if ;
        end foreach ;
        outInclusionsForHeaderFile += ![componentName string] ;
      #--- Check that every used option component is already declared
        foreach importedOptionsComponentsMap (??@lstring optionComponentMap ...) :
          if not [ioOptionsComponentsMapForUse hasKey ![optionComponentMap string]] then
            error here: "the '" . [optionComponentMap string] . "' option component must have been imported" ;
          end if ;
        end foreach ;
      end if ;
    #--- Import semantics component
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioMetamodelComponentMap
        !?outModelMap
        !?outActionMap
        !?alreadyImportedSemanticsComponents
        !?alreadyImportedMetamodelComponents
        !componentName
      ;
    #---
      outInclusionsForHeaderFile += ![componentName string] ;
      outImportedSemanticsComponents += ![componentName string] ;
    or
      $metamodel$ ;
      @lstring metamodelComponentName ;
      $identifier$ ? metamodelComponentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      if not [outIncludedMetamodelComponents hasKey ![metamodelComponentName string]] then
        @M_semanticsEntitiesForUse importedEntities ;
        [ioMetamodelComponentMap searchKey !metamodelComponentName ?* ?importedEntities ?* ?*] ;
        foreach importedEntities (??@lstring entityName ??@AC_semanticsEntity entityType) :
          if not [ioComponentSemanticsEntitiesMap hasKey ![entityName string]] then
            [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
          end if ;
        end foreach ;
        outInclusionsForHeaderFile += ![metamodelComponentName string] ;
      end if ;
    #---
      outInclusionsForHeaderFile += ![metamodelComponentName string] ;
      outIncludedMetamodelComponents += ![metamodelComponentName string] ;
    end select ;
    $;$ ;
  end repeat ;
#--- Check that every option component used by an imported component is declared here

label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  outActionMap := [@ActionMap emptyMap] ;
  outModelMap := [@ModelMap emptyMap] ;
  outIncludedSemanticsComponents := [@stringset emptySet] ;
  outIncludedOptionComponents := [@stringset emptySet] ;
  @stringset alreadyImportedSemanticsComponents [emptySet] ;
  @stringset alreadyImportedMetamodelComponents [emptySet] ;
  repeat
  while
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outIncludedOptionComponents += ![optionComponentName string] ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
     end select ;
    or
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_grammar_component_for_importing> parse ;
      end select ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      outIncludedSemanticsComponents += ![componentName string] ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ? sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      @M_semanticsEntitiesForUse importedEntities ;
      [ioSemanticsComponentsMap searchKey !componentName ?* ?* ?* ?* ?* ?* ?importedEntities] ;
      foreach importedEntities (??@lstring entityName ??@AC_semanticsEntity entityType) :
        if not [ioComponentSemanticsEntitiesMap hasKey ![entityName string]] then
          [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
        end if ;
      end foreach ;
    #--- Import semantics component
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioMetamodelComponentMap
        !?outModelMap
        !?outActionMap
        !?alreadyImportedSemanticsComponents
        !?alreadyImportedMetamodelComponents
        !componentName
      ;
    or
      $metamodel$ ;
      @lstring metamodelComponentName ;
      $identifier$ ?metamodelComponentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      @M_semanticsEntitiesForUse importedEntities ;
      [ioMetamodelComponentMap searchKey !metamodelComponentName ?* ?importedEntities ?* ?*] ;
      foreach importedEntities (??@lstring entityName ??@AC_semanticsEntity entityType) :
        if not [ioComponentSemanticsEntitiesMap hasKey ![entityName string]] then
          [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
        end if ;
      end foreach ;
    end select ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  R O U T I N E    D E C L A R A T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @L_EXsignature listeDeTypesPrecedenteDeclaration ;
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    extract entite->@typeEntiteRoutine (?listeDeTypesPrecedenteDeclaration) error routineName : messageTypeEntite ;
    verifierCompatibiliteSignatures
      !listeDeTypesPrecedenteDeclaration
      !listeDeTypes
      !here
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey ! routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionList ioInstructionList [emptyList] ;
    @entityPropertyMap propertyMap [emptyMap] ;
    @stringset constraintPropertyDefinitionSet [emptySet] ;
    @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
    <semantic_instructions_list>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?tableArgumentsMethode
      !?ioInstructionList
      !?propertyMap
      !?constraintPropertyDefinitionSet
      !?callInstructionSharedPropertySignatureMap
    ;
    $end$ ;
    $routine$ ;
    $;$ ;
  #--- Inserer la routine dans la map des routines a implementer
    @typeEntityToGenerate ea := [@typeRoutineAengendrer new ! routineName
                                                              !listeTypeEtNomsArguments
                                                              !ioInstructionList] ;
    listeEntitesAengendrer += !ea ;
    [!?tableRoutinesAimplementer insertKey ! routineName] ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signature ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ? signature
  ;
  [!?ioExternActionMap insertKey !routineName !signature !false] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @L_EXsignature listeDeTypesPrecedenteDeclaration ;
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    extract entite->@typeEntiteRoutine (?listeDeTypesPrecedenteDeclaration) error routineName : messageTypeEntite ;
    verifierCompatibiliteSignatures
      !listeDeTypesPrecedenteDeclaration
      !listeDeTypes
      !here
    ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey ! routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionList ioInstructionList [emptyList] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    @entityPropertyMap propertyMap [emptyMap] ;
    @stringset constraintPropertyDefinitionSet [emptySet] ;
    @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
    <semantic_instructions_list>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?optionsComponentsMapForUse
      !?tableArgumentsMethode
      !?ioInstructionList
      !?propertyMap
      !?constraintPropertyDefinitionSet
      !?callInstructionSharedPropertySignatureMap
    ;
    $end$ ;
    $routine$ ;
    $;$ ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                        ANALYSE D'UNE CLASSE MERE                          *
#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  tableDesClassesAncetres := [@typeSuperClassesMap emptyMap] ;
  tableDesMethodes := [@typeTableMethodes emptyMap] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap emptyMap] ;
  tableAttributs := [@typeSemanticAttributesMap emptyMap] ;
  outSuperClassName := [@lstring new !"" !here] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  tableDesClassesAncetres := [@typeSuperClassesMap emptyMap] ;
  tableDesMethodes := [@typeTableMethodes emptyMap] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap emptyMap] ;
  tableAttributs := [@typeSemanticAttributesMap emptyMap] ;
#---
  outMessageMap := [@classMessageMap emptyMap] ;
  outSuperClasses := [@stringset emptySet] ;
  outAttributeList := [@typeListModel emptyList] ;
end rule ;

#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
:
#--- Parse super class name
  $extends$ ;
  $type_name$ ? outSuperClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_galgasType typeUtilisateur ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey ! outSuperClassName ?entite] ;
  extract entite->@typeEntiteType (?typeUtilisateur) error outSuperClassName : messageTypeEntite ;
  extract typeUtilisateur->@typeGalgasClassType (?*
                                    ?tableDesMethodes
                                    ?listeTousAttributsSemantiques
                                    ?tableDesClassesAncetres
                                    ?tableMessagesAbstraits
                                    ?tableAttributs
                                    ?*)
             error outSuperClassName : messageGalgasType ;
#--- Le Parse super class name est la derniere inseree en fin de la liste des ancetres 
  [!?tableDesClassesAncetres insertKey ! outSuperClassName] ;
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
#--- Parse super class name
  @lstring superClassName ;
  $extends$ ;
  $type_name$ ? superClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_galgasType typeUtilisateur ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey ! superClassName ?entite] ;
  extract entite->@typeEntiteType (?typeUtilisateur) error superClassName : messageTypeEntite ;
  extract typeUtilisateur->@typeGalgasClassType (?*
                                    ?tableDesMethodes
                                    ?listeTousAttributsSemantiques
                                    ?tableDesClassesAncetres
                                    ?tableMessagesAbstraits
                                    ?tableAttributs
                                    ?*)
             error superClassName : messageGalgasType ;
#--- The direct super class is last inserted one 
  [!?tableDesClassesAncetres insertKey ! superClassName] ;
#---
  @TypeModel type ;
  [ioModelMap searchKey ! superClassName ?type] ;
  extract type :
  when @ClassModel (??* ??@stringset superClasses ??@typeListModel attributeList ??@classMessageMap messageMap) ->
    outSuperClasses := superClasses ;
    outAttributeList := attributeList ;
    outMessageMap := messageMap ;
  else
    error superClassName: "the '@" . [superClassName string] . "' type is not a class"
     -> outSuperClasses, outAttributeList, outMessageMap ;
  end extract ;
  outSuperClasses += ![superClassName string] ;

  outMessageMap := [@classMessageMap emptyMap] ;
  outSuperClasses := [@stringset emptySet] ;
  outAttributeList := [@typeListModel emptyList] ;

end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     A B S T R A C T    C L A S S                                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $abstract$ ;
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName string]] |
          [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    <parent_class>
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
      ?*
    ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeAttributsExternesCourants ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @bool estAbstraite := true ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    repeat
    while
      $message$ ;
      @lstring messageName ;
      $identifier$ ? messageName ;
    #--- Chaine definissant le message d'erreur
      @lstring messageText ;
      $literal_string$ ? messageText ;
    #--- Entrer le message dans la map
      if not [inheritedMessageMap hasKey ![messageName string]] then
        [!?messageMapForHeirs insertKey !messageName] ;
      end if ; 
      [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      $;$ ;
    while
      <abstract_method> !?listeAttributsSemantiquesCourants
                       !?listeEntitesAengendrer
                       !?ioComponentSemanticsEntitiesMap
                       !?tableDesMethodes
                       !?tableMethodesAimplementer
                       !?tableEnAvant ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?ioOptionsComponentsMapForUse
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?ioOptionsComponentsMapForUse
     ;
    end repeat ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
      if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait string]] then
        error here : "the message '" . [nomMessageAbstrait string] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
                                             !abstractClassName
                                             !tableDesMethodes
                                             !listeTousAttributsSemantiques
                                             !tableDesClassesAncetres
                                             !messageMapForHeirs
                                             !tableAttributs
                                             !estAbstraite] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
  #--- Inserer dans la map des classes definies dans ce fichier (a implementer)
    @typeEntityToGenerate def := [@typeDefClasseAbstraiteAimplementer new 
                                            !abstractClassName
                                             !listeTousAttributsSemantiques
                                             !tableDesMethodes
                                             !tableMethodesAimplementer
                                             !listeAttributsSemantiquesCourants
                                             !listeAttributsExternesCourants
                                             !tableDesClassesAncetres
                                             !tableMessagesClasseConcrete] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $abstract$ ;
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName string]] |
            [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    @stringset superClasses ;
    @typeListModel attributeList ;
    @classMessageMap messageMap ;
    <parent_class> importSemantics
      !?ioModelMap
      ?superClasses
      ?attributeList
      ?messageMap
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
    ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeAttributsExternesCourants ;
    <attributes_definition_list>
      !?attributeList
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @bool estAbstraite := true ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
    repeat
    while
      $message$ ;
      @lstring messageName ;
      $identifier$ ? messageName ;
####      [!?messageMap insertKey !messageName] ;
    #--- Chaine definissant le message d'erreur
      @lstring messageText ;
      $literal_string$ ? messageText ;
    #--- Entrer le message dans la map
      if not [inheritedMessageMap hasKey ![messageName string]] then
        [!?messageMapForHeirs insertKey !messageName] ;
      end if ; 
      [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      $;$ ;
    while
      <abstract_method>
        !?listeAttributsSemantiquesCourants
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableDesMethodes
        !?tableMethodesAimplementer
        !?tableEnAvant ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?optionsComponentsMapForUse
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !listeAttributsSemantiquesCourants
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !?optionsComponentsMapForUse
     ;
    end repeat ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
      if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait string]] then
        error here : "the message '" .  [nomMessageAbstrait string] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
                                             !abstractClassName
                                             !tableDesMethodes
                                             !listeTousAttributsSemantiques
                                             !tableDesClassesAncetres
                                             !messageMapForHeirs
                                             !tableAttributs
                                             !estAbstraite] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
    $}$ ;
    @TypeModel t := [@ClassModel new !true !superClasses !attributeList !messageMap] ;
    [!?ioModelMap insertKey !abstractClassName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     C O N C R E T E    C L A S S                                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $class$ ;
#--- Nom de la classe
  @lstring concreteClassName ;
  $type_name$ ? concreteClassName ;
#--- Verifier que cette classe n'a pas ete predeclaree
  if [tableEnAvant hasKey ![concreteClassName string]] then
    error concreteClassName : "a non abstract class cannot be predeclared" ; 
  end if ;
#--- Super class
  @typeTableMethodes ancestorClassMethodsMap ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
  @typeSuperClassesMap tableDesClassesAncetres ;
  @typeClassInheritedMessagesMap inheritedMessageMap ;
  @typeSemanticAttributesMap tableAttributs ;
  <parent_class>
    !?ioComponentSemanticsEntitiesMap
    ?tableAttributs
    ?listeTousAttributsSemantiques
    ?ancestorClassMethodsMap
    ?tableDesClassesAncetres
    ?inheritedMessageMap
    ?*
  ;
  #message "Classe " . [concreteClassName string] . ", tableAttributs " . [tableAttributs description] . "\n" ;
  ${$ ;
#------------------- list des attributs de la classe -------------------
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
  @L_nameWithType listeTypeeAttributsExternesCourants ;
  @typeListModel attributeListModel [emptyList] ;
  <attributes_definition_list>
    !?attributeListModel
    !?tableAttributs
    !?listeTousAttributsSemantiques
    ?listeAttributsSemantiquesCourants
    ?listeTypeeAttributsExternesCourants
    !?ioComponentSemanticsEntitiesMap
  ;
  @bool estAbstraite := false ;
#--------------------- Methodes de la classe ----------------------------
  @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
  @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
  @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
  @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
  repeat
  while
    <overrided_method>
      !concreteClassName
      !ancestorClassMethodsMap
      !listeTousAttributsSemantiques
      !listeAttributsSemantiquesCourants
      !?tableDesMethodes
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !estAbstraite
      !?listeEntitesAengendrer
      !?ioComponentSemanticsEntitiesMap
      !?tableMethodesAimplementer
      !?tableEnAvant
      !?ioOptionsComponentsMapForUse
    ;
  while
    $message$ ;
  #--- Nom du message
    @lstring messageName ;
    $identifier$ ? messageName ;
  #--- Chaine definissant le message d'erreur
    @lstring messageText ;
    $literal_string$ ? messageText ;
  #--- Entrer le message dans la map
    if not [inheritedMessageMap hasKey ![messageName string]] then
      [!?messageMapForHeirs insertKey !messageName] ;
    end if ; 
    [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ; 
    $;$ ;
  while
    <non_abstract_method>
      !concreteClassName
      !ancestorClassMethodsMap
      !listeTousAttributsSemantiques
      !listeAttributsSemantiquesCourants
      !?tableDesMethodes
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !estAbstraite
      !?listeEntitesAengendrer
      !?ioComponentSemanticsEntitiesMap
      !?tableMethodesAimplementer
      !?tableEnAvant
      !?ioOptionsComponentsMapForUse
    ;
  end repeat ;
#--- Verify that all inherited messages are defined
  foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
    if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait string]] then
      error here : "the message '" . [nomMessageAbstrait string] . "' is not defined" ;
    end if ;
  end foreach ;
#--- Insertion dans la tables des classes utilisables
  @AC_galgasType c := [@typeGalgasClassType new 
                        !concreteClassName
                        !tableDesMethodes
                        !listeTousAttributsSemantiques
                        !tableDesClassesAncetres
                        !messageMapForHeirs
                        !tableAttributs
                        !estAbstraite] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !concreteClassName ![@typeEntiteType new !c]] ;
#--- Insertion dans la map des classes a implementer
  @typeEntityToGenerate def := [@typeDefClasseNonAbstraiteAimplementer new 
                                                !concreteClassName
                                                !listeTousAttributsSemantiques
                                                !tableDesMethodes
                                                !tableMethodesAimplementer
                                                !listeAttributsSemantiquesCourants
                                                !listeTypeeAttributsExternesCourants
                                                !tableDesClassesAncetres
                                                !tableMessagesClasseConcrete] ;
  listeEntitesAengendrer += !def ;
  $}$ ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $class$ ;
#--- Nom de la classe
  @lstring concreteClassName ;
  $type_name$ ? concreteClassName ;
#--- Verifier que cette classe n'a pas ete predeclaree
  if [tableEnAvant hasKey ![concreteClassName string]] then
    error concreteClassName : "a non abstract class cannot be predeclared" ; 
  end if ;
#--- Super class
  @typeTableMethodes ancestorClassMethodsMap ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
  @typeSuperClassesMap tableDesClassesAncetres ;
  @typeClassInheritedMessagesMap inheritedMessageMap ;
  @typeSemanticAttributesMap tableAttributs ;
  @lstring superClassName ;
  <parent_class>
    !?ioComponentSemanticsEntitiesMap
    ?tableAttributs
    ?listeTousAttributsSemantiques
    ?ancestorClassMethodsMap
    ?tableDesClassesAncetres
    ?inheritedMessageMap
    ?superClassName
  ;



#--- Parse super class name
#  $extends$ ;
#  @lstring superClassName ;
#  $type_name$ ? superClassName ;
#--- Get super class infos
#  @typeListModel attributeList ;
#  @classMessageMap messageMap ;
#  @stringset superClasses ;
  @typeListModel attributeList [ emptyList] ;
  @classMessageMap messageMap [emptyMap] ;
  @stringset superClasses [emptySet] ;
  if [superClassName string] != "" then
    @TypeModel type ;
    [ioModelMap searchKey !superClassName ?type] ;
    extract type :
    when @ClassModel (??* ??@stringset kSuperClasses ??@typeListModel kAttributeList ??@classMessageMap kMessageMap) ->
      superClasses := kSuperClasses ;
      attributeList := kAttributeList ;
      messageMap := kMessageMap ;
    else
      error superClassName: "the '@" . [superClassName string] . "' type is not a class"
       -> superClasses, attributeList, messageMap ;
    end extract ;
    superClasses += ![superClassName string] ;
  end if ;
  ${$ ;
#--- Check super class name
#  @AC_galgasType definitionClasseMere ;
#  @AC_semanticsEntity entite ;
#  [ioComponentSemanticsEntitiesMap searchKey !superClassName ?entite] ;
#  extract entite->@typeEntiteType (?definitionClasseMere) error superClassName : messageTypeEntite ;
#  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
#  @typeSuperClassesMap tableDesClassesAncetres ;  
 # @typeTableMethodes ancestorClassMethodsMap ;
#  @typeClassInheritedMessagesMap inheritedMessageMap ;
#  @typeSemanticAttributesMap tableAttributs ;
#  extract definitionClasseMere->@typeGalgasClassType (?*
#                                    ?ancestorClassMethodsMap
#                                    ?listeTousAttributsSemantiques
#                                    ?tableDesClassesAncetres
#                                    ?inheritedMessageMap
#                                    ?tableAttributs
#                                    ?*)
#           error superClassName : messageGalgasType ;
#  [!?tableDesClassesAncetres insertKey !superClassName] ;
#------------------- list des attributs de la classe -------------------
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
  @L_nameWithType listeTypeeAttributsExternesCourants ;
  @typeListModel attributeListModel [emptyList] ;
  <attributes_definition_list>
    !?attributeListModel
    !?tableAttributs
    !?listeTousAttributsSemantiques
    ?listeAttributsSemantiquesCourants
    ?listeTypeeAttributsExternesCourants
    !?ioComponentSemanticsEntitiesMap
  ;
  @bool estAbstraite := false ;
#--------------------- Methodes de la classe ----------------------------
  @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
  @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
  @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
  @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  repeat
  while
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    <overrided_method>
      !concreteClassName
      !ancestorClassMethodsMap
      !listeTousAttributsSemantiques
      !listeAttributsSemantiquesCourants
      !?tableDesMethodes
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !estAbstraite
      !?listeEntitesAengendrer
      !?ioComponentSemanticsEntitiesMap
      !?tableMethodesAimplementer
      !?tableEnAvant
      !?optionsComponentsMapForUse
    ;
  while
    $message$ ;
  #--- Nom du message
    @lstring messageName ;
    $identifier$ ? messageName ;
    @lstring messageText ;
    $literal_string$ ?messageText ;
  #--- Entrer le message dans la map
    if not [inheritedMessageMap hasKey ![messageName string]] then
      [!?messageMapForHeirs insertKey !messageName] ;
    end if ; 
    [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ; 
    $;$ ;
  while
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    <non_abstract_method>
      !concreteClassName
      !ancestorClassMethodsMap
      !listeTousAttributsSemantiques
      !listeAttributsSemantiquesCourants
      !?tableDesMethodes
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !estAbstraite
      !?listeEntitesAengendrer
      !?ioComponentSemanticsEntitiesMap
      !?tableMethodesAimplementer
      !?tableEnAvant
      !?optionsComponentsMapForUse
    ;
  end repeat ;
#--- Verify that all inherited messages are defined
  foreach inheritedMessageMap (??@lstring nomMessageAbstrait) :
    if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait string]] then
      error here : "the message '" . [nomMessageAbstrait string] . "' is not defined" ;
    end if ;
  end foreach ;
#--- Insertion dans la tables des classes utilisables
  @AC_galgasType c := [@typeGalgasClassType new 
                        !concreteClassName
                        !tableDesMethodes
                        !listeTousAttributsSemantiques
                        !tableDesClassesAncetres
                        !messageMapForHeirs
                        !tableAttributs
                        !estAbstraite] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !concreteClassName ![@typeEntiteType new !c]] ;
  @TypeModel t := [@ClassModel new !false !superClasses !attributeList !messageMap] ;
  [!?ioModelMap insertKey !concreteClassName !t] ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                 Methode abstract                          *
#---------------------------------------------------------------------------*

rule <abstract_method>
  ?!@typeListeAttributsSemantiques unused listeAttributsSemantiquesCourants
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
:
  $abstract$ ;
  $reader$ ;
  @lstring nomMethode ;
  $identifier$ ? nomMethode ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  [!?tableDesMethodes insertKey !nomMethode !listeDeTypes] ;
  @typeInstructionList listeInstructions [emptyList] ;
  [!?tableMethodesAimplementer insertAbstract !nomMethode !listeDeTypes !listeTypeEtNomsArguments !listeInstructions] ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributsHerites
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@M_optionComponents ioOptionsComponentsMapForUse
:
#--- Get reader name
  $identifier$ ? outMethodName ;
#--- Create local variable map
  @typeVariablesMap methodLocalVariablesMap [emptyMap]  ;
  foreach tableAttributsHerites (??@lstring kKey ??@AC_galgasType kType) :
    @typeCplusPlusName nomCpp := [@typeDirectName new !kKey] ;
    [!?methodLocalVariablesMap insertUsedConstInArgument !kKey !kType !nomCpp] ;
  end foreach ;
#--- Insert the predefined "self" variable
  @lstring me_Constant := [@lstring new !"self" !here] ;
  @typeCplusPlusName me_constantCppName := [@typeCppThisName new] ;
  @AC_galgasType typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !tableDesMethodes
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument !me_Constant !typeDefinition !me_constantCppName] ;
#--- Insert the predefined "super" variable
  @lstring super_Constant := [@lstring new !"super" !here] ;
  @typeCplusPlusName super_constantCppName := [@typeCppInheritedName new] ;
  typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !inAncestorClassMethodsMap
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument !super_Constant !typeDefinition !super_constantCppName] ;
#--- Parse formal arguments
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?outMethodSignature
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  $:$ ;
#--- Build local attributes table
  foreach listeAttributsSemantiquesCourants (??@AC_galgasType typeAttribut ??@lstring nomAttribut) :
#    @typeCplusPlusName nomCpp := [@typeDirectName new !nomAttribut] ;
#    [!?methodLocalVariablesMap insertUsedConstInArgument !nomAttribut !typeAttribut !nomCpp] ;
  end foreach ;
#--- Parse reader instruction list
  outInstructionsList := [@typeInstructionList emptyList] ;
  @entityPropertyMap propertyMap [emptyMap] ;
  @stringset constraintPropertyDefinitionSet [emptySet] ;
  @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
  <semantic_instructions_list>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !?ioOptionsComponentsMapForUse
    !?methodLocalVariablesMap
    !?outInstructionsList
    !?propertyMap
    !?constraintPropertyDefinitionSet
    !?callInstructionSharedPropertySignatureMap
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
:
  $reader$ ;
  @lstring methodName ;
  @typeInstructionList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !listeAttributsSemantiquesCourants
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?listeEntitesAengendrer
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !?ioOptionsComponentsMapForUse
 ;
  [!?tableDesMethodes insertKey !methodName !methodSignature] ;
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  $reader$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ?!@M_optionComponents ioOptionsComponentsMapForUse
:
  $override$ ;
  $reader$ ;
  @lstring methodName ;
  @typeInstructionList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !listeAttributsSemantiquesCourants
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?listeEntitesAengendrer
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !?ioOptionsComponentsMapForUse
  ;
#--- Verify reader signature is compatible with overriden reader signature
  @L_EXsignature listeDeTypesMethodeOriginale ;
  [tableDesMethodes searchKey !methodName ?listeDeTypesMethodeOriginale] ;
  verifierCompatibiliteSignatures
    !listeDeTypesMethodeOriginale 
    !methodSignature
    !here
  ;
#--- Insert reader into reader table
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  $reader$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#               Analyse des arguments formels d'une methode                 *
#                     (entree, sortie, or entree/sortie)                    *
#---------------------------------------------------------------------------*

rule <formal_arguments_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignatureForGrammar
:
  listeDeTypes := [@L_EXsignature emptyList] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  outSignatureForGrammar := [@L_signature emptyList] ;
  repeat
  while
    $??$ ; # '??'  : constant input formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    @bool modeIn := true ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertConstInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?$ ; # '?'  : input formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true ;
      [!?tableArgumentsMethode insertUnusedInArgument !nomArgument !type_semantique !natureNom] ;
    or
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true ;
      [!?tableArgumentsMethode insertInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?!$ ; # '?!' : input/output formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentInOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !false ;
      [!?tableArgumentsMethode insertUnusedInOutArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !false ;
      [!?tableArgumentsMethode insertInOutArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $!$ ; # '!' : output formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !?ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    @typeCplusPlusName natureNom := [@typeAutomaticName new !nomArgument] ;
    @bool modeIn := false ;
    listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
    [!?tableArgumentsMethode insertOutArgument !nomArgument !type_semantique !natureNom] ;
  end repeat ;
label importGrammarForSemantics
  !@L_signature outSignature
:
  outSignature := [@L_signature emptyList] ;
  repeat
  while
    $??$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?!$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentInOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $!$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    $identifier$ ? * ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#            Parse type name and check it is defined                        *
#---------------------------------------------------------------------------*

rule <type_parsing>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType definitionType
  !@lstring outTypeName
:
  $type_name$ ? outTypeName ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
  extract entite->@typeEntiteType (?definitionType) error outTypeName : messageTypeEntite ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A S S I G N M E N T     I N S T R U C T I O N     idf := ... ;           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring inTargetVarName
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Get target entity infos
  @AC_galgasType targetVarType ;
  @typeCplusPlusName targetVarCppName ;
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?targetVarType ?targetVarCppName] ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !targetVarType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_assignmentInstruction new !targetVarCppName !sourceExpression] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#        Liste d'arguments effectifs en entree : ( ?<entite dest> ? * ...)  *
#---------------------------------------------------------------------------*

rule <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
:
  @typeListeCibles listeCibles [emptyList] ;
  repeat
  while
    $?$ ;
    @typeCible typeEntiteDestination ;
    <target_entity> ?typeEntiteDestination !?ioVariablesMap ;
    listeCibles += !typeEntiteDestination ;
  end repeat ;
  @bool ellipsis ;
  select
    $...$ ;
    ellipsis := true ;
  or
    ellipsis := false ;
  end select ;
#--- Verifier la compatibilite des list et construire la list des affectations
  if [listeAttributsSemantiques length] < [listeCibles length] then
    error here : "too much arguments: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found" 
      -> outAllVariablesList, listeAffectationParametresEffectifs ;
  elsif ([listeAttributsSemantiques length] > [listeCibles length]) & not ellipsis then
    error here : "argument(s) missing: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found"
      -> outAllVariablesList, listeAffectationParametresEffectifs ;
  else
    listeAffectationParametresEffectifs := [@L_assignedVariables emptyList] ;
    outAllVariablesList := [@typeCplusPlusNameList emptyList] ;
    foreach listeAttributsSemantiques (??@AC_galgasType attTypeAttribut ??@lstring attNomAttribut),
            listeCibles (??@typeCible attCible) :
      @lstring nomAttributSource := attNomAttribut ;
      [attCible verifierType !attTypeAttribut !?nomAttributSource !?listeAffectationParametresEffectifs !?outAllVariablesList] ;
    end foreach ;
  end if ;
#--- Append Jojker if needed
  @typeCplusPlusName nullName := [@typeNullName new] ;
  action appendJokersIfNeeded
   !?outAllVariablesList
   ![listeCibles length]
   ![listeAttributsSemantiques length]
   !nullName
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <target_entity>
  !@typeCible typeEntiteDestination
  ?!@typeVariablesMap ioVariablesMap
:
  @lstring nomVariableDest ;
  $identifier$ ? nomVariableDest ;
  @AC_galgasType typeVarDest ;
  @typeCplusPlusName nomCppDest ;
  [!?ioVariablesMap searchForWriteAccess !nomVariableDest ?typeVarDest ?nomCppDest] ;
  typeEntiteDestination := [@typeEntiteDest new !typeVarDest !nomCppDest !here] ;
end rule ;

#---------------------------------------------------------------------------*

rule <target_entity>
  !@typeCible typeEntiteDestination
  ?!@typeVariablesMap unused ioVariablesMap
:
  $*$ ;
  typeEntiteDestination := [@typeJoker new] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   + =    I N S T R U C T I O N                                            *
#                                                                           *
#  variable += !source_exp !... !source_exp ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $+=$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  [targetVariableType handleAddAssignOperatorCall !here ?formalParametersList] ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList emptyList] ;
  @typeExpressionList expressionList [emptyList] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !?ioComponentSemanticsEntitiesMap
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList (??@AC_galgasType formalType ??@lstring formalName),
            typeList (??@AC_galgasType effectiveType ??@location kErrorLocation) :
      checkAssignmentTypesCompatibility
        !formalType
        !effectiveType
        !kErrorLocation
        !true
      ;
    end foreach ;
  end if ;
  @typeInstruction instruction := [@typeAppendInstruction new !nomCppVariableSource !expressionList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   - =    I N S T R U C T I O N                                            *
#                                                                           *
#  variable -= !source_exp !... !source_exp ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $-=$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  [targetVariableType handleMinusAssignOperatorCall !here ?formalParametersList] ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList emptyList] ;
  @typeExpressionList expressionList [emptyList] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !?ioComponentSemanticsEntitiesMap
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList (??@AC_galgasType formalType ??@lstring formalName),
            typeList (??@AC_galgasType effectiveType ??@location kErrorLocation) :
      checkAssignmentTypesCompatibility
        !formalType
        !effectiveType
        !kErrorLocation
        !true
      ;
    end foreach ;
  end if ;
  @typeInstruction instruction := [@typeRemoveInstruction new !nomCppVariableSource !expressionList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   I N C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable ++ ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  $++$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the ++ operator ?
  [targetVariableType handleIncrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeIncrementInstruction new !nomCppVariableSource !here] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable -- ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  $--$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the ++ operator ?
  [targetVariableType handleDecrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeDecrementInstruction new !nomCppVariableSource !here] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#---------------------------------------------------------------------------*

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList
:
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?outExpressionList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
#--- Verifier la correction des arguments effectifs
  verifierCompatibiliteArgEffectifsSignature
    !listeTypesParametresFormels
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?outExpressionList
  ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#                          sans verification de type                        *
#---------------------------------------------------------------------------*

rule <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  outExpressionList := [@typeExpressionList emptyList] ;
  listeTypesParametresEffectifs := [@L_actualParametersSignature emptyList] ;
  @stringset exclusiveVariables [emptySet] ;
  repeat
  while
    $!$ ;
    @AC_galgasType expressionType ;
    @typeExpression expressionValue ;
    <expression>
      !?ioComponentSemanticsEntitiesMap
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expressionValue
      ?expressionType ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterOut] ;
    listeTypesParametresEffectifs += !expressionType !parameterPassingMode ;
    outExpressionList += !expressionValue ;
  while
    $?$ ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterIn] ;
    select
      $*$ ;
      @AC_galgasType typeArgument := [@typeGalgas_jokerInParameterList new] ;
      listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
      @typeExpression e := [@typeJokerInExpression new !here] ;
      outExpressionList += !e ;
    or
      @AC_galgasType typeArgument ;
      @typeCplusPlusName nomCppArgument ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      [!?ioVariablesMap searchForWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
      listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
      @typeExpression e := [@typeVarInExpression new !nomCppArgument] ;
      outExpressionList += !e ;
      if [exclusiveVariables hasKey ![nomArgument string]] then
        error nomArgument: "this object is already named as input or output/input effectif argument of current instruction" ;
      else
         exclusiveVariables += ![nomArgument string] ;
      end if ;
    end select ;
  while
    $!?$ ;
    @AC_galgasType typeArgument ;
    @typeCplusPlusName nomCppArgument ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    [!?ioVariablesMap searchForReadWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterOutIn] ;
    listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
    @typeExpression e := [@typeVarInExpression new !nomCppArgument] ;
    outExpressionList += !e ;
      if [exclusiveVariables hasKey ![nomArgument string]] then
        error nomArgument: "this object is already named as input or output/input effectif argument of current instruction" ;
      else
         exclusiveVariables += ![nomArgument string] ;
      end if ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SEMANTIQUES D'UNE METHODE             *
#---------------------------------------------------------------------------*

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  block ioVariablesMap.verifyVariableUsing () :
    <semantic_instructions_list_no_verif>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?ioPropertyMap
      !?ioConstraintPropertyDefinitionSet
      !?ioCallInstructionSharedPropertySignatureMap
    ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      call instruction                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $call$ ;
#--- Called property
  @lstring calledPropertyName ;
  $identifier$ ?calledPropertyName ;
  @metamodelPropertyKind kind ;
  @lstring typeName ;
  [ioPropertyMap searchKey !calledPropertyName ?kind ?typeName] ;
  switch kind
  when attributeProperty:
    error calledPropertyName:"only a reference can used used here" ;
  when singleReferenceProperty, multipleReferenceProperty:
    # Ok
  end switch ;
  if [ioConstraintPropertyDefinitionSet hasKey ![calledPropertyName string]] then
    error calledPropertyName: "this property has been already initialized" ;
  else
    ioConstraintPropertyDefinitionSet += ![calledPropertyName string] ;
  end if ;
#--- Effective parameters
  @L_lstringList parameterList [emptyList] ;
  select
  or
    $($ ;
    repeat
      @lstring propertyArgumentName ;
      $identifier$ ?propertyArgumentName ;
      parameterList += !propertyArgumentName ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  end select ;
#--- Check parameter type list
  if [ioCallInstructionSharedPropertySignatureMap hasKey ![calledPropertyName string]] then
    @L_lstringList previousParameterList ;
    @location previousParameterTypeListLocation ;
    [ioCallInstructionSharedPropertySignatureMap searchKey !calledPropertyName ?previousParameterList ?previousParameterTypeListLocation] ;
    if [previousParameterList length] == [parameterList length] then
#      foreach previousParameterList (??@lstring kPreviousTypeName), parameterTypeList (??@lstring kCurrentTypeName) :
#        if [kPreviousTypeName string] != [kCurrentTypeName string] then
#          error kCurrentPropertyName: "this shared property has '@" . [kCurrentTypeName string]
#          . "' type, while a previous call has named an attribute of type '@" . [kPreviousTypeName string] . "'" ;
#        end if ;
#      end foreach ;
    else
     error previousParameterTypeListLocation:"this instruction names " . [[parameterList length] string]
     . " shared parameter(s), while a previous call has named "  . [[previousParameterList length] string]
     . " parameter(s)" ;
    end if ;
  else
    [!?ioCallInstructionSharedPropertySignatureMap insertKey !calledPropertyName !parameterList !here] ;
  end if ;
  $;$ ;
#--- Generate instruction
  @typeInstruction instruction := [@callInstruction new
    !calledPropertyName
    !kind
    !typeName
    !parameterList
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      extract instruction                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $extract$ ;
#--- Source variable
  @AC_galgasType typeVarSource ;
  @typeCplusPlusName sourceVarCppName ;
  @lstring nomVarSource ;
  <read_access> ?nomVarSource ?sourceVarCppName ?typeVarSource !?ioVariablesMap ;
#--- Check variable has class type
  @lstring nomTypeSource ;
  @typeClassInheritedMessagesMap tableMessagesAbstraits ;
  extract typeVarSource->@typeGalgasClassType
           (?nomTypeSource ?* ?* ?* ?tableMessagesAbstraits ?* ?*)
           error nomVarSource : messageGalgasType ;
#--- Parse simple or structured extract instruction
  @typeInstruction instruction ;
  <extract_instruction>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    !sourceVarCppName
    !nomTypeSource
    !tableMessagesAbstraits
    ?instruction
    !?ioPropertyMap
    !?ioConstraintPropertyDefinitionSet
    !?ioCallInstructionSharedPropertySignatureMap
  ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#       Simple extract instruction                                          *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
#--- Nom de la classe pour la conversion
  $->$ ;
  @lstring nomClasse ;
  $type_name$ ? nomClasse ;
#--- Obtenir les caracteristiques de la classe nommee
  @AC_galgasType leType ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !nomClasse ?entite] ;
  extract entite->@typeEntiteType (?leType) error nomClasse : messageTypeEntite ;
  @typeListeAttributsSemantiques listeAttributsSemantiques ;
  @typeSuperClassesMap tableDesClassesAncetres ;
  extract leType->@typeGalgasClassType
               (?*
                ?*
                ?listeAttributsSemantiques
                ?tableDesClassesAncetres
                ?*
                ?*
                ?*)
             error nomClasse : messageGalgasType ;
#--- Verify class is an heir of variable type
  if not [tableDesClassesAncetres hasKey ![nomTypeSource string]] then
    error nomClasse : "This class does not inherit from '@" . [nomTypeSource string] . "'" ;
  end if ;
#--- Arguments
  @L_assignedVariables listeAffectationParametresEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  $($ ;
  <input_parameters_list>
    ?listeAffectationParametresEffectifs
    ?allVariablesList
    !listeAttributsSemantiques
    !?ioVariablesMap
  ;
  $)$ ;
#------------------------------------------------- Error message
  $error$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
  @lstring messageName ;
  $identifier$ ? messageName ;
  [tableMessagesAbstraits searchKey !messageName] ;
#------------------------------------------------- Generate instruction
  outInstruction := [@typeSimpleExtractInstruction new !inSourceVarCppName
                                                       !nomClasse
                                                       !listeAffectationParametresEffectifs
                                                       !errorExpression
                                                       !messageName] ;
end rule ;

#---------------------------------------------------------------------------*
#       Structured extract instruction                                      *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap unused tableMessagesAbstraits
  !@typeInstruction outInstruction
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  @typeStructuredExtractCasesList casesList [emptyList] ;
  $:$ ;
  $when$ ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @location indicatif1 := here ;
      #--- Nom du type 1
        @lstring nomType1 ;
        $type_name$ ? nomType1 ;
      #--- Verifier que la classe 'nomType1' est declaree
        @AC_galgasType definitionClasse1 ;
        @AC_semanticsEntity entite ;
        [ioComponentSemanticsEntitiesMap searchKey !nomType1 ?entite] ;
        extract entite->@typeEntiteType (?definitionClasse1) error nomType1 : messageTypeEntite ;
      #--- Verifier que la classe 'nomType1' herite de la classe 'nomTypeBase1'
        @typeSuperClassesMap tableDesClassesAncetresType1 ;
        @typeListeAttributsSemantiques listeAttributs1 ;
        extract definitionClasse1->@typeGalgasClassType
                  (?*
                   ?*
                   ?listeAttributs1
                   ?tableDesClassesAncetresType1
                   ?*
                   ?*
                   ?*)
              error nomType1 : messageGalgasType ;
      #--- Verify class is an heir of variable type
        if not [tableDesClassesAncetresType1 hasKey ![nomTypeSource string]] then
          error nomType1 : "This class does not inherit from '@" . [nomTypeSource string] . "'" ;
        end if ;
      #--- Arguments du type 1
       @bool noUsedParameter ;
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !listeAttributs1
          !indicatif1
          ![@localConstantBuildStyleEnum listStyle]
          ?noUsedParameter
        ;
      #--- Liste des instructions
        $->$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !?ioPropertyMap
          !?ioConstraintPropertyDefinitionSet
          !?ioCallInstructionSharedPropertySignatureMap
        ;
        casesList += !nomType1 !indicatif1 !instructionsList !noUsedParameter ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  #---------------------  Default error -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionList elseInstructionList [emptyList] ;
      <semantic_instructions_list>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elseInstructionList
        !?ioPropertyMap
        !?ioConstraintPropertyDefinitionSet
        !?ioCallInstructionSharedPropertySignatureMap
      ;
      outInstruction := [@typeStructuredExtractInstructionWithElse new
        !inSourceVarCppName !casesList !elseInstructionList
      ] ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $extract$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# Local variable declaration                                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
#--- Type name
  @AC_galgasType definitionType ;
  @lstring typeName ;
  <type_parsing> !?ioComponentSemanticsEntitiesMap ?definitionType ?typeName ;
#--- Variable name
  @lstring nomVariable ;
  $identifier$ ? nomVariable ;
  @typeCplusPlusName nomCppVariable := [@typeAutomaticName new !nomVariable] ;
  [!?ioVariablesMap insertLocalVariable !nomVariable !definitionType !nomCppVariable] ;
#--- Assignment ?
  <optional_assignment>
    !typeName
    !nomVariable
    !nomCppVariable
    !definitionType
    !?ioVariablesMap
    !?ioInstructionList
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction log variableName, ... ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $log$ ;
  repeat
    @lstring galgasVariableName ;
    $identifier$ ? galgasVariableName ;
    @typeCplusPlusName nomCppVar ;
    [!?ioVariablesMap searchForReadOnlyAccess !galgasVariableName ?* ?nomCppVar] ;
    @typeInstruction instruction := [@typeLogInstruction new !galgasVariableName !nomCppVar] ;
    ioInstructionList += !instruction ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction drop nomVariable, ... ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $drop$ ;
  repeat
    @lstring nom ;
    $identifier$ ? nom ;
    @typeCplusPlusName nomCppVar ;
    [!?ioVariablesMap searchForDestructiveReadAccess !nom ?* ?nomCppVar] ;
    @typeInstruction instruction := [@typeDropInstruction new !nomCppVar] ;
    ioInstructionList += !instruction ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#            R O U T I N E    C A L L    I N S T R U C T I O N              *
#                                                                           *
#                          routine_name ... ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
#--- Verifier que le nom est bien un nom de routine
  @L_EXsignature signatureRoutine ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !nomVarDest ?entite] ;
  extract entite->@typeEntiteRoutine (?signatureRoutine) error nomVarDest : messageTypeEntite ;
#--- Arguments effectifs
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !signatureRoutine
    ?expressionsList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
    !?ioInstructionList
  ;
#--- Generate instruction
  @typeInstruction instruction := [@typeRoutineCallInstruction new !nomVarDest !expressionsList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#           E X T E R N    C A L L    I N S T R U C T I O N                 *
#                                                                           *
#                         action extern_action ... ;                        *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
#--- Action name
  $action$ ;
  @lstring nomAction ;
  $identifier$ ? nomAction ;
#--- Search action in action map
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !nomAction ?entite] ;
  @L_EXsignature listeTypesParametresFormels ;
  extract entite->@typeEntiteActionExterne (?listeTypesParametresFormels) error nomAction : messageTypeEntite ;
#--- Check argument list types
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !listeTypesParametresFormels
    ?expressionsList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
    !?ioInstructionList
  ;
  $;$ ;
#--- Generate instruction
  @typeInstruction instruction :=
        [@typeInstructionAppelActionExterne new !nomAction
                                               !expressionsList
                                               !listeTypesParametresFormels] ;

  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R E A D E R    C A L L   I N S T R U C T I O N                         *
#               [object reader_method !... !?... ?...] ;                    *
#                                                                           *
#    M O D I F I E R    C A L L   I N S T R U C T I O N                     *
#               [!?object modifier_method !... !?... ?...] ;                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $[$ ;
#--- Get source identity characteristics
  @typeInstruction instruction ;
  select
    @lstring readObjectName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    <read_access> ?readObjectName ?cppVariableName ?variableType !?ioVariablesMap ;
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    [variableType handleReaderInstructionCall !readObjectName !methodName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !?ioOptionsComponentsMapForUse
      !?ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeReaderCallInstruction new !cppVariableName !methodName !expressionsList] ;
  or
    $!?$ ;
    @lstring modifiedObjectName ;
    $identifier$ ? modifiedObjectName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    [!?ioVariablesMap searchForReadWriteAccess !modifiedObjectName ?variableType ?cppVariableName] ; 
  #--- Get method name
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    [variableType handleModifierCall !modifiedObjectName !methodName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !?ioOptionsComponentsMapForUse
      !?ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeModifierCallInstruction new !cppVariableName !methodName !expressionsList] ;
  end select ;
  ioInstructionList += !instruction ;
  $]$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#             I N S T R U C T I O N   B E G I N N I N G                     *
#               W I T H    A N    I D E N T I F I E R                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  @lstring nomVarDest ;
  $identifier$ ? nomVarDest ;
  <instruction_beginning_with_identifier>
    !nomVarDest
    !?ioVariablesMap 
    !?ioInstructionList
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'warning ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $warning$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Warning message
  @typeExpression warningMessageExpression ;
  @AC_galgasType warningMessageExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?warningMessageExpression
    ?warningMessageExpressionType
  ;
#--- Check that error message is a @string instance
  extract warningMessageExpressionType->@typeGalgas_string () error here : messageGalgasType ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeWarningInstruction new !errorExpression !warningMessageExpression !here] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           Instruction 'error ... ;'                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $error$ ;
  @typeExpression errorLocationExpression ;
  @AC_galgasType errorLocationExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorLocationExpression
    ?errorLocationExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Error message
  @typeExpression errorMessageExpression ;
  @AC_galgasType errorMessageExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorMessageExpression
    ?errorMessageExpressionType
  ;
#--- Check that error message is a @string instance
  extract errorMessageExpressionType->@typeGalgas_string () error here : messageGalgasType ;
#--- Valuations fictives
  @varToDropList variablesToDrop [emptyList] ;
  select
  or
    $->$ ;
    repeat
      @lstring nomVariable ;
      $identifier$ ? nomVariable ;
      @typeCplusPlusName varCppName ;
      [!?ioVariablesMap searchForWriteAccess !nomVariable ?* ?varCppName] ;
      variablesToDrop += !varCppName ;
    while
      $,$ ;
   end repeat ;
  end select ;
  $;$ ;
#--- Build instruction and append it to instructions list
  @typeInstruction instruction := [@typeErrorInstruction new
    !errorLocationExpression
    !errorMessageExpression
    !here
    !variablesToDrop
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'message ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $message$ ;
  @location instructionLocation := here ;
#--- Message
  @typeExpression messageExpression ;
  @AC_galgasType messageExpressionType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?messageExpression
    ?messageExpressionType
  ;
#--- Check that error message is a @string instance
  extract messageExpressionType->@typeGalgas_string () error here : messageGalgasType ;
#--- Construire l'instruction
  @typeInstruction instruction := [@typeMessageInstruction new !messageExpression !instructionLocation] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction 'if ... then ... elsif ... else ... end if ;'               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $if$ ;
  @stringset startConstraintPropertyDefinitionSet := ioConstraintPropertyDefinitionSet ;
  @bool firstBranch := true ;
  @L_expression_instructionsList_list listeBranchesTest [emptyList] ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @typeExpression testBranche ;
        @AC_galgasType resultType ;
        <expression>
          !?ioComponentSemanticsEntitiesMap
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          ?testBranche
          ?resultType
        ;
        extract resultType ->@typeGalgas_bool () error here : messageGalgasType ;
        $then$ ;
        @typeInstructionList listeInstructionsBrancheTest [emptyList] ;
        @stringset constraintPropertyDefinitionSet := startConstraintPropertyDefinitionSet ;
        <semantic_instructions_list_no_verif>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheTest
          !?ioPropertyMap
          !?constraintPropertyDefinitionSet
          !?ioCallInstructionSharedPropertySignatureMap
        ;
        if firstBranch then
          ioConstraintPropertyDefinitionSet := constraintPropertyDefinitionSet ;
          firstBranch := false ;
        elsif ioConstraintPropertyDefinitionSet != constraintPropertyDefinitionSet then
          displayConstraintDefinitionErrors !ioConstraintPropertyDefinitionSet !constraintPropertyDefinitionSet ; 
        end if ;
        listeBranchesTest += !testBranche !listeInstructionsBrancheTest ;
      end block (!here) ;
    while
      $elsif$ ;
    end repeat ;
    @typeInstructionList listeInstructionsBrancheAutre [emptyList] ;
    block ioVariablesMap.testPart () :
      select
        if ioConstraintPropertyDefinitionSet != startConstraintPropertyDefinitionSet then
          displayConstraintDefinitionErrorsNoElse !ioConstraintPropertyDefinitionSet !startConstraintPropertyDefinitionSet ; 
       end if ;
      or
        $else$ ;
        @stringset constraintPropertyDefinitionSet := startConstraintPropertyDefinitionSet ;
        <semantic_instructions_list_no_verif>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheAutre
          !?ioPropertyMap
          !?constraintPropertyDefinitionSet
          !?ioCallInstructionSharedPropertySignatureMap
        ;
        if ioConstraintPropertyDefinitionSet != constraintPropertyDefinitionSet then
          displayConstraintDefinitionErrors !ioConstraintPropertyDefinitionSet !constraintPropertyDefinitionSet ; 
       end if ;
     end select ; 
    end block (!here) ;
    $end$ ;
    $if$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_if_instruction new !listeBranchesTest !listeInstructionsBrancheAutre] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction                                                             *
#     'switch exp when cst, cst: ...instructions... when ... end switch ;'  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $switch$ ;
#--- Expression
  @typeExpression switchExpression ;
  @AC_galgasType resultType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?switchExpression
    ?resultType
  ;
#--- Check expression type in an enum type
  @lstring enumTypeName ;
  @enumConstantMap enumConstantesMap ;
  extract resultType->@typeGalgas_enum (?enumTypeName ?enumConstantesMap ?*) error here : messageGalgasType ;
#---- When branches
  @stringset startConstraintPropertyDefinitionSet := ioConstraintPropertyDefinitionSet ;
  @bool firstBranch := true ;
  @stringset allBranchConstantSet [emptySet] ;
  @L_switchBranchlist switchBranchlist [emptyList] ;
  block ioVariablesMap.testBloc () :
    $when$ ;
    repeat
    #--- Parse constant list
      @stringset branchConstantSet [emptySet] ;
      repeat
        @lstring enumConstantName ;
        $identifier$ ? enumConstantName ;
        branchConstantSet += ![enumConstantName string] ;
        [enumConstantesMap searchKey !enumConstantName] ;
        if [allBranchConstantSet hasKey ![enumConstantName string]] then
          error enumConstantName: "this constant is already used in current switch instruction" ;
        end if ;
      while
        $,$ ;
      end repeat ;
      $:$ ;
      allBranchConstantSet := allBranchConstantSet | branchConstantSet ;
      block ioVariablesMap.testPart () :
        @typeInstructionList branchInstructionList [emptyList] ;
        @stringset constraintPropertyDefinitionSet := startConstraintPropertyDefinitionSet ;
        <semantic_instructions_list_no_verif>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?branchInstructionList
          !?ioPropertyMap
          !?constraintPropertyDefinitionSet
          !?ioCallInstructionSharedPropertySignatureMap
        ;
        switchBranchlist += !branchConstantSet !branchInstructionList ;
        if firstBranch then
          ioConstraintPropertyDefinitionSet := constraintPropertyDefinitionSet ;
          firstBranch := false ;
        elsif ioConstraintPropertyDefinitionSet != constraintPropertyDefinitionSet then
          displayConstraintDefinitionErrors !ioConstraintPropertyDefinitionSet !constraintPropertyDefinitionSet ; 
        end if ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  end block () ;
  $end$ ;
#--- Check all constant are named
  @stringset missingConstants := [enumConstantesMap allKeys] - allBranchConstantSet ;
  foreach missingConstants (??@string kConstant) :
    error here: "the '" . kConstant . "' is not used in switch instruction" ;
  end foreach ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@C_switch_instruction new !switchExpression !enumTypeName !switchBranchlist] ;
  ioInstructionList += !instruction ;
  $switch$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction 'while ... do ... end while ;'                              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $loop$ ;
#--- Variant expression
  @typeExpression variantExpression ;
  @AC_galgasType variantResultType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?variantExpression
    ?variantResultType
  ;
  extract variantResultType ->@typeGalgas_uint () error here : messageGalgasType ;
  $:$ ;
#--- Repeated instruction list
  @typeInstructionList instructionList1 [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Liste d'instructions
      <semantic_instructions_list_no_verif>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList1
        !?ioPropertyMap
        !?ioConstraintPropertyDefinitionSet
        !?ioCallInstructionSharedPropertySignatureMap
      ;
    end block (!here) ;
  end block () ;
  $while$ ;
#--- Conditionnal expression
  @typeExpression conditionalExpression ;
  @AC_galgasType resultType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?conditionalExpression
    ?resultType
  ;
  extract resultType ->@typeGalgas_bool () error here : messageGalgasType ;
  $do$ ;
#--- Repeated instruction list
  @typeInstructionList instructionList2 [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Liste d'instructions
      <semantic_instructions_list_no_verif>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList2
        !?ioPropertyMap
        !?ioConstraintPropertyDefinitionSet
        !?ioCallInstructionSharedPropertySignatureMap
      ;
    end block (!here) ;
  end block () ;
  @typeInstruction  instruction := [@C_while_instruction new
    !variantExpression
    !instructionList1
    !conditionalExpression
    !instructionList2
    !here
  ] ;
  $end$ ;
  $loop$ ;
  $;$ ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    G R A M M A R    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap unused ioPropertyMap
  ?!@stringset unused ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap unused ioCallInstructionSharedPropertySignatureMap
:
  $grammar$ ;
#--- Nom du fichier is
  @lstring grammarName ;
  $identifier$ ? grammarName ;
#--- Alt option ?
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $label$ ;
    $identifier$ ? altName ;
  end select ;
#--- Parse file name
  $in$ ;
  @lstring nomFichierSource ;
  @typeCplusPlusName nomCppFichierSource ;
  @AC_galgasType typeNomFichierSource ;
  <read_access> ?nomFichierSource ?nomCppFichierSource ?typeNomFichierSource !?ioVariablesMap ;
  extract typeNomFichierSource ->@typeGalgas_lstring () error nomFichierSource : messageGalgasType ;
#--- Analyse des arguments effectifs
  @typeExpressionList expressionsList ;
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?expressionsList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioComponentSemanticsEntitiesMap
  ;
#--- Look for grammar
  @AC_semanticsEntity e  ;
  [ioComponentSemanticsEntitiesMap searchKey !grammarName ?e] ;
  @M_nonterminalSymbolAlts startSymbolAltMap ;
  extract e->@C_grammarForSemantics (?startSymbolAltMap) error grammarName : messageTypeEntite ;
  @L_EXsignature startSymbolSignature ;
  @lstring returnedEntity ;
  [startSymbolAltMap searchKey !altName ?startSymbolSignature ?returnedEntity] ;
#--- Verifier la coherence avec la declaration
  verifierCompatibiliteArgEffectifsSignature 
    !startSymbolSignature
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?expressionsList
  ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_grammarInstruction new !nomCppFichierSource
                                           !grammarName
                                           !expressionsList
                                           !altName] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     Instruction 'foreach ... ;'                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $foreach$ ;
  @typeInstruction instruction ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Parse enumerated variables
      @foreachEnumerationList foreachEnumerationList [emptyList] ;
      repeat
      #--- Enumerated variable
        @lstring enumeratedVariableName ;
        @typeCplusPlusName enumeratedVariableCPPName ;
        @AC_galgasType enumeratedVariableType ;
        <read_access>
          ?enumeratedVariableName
          ?enumeratedVariableCPPName
          ?enumeratedVariableType
          !?ioVariablesMap
        ;
      #--- Insert iterated variable as local constant
        [!?ioVariablesMap insertUsedConstInArgument !enumeratedVariableName !enumeratedVariableType !enumeratedVariableCPPName] ;
      #--- Check this variable can be enumerated
        @typeListeAttributsSemantiques formalEnumerationList ;
        @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
        [enumeratedVariableType acceptForeachInstruction !enumeratedVariableName ?formalEnumerationList ?localConstantBuildStyleEnum] ;
      #--- Extract type name
        @string typeName ;
        [enumeratedVariableType getTypeName ?typeName] ;
      #--- Parse effective input attribute list
        @location magicNumber := here ;
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !formalEnumerationList
          !magicNumber
          !localConstantBuildStyleEnum
          ?*
        ;
        foreachEnumerationList += !enumeratedVariableCPPName !magicNumber !typeName ;
      while
        $,$ ;
      end repeat ;
    #--- While expression
      @typeExpression whileExpression ;
      select
        whileExpression := [@typeTrueBool new] ;
      or
        $while$ ;
        @AC_galgasType resultType ;
        <expression>
          !?ioComponentSemanticsEntitiesMap
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          ?whileExpression
          ?resultType
         ;
      end select ;
    #--- Repeated instruction list
      $:$ ;
    #--- Liste d'instructions
      @typeInstructionList instructionList [emptyList] ;
      <semantic_instructions_list_no_verif>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList
        !?ioPropertyMap
        !?ioConstraintPropertyDefinitionSet
        !?ioCallInstructionSharedPropertySignatureMap
      ;
    end block (!here) ;
  end block () ;
  instruction := [@typeForeachInstruction new
    !foreachEnumerationList
    !whileExpression
    !instructionList
  ] ;
  $end$ ;
  $foreach$ ;
  $;$ ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ' M A T C H '    I N S T R U C T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
:
  @lstring variableName ;
  @AC_galgasType type ;
  <read_access>
    ?variableName
    ?outCppName
    ?type
    !?ioVariablesMap
  ;
  outVarLocation := here ;
  extract type :
  when @typeGalgasClassType (??@lstring baseTypeName ??* ??* ??* ??* ??* ??*) ->
    outBaseTypeName := baseTypeName ;
    outIsEnumeration := false ;
    outEnumMessageMap := [@enumConstantMap emptyMap] ;
  when @typeGalgas_enum (??@lstring typeName ??@enumConstantMap enumMessageMap ??*) ->
    outBaseTypeName := typeName ;
    outIsEnumeration := true ;
    outEnumMessageMap := enumMessageMap ;
  else
    @string actualTypeName ;
    [type getTypeName ?actualTypeName] ; 
    error variableName : "the type of this variable is '@" . actualTypeName
      . "' ; I was expected an enumeration type or an abstract type" 
      -> outBaseTypeName, outIsEnumeration, outEnumMessageMap ;
  end extract ;
end rule ;


#---------------------------------------------------------------------------*

rule <parse_match_case>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap unused inEnumMessageMap
  !@lstring outTypeName
:
#--- Nom du type 1
  $type_name$ ? outTypeName ;
#--- Verifier que la classe 'outTypeName' est declaree
  @AC_galgasType definitionClasse1 ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
  extract entite->@typeEntiteType (?definitionClasse1) error outTypeName : messageTypeEntite ;
#--- Verifier que la classe 'outTypeName' herite de la classe 'baseTypeName1'
  @typeSuperClassesMap tableDesClassesAncetresType1 ;
  @typeListeAttributsSemantiques listeAttributs1 ;
  @bool isAbstract ;
  extract definitionClasse1->@typeGalgasClassType
                 (?*
                   ?*
                   ?listeAttributs1
                   ?tableDesClassesAncetresType1
                   ?*
                   ?*
                   ?isAbstract)
              error outTypeName : messageGalgasType ;
#--- Check class is not abstract
  if isAbstract then
    error outTypeName : "an abstract class is not allowed here" ;
  end if ;
#--- Verify class is an heir of variable type
  if inIsEnumeration then
    error outTypeName : "a constant of '@" . [inTypeName string] . "' enumeration type is expected here" ;
  elsif not [tableDesClassesAncetresType1 hasKey ![inTypeName string]] then
    error outTypeName : "This type does not inherit from '" . [inTypeName string] . "'" ;
  end if ;
#--- Arguments
  <parse_effective_input_parameters_list>
    !?ioVariablesMap
    !listeAttributs1
    !inVarLocation
    ![@localConstantBuildStyleEnum listStyle]
    ?*
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_match_case>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap unused ioVariablesMap
  ?@lstring inTypeName
  ?@location unused inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outEnumConstantName
:
#--- Enumeration constant
  $identifier$ ? outEnumConstantName ;
#--- Verify constant belongs to constants map
  if inIsEnumeration then
    [inEnumMessageMap searchKey !outEnumConstantName] ;
  else
    error outEnumConstantName : "a class that inherit from '@" . [inTypeName string] . "' abstract class is expected here" ;
  end if ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  $match$ ;
#--- Get first operand
  @typeCplusPlusName operand1_cppName ;
  @lstring operand1_typeName ;
  @location operand1_location ;
  @bool operand1_isEnumeration ;
  @enumConstantMap operand1_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand1_cppName
    ?operand1_typeName
    ?operand1_location
    ?operand1_isEnumeration
    ?operand1_enumMessageMap
  ;
#--- Get second operand
  $::$ ;
  @typeCplusPlusName operand2_cppName ;
  @lstring operand2_typeName ;
  @location operand2_location ;
  @bool operand2_isEnumeration ;
  @enumConstantMap operand2_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand2_cppName
    ?operand2_typeName
    ?operand2_location
    ?operand2_isEnumeration
    ?operand2_enumMessageMap
  ;
#---  Cases list
  $:$ ;
  @L_matchInstructionCasesList casesList [emptyList] ;
  block ioVariablesMap.testBloc () :
    repeat
    while
      $when$ ;
      block ioVariablesMap.testPart () :
        @lstring case1_name ;
      #--- First case 
       <parse_match_case>
          !?ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand1_typeName
          !operand1_location
          !operand1_isEnumeration
          !operand1_enumMessageMap
          ?case1_name
        ;
      #--- Separator
        $::$ ;
      #--- Second case
        @lstring case2_name ;
        <parse_match_case>
          !?ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand2_typeName
          !operand2_location
          !operand2_isEnumeration
          !operand2_enumMessageMap
          ?case2_name
        ;
      #--- Instructions list
        $:$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !?ioComponentSemanticsEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !?ioPropertyMap
          !?ioConstraintPropertyDefinitionSet
          !?ioCallInstructionSharedPropertySignatureMap
        ;
        casesList += !case1_name !case2_name !instructionsList ;
      end block (!here) ;
    end repeat ;
  #---------------------  E L S E    P A R T -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionList elsePartInstructionsList [emptyList] ;
      <semantic_instructions_list>
        !?ioComponentSemanticsEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elsePartInstructionsList
        !?ioPropertyMap
        !?ioConstraintPropertyDefinitionSet
        !?ioCallInstructionSharedPropertySignatureMap
      ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $match$ ;
  $;$ ;
#--- Insert instruction
  @typeInstruction instruction := [@typeMatchInstruction new !operand1_location
                                                             !operand2_location
                                                             !operand1_cppName
                                                             !operand2_cppName
                                                             !operand1_typeName
                                                             !operand2_typeName
                                                             !operand1_isEnumeration
                                                             !operand2_isEnumeration
                                                             !casesList
                                                             !elsePartInstructionsList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instructions_list_no_verif>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
:
  repeat
  while
    <semantic_instruction>
      !?ioComponentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !?ioPropertyMap
      !?ioConstraintPropertyDefinitionSet
      !?ioCallInstructionSharedPropertySignatureMap
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                 Affection optionnelle dans une declaration                *
#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring unused nomVarDest
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  @typeInstruction instruction := [@typeInstructionDeclarationVarLocale new !inVariableCppName !inVariableType] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $:=$ ;
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !inVariableType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !sourceExpression] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
  $[$ ;
#--- Class method name
  @lstring constructorName ;
  $identifier$ ? constructorName ;
  @typeListeAttributsSemantiques listeAttributsSemantiques ;
  [inVariableType handleConstructorCall !constructorName ?listeAttributsSemantiques] ;
#--- Actual arguments
  @typeExpressionList expressionList ;
  <output_expression_list>
    ?expressionList
    !listeAttributsSemantiques
    !?ioComponentSemanticsEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
  ;
  $]$ ;
#--- Generate instruction
  @typeExpression  e := [@typeConstructorExpression new !inTypeName !constructorName !expressionList] ;
  @typeInstruction i := [@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !e] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    D E C L A R A T I O N                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    warning cppClassName: "old style map definition" ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      insertMethodList += !nomMethode ![errorMessage string] !true !"" ; # Bool parameter has any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      searchMethodList += !nomMethode ![errorMessage string] !true !"" ; # Bool parameter has any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapMethodMap mapModifierMethodMap [emptyMap] ;
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList (??@lstring kKey ...) :
    #--- Insert Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList (??@lstring kKey ...) :
   #--- insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
   #--- insert method GetIndex
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      ![@mapMethodMap emptyMap]
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@typeDefinitionTableAimplementer new !mapTypeName
                                                                       !listeTousAttributsSemantiques
                                                                       !listeTypeeAttributsExternesCourants
                                                                       !cppClassName
                                                                       !insertMethodList
                                                                       !searchMethodList
                                                                       !tableMethodesBloc] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  or
    ${$ ;
  #--- Parse Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
  #--- Build insert and search method map
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapMethodMap mapModifierMethodMap [emptyMap] ;
    @mapMethodMap mapReaderMethodMap [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      action check_KL_escapeCharacters !errorMessage ;
      @string shadowErrorMessage ;
      select
        shadowErrorMessage := "" ;
      or
        $,$ ;
        @lstring shadowErrorMessageString ;
        $literal_string$ ? shadowErrorMessageString ;
        action check_KL_escapeCharacters !shadowErrorMessageString ;
        shadowErrorMessage := [shadowErrorMessageString string] ;
      end select ;
      $;$ ;
    #--- Insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
      insertMethodList += !methodName ![errorMessage string] !false !shadowErrorMessage ;
   #-- Insert And Get Index Method
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !inPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        insertMethodList += !getIndexMethodName ![errorMessage string] !true !shadowErrorMessage ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      action check_K_escapeCharacters !errorMessage ;
      $;$ ;
    #--- Insert search method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapReaderMethodMap insertKey !methodName !methodSignature] ;
      searchMethodList += !methodName ![errorMessage string] !false !"" ;
    #--- Insert 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
         getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapReaderMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        searchMethodList += !getIndexMethodName ![errorMessage string] !true !"" ;
      end if ;
    end repeat ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      !mapReaderMethodMap
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@C_mapToImplement new !mapTypeName
                                                        !listeTousAttributsSemantiques
                                                        !listeTypeeAttributsExternesCourants
                                                        !insertMethodList
                                                        !searchMethodList] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not([tableEnAvant hasKey ![mapTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      insertMethodList += !nomMethode ![errorMessage string] !true !"" ; #bool parameter can have any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      searchMethodList += !nomMethode ![errorMessage string] !true !"" ; #bool parameter can have any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapMethodMap mapModifierMethodMap [emptyMap] ;
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList (??@lstring kKey ...) :
    #--- Insert Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList (??@lstring kKey ...) :
    #--- Search Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
    #--- Search Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      ![@mapMethodMap emptyMap]
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  or
    ${$ ;
  #--- Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
  #--- Build insert and search method map
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapMethodMap mapModifierMethodMap [emptyMap] ;
    @mapMethodMap mapReaderMethodMap [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      select
      or
        $,$ ;
        $literal_string$ ? * ;
      end select ;
      $;$ ;
    #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'GetIndex' insert method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !inPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName ! getIndexMethodSignature] ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      $;$ ;
    #--- Enter search method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ; # Key
      foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapReaderMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature := [@L_EXsignature emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ; # Key
        getIndexMethodSignature += !luintType !outPassingMode ; # Returned Index
        foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapReaderMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
      end if ;
    end repeat ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
     !mapTypeName
     !listeTousAttributsSemantiques
     !tableMethodesBloc
     !mapModifierMethodMap
     !mapReaderMethodMap
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
:
  $identifier$ ? nomMethode ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*

rule <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
:
  $identifier$ ?methodName ;
  select
    getIndexMethodName := [@lstring new !"" !here] ;
  or
    $,$ ;
    $identifier$ ?getIndexMethodName ;
  end select ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*

rule <message_pattern>
  !@L_stringList outMessageList
:
  outMessageList := [@L_stringList emptyList] ;
  repeat
    select
      @lstring messageText ;
      $literal_string$ ? messageText ;
      if [messageText string] != "" then
        outMessageList += ![messageText string] ;
      end if ;
    or
      $*$ ;
      outMessageList += !"" ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     L I S T   T Y P E   D E C L A R A T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    @L_EXsignature inputSignature [emptyList] ;
    foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ??@lstring kNomAttribut) :
      extractSignature += !kAttributType ![@formalArgumentPassingMode argumentOut] ;
      inputSignature += !kAttributType ![@formalArgumentPassingMode argumentIn] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
      !inputSignature
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @typeEntityToGenerate def := [@C_listTypeToImplement new !listTypeName !listeTousAttributsSemantiques !listeTypeeAttributsExternesCourants] ;
    listeEntitesAengendrer += !def ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListModel attributeListModel [emptyList] ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @L_nameWithType listeTypeeAttributsExternesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    <attributes_definition_list>
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      ?listeTypeeAttributsExternesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    @L_EXsignature inputSignature [emptyList] ;
    foreach listeTousAttributsSemantiques (??@AC_galgasType kAttributType ??@lstring kNomAttribut) :
      extractSignature += !kAttributType ![@formalArgumentPassingMode argumentOut] ;
      inputSignature += !kAttributType ![@formalArgumentPassingMode argumentIn] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
      !inputSignature
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @TypeModel t := [@ListModel new !attributeListModel] ;
    [!?ioModelMap insertKey !listTypeName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                 LISTE DE DEFINITION DES ATTRIBUTS SEMANTIQUES             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <attributes_definition_list>
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  !@L_nameWithType listeTypeeAttributsExternesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  listeTypeeAttributsExternesCourants := [@L_nameWithType emptyList] ;
  listeAttributsSemantiquesCourants := [@typeListeAttributsSemantiques emptyList] ;
  outAttributeListModel := [@typeListModel emptyList] ;
  repeat
  while
  #--- Type name
    @AC_galgasType definitionType ;
    @lstring typeName ;
    <type_parsing>
      !?ioComponentSemanticsEntitiesMap
      ?definitionType
      ?typeName
     ;
  #--- Formal argument
    @lstring attributeName ;
    $identifier$ ? attributeName ;
    [!?tableAttributs insertKey ! attributeName !definitionType] ;
    listeTousAttributsSemantiques += !definitionType ! attributeName ;
    listeAttributsSemantiquesCourants += !definitionType ! attributeName ;
    outAttributeListModel += !typeName ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     E X T E R N   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $extern$ ;
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
#--- Parse C++ class name
  $class$ ;
  @lstring cppClassName ;
  $identifier$ ? cppClassName ;
  $in$ ;
  @lstring path ;
  $literal_string$ ? path ; 
  ${$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes modifiersMap [emptyMap] ;
  @typeTableMethodes readersInInstructionMap [emptyMap] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [emptyList] ;
  @M_externTypeConstructorMap constructorsMap [emptyMap] ;
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !?ioComponentSemanticsEntitiesMap
        ?type_semantique
        !?tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
    end repeat ;
    $;$ ;
    [!?constructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
  while
    $reader$ ;
  #--- Method name
    @lstring methodName ;
    $identifier$ ? methodName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @L_signature signatureForGrammarComponent ; # Not used here
    <formal_arguments_list>
      !?ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent
    ;
    $;$ ;
    [!?readersInInstructionMap insertKey !methodName !listeDeTypes] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring methodName ;
      $identifier$ ? methodName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      [!?modifiersMap insertKey !methodName !listeDeTypes] ;
    or
      $+=$ ;
      @location errorLocation := here ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ; # Not used here
        <formal_argument_type>
          !?ioComponentSemanticsEntitiesMap
          ?type_semantique
          !?tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
      end repeat ;
      if acceptAddAssignOperatorCall then
        error errorLocation : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
    end select ;
    $;$ ;
  end repeat ;
#--- enter the new type into the list of entities to be generated
  @typeEntityToGenerate t := [@typeExternTypeToGenerate new !externTypeName !cppClassName !path] ;
  listeEntitesAengendrer += !t ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new !externTypeName
                                                 !cppClassName
                                                 !constructorsMap
                                                 !modifiersMap
                                                 !readersInInstructionMap
                                                 !acceptAddAssignOperatorCall
                                                 !addAssignOperatorCallTypeList] ;
  @AC_semanticsEntity e := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !e] ;
  $}$ ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $extern$ ;
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
#--- Parse C++ class name
  $class$ ;
  @lstring cppClassName ;
  $identifier$ ? cppClassName ;
  $in$ ;
  $literal_string$ ? * ; 
  ${$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes EXmodifiersMap [emptyMap] ;
  @typeTableMethodes readersInInstructionMap [emptyMap] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [emptyList] ;
  @M_externTypeConstructorMap EXconstructorsMap [emptyMap] ;
  @constructorMap constructorMap [emptyMap] ;
  @readerMap readerMap [emptyMap] ;
  @modifierMap modifierMap [emptyMap] ;
  @typeListModel addAssignFormalInputArgumentList [emptyList] ; # List is empty if += operator is not defined
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [emptyList] ;
    @typeListModel formalInputArgumentList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !?ioComponentSemanticsEntitiesMap
        ?type_semantique
        !?tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
      formalInputArgumentList += !galgasTypeName ;
    end repeat ;
    $;$ ;
    [!?EXconstructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
    [!?constructorMap insertKey !constructorName ! formalInputArgumentList] ;
  while
    $reader$ ;
  #--- Reader name
    @lstring readerName ;
    $identifier$ ? readerName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @L_signature signature ;
    <formal_arguments_list>
      !?ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signature
    ;
    $;$ ;
    [!?readersInInstructionMap insertKey !readerName !listeDeTypes] ;
    [!?readerMap insertKey !readerName !signature] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring modifierName ;
      $identifier$ ? modifierName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @L_signature signature ;
      <formal_arguments_list>
        !?ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signature
      ;
      [!?EXmodifiersMap insertKey ! modifierName !listeDeTypes] ;
      [!?modifierMap insertKey !modifierName !signature] ;
    or
      $+=$ ;
      if [addAssignFormalInputArgumentList length] > 0 then
        error here : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ;
        <formal_argument_type>
          !?ioComponentSemanticsEntitiesMap
          ?type_semantique
          !?tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
        addAssignFormalInputArgumentList += !galgasTypeName ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new !externTypeName
                                                 !cppClassName
                                                 !EXconstructorsMap
                                                 !EXmodifiersMap
                                                 !readersInInstructionMap
                                                 !acceptAddAssignOperatorCall
                                                 !addAssignOperatorCallTypeList] ;
  @AC_semanticsEntity e := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !e] ;
  @TypeModel t := [@ExternTypeModel new !constructorMap !readerMap !modifierMap !addAssignFormalInputArgumentList] ;
  [!? ioModelMap insertKey !externTypeName !t] ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                            Type d'un argument                             *
#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    extract type_semantique->@typeGalgasUndefinedListType (?*) error outGalgasTypeName : messageGalgasType ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    extract type_semantique->@typeGalgasUndefinedMapType (?*) error outGalgasTypeName : messageGalgasType ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    extract entite->@typeEntiteType (?type_semantique) error outGalgasTypeName : messageTypeEntite ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    extract type_semantique->@typeGalgasUndefinedClassType (?*) error outGalgasTypeName : messageGalgasType ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                   DECLARATION D'UNE ACTION EXTERNE                        *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $action$ ;
  @lstring nomAction ;
  $identifier$ ?nomAction ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ; # Not used here
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  @AC_semanticsEntity entite := [@typeEntiteActionExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !nomAction !entite] ;
  @typeEntityToGenerate ea := [@typeActionExterneAengendrer new !nomAction !listeDeTypes] ;
  listeEntitesAengendrer += !ea ;
  $;$ ;    
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $action$ ;
  @lstring actionName ;
  $identifier$ ? actionName ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signature ;
  <formal_arguments_list>
    !?ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;
  @AC_semanticsEntity entite := [@typeEntiteActionExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ! actionName !entite] ;
  [!?ioExternActionMap insertKey !actionName !signature !true] ;
  $;$ ;    
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [emptyMap] ;
#--- Messages map
  @typeEnumMessageMap enumMessageMap [emptyMap] ;
  repeat
    @lstring constantName ;
    $identifier$ ? constantName ;
    [!?constantMap insertKey !constantName] ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
  ${$ ;
#--- Enum messages
  repeat
  while
    $message$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
    $:$ ;
    @typeEnumCstMessageStringMap cstMessageStringMap [emptyMap] ;
    repeat
      @lstring cstName ;
      $identifier$ ? cstName ;
      $->$ ;
      @lstring cstString ;
      $literal_string$ ? cstString ;
      [!?cstMessageStringMap insertKey !cstName !cstString] ;
      $;$ ;
    while
    end repeat ;
    $end$ ;
  #--- Build message string list
    @L_lstringList messageStringList [emptyList] ;
    foreach constantMap (??@lstring constantName) :
      @lstring name := [@lstring new ![constantName string] !here] ; #--- For best error location
      @lstring cstString ;
      [cstMessageStringMap searchKey !name ?cstString] ;
      messageStringList += !cstString ;
    end foreach ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName !messageStringList] ;
    $message$ ;
    $;$ ;
  end repeat ;
#--- End type definition end
  $}$ ;
#---- Enter enum datas into the list of entities to generate
  @typeEntityToGenerate e := [@enumGalgasType new !enumTypeName !constantMap !enumMessageMap] ;
  listeEntitesAengendrer += !e ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new !enumTypeName !constantMap !enumMessageMap] ;
  @AC_semanticsEntity ee := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !ee] ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [emptyMap] ;
  repeat
    @lstring constantName ;
    $identifier$ ? constantName ;
    [!?constantMap insertKey !constantName] ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
  ${$ ;
#--- Messages map
  @typeEnumMessageMap exEnumMessageMap [emptyMap] ;
  @enumMessageMap enumMessageMap [emptyMap] ;
  repeat
  while
    $message$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName] ;
    @L_lstringList messageStringList [emptyList] ;
    [!? exEnumMessageMap insertKey !messageName !messageStringList] ;
    $:$ ;
    repeat
      $identifier$ ? * ;
      $->$ ;
      $literal_string$ ? * ;
      $;$ ;
    while
    end repeat ;
    $end$ ;
    $message$ ;
    $;$ ;
  end repeat ;
  $}$ ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new !enumTypeName !constantMap !exEnumMessageMap] ;
  @AC_semanticsEntity e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !e] ;
  @TypeModel type := [@EnumModel new !constantMap !enumMessageMap] ;
  [!?ioModelMap insertKey !enumTypeName !type] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
