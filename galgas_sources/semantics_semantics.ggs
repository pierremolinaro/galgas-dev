#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component semantics definition                          *
#                                                                           *
#  Copyright (C) 1997-2004 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semantics_semantics :

import semantics common_semantics in "common_semantics.ggs" ;

#---------------------------------------------------------------------------*
#                                                                           *
#       C++ NAME FOR A FORMAL PARAMETER OR LOCAL VARIABLE                   *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is the value of mName

class @typeDirectName extends @typeCplusPlusName {
  @lstring mName ;
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for local method call)

class @typeCppThisName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for inherited method call)

class @typeCppInheritedName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of mName

class @typeAutomaticName extends @typeCplusPlusName {
  @lstring mName ;
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of location

class @typeLocationAutomaticName extends @typeCplusPlusName {
  @location mLocation ;
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->zz' followed by the value of mName

class @typeOperandName extends @typeCplusPlusName {
  @lstring mName ;
  @location mLocationOffset ;
  @bool mFieldKind ; # false : zz est vide ; true : zz est 'mInfo.'
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->mKey' followed by the value of mName

class @typeKeyName extends @typeCplusPlusName {
  @location mLocationOffset ;
}

#---------------------------------------------------------------------------*
# No variable

class @typeNullName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A LIST OF C++ NAMES                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeCplusPlusNameList {
  @typeCplusPlusName mCppName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   E X P R E S S I O N    A B S T R A C T    C L A S S                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeExpression {
}
 
#---------------------------------------------------------------------------*
#                                                                           *
#   C L A S S    M E S S A G E    M A P                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassMessagesMap {
  @lstring mMessage ;
  insert insertKey error message "the message '" . * . "' is already declared" ;
  search searchKey error message "the message '" . * . "' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S E M A N T I C S   T Y P E S   L I S T                                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeSemanticsTypesList {
  @AC_galgasType mType ;
  @lstring mGalgasVariableName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  V A R I A B L E S    M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeVariablesMap
  class cGalgasVariablesMap in "cGalgasVariablesMap.h", "cGalgasVariablesMap.hh" ;
#--- Inserting
  insert insertInArgument error message "the variable '%' is already declared" ;
  insert insertConstInArgument error message "the variable '%' is already declared" ;
  insert insertUsedConstInArgument error message "the variable '%' is already declared" ;
  insert insertUnusedConstInArgument error message "the variable '%' is already declared" ;
  insert insertLocalVariable error message "the variable '%' is already declared" ;
  insert insertOutArgument error message "the variable '%' is already declared" ;
  insert insertInOutArgument error message "the variable '%' is already declared" ;
  insert insertUnusedInOutArgument error message "the variable '%' is already declared" ;
#--- Searching
  search searchForReadOnlyAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in read only mode" ;
  search searchForDestructiveReadAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in destructive read mode" ;
  search searchForReadWriteAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in read/write mode" ;
  search searchForWriteAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in write mode" ;
#--- Blocks
  block  verifyVariableUsing : () : (?@location positionErreur) ;
  block  testBloc : () : () ;
  block  testPart : () : (?@location positionErreur) ;
  block  repeatBlock : () : () ;
  block  repeatPart : () : (?@location positionErreur) ;
#--- Attributes
  @AC_galgasType mArgumentType ;
  @typeCplusPlusName mCplusPlusName ;
}

#---------------------------------------------------------------------------*

list @L_assignedVariables  {
  @typeCplusPlusName aNomVariableCible ;
  @lstring aNomAttributSource ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                            class 'typeCible'                              *
#     Est utilise pour denoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCible {
  abstract reader verifierType ?@AC_galgasType typeArgumentFormel
                               ?!@lstring nomAttributSource
                               ?!@L_assignedVariables listeAffectations
                               ?!@typeCplusPlusNameList outAllVariablesList ;
}

#---------------------------------------------------------------------------*

list @typeListeCibles {
  @typeCible aCible ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#     Liste des types et des noms C++ des arguments d'une methode           *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListeTypesEtNomsArgMethode {
  @AC_galgasType mType ;
  @formalArgumentPassingMode mFormalArgumentPassingMode ;
  @typeCplusPlusName mCppName ;
  @bool aModeIn ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type abstrait instruction d'une methode              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeInstruction {
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type list d'instructions d'une methode               *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeInstructionsList {
  @typeInstruction aInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                  Liste d'attributs externes                               *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_nameWithType {
  @lstring mType ;
  @lstring mName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Table des methodes (d'une classe a implementer)              *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodesAimplementer
  class cTableMethodesAimplementer in "cTableMethodesAimplementer.h", "cTableMethodesAimplementer.hh" ;
  insert insertAbstract error message "the method '%' is already declared" ;
  insert insertNotAbstract error message "the method '%' is already declared" ;
  @L_signature aListeTypesParametres ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionsList mInstructionsList ;
}

#---------------------------------------------------------------------------*
#   E X P R E S S I O N S    L I S T                                        *
#---------------------------------------------------------------------------*

list @typeExpressionList {
  @typeExpression mExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    E R R O R    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeErrorInstruction extends @typeInstruction {
  @typeExpression mErrorLocationExpression ;
  @typeExpression mErrorMessageExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    W A R N I N G    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeWarningInstruction extends @typeInstruction {
  @typeExpression mWarningLocationExpression ;
  @typeExpression mWarningMessageExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    M E S S A G E    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMessageInstruction extends @typeInstruction {
  @typeExpression mMessageExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   R E A D E R    C A L L    I N S T R U C T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeReaderCallInstruction extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M O D I F I E R    C A L L    I N S T R U C T I O N                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeModifierCallInstruction extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction d'appel d'une methode de list                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelMethodeListe extends @typeInstruction {
  @typeCplusPlusName aNomCppAttribut ;
  @lstring aMethodeDeListe ;
  @typeCplusPlusNameList aListeNomsCppArguments ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction de declaration d'une variable locale                *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionDeclarationVarLocale extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @AC_galgasType aTypeVariable ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#               'block...' instruction for a map                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMapBlockPrologueInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mPrologueExpressionList ;
}

#---------------------------------------------------------------------------*

class @typeMapBlockEpilogueInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mEpilogueExpressionList ;
}

#---------------------------------------------------------------------------*
#   R E A D E R    C A L L    O P E R A N D                                 *
#---------------------------------------------------------------------------*

class @typeReaderCallInExpression extends @typeExpression {
  @typeExpression mExpressionValue ;
  @lstring mReaderName ;
  @typeExpressionList mExpressionList ;
}
 
#---------------------------------------------------------------------------*
#   B O O L E A N    O P E R A T I O N S                                    *
#---------------------------------------------------------------------------*

class @typeAndOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeOrOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeConcatOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeTrueBool extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeFalseBool extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeLiteralStringExpression extends @typeExpression {
  @lstring mLiteralString ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralUIntExpression extends @typeExpression {
  @luint mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralSIntExpression extends @typeExpression {
  @lsint mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralCharExpression extends @typeExpression {
  @lchar mLiteralChar ;
}
 
#---------------------------------------------------------------------------*

class @typeHereExpression extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeConstructorExpression extends @typeExpression {
  @lstring mClassName ;
  @lstring mClassMethodName ;
  @typeExpressionList mExpressionList ;
}
 
#---------------------------------------------------------------------------*

class @typeTestComplement extends @typeExpression {
  @typeExpression mTest ;
}
 
#---------------------------------------------------------------------------*

class @typeBoolOption extends @typeExpression {
  @lstring mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*

class @typeUIntOption extends @typeExpression {
  @lstring mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*
#   S I M P L E    V A R I A B L E                                          *
#---------------------------------------------------------------------------*

class @typeVarInExpression extends @typeExpression {
  @typeCplusPlusName mCppVarName ;
}
 
#---------------------------------------------------------------------------*
#   J O K E R    E X P R E S S I O N                                        *
#---------------------------------------------------------------------------*

class @typeJokerInExpression extends @typeExpression {
  @location mLocation ;
}
 
#---------------------------------------------------------------------------*
#   C O M P A R E    O P E R A T I O N S                                    *
#---------------------------------------------------------------------------*

class @typeEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeNonEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeStrictInfTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeInfOrEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeStrictSupTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeSupOrEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   C A L L    T E S T    M E T H O D    F O R    M A P                     *
#---------------------------------------------------------------------------*

class @typeTextTableCall extends @typeExpression {
  @typeExpression mExpression ;
  @lstring aNomMethodeTest ;
  @typeCplusPlusName aNomCppClef ;
}
 
#---------------------------------------------------------------------------*
#                                                                           *
#   A S S I G N M E N T    I N S T R U C T I O N                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_assignmentInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C L A R A T I O N    I N S T R U C T I O N                          *
#                                                                           *
#   W I T H    A S S I G N M E N T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_declarationInstructionWithAssignment extends @typeInstruction {
  @AC_galgasType mVariableType ;
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " I F "   I N S T R U C T I O N                                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_expression_instructionsList_list {
  @typeExpression mIFexpression ;
  @typeInstructionsList mInstructionsList ;
}

#---------------------------------------------------------------------------*

class @C_if_instruction extends @typeInstruction {
  @L_expression_instructionsList_list mIFbranchesList ;
  @typeInstructionsList mElseInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Definition de la map des routines a implementer                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableRoutinesAimplementer {
  insert insertKey error message "the routine '" . * . "' is already declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# Table des attributs semantiques internes (pour list d'instructions)       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableAttributsSemantiques {
  @typeCplusPlusName aNomCppAttribut ;
  @AC_galgasType mAttributType ;
  insert insertKey error message "the attribute '" . * . "' is already declared" ;
  search searchKey error message "the attribute '" . * . "' is not declared" ;
}

#---------------------------------------------------------------------------*

routine buildMapWithLocalConstants
  ?@L_nameWithType inLocalDeclarationsList
  ?@typeListeAttributsSemantiques inSemanticAttributsList
  ?!@typeVariablesMap ioVariablesMap
  ?@location inLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  ?@bool inEllipsisFound
:
  @bool mapStyle := inLocalConstantStyle != [@localConstantBuildStyleEnum listStyle] ;
  @bool first := true ;
  foreach inLocalDeclarationsList (??@lstring typeNameInDeclaration ??@lstring cstName),
          inSemanticAttributsList (??@AC_galgasType type ??@lstring attributeName) :
    if [cstName value] != "" then
      @string typeName ;
      [type getTypeName ? typeName] ;
      if [typeNameInDeclaration value] == typeName then
        @typeCplusPlusName cppName ;
        if (inLocalConstantStyle == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & first then
          cppName := [@typeKeyName new !inLocation] ;
        else
          cppName := [@typeOperandName new !attributeName !inLocation !mapStyle] ;
        end if ;
        [!?ioVariablesMap insertUsedConstInArgument !cstName !type !cppName] ;
      else
        error typeNameInDeclaration : "I have found the '@" . [typeNameInDeclaration value]
          . "' type, I was expected the '@" . typeName . "' type" ;
      end if ;
    end if ;
    first := false ;
  end foreach ;
#--- Check effective parameters list length
  if ([inLocalDeclarationsList length] < [inSemanticAttributsList length]) & not inEllipsisFound then
    error here : "one or more parameters missing: found "
    . [[inLocalDeclarationsList length] string] . " effective parameters, while "
    . [[inSemanticAttributsList length] string] . " are needed" ;
  elsif [inLocalDeclarationsList length] > [inSemanticAttributsList length] then
    error here : "too much parameters: found "
    . [[inLocalDeclarationsList length] string] . " effective parameters, while "
    . [[inSemanticAttributsList length] string] . " are needed" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#       CHECK ASSIGNMENT TYPE COMPATIBILITY                                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkAssignmentTypesCompatibility
  ?@AC_galgasType targetType
  ?@AC_galgasType sourceType
  ?@location inErrorLocation
:
  match targetType :: sourceType :
  when @typeGalgas_stringset () :: @typeGalgas_stringset () :
  when @typeGalgas_uint () :: @typeGalgas_uint () :
  when @typeGalgas_sint () :: @typeGalgas_sint () :
  when @typeGalgas_char () :: @typeGalgas_char () :
  when @typeGalgas_string () :: @typeGalgas_string () :
  when @typeGalgas_bool () :: @typeGalgas_bool () :
  when @typeGalgas_double() :: @typeGalgas_double () :
  when @typeGalgas_ldouble () :: @typeGalgas_ldouble () :
  when @typeGalgas_location () :: @typeGalgas_location () :

#--- Assignment to lchar 
  when @typeGalgas_lchar () :: @typeGalgas_lchar () :
#--- Assignment to luint 
  when @typeGalgas_luint () :: @typeGalgas_luint () :
#--- Assignment to lsint 
  when @typeGalgas_lsint () :: @typeGalgas_lsint () :
#--- Assignment to lstring
  when @typeGalgas_lstring () :: @typeGalgas_lstring () :
#--- Assignment to lbool type
  when @typeGalgas_lbool () :: @typeGalgas_lbool () :

  when @typeGalgasUndefinedExternType (??@lstring attNomType1 ??*)
    :: @typeGalgasUndefinedExternType (??@lstring attNomType2 ??*) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting an extern variable of extern '" . [attNomType1 value] .
                                "' type variable, and I got an extern '" . [attNomType2 value] . "' type variable" ;
    end if ;

  when @typeGalgasUndefinedListType (??@lstring attNomType1) :: @typeGalgasUndefinedListType (??@lstring attNomType2) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting a '" . [attNomType1 value] .
                                "' list type variable, and I got a '" . [attNomType2 value] . "' list type variable" ;
    end if ;

  when @typeGalgasClassType (??@lstring attNomType1 ??* ??* ??* ??* ??* ??*)
    :: @typeGalgasClassType (??@lstring attNomType2 ??* ??* ??@typeSuperClassesMap attAncestorClassesMap2 ??* ??* ??*) :
    if [attNomType1 value] == [attNomType2 value] then
    elsif not [attAncestorClassesMap2 hasKey ![attNomType1 value]] then
      error inErrorLocation : "The '" . [attNomType2 value] .
                              "' does not inherit from '" . [attNomType2 value] . "' class" ;
    end if ;

  when @typeGalgasUndefinedClassType (??@lstring attNomType1) :: @typeGalgasUndefinedClassType (??@lstring attNomType2) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting a '" . [attNomType1 value] .
                              "' class type variable, and I got a '" . [attNomType2 value] . "' class type variable" ;
    end if ;

  when @typeGalgasUndefinedMapType (??@lstring attNomType1) :: @typeGalgasUndefinedMapType (??@lstring attNomType2) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting a '" . [attNomType1 value] .
                              "' map type variable, and I got a '" . [ attNomType2 value] .
                              "' map type variable" ;
    end if ;

  when @typeGalgas_enum (??@lstring aTypeName1 ??* ??*)
    :: @typeGalgas_enum (??@lstring aTypeName2 ??* ??*) :
    if [aTypeName1 value] != [aTypeName2 value] then
      error inErrorLocation : "I was expecting an enum variable of  '" . [aTypeName1 value] .
                              "' type variable, and I got an enum '" . [aTypeName2 value] .
                              "' type variable" ;
    end if ;
  else
    error inErrorLocation : [targetType messageGalgasType] . " cannot be assigned from " . 
                            [sourceType messageGalgasType] ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ITERATEUR (DOUBLE) DE VERIFICATION DE COMPATIBILITE ENTRE             *
#   ENTRE UNE LISTE DE TYPES ET UNE LISTE D'ATTRIBUTS SEMANTIQUES           *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteTypes
  ?@typeSemanticsTypesList t1
  ?@typeListeAttributsSemantiques t2
  ??@location inErrorLocation
:
  if [t1 length] < [t2 length] then
    error inErrorLocation : "one or more identifiers missing" ;
  elsif [t1 length] > [t2 length] then
    error inErrorLocation : "too much identifiers" ;
  else
    foreach t1 (??@AC_galgasType attTypeEffectif ??@lstring attNomVariableEffectif),
            t2 (??@AC_galgasType attTypeAttributFormel ??@lstring attNomAttributFormel) :
      verifierCompatibiliteTypesSemantiques !attTypeEffectif !attTypeAttributFormel ![attNomVariableEffectif location] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VERIFICATION DE COMPATIBILITE ENTRE UNE SIGNATURE ET UN APPEL         *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteArgEffectifsSignature
  ?@L_signature signatureReference
  ?@L_actualParametersSignature inEffectiveArgumentsSignature
  ??@location inErrorLocation
  ?!@typeInstructionsList ioInstructionsList
  ?!@typeExpressionList ioExpressionList
:
  if [signatureReference length] > [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "one or more arguments missing" ;
  elsif [signatureReference length] < [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "too much arguments" ;
  else
  #--- Check signatures
    foreach signatureReference (??@AC_galgasType attSignatureType ??@formalArgumentPassingMode formalArgPassingMode),
            inEffectiveArgumentsSignature (??@AC_galgasType attEffectiveType ??@actualParametersPassingMode parameterPassingMode) :
      match formalArgPassingMode::parameterPassingMode :
      when argumentConstantIn :: parameterOut :
        verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
      when argumentIn :: parameterOut :
        verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
      when argumentInOut :: parameterOutIn :
        verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
      when argumentOut :: parameterIn :
        extract attEffectiveType :
        when @typeGalgas_jokerInParameterList () ->
        else
          verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
        end extract ;
      else
        error inErrorLocation : [parameterPassingMode actualArgumentMessage] . " is not compatible with " .
                                [formalArgPassingMode formalArgumentMessage] ;
      end match ;
    end foreach ;
  #--- Build expression list
    @typeExpressionList expressionList := ioExpressionList ;
    ioExpressionList := [@typeExpressionList empty] ;
    foreach signatureReference (??@AC_galgasType attSignatureType ??*),
            expressionList (??@typeExpression attExpressionType) :
      extract attExpressionType :
      when @typeJokerInExpression (??@location kLocation) ->
        @typeCplusPlusName cppVarName := [@typeLocationAutomaticName new !kLocation] ;
        @typeExpression e := [@typeVarInExpression new ! cppVarName] ;
        ioExpressionList += !e ;
        @typeInstruction i := [@typeInstructionDeclarationVarLocale new !cppVarName !attSignatureType] ;
        ioInstructionsList += !i ;
      else
        ioExpressionList += !attExpressionType ;
      end extract ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           class 'typeJoker'                               *
#     Est utilise pour denoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

class @typeJoker extends @typeCible {
  override reader verifierType ?@AC_galgasType typeArgumentFormel
                               ?!@lstring unused nomAttributSource
                               ?!@L_assignedVariables unused listeAffectations
                               ?!@typeCplusPlusNameList outAllVariablesList :
    @typeCplusPlusName nullName := [@typeNullName new] ;
    outAllVariablesList += !nullName ;
  end reader ;
}

#---------------------------------------------------------------------------*

class @typeEntiteDest extends @typeCible {
  @AC_galgasType aTypeVarDest ;
  @typeCplusPlusName mCppName ;
  @location aPositionVariableCible ;

  override reader verifierType ?@AC_galgasType typeArgumentFormel
                               ?!@lstring nomAttributSource
                               ?!@L_assignedVariables listeAffectations
                               ?!@typeCplusPlusNameList outAllVariablesList :
    @location positionErreur := aPositionVariableCible ;
    verifierCompatibiliteTypesSemantiques !aTypeVarDest !typeArgumentFormel !positionErreur ;
    listeAffectations += !mCppName !nomAttributSource ;
    outAllVariablesList += !mCppName ;
  end reader ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Entite 'not-terminal'                                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeEntiteNonTerminal extends @AC_semanticsEntity {
  @M_nonterminalSymbolAlts mAltParametersMap ;
  message messageTypeEntite "a nonterminal symbol" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Grammar instruction                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarInstruction extends @typeInstruction {
  @typeCplusPlusName mSourceFileCppName ;
  @lstring mGrammarName ;
  @typeExpressionList mExpressionsList ;
  @lstring mAltSymbol ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          += instruction (without luint assignment)                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeAppendInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpressionList mSourceExpressions ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          ++ instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeIncrementInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          += instruction (with luint assignment)                           *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeAppendInstructionWithAssignment extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpressionList mSourceExpressions ;
  @typeCplusPlusName m_luint_TargetVarCppName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                Instruction d'appel d'action extern                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelActionExterne extends @typeInstruction {
  @lstring aNomAction ;
  @typeExpressionList mExpressionsList ;
  @L_signature aListeTypesParametresFormels ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C A S E S    L I S T    F O R    M A T C H    I N S T R U C T I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_matchInstructionCasesList {
  @lstring mCase1_name ;
  @lstring mCase2_name ;
  @typeInstructionsList mInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#     M A T C H    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMatchInstruction extends @typeInstruction {
  @location aIndicatif1 ;
  @location aIndicatif2 ;
  @typeCplusPlusName aNomCppVariable1 ;
  @typeCplusPlusName aNomCppVariable2 ;
  @lstring aNomTypeBase1 ;
  @lstring aNomTypeBase2 ;
  @bool mOperand1_isEnumeration ;
  @bool mOperand2_isEnumeration ;
  @L_matchInstructionCasesList aListeCas ;
  @typeInstructionsList mElseInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  Instruction                                                              *
#    foreach var ??@... name ??@... name, ... :                             *
#      instructions                                                         *
#    end foreach ;                                                          *
#                                                                           *
#---------------------------------------------------------------------------*

list @foreachEnumerationList  {
  @typeCplusPlusName mCppEnumeratedVariableName ;
  @location mLocationOffset ;
  @string mCppTypeName ;
}

#---------------------------------------------------------------------------*

class @typeForeachInstruction extends @typeInstruction {
  @foreachEnumerationList mForeachEnumerationList ;
  @typeExpression mWhileExpression ;
  @typeInstructionsList mInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'extract ...'                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeSimpleExtractInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariable ;
  @lstring aNomClasse ;
  @L_assignedVariables aListeAffectationParametresEffectifs ;
  @typeExpression mErrorLocationExpression ;
  @lstring aNomMessage ;
}

#----------------------------------------------------------------------*
#                                                                      *
#                    Structured instruction 'extract ...'              *
#                                                                      *
#----------------------------------------------------------------------*

list @typeStructuredExtractCasesList {
  @lstring mClassName ;
  @location mResultVarID ;
  @typeInstructionsList mInstructionsList ;
  @bool mNoUsedParameter ;
}

#----------------------------------------------------------------------*

class @typeStructuredExtractInstructionWithElse extends @typeInstruction {
  @typeCplusPlusName mVariableName ;
  @typeStructuredExtractCasesList mCasesList ;
  @typeInstructionsList mElseInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    Routine call instruction                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeRoutineCallInstruction extends @typeInstruction {
  @lstring aNomRoutine ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    'drop ...' instruction                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeDropInstruction extends @typeInstruction {
  @typeCplusPlusName aVariableConsommee ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Table des routines declarees par un prototype                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableNomRoutinesDeclarees {
  insert insertKey error message "the routine '" . * . "' is already declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Entites a engendrer                                          *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeEntityToGenerate {
}

#---------------------------------------------------------------------------*

class @typeExternTypeToGenerate extends @typeEntityToGenerate {
#--- Class name
  @lstring mName ;

#--- C++ class name
  @lstring mCppClassName ;
}

#---------------------------------------------------------------------------*

class @typeRoutineAengendrer extends @typeEntityToGenerate {
  @lstring aNomRoutine ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionsList mInstructionsList ;
}

#---------------------------------------------------------------------------*

class @C_listTypeToImplement extends @typeEntityToGenerate {
  @lstring aNomListe ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
}

#---------------------------------------------------------------------------*

class @typeDefinitionTableAimplementer extends @typeEntityToGenerate {
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @lstring aNomClasseGenerique ;
  @insertOrSearchMethodList mInsertMethodList ;
  @insertOrSearchMethodList mSearchMethodList ;
  @typeTableBlocsDeTable aTableMethodesSurcharger ;
}

#---------------------------------------------------------------------------*

map @stateMap {
  insert insertKey error message "the '" . * . "' state is already declared"  ;
  search searchKey error message "the '" . * . "' state is not declared" ;
}

#---------------------------------------------------------------------------*

class @C_mapToImplement extends @typeEntityToGenerate {
  @stateMap mStateMap ;
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @insertOrSearchMethodList mInsertMethodList ;
  @insertOrSearchMethodList mSearchMethodList ;
}

#---------------------------------------------------------------------------*

class @typeDefClasseAbstraiteAimplementer extends @typeEntityToGenerate {
  @lstring aNomClasse ;

#--- Liste de tous les attributs not externes, y compris ceux definis dans une classe mere
  @typeListeAttributsSemantiques aListeTousAttributsNonExternes ;  

#--- Table de toutes les methodes, y compris celles heritees
  @typeTableMethodes aTableToutesMethodes ;

#--- Table des methodes de la classe abstract
  @typeTableMethodesAimplementer mMethodsMap ;

#--- Liste des attributs semantiques not externes definis dans cette classe
  @typeListeAttributsSemantiques aListeAttributsCourants ;

#--- Liste des attributs externes definis dans cette classe
  @L_nameWithType aListeExternesCourants ;

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;

#--- Table des messages
  @typeClassMessagesMap mMessagesMap ;
}

#---------------------------------------------------------------------------*

class @typeDefClasseNonAbstraiteAimplementer extends @typeEntityToGenerate {
  @lstring aNomClasse ;

#--- Liste de tous les attributs not externes, y compris ceux definis dans une classe mere
  @typeListeAttributsSemantiques aListeTousAttributsNonExternes ;  

#--- Table de toutes les methodes, y compris celles heritees
  @typeTableMethodes aTableToutesMethodes ;

#--- Table des methodes de la classe a implementer
  @typeTableMethodesAimplementer mMethodsMap ;

#--- Liste des attributs semantiques not externes definis dans cette classe
  @typeListeAttributsSemantiques aListeAttributsCourants ;

#--- Liste des attributs externes definis dans cette classe
  @L_nameWithType aListeExternesCourants ;

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;  

#--- Table des messages concrets de la classe courante
  @typeClassMessagesMap mMessagesMap ;  
}

#---------------------------------------------------------------------------*

class @typeEntiteActionExterne extends @AC_semanticsEntity {
  @L_signature aSignature ;
  message messageTypeEntite "an external action" ;
}

#---------------------------------------------------------------------------*

class @typeActionExterneAengendrer extends @typeEntityToGenerate {
  @lstring aNomAction ;
  @L_signature aSignature ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Liste des entites a engendrer                                *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeEntitiesToGenerateList {
  @typeEntityToGenerate mEntityToGenerate ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#         E N T E R    B U I L T I N    T Y P E S                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterBuiltinTypes !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap :
  ioComponentSemanticsEntitiesMap := [@M_semanticsEntitiesForUse empty] ;

  @lstring name := [@lstring new !"lstring" !here] ;
  @AC_galgasType t := [@typeGalgas_lstring new] ;
  @AC_semanticsEntity e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"lbool" !here] ;
  t := [@typeGalgas_lbool new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"luint" !here] ;
  t := [@typeGalgas_luint new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"lsint" !here] ;
  t := [@typeGalgas_lsint new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"ldouble" !here] ;
  t := [@typeGalgas_ldouble new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"lchar" !here] ;
  t := [@typeGalgas_lchar new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"location" !here] ;
  t := [@typeGalgas_location new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"uint" !here] ;
  t := [@typeGalgas_uint new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"sint" !here] ;
  t := [@typeGalgas_sint new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"char" !here] ;
  t := [@typeGalgas_char new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"string" !here] ;
  t := [@typeGalgas_string new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"bool" !here] ;
  t := [@typeGalgas_bool new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"double" !here] ;
  t := [@typeGalgas_double new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;

  name := [@lstring new !"stringset" !here] ;
  t := [@typeGalgas_stringset new] ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !name !e] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumCstMessageStringMap {
  @lstring mMessageString ;
  insert insertKey error message "the message for '" . * . "' constant is already declared" ;
  search searchKey error message "the message for '" . * . "' constant is not declared" ;
}

#---------------------------------------------------------------------------*

class @enumGalgasType extends @typeEntityToGenerate {
  @lstring mEnumTypeName ;
  @typeEnumConstantesMap mConstantMap ;
  @typeEnumMessageMap mEnumMessageMap ;
}

#---------------------------------------------------------------------------*

action appendJokersIfNeeded
 ?!@typeCplusPlusNameList ioAllVariablesList
 ?@uint inEffectiveParametersCount
 ?@uint inFormalArgumentsCount
 ?@typeCplusPlusName inNullName
;

#---------------------------------------------------------------------------*

end semantics ;
