#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component semantics definition                          *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semantics_semantics :

import semantics common_semantics in "common_semantics.ggs" ;

#---------------------------------------------------------------------------*
#                                                                           *
#       C++ NAME FOR A FORMAL PARAMETER OR LOCAL VARIABLE                   *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is the value of mName

class @typeDirectName extends @typeCplusPlusName {
  @lstring mName ;
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for local method call)

class @typeCppThisName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for inherited method call)

class @typeCppInheritedName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of mName

class @typeAutomaticName extends @typeCplusPlusName {
  @lstring mName ;
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of an unique sequence number

class @typeLocationAutomaticName extends @typeCplusPlusName {
  @uint mSequenceNumber ;
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->zz' followed by the value of mName

class @typeOperandName extends @typeCplusPlusName {
  @lstring mName ;
  @location mLocationOffset ;
  @bool mFieldKind ; # false : zz est vide ; true : zz est 'mInfo.'
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->mKey' followed by the value of mName

class @typeKeyName extends @typeCplusPlusName {
  @location mLocationOffset ;
}

#---------------------------------------------------------------------------*
# No variable

class @typeNullName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A LIST OF C++ NAMES                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeCplusPlusNameList {
  @typeCplusPlusName mCppName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   E X P R E S S I O N    A B S T R A C T    C L A S S                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeExpression {
}
 
#---------------------------------------------------------------------------*
#                                                                           *
#   C L A S S    M E S S A G E    M A P                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassMessagesMap {
  @lstring mMessage ;
  insert insertKey error message "the message '%K' is already declared in %L" ;
  search searchKey error message "the message '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S E M A N T I C S   T Y P E S   L I S T                                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeSemanticsTypesList {
  @AC_galgasType mType ;
  @lstring mGalgasVariableName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  V A R I A B L E S    M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeVariablesMap
  class cGalgasVariablesMap ;
#--- Inserting
  insert insertListOfEntitiesLocalVariable error message "the variable '%' is already declared" ;
  insert insertSingleEntityLocalVariable error message "the variable '%' is already declared" ;
  insert insertEntityAttributeLocalVariable error message "the variable '%' is already declared" ;
  insert insertInArgument error message "the variable '%' is already declared" ;
  insert insertUnusedInArgument error message "the variable '%' is already declared" ;
  insert insertConstInArgument error message "the variable '%' is already declared" ;
  insert insertUsedConstInArgument error message "the variable '%' is already declared" ;
  insert insertUsedConstInArgumentNoShadow error message "the variable '%' is already declared" ;
  insert insertUnusedConstInArgument error message "the variable '%' is already declared" ;
  insert insertLocalVariable error message "the variable '%' is already declared" ;
  insert insertOutArgument error message "the variable '%' is already declared" ;
  insert insertOutProperty error message "the variable '%' is already declared" ;
  insert insertInOutArgument error message "the variable '%' is already declared" ;
  insert insertUsedInOutArgument error message "the variable '%' is already declared" ;
  insert insertUnusedInOutArgument error message "the variable '%' is already declared" ;
#--- Searching
  search searchForReadOnlyAccess error message "the variable '%' cannot be accessed in read only mode" ;
  search searchForDestructiveReadAccess error message "the variable '%' cannot be accessed in destructive read mode" ;
  search searchForReadWriteAccess error message "the variable '%' cannot be accessed in read/write mode" ;
  search searchForWriteAccess error message "the variable '%' cannot be accessed in write mode" ;
#--- Blocks
  block  verifyVariableUsing : () : (?@location positionErreur) ;
  block  testBloc : () : () ;
  block  testPart : () : (?@location positionErreur) ;
  block  repeatBlock : () : () ;
  block  repeatPart : () : (?@location positionErreur) ;
#--- Attributes
  @AC_galgasType mArgumentType ;
  @typeCplusPlusName mCplusPlusName ;
}

#---------------------------------------------------------------------------*

list @L_assignedVariables  {
  @typeCplusPlusName aNomVariableCible ;
  @lstring aNomAttributSource ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                            class 'typeCible'                              *
#     Est utilise pour denoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCible {
  abstract method verifierType
    ??@AC_galgasType typeArgumentFormel
    ?!@lstring nomAttributSource
    ?!@L_assignedVariables listeAffectations
    ?!@typeCplusPlusNameList outAllVariablesList
  ;
}

#---------------------------------------------------------------------------*

list @typeListeCibles {
  @typeCible aCible ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#     Liste des types et des noms C++ des arguments d'une methode           *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListeTypesEtNomsArgMethode {
  @AC_galgasType mType ;
  @formalArgumentPassingMode mFormalArgumentPassingMode ;
  @typeCplusPlusName mCppName ;
  @bool mModeIn ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type abstrait instruction d'une methode              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeInstruction {
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type list d'instructions d'une methode               *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeInstructionList {
  @typeInstruction mInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                  Liste d'attributs externes                               *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_nameWithType {
  @lstring mType ;
  @lstring mName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Table des methodes (d'une classe a implementer)              *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodesAimplementer
  class cTableMethodesAimplementer ;
  insert insertAbstract error message "the method '%' is already declared" ;
  insert insertNotAbstract error message "the method '%' is already declared" ;
  @L_EXsignature aListeTypesParametres ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*
#   E X P R E S S I O N S    L I S T                                        *
#---------------------------------------------------------------------------*

list @typeExpressionList {
  @typeExpression mExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    E R R O R    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

list @varToDropList {
  @typeCplusPlusName mVarToDrop ;
}

#---------------------------------------------------------------------------*

class @typeErrorInstruction extends @typeInstruction {
  @typeExpression mErrorLocationExpression ;
  @typeExpression mErrorMessageExpression ;
  @location mLocation ;
  @varToDropList mVarToDropList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    W A R N I N G    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeWarningInstruction extends @typeInstruction {
  @typeExpression mWarningLocationExpression ;
  @typeExpression mWarningMessageExpression ;
  @location mLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    M E S S A G E    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMessageInstruction extends @typeInstruction {
  @typeExpression mMessageExpression ;
  @location mInstructionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   R E A D E R    C A L L    I N S T R U C T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMethodCallInstruction extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   T Y P E    M E T H O D    C A L L    I N S T R U C T I O N              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeCallOfTypeMethodInstruction extends @typeInstruction {
  @lstring mTypeName ;
  @lstring mTypeMethodName ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M O D I F I E R    C A L L    I N S T R U C T I O N                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeModifierCallInstruction extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction d'appel d'une methode de list                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelMethodeListe extends @typeInstruction {
  @typeCplusPlusName aNomCppAttribut ;
  @lstring aMethodeDeListe ;
  @typeCplusPlusNameList aListeNomsCppArguments ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction de declaration d'une variable locale                *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionDeclarationVarLocale extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @AC_galgasType aTypeVariable ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#               'block...' instruction for a map                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMapBlockPrologueInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mPrologueExpressionList ;
}

#---------------------------------------------------------------------------*

class @typeMapBlockEpilogueInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mEpilogueExpressionList ;
}

#---------------------------------------------------------------------------*
#   R E A D E R    C A L L    O P E R A N D                                 *
#---------------------------------------------------------------------------*

class @typeReaderCallInExpression extends @typeExpression {
  @typeExpression mExpressionValue ;
  @lstring mReaderName ;
  @typeExpressionList mExpressionList ;
  @location mInstructionLocation ;
  @string mConversionMethod ;
}
 
#---------------------------------------------------------------------------*
#   B O O L E A N    O P E R A T I O N S                                    *
#---------------------------------------------------------------------------*

class @typeAndOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeOrOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeXorOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeConcatOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeTrueBool extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeFalseBool extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeLiteralStringExpression extends @typeExpression {
  @lstring mLiteralString ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralUIntExpression extends @typeExpression {
  @luint mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralSIntExpression extends @typeExpression {
  @lsint mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralUInt64Expression extends @typeExpression {
  @luint64 mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralSInt64Expression extends @typeExpression {
  @lsint64 mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralCharExpression extends @typeExpression {
  @lchar mLiteralChar ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralDoubleExpression extends @typeExpression {
  @ldouble mLiteralDouble ;
}
 
#---------------------------------------------------------------------------*

class @typeHereExpression extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeConstructorExpression extends @typeExpression {
  @lstring mClassName ;
  @lstring mClassMethodName ;
  @typeExpressionList mExpressionList ;
}
 
#---------------------------------------------------------------------------*

class @typeTestComplement extends @typeExpression {
  @typeExpression mExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeLogicalNegate extends @typeExpression {
  @typeExpression mExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeBoolOption extends @typeExpression {
  @string mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*

class @typeUIntOption extends @typeExpression {
  @string mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*

class @typeStringOption extends @typeExpression {
  @string mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*
#   S I M P L E    V A R I A B L E                                          *
#---------------------------------------------------------------------------*

class @typeVarInExpression extends @typeExpression {
  @typeCplusPlusName mCppVarName ;
}
 
#---------------------------------------------------------------------------*
#   J O K E R    E X P R E S S I O N                                        *
#---------------------------------------------------------------------------*

class @typeJokerInExpression extends @typeExpression {
}
 
#---------------------------------------------------------------------------*
#   A D D I T I O N    O P E R A T I O N                                    *
#---------------------------------------------------------------------------*

class @typeAddOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#   S U B S T R A C T I O N    O P E R A T I O N                            *
#---------------------------------------------------------------------------*

class @typeSubOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#   M U L T I P L I C A T I O N    O P E R A T I O N                        *
#---------------------------------------------------------------------------*

class @typeMultiplyOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#   D I V I S I O N    O P E R A T I O N                                    *
#---------------------------------------------------------------------------*

class @typeDivideOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#   M O D U L O    O P E R A T I O N                                        *
#---------------------------------------------------------------------------*

class @typeModuloOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#   U N A R Y   -    O P E R A T I O N                                      *
#---------------------------------------------------------------------------*

class @typeUnaryMinusOperation extends @typeExpression {
  @typeExpression mExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#  ==    O P E R A T I O N                                                  *
#---------------------------------------------------------------------------*

class @typeEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeNonEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeStrictInfTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeInfOrEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeStrictSupTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeSupOrEqualTest extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeLeftShiftOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*

class @typeRightShiftOperation extends @typeExpression {
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
  @location mInstructionLocation ;
}
 
#---------------------------------------------------------------------------*
#   C A L L    T E S T    M E T H O D    F O R    M A P                     *
#---------------------------------------------------------------------------*

class @typeTextTableCall extends @typeExpression {
  @typeExpression mExpression ;
  @lstring aNomMethodeTest ;
  @typeCplusPlusName aNomCppClef ;
}
 
#---------------------------------------------------------------------------*
#                                                                           *
#   A S S I G N M E N T    I N S T R U C T I O N                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_assignmentInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   . =    I N S T R U C T I O N                                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_dotEqualInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
  @string mSourceExpressionConverter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C L A R A T I O N    I N S T R U C T I O N                          *
#                                                                           *
#   W I T H    A S S I G N M E N T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_declarationInstructionWithAssignment extends @typeInstruction {
  @AC_galgasType mVariableType ;
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " W H I L E "   I N S T R U C T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_while_instruction extends @typeInstruction {
  @typeExpression mVariantExpression ;
  @typeInstructionList mInstructionList1 ;
  @typeExpression mWhileExpression ;
  @typeInstructionList mInstructionList2 ;
  @location mLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " I F "   I N S T R U C T I O N                                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_expression_instructionsList_list {
  @typeExpression mIFexpression ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @C_if_instruction extends @typeInstruction {
  @L_expression_instructionsList_list mIFbranchesList ;
  @typeInstructionList mElseInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " S W I T C H "   I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_switchBranchlist {
  @stringset mConstantSet ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @C_switch_instruction extends @typeInstruction {
  @typeExpression mSwitchExpression ;
  @lstring mEnumTypeName ;
  @L_switchBranchlist mBranchList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Definition de la map des routines a implementer                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableRoutinesAimplementer {
  insert insertKey error message "the routine '%K' is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# Table des attributs semantiques internes (pour list d'instructions)       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableAttributsSemantiques {
  @typeCplusPlusName aNomCppAttribut ;
  @AC_galgasType mAttributType ;
  insert insertKey error message "the attribute '%K' is already declared in %L" ;
  search searchKey error message "the attribute '%K' is not declared" ;
}

#---------------------------------------------------------------------------*

routine buildMapWithLocalConstants
  ?@L_nameWithType inLocalDeclarationsList
  ?@typeListeAttributsSemantiques inSemanticAttributsList
  ?!@typeVariablesMap ioVariablesMap
  ?@location inLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  ?@bool inEllipsisFound
:
  @bool mapStyle := inLocalConstantStyle != [@localConstantBuildStyleEnum listStyle] ;
  @bool firstOne := true ;
  foreach inLocalDeclarationsList (@lstring typeNameInDeclaration @lstring cstName),
          inSemanticAttributsList (@AC_galgasType type @lstring attributeName) :
    if [cstName string] != "" then
      @string typeName ;
      [type getTypeName ? typeName] ;
      if [typeNameInDeclaration string] == typeName then
        @typeCplusPlusName cppName ;
        if (inLocalConstantStyle == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
          cppName := [@typeKeyName new !inLocation] ;
        else
          cppName := [@typeOperandName new !attributeName !inLocation !mapStyle] ;
        end if ;
        [!?ioVariablesMap insertUsedConstInArgument !cstName !type !cppName] ;
      else
        error typeNameInDeclaration : "I have found the '@" . [typeNameInDeclaration string]
          . "' type, I was expected the '@" . typeName . "' type" ;
      end if ;
    end if ;
    firstOne := false ;
  end foreach ;
#--- Check effective parameters list length
  if ([inLocalDeclarationsList length] < [inSemanticAttributsList length]) & not inEllipsisFound then
    error here : "one or more parameters missing: found "
    . [[inLocalDeclarationsList length] string] . " effective parameters, while "
    . [[inSemanticAttributsList length] string] . " are needed" ;
  elsif [inLocalDeclarationsList length] > [inSemanticAttributsList length] then
    error here : "too much parameters: found "
    . [[inLocalDeclarationsList length] string] . " effective parameters, while "
    . [[inSemanticAttributsList length] string] . " are needed" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ITERATEUR (DOUBLE) DE VERIFICATION DE COMPATIBILITE ENTRE             *
#   ENTRE UNE LISTE DE TYPES ET UNE LISTE D'ATTRIBUTS SEMANTIQUES           *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteTypes
  ??@typeSemanticsTypesList t1
  ??@typeListeAttributsSemantiques t2
  ??@location inErrorLocation
:
  if [t1 length] < [t2 length] then
    error inErrorLocation : "one or more identifiers missing" ;
  elsif [t1 length] > [t2 length] then
    error inErrorLocation : "too much identifiers" ;
  else
    foreach t1 (@AC_galgasType attTypeEffectif @lstring attNomVariableEffectif),
            t2 (@AC_galgasType attTypeAttributFormel @lstring attNomAttributFormel) :
      checkAssignmentTypesCompatibility
        !attTypeEffectif
        !attTypeAttributFormel
        ![attNomVariableEffectif location]
        !false
      ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VERIFICATION DE COMPATIBILITE ENTRE UNE SIGNATURE ET UN APPEL         *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteArgEffectifsSignature
  ??@L_EXsignature signatureReference
  ??@L_actualParametersSignature inEffectiveArgumentsSignature
  ??@location inErrorLocation
  ?!@typeInstructionList ioInstructionsList
  ?!@typeExpressionList ioExpressionList
:
  if [signatureReference length] > [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "one or more arguments missing" ;
  elsif [signatureReference length] < [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "too much arguments" ;
  else
  #--- Check signatures
    foreach signatureReference (@AC_galgasType attSignatureType @formalArgumentPassingMode formalArgPassingMode),
            inEffectiveArgumentsSignature (@AC_galgasType attEffectiveType @actualParametersPassingMode parameterPassingMode) :
      match formalArgPassingMode::parameterPassingMode :
      when argumentConstantIn :: parameterOut :
        checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !true ;
      when argumentIn :: parameterOut :
        checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !true ;
      when argumentInOut :: parameterOutIn :
        checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !false ;
      when argumentOut :: parameterIn :
        extract attEffectiveType :
        when @typeGalgas_jokerInParameterList () ->
        else
          checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !false ;
        end extract ;
      else
        error inErrorLocation : [parameterPassingMode actualArgumentMessage] . " is not compatible with " .
                                [formalArgPassingMode formalArgumentMessage] ;
      end match ;
    end foreach ;
  #--- Build expression list
    @typeExpressionList expressionList := ioExpressionList ;
    ioExpressionList := [@typeExpressionList emptyList] ;
    foreach signatureReference (@AC_galgasType attSignatureType *),
            expressionList (@typeExpression attExpressionType) :
      extract attExpressionType :
      when @typeJokerInExpression () ->
        @typeCplusPlusName cppVarName := [@typeLocationAutomaticName new ![@uint sequenceNumber]] ;
        @typeExpression e := [@typeVarInExpression new !cppVarName] ;
        ioExpressionList += !e ;
        @typeInstruction i := [@typeInstructionDeclarationVarLocale new !cppVarName !attSignatureType] ;
        ioInstructionsList += !i ;
      else
        ioExpressionList += !attExpressionType ;
      end extract ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           class 'typeJoker'                               *
#     Est utilise pour denoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

class @typeJoker extends @typeCible {
  override method verifierType
    ??@AC_galgasType unused typeArgumentFormel
    ?!@lstring unused nomAttributSource
    ?!@L_assignedVariables unused listeAffectations
    ?!@typeCplusPlusNameList outAllVariablesList
  :
    outAllVariablesList += ![@typeNullName new] ;
  end method ;
}

#---------------------------------------------------------------------------*

class @typeEntiteDest extends @typeCible {
  @AC_galgasType aTypeVarDest ;
  @typeCplusPlusName mCppName ;
  @location aPositionVariableCible ;

  override method verifierType
    ??@AC_galgasType typeArgumentFormel
    ?!@lstring nomAttributSource
    ?!@L_assignedVariables listeAffectations
    ?!@typeCplusPlusNameList ioAllVariablesList
  :
    checkAssignmentTypesCompatibility
       !aTypeVarDest
       !typeArgumentFormel
       !aPositionVariableCible
       !false
    ;
    listeAffectations += !mCppName !nomAttributSource ;
    ioAllVariablesList += !mCppName ;
  end method ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Map of non terminal symbols                                          *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonTerminalSymbolForSyntax {
  @M_nonterminalSymbolAlts mAltParametersMap ;
  insert insertKey error message "the '%K' non terminal symbol is already declared in %L"  ;
  search searchKey error message "the '%K' non terminal symbol is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Grammar instruction                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarInstruction extends @typeInstruction {
  @typeCplusPlusName mSourceFileCppName ;
  @lstring mGrammarName ;
  @typeExpressionList mExpressionsList ;
  @lstring mAltSymbol ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          += instruction (without luint assignment)                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeAppendInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpressionList mSourceExpressions ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          -= instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeRemoveInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpressionList mSourceExpressions ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          ++ instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeIncrementInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @location mInstructionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          -- instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeDecrementInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @location mInstructionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                Instruction d'appel d'action extern                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelActionExterne extends @typeInstruction {
  @lstring aNomAction ;
  @typeExpressionList mExpressionsList ;
  @L_EXsignature aListeTypesParametresFormels ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C A S E S    L I S T    F O R    M A T C H    I N S T R U C T I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_matchInstructionCasesList {
  @lstring mCase1_name ;
  @lstring mCase2_name ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#     M A T C H    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMatchInstruction extends @typeInstruction {
  @location aIndicatif1 ;
  @location aIndicatif2 ;
  @typeCplusPlusName aNomCppVariable1 ;
  @typeCplusPlusName aNomCppVariable2 ;
  @lstring aNomTypeBase1 ;
  @lstring aNomTypeBase2 ;
  @bool mOperand1_isEnumeration ;
  @bool mOperand2_isEnumeration ;
  @L_matchInstructionCasesList aListeCas ;
  @typeInstructionList mElseInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  Instruction                                                              *
#    foreach var ??@... name ??@... name, ... :                             *
#      instructions                                                         *
#    end foreach ;                                                          *
#                                                                           *
#---------------------------------------------------------------------------*

list @foreachEnumerationList  {
  @typeCplusPlusName mCppEnumeratedVariableName ;
  @location mLocationOffset ;
  @string mCppTypeName ;
}

#---------------------------------------------------------------------------*

class @typeForeachInstruction extends @typeInstruction {
  @foreachEnumerationList mForeachEnumerationList ;
  @typeExpression mWhileExpression ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'extract ...'                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeSimpleExtractInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariable ;
  @lstring aNomClasse ;
  @L_assignedVariables aListeAffectationParametresEffectifs ;
  @typeExpression mErrorLocationExpression ;
  @lstring aNomMessage ;
}

#----------------------------------------------------------------------*
#                                                                      *
#                    Structured instruction 'extract ...'              *
#                                                                      *
#----------------------------------------------------------------------*

list @typeStructuredExtractCasesList {
  @lstring mClassName ;
  @location mResultVarID ;
  @typeInstructionList mInstructionList ;
  @bool mNoUsedParameter ;
}

#----------------------------------------------------------------------*

class @typeStructuredExtractInstructionWithElse extends @typeInstruction {
  @typeCplusPlusName mVariableName ;
  @typeStructuredExtractCasesList mCasesList ;
  @typeInstructionList mElseInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    Routine call instruction                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeRoutineCallInstruction extends @typeInstruction {
  @lstring aNomRoutine ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    'log ...' instruction                                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeLogInstruction extends @typeInstruction {
  @lstring mGalgasVariableName ;
  @typeCplusPlusName mLoggedVariable ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    'drop ...' instruction                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeDropInstruction extends @typeInstruction {
  @typeCplusPlusName aVariableConsommee ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Table des routines declarees par un prototype                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableNomRoutinesDeclarees {
  insert insertKey error message "the routine '%K' is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Entites a engendrer                                          *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeEntityToGenerate {
}

#---------------------------------------------------------------------------*

class @typeExternTypeToGenerate extends @typeEntityToGenerate {
  @lstring mGalgasName ;
  @lstring mCppClassName ;
  @lstring mIncludePath ;
}

#---------------------------------------------------------------------------*

class @typeRoutineAengendrer extends @typeEntityToGenerate {
  @lstring aNomRoutine ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @C_listTypeToImplement extends @typeEntityToGenerate {
  @lstring aNomListe ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
}

#---------------------------------------------------------------------------*

list @sortDescriptorList {
  @lstring mSortAttribute ;
  @bool mAscendingOrder ;
}

#---------------------------------------------------------------------------*

class @C_sortedListTypeToImplement extends @typeEntityToGenerate {
  @lstring aNomListe ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @sortDescriptorList mSortDescriptorList ;
}

#---------------------------------------------------------------------------*

class @typeDefinitionTableAimplementer extends @typeEntityToGenerate {
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @lstring aNomClasseGenerique ;
  @insertOrSearchMethodList mInsertMethodList ;
  @insertOrSearchMethodList mSearchMethodList ;
  @typeTableBlocsDeTable aTableMethodesSurcharger ;
}

#---------------------------------------------------------------------------*

class @C_mapToImplement extends @typeEntityToGenerate {
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @insertOrSearchMethodList mInsertMethodList ;
  @insertOrSearchMethodList mSearchMethodList ;
  @insertOrSearchMethodList mRemoveMethodList ;
}

#---------------------------------------------------------------------------*

class @C_classToImplement extends @typeEntityToGenerate {
#--- Class Name
  @lstring aNomClasse ;

#--- Is Abstract ?
  @bool mIsAbstract ;

#--- Liste de tous les attributs not externes, y compris ceux definis dans une classe mere
  @typeListeAttributsSemantiques aListeTousAttributsNonExternes ;  

#--- Table de toutes les methodes, y compris celles heritees
  @typeTableMethodes aTableToutesMethodes ;

#--- Table des methodes de la classe abstract
  @typeTableMethodesAimplementer mMethodsMap ;

#--- Liste des attributs semantiques not externes definis dans cette classe
  @typeListeAttributsSemantiques aListeAttributsCourants ;

#--- Liste des attributs externes definis dans cette classe
  @L_nameWithType aListeExternesCourants ;

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;

#--- Table des messages
  @typeClassMessagesMap mMessagesMap ;
}

#---------------------------------------------------------------------------*

class @C_mapindexToImplement extends @typeEntityToGenerate {
#--- Map index type Name
  @lstring mMapindexTypeName ;
#--- Map type Map
  @lstring mMapTypeName ;
#--- Map attributes
  @typeListeAttributsSemantiques mMapAttributesList ;
#--- Readers
  @mapIndexSearchReaderMap mMapIndexSearchReaderMap ;
}

#---------------------------------------------------------------------------*

map @domainRelationMap {
  @stringlist mDomains ;
  insert insertKey error message "the '%K' domain relation has been already declared in %L" ;
  search searchKey error message "the '%K' domain relation is not declared" ;
}

#---------------------------------------------------------------------------*

class @C_domainToImplement extends @typeEntityToGenerate {
#--- Domain Name
  @lstring mDomainName ;
#--- Attribute Map
  @domainAttributeMap mAttributeMap ;
#--- Relation Map
  @domainRelationMap mRelationMap ;
}

#---------------------------------------------------------------------------*

class @typeEntiteActionExterne extends @AC_semanticsEntity {
  @L_EXsignature aSignature ;
  message messageTypeEntite "an external action" ;
}

#---------------------------------------------------------------------------*

class @typeActionExterneAengendrer extends @typeEntityToGenerate {
  @lstring aNomAction ;
  @L_EXsignature aSignature ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Liste des entites a engendrer                                *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeEntitiesToGenerateList {
  @typeEntityToGenerate mEntityToGenerate ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#         E N T E R    B U I L T I N    T Y P E S                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterBuiltinTypes !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap :
  ioComponentSemanticsEntitiesMap := [@M_semanticsEntitiesForUse emptyMap] ;

  @AC_semanticsEntity e := [@typeEntiteType new ![@typeGalgas_lstring new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lstring" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lbool new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lbool" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_luint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lsint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lsint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_luint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lsint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lsint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_ldouble new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"ldouble" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lchar new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lchar" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_location new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"location" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_uint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_sint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"sint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_uint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_sint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"sint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_char new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"char" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_string new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"string" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_bool new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"bool" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_binaryset new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"binaryset" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_double new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"double" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_stringset new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"stringset" !here] !e] ;

  @AC_galgasType t ; build_uint64list_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint64list" !here] !e] ;

  build_stringlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"stringlist" !here] !e] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumCstMessageStringMap {
  @lstring mMessageString ;
  insert insertKey error message "the message for '%K' constant is already declared in %L" ;
  search searchKey error message "the message for '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

class @enumGalgasType extends @typeEntityToGenerate {
  @lstring mEnumTypeName ;
  @enumConstantMap mConstantMap ;
  @typeEnumMessageMap mEnumMessageMap ;
}

#---------------------------------------------------------------------------*

action appendJokersIfNeeded
 ?!@typeCplusPlusNameList ioAllVariablesList
 ?@uint inEffectiveParametersCount
 ?@uint inFormalArgumentsCount
 ?@typeCplusPlusName inNullName
;

#---------------------------------------------------------------------------*

action generateSemanticsComponent
  ?!@lstring componentName
  ?!@stringset includesForHeaderFile
  ?!@string defLexique
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@stringset includesForImplementationFile
;

#---------------------------------------------------------------------------*
#                                                                           *
#    C O N S T R A I N T     C O M P O N E N T                              *
#                                                                           *
#---------------------------------------------------------------------------*

map @representativeEntityMap {
  @lstring mRepresentativeEntityName ;
  @stringset mSuperEntitySet ;
  insert insertKey error message "internal error: the '%K' entity has been already declared in %L" ;
  search searchKey error message "internal error: the '%K' entity is not declared" ;
}

#---------------------------------------------------------------------------*

map @callInstructionSharedPropertySignatureMap {
  @L_lstringList mEffectiveArgumentList ;
  @location mSignatureLocation ;
  insert insertKey error message "internal error: the '%K' property has been already declared in %L" ;
  search searchKey error message "internal error: the '%K' property is not declared" ;
}

#---------------------------------------------------------------------------*

map @constraintInstructionListMap {
  @typeInstructionList instructionsList ;
  @callInstructionSharedPropertySignatureMap mCallInstructionSharedPropertySignatureMap ;
  @location mEndOfInstructionList ;
  insert insertKey error message "the instruction list of '%K' entity constraint  is already defined in %L" ;
  search searchKey error message "the instruction list of '%K' constraint entity is not defined" ;
}

#---------------------------------------------------------------------------*

action generate_constraints
  ?@entityToImplementMap inEntityMap
  ?@mapEntityMap inMapEntityMap
  ?@lstring inMetamodelComponentName
  ?@lstring inConstraintComponentName
  ?@entityToImplementMap inConstrainedEntityMap
  ?@stringset inMultiReferencedEntities
  ?@lstring inRootEntityName
  ?@representativeEntityMap inRepresentativeEntityMap
  ?@constraintInstructionListMap inConstraintInstructionListMap
;

#---------------------------------------------------------------------------*

class @callInstruction extends @typeInstruction {
  @lstring mCalledPropertyName ;
  @metamodelProperty mProperty ;
  @L_lstringList mParameterList ;
}

#---------------------------------------------------------------------------*

routine displayConstraintDefinitionErrors
  ?@stringset inFirstBranchconstraintDefinitionSet
  ?@stringset inCurrentBranchconstraintDefinitionSet
:
  @stringset missingDefinition := inFirstBranchconstraintDefinitionSet - inCurrentBranchconstraintDefinitionSet ;
  foreach missingDefinition (@string kMissingDef) :
   error here: "the '" . kMissingDef . "' property is initialized by first branch, but not by this one" ;
  end foreach ;
  @stringset unexpectedDefinition := inCurrentBranchconstraintDefinitionSet  - inFirstBranchconstraintDefinitionSet ;
  foreach unexpectedDefinition (@string kUnexpectedDef) :
   error here: "the '" . kUnexpectedDef . "' property is not initialized by first branch, but by this one" ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine displayConstraintDefinitionErrorsNoElse
  ?@stringset inFirstBranchConstraintDefinitionSet
  ?@stringset inInheritedConstraintDefinitionSet
:
  @stringset missingDefinition := inFirstBranchConstraintDefinitionSet - inInheritedConstraintDefinitionSet ;
  foreach missingDefinition (@string kMissingDef) :
   error here: "the '" . kMissingDef . "' property is initialized by first branch, but there is no else branch" ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
