#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component semantics definition                          *
#                                                                           *
#  Copyright (C) 1997-2004 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semantics_semantics :

import semantics common_semantics in "common_semantics.ggs" ;

#---------------------------------------------------------------------------*
#                                                                           *
#       C++ NAME FOR A FORMAL PARAMETER OR LOCAL VARIABLE                   *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCplusPlusName
  include header ;
end class ;

#---------------------------------------------------------------------------*
# C++ name is the value of mName

class @typeDirectName extends @typeCplusPlusName
  @lstring mName ;
end class ;

#---------------------------------------------------------------------------*
# C++ name is implicit (used for local method call)

class @typeCppThisName extends @typeCplusPlusName
end class ;

#---------------------------------------------------------------------------*
# C++ name is implicit (used for inherited method call)

class @typeCppInheritedName extends @typeCplusPlusName
end class ;

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of mName

class @typeAutomaticName extends @typeCplusPlusName
  @lstring mName ;
end class ;

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of location

class @typeLocationAutomaticName extends @typeCplusPlusName
  @location mLocation ;
end class ;

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->zz' followed by the value of mName

class @typeOperandName extends @typeCplusPlusName
  @lstring mName ;
  @location mLocationOffset ;
  @bool mFieldKind ; # false : zz est vide ; true : zz est 'mInfo.'
end class ;

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->mKey' followed by the value of mName

class @typeKeyName extends @typeCplusPlusName
  @location mLocationOffset ;
end class ;

#---------------------------------------------------------------------------*
# No variable

class @typeNullName extends @typeCplusPlusName
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#   A LIST OF C++ NAMES                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeCplusPlusNameList
  @typeCplusPlusName mCppName ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#   E X P R E S S I O N    A B S T R A C T    C L A S S                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeExpression
  include header ;
end class ;
 
#---------------------------------------------------------------------------*
#                                                                           *
#   C L A S S    M E S S A G E    M A P                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassMessagesMap
  insert insertKey error message "the message '" . * . "' is already declared" ;
  search searchKey error message "the message '" . * . "' is not declared" ;
  key @lstring ;
  @lstring mMessage ;
end map ;

#---------------------------------------------------------------------------*
#                                                                           *
#  S E M A N T I C S   T Y P E S   L I S T                                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeSemanticsTypesList
  @AC_galgasType mType ;
  @lstring mGalgasVariableName ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#  V A R I A B L E S    M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeVariablesMap
  class cGalgasVariablesMap in "cGalgasVariablesMap.h", "cGalgasVariablesMap.hh" ;
#--- Inserting
  insert insertInArgument error message "the variable '%' is already declared" ;
  insert insertConstInArgument error message "the variable '%' is already declared" ;
  insert insertUsedConstInArgument error message "the variable '%' is already declared" ;
  insert insertUnusedConstInArgument error message "the variable '%' is already declared" ;
  insert insertLocalVariable error message "the variable '%' is already declared" ;
  insert insertOutArgument error message "the variable '%' is already declared" ;
  insert insertInOutArgument error message "the variable '%' is already declared" ;
  insert insertUnusedInOutArgument error message "the variable '%' is already declared" ;
#--- Searching
  search searchForReadOnlyAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in read only mode" ;
  search searchForDestructiveReadAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in destructive read mode" ;
  search searchForReadWriteAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in read/write mode" ;
  search searchForWriteAccess error message "the variable '%' is not declared",
             "the variable '%' cannot be accessed in write mode" ;
#--- Blocks
  block  verifyVariableUsing : () : (?@location positionErreur) ;
  block  testBloc : () : () ;
  block  testPart : () : (?@location positionErreur) ;
  block  repeatBlock : () : () ;
  block  repeatPart : () : (?@location positionErreur) ;
#--- Key
  key @lstring ;
#--- Attribut
  @AC_galgasType mArgumentType ;
  @typeCplusPlusName mCplusPlusName ;
end map ;

#---------------------------------------------------------------------------*

list @L_assignedVariables 
  @typeCplusPlusName aNomVariableCible ;
  @lstring aNomAttributSource ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#                            class 'typeCible'                              *
#     Est utilisé pour dénoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCible
  abstract reader verifierType ?@AC_galgasType typeArgumentFormel
                               ?!@lstring nomAttributSource
                               ?!@L_assignedVariables listeAffectations
                               ?!@typeCplusPlusNameList outAllVariablesList ;
end class ;

#---------------------------------------------------------------------------*

list @typeListeCibles
  @typeCible aCible ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#     Liste des types et des noms C++ des arguments d'une méthode           *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListeTypesEtNomsArgMethode
  @AC_galgasType mType ;
  @formalArgumentPassingMode mFormalArgumentPassingMode ;
  @typeCplusPlusName mCppName ;
  @bool aModeIn ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#        Définition du type abstrait instruction d'une méthode              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeInstruction
  include header ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#        Définition du type list d'instructions d'une méthode               *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeInstructionsList
  @typeInstruction aInstruction ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#                  Liste d'attributs externes                               *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_nameWithType
  @lstring mType ;
  @lstring mName ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#              Table des méthodes (d'une classe à implémenter)              *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodesAimplementer
  class cTableMethodesAimplementer in "cTableMethodesAimplementer.h", "cTableMethodesAimplementer.hh" ;
  insert insertAbstract error message "the method '%' is already declared" ;
  insert insertNotAbstract error message "the method '%' is already declared" ;
  key @lstring ;
  @L_signature aListeTypesParametres ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionsList mInstructionsList ;
end map ;

#---------------------------------------------------------------------------*
#   E X P R E S S I O N S    L I S T                                        *
#---------------------------------------------------------------------------*

list @typeExpressionList
  @typeExpression mExpression ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E R R O R    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeErrorInstruction extends @typeInstruction
  @typeExpression mErrorLocationExpression ;
  @typeExpression mErrorMessageExpression ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#    W A R N I N G    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeWarningInstruction extends @typeInstruction
  @typeExpression mWarningLocationExpression ;
  @typeExpression mWarningMessageExpression ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E S S A G E    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMessageInstruction extends @typeInstruction
  @typeExpression mMessageExpression ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#   R E A D E R    C A L L    I N S T R U C T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeReaderCallInstruction extends @typeInstruction
  @typeCplusPlusName aNomCppVariable ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M O D I F I E R    C A L L    I N S T R U C T I O N                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeModifierCallInstruction extends @typeInstruction
  @typeCplusPlusName aNomCppVariable ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#           Insert in a map instruction                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMapInsertInstruction extends @typeInstruction
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeInsertion ;
  @lstring aNomTypeTable ;
  @typeCplusPlusName aNomVariableClef ;
  @typeCplusPlusNameList aListeParametresEffectifs ;
  @typeCplusPlusName mOptionalIndexVariable ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#           Search in a map instruction                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMapSearchInstruction extends @typeInstruction
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeRecherche ;
  @lstring aNomTypeTable ;
  @typeCplusPlusName aNomVariableClef ;
  @typeCplusPlusNameList mAllVariablesList ;
  @typeCplusPlusName mOptionalIndexVariable ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction d'appel d'une méthode de list                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelMethodeListe extends @typeInstruction
  @typeCplusPlusName aNomCppAttribut ;
  @lstring aMethodeDeListe ;
  @typeCplusPlusNameList aListeNomsCppArguments ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction de déclaration d'une variable locale                *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionDeclarationVarLocale extends @typeInstruction
  @typeCplusPlusName aNomCppVariable ;
  @AC_galgasType aTypeVariable ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#               'block...' instruction for a map                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMapBlockPrologueInstruction extends @typeInstruction
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mPrologueExpressionList ;
end class ;

#---------------------------------------------------------------------------*

class @typeMapBlockEpilogueInstruction extends @typeInstruction
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mEpilogueExpressionList ;
end class ;

#---------------------------------------------------------------------------*
#   R E A D E R    C A L L    O P E R A N D                                 *
#---------------------------------------------------------------------------*

class @typeReaderCallInExpression extends @typeExpression
  @typeExpression mExpressionValue ;
  @lstring mReaderName ;
  @typeExpressionList mExpressionList ;
end class ;
 
#---------------------------------------------------------------------------*
#   B O O L E A N    O P E R A T I O N S                                    *
#---------------------------------------------------------------------------*

class @typeAndOperation extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeOrOperation extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeConcatOperation extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeTrueBool extends @typeExpression
end class ;
 
#---------------------------------------------------------------------------*

class @typeFalseBool extends @typeExpression
end class ;
 
#---------------------------------------------------------------------------*

class @typeLiteralStringExpression extends @typeExpression
  @lstring mLiteralString ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeLiteralUIntExpression extends @typeExpression
  @luint mLiteralInt ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeLiteralSIntExpression extends @typeExpression
  @lsint mLiteralInt ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeLiteralCharExpression extends @typeExpression
  @lchar mLiteralChar ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeHereExpression extends @typeExpression
end class ;
 
#---------------------------------------------------------------------------*

class @typeConstructorExpression extends @typeExpression
  @lstring mClassName ;
  @lstring mClassMethodName ;
  @typeExpressionList mExpressionList ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeTestComplement extends @typeExpression
  @typeExpression mTest ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeBoolOption extends @typeExpression
  @lstring mOptionComponentName ;
  @lstring mOptionName ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeUIntOption extends @typeExpression
  @lstring mOptionComponentName ;
  @lstring mOptionName ;
end class ;
 
#---------------------------------------------------------------------------*
#   S I M P L E    V A R I A B L E                                          *
#---------------------------------------------------------------------------*

class @typeVarInExpression extends @typeExpression
  @typeCplusPlusName mCppVarName ;
end class ;
 
#---------------------------------------------------------------------------*
#   J O K E R    E X P R E S S I O N                                        *
#---------------------------------------------------------------------------*

class @typeJokerInExpression extends @typeExpression
  @location mLocation ;
end class ;
 
#---------------------------------------------------------------------------*
#   C O M P A R E    O P E R A T I O N S                                    *
#---------------------------------------------------------------------------*

class @typeEqualTest extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeNonEqualTest extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeStrictInfTest extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeInfOrEqualTest extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeStrictSupTest extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*

class @typeSupOrEqualTest extends @typeExpression
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
end class ;
 
#---------------------------------------------------------------------------*
#   C A L L    T E S T    M E T H O D    F O R    M A P                     *
#---------------------------------------------------------------------------*

class @typeTextTableCall extends @typeExpression
  @typeExpression mExpression ;
  @lstring aNomMethodeTest ;
  @typeCplusPlusName aNomCppClef ;
end class ;
 
#---------------------------------------------------------------------------*
#                                                                           *
#   A S S I G N M E N T    I N S T R U C T I O N                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_assignmentInstruction extends @typeInstruction
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C L A R A T I O N    I N S T R U C T I O N                          *
#                                                                           *
#   W I T H    A S S I G N M E N T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_declarationInstructionWithAssignment extends @typeInstruction
  @AC_galgasType mVariableType ;
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#   " I F "   I N S T R U C T I O N                                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_expression_instructionsList_list
  @typeExpression mIFexpression ;
  @typeInstructionsList mInstructionsList ;
end list ;

#---------------------------------------------------------------------------*

class @C_if_instruction extends @typeInstruction
  @L_expression_instructionsList_list mIFbranchesList ;
  @typeInstructionsList mElseInstructionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#      Définition de la map des routines à implémenter                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableRoutinesAimplementer
  insert insertKey error message "the routine '" . * . "' is already declared" ;
  key @lstring ;
end map ;

#---------------------------------------------------------------------------*
#                                                                           *
# Table des attributs sémantiques internes (pour list d'instructions)       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableAttributsSemantiques
  insert insertKey error message "the attribute '" . * . "' is already declared" ;
  search searchKey error message "the attribute '" . * . "' is not declared" ;
  key @lstring ;
  @typeCplusPlusName aNomCppAttribut ;
  @AC_galgasType mAttributType ;
end map ;

#---------------------------------------------------------------------------*

routine buildMapWithLocalConstants
  ?@L_nameWithType inLocalDeclarationsList
  ?@typeListeAttributsSemantiques inSemanticAttributsList
  ?!@typeVariablesMap ioVariablesMap
  ?@location inLocation
  ?@bool inMapField
:
  foreach list inLocalDeclarationsList :: inSemanticAttributsList ->
  (??@lstring typeNameInDeclaration ??@lstring cstName) :: (??@AC_galgasType type ??@lstring attributeName) :
    if [cstName value] != "" then
      @string typeName ;
      [type getTypeName ? typeName] ;
      if [typeNameInDeclaration value] == typeName then
        @typeCplusPlusName cppName := [@typeOperandName new !attributeName !inLocation !inMapField] ;
        insert ioVariablesMap.insertUsedConstInArgument cstName (!type !cppName) ;
      else
        error typeNameInDeclaration : "I have found the '@" . [typeNameInDeclaration value]
          . "' type, I was expected the '@" . typeName . "' type" ;
      end if ;
    end if ;
  end foreach ;
  if [inLocalDeclarationsList length] <  [inSemanticAttributsList length] then
    error here : "one or more identifiers missing" ;
  else
    if [inLocalDeclarationsList length] <  [inSemanticAttributsList length] then
      error here : "too much identifiers" ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#       CHECK ASSIGNMENT TYPE COMPATIBILITY                                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkAssignmentTypesCompatibility
  ?@AC_galgasType targetType
  ?@AC_galgasType sourceType
  ?@location inErrorLocation
:
  match targetType :: sourceType :
  when @typeGalgas_uint () :: @typeGalgas_uint () :
  when @typeGalgas_sint () :: @typeGalgas_sint () :
  when @typeGalgas_char () :: @typeGalgas_char () :
  when @typeGalgas_string () :: @typeGalgas_string () :
  when @typeGalgas_bool () :: @typeGalgas_bool () :
  when @typeGalgas_double() :: @typeGalgas_double () :
  when @typeGalgas_ldouble () :: @typeGalgas_ldouble () :
  when @typeGalgas_location () :: @typeGalgas_location () :

#--- Assignment to lchar 
  when @typeGalgas_lchar () :: @typeGalgas_lchar () :
#--- Assignment to luint 
  when @typeGalgas_luint () :: @typeGalgas_luint () :
#--- Assignment to lsint 
  when @typeGalgas_lsint () :: @typeGalgas_lsint () :
#--- Assignment to lstring
  when @typeGalgas_lstring () :: @typeGalgas_lstring () :
#--- Assignment to lbool type
  when @typeGalgas_lbool () :: @typeGalgas_lbool () :

  when @typeGalgasUndefinedExternType (??@lstring attNomType1 ??*)
    :: @typeGalgasUndefinedExternType (??@lstring attNomType2 ??*) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting an extern variable of extern '" . [attNomType1 value] .
                                "' type variable, and I got an extern '" . [attNomType2 value] . "' type variable" ;
    end if ;

  when @typeGalgasUndefinedListType (??@lstring attNomType1) :: @typeGalgasUndefinedListType (??@lstring attNomType2) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting a '" . [attNomType1 value] .
                                "' list type variable, and I got a '" . [attNomType2 value] . "' list type variable" ;
    end if ;

  when @typeGalgasClassType (??@lstring attNomType1 ??* ??* ??* ??* ??* ??*)
    :: @typeGalgasClassType (??@lstring attNomType2 ??* ??* ??@typeSuperClassesMap attAncestorClassesMap2 ??* ??* ??*) :
    if [attNomType1 value] == [attNomType2 value] then
    elsif not [attAncestorClassesMap2 hasKey !attNomType1] then
      error inErrorLocation : "The '" . [attNomType2 value] .
                              "' does not inherit from '" . [attNomType2 value] . "' class" ;
    end if ;

  when @typeGalgasUndefinedClassType (??@lstring attNomType1) :: @typeGalgasUndefinedClassType (??@lstring attNomType2) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting a '" . [attNomType1 value] .
                              "' class type variable, and I got a '" . [attNomType2 value] . "' class type variable" ;
    end if ;

  when @typeGalgasUndefinedMapType (??@lstring attNomType1) :: @typeGalgasUndefinedMapType (??@lstring attNomType2) :
    if [attNomType1 value] != [attNomType2 value] then
      error inErrorLocation : "I was expecting a '" . [attNomType1 value] .
                              "' map type variable, and I got a '" . [ attNomType2 value] .
                              "' map type variable" ;
    end if ;

  when @typeGalgas_enum (??@lstring aTypeName1 ??* ??*)
    :: @typeGalgas_enum (??@lstring aTypeName2 ??* ??*) :
    if [aTypeName1 value] != [aTypeName2 value] then
      error inErrorLocation : "I was expecting an enum variable of  '" . [aTypeName1 value] .
                              "' type variable, and I got an enum '" . [aTypeName2 value] .
                              "' type variable" ;
    end if ;
  else
    error inErrorLocation : [targetType messageGalgasType] . " cannot be assigned from " . 
                            [sourceType messageGalgasType] ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ITÉRATEUR (DOUBLE) DE VÉRIFICATION DE COMPATIBILITÉ ENTRE             *
#   ENTRE UNE LISTE DE TYPES ET UNE LISTE D'ATTRIBUTS SÉMANTIQUES           *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteTypes
  ?@typeSemanticsTypesList t1
  ?@typeListeAttributsSemantiques t2
  ??@location inErrorLocation
:
  if [t1 length] < [t2 length] then
    error inErrorLocation : "one or more identifiers missing" ;
  elsif [t1 length] > [t2 length] then
    error inErrorLocation : "too much identifiers" ;
  else
    foreach list t1 :: t2 ->
         (??@AC_galgasType attTypeEffectif ??@lstring attNomVariableEffectif)
      :: (??@AC_galgasType attTypeAttributFormel ??@lstring attNomAttributFormel) :
      verifierCompatibiliteTypesSemantiques !attTypeEffectif !attTypeAttributFormel ![attNomVariableEffectif location] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VÉRIFICATION DE COMPATIBILITÉ ENTRE UNE SIGNATURE ET UN APPEL         *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteArgEffectifsSignature
  ?@L_signature signatureReference
  ?@L_actualParametersSignature inEffectiveArgumentsSignature
  ??@location inErrorLocation
  ?!@typeInstructionsList ioInstructionsList
  ?!@typeExpressionList ioExpressionList
:
  if [signatureReference length] > [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "one or more arguments missing" ;
  elsif [signatureReference length] < [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "too much arguments" ;
  else
  #--- Check signatures
    foreach list signatureReference:: inEffectiveArgumentsSignature ->
         (??@AC_galgasType attSignatureType ??@formalArgumentPassingMode formalArgPassingMode)
      :: (??@AC_galgasType attEffectiveType ??@actualParametersPassingMode parameterPassingMode) :
      match formalArgPassingMode::parameterPassingMode :
      when argumentConstantIn :: parameterOut :
        verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
      when argumentIn :: parameterOut :
        verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
      when argumentInOut :: parameterOutIn :
        verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
      when argumentOut :: parameterIn :
        extract attEffectiveType :
        when @typeGalgas_jokerInParameterList () ->
        else
          verifierCompatibiliteTypesSemantiques !attSignatureType !attEffectiveType !inErrorLocation ;
        end extract ;
      else
        error inErrorLocation : [parameterPassingMode actualArgumentMessage] . " is not compatible with " .
                                [formalArgPassingMode formalArgumentMessage] ;
      end match ;
    end foreach ;
  #--- Build expression list
    @typeExpressionList expressionList := ioExpressionList ;
    ioExpressionList := [@typeExpressionList empty] ;
    foreach list signatureReference::expressionList ->
         (??@AC_galgasType attSignatureType ??*)
      :: (??@typeExpression attExpressionType) :
      extract attExpressionType :
      when @typeJokerInExpression (??@location kLocation) ->
        @typeCplusPlusName cppVarName := [@typeLocationAutomaticName new !kLocation] ;
        @typeExpression e := [@typeVarInExpression new ! cppVarName] ;
        ioExpressionList += !e ;
        @typeInstruction i := [@typeInstructionDeclarationVarLocale new !cppVarName !attSignatureType] ;
        ioInstructionsList += !i ;
      else
        ioExpressionList += !attExpressionType ;
      end extract ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           class 'typeJoker'                               *
#     Est utilisé pour dénoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

class @typeJoker extends @typeCible
  override reader verifierType ?@AC_galgasType typeArgumentFormel
                               ?!@lstring unused nomAttributSource
                               ?!@L_assignedVariables unused listeAffectations
                               ?!@typeCplusPlusNameList outAllVariablesList :
    @typeCplusPlusName nullName := [@typeNullName new] ;
    outAllVariablesList += !nullName ;
  end reader ;
end class ;

#---------------------------------------------------------------------------*

class @typeEntiteDest extends @typeCible
  @AC_galgasType aTypeVarDest ;
  @typeCplusPlusName mCppName ;
  @location aPositionVariableCible ;

  override reader verifierType ?@AC_galgasType typeArgumentFormel
                               ?!@lstring nomAttributSource
                               ?!@L_assignedVariables listeAffectations
                               ?!@typeCplusPlusNameList outAllVariablesList :
    @location positionErreur := aPositionVariableCible ;
    verifierCompatibiliteTypesSemantiques !aTypeVarDest !typeArgumentFormel !positionErreur ;
    listeAffectations += !mCppName !nomAttributSource ;
    outAllVariablesList += !mCppName ;
  end reader ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#              Entité 'not-terminal'                                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeEntiteNonTerminal extends @AC_semanticsEntity
  @M_nonterminalSymbolAlts mAltParametersMap ;
  message messageTypeEntite "a nonterminal symbol" ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#    Grammar instruction                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarInstruction extends @typeInstruction
  @typeCplusPlusName mSourceFileCppName ;
  @lstring mGrammarName ;
  @typeExpressionList mExpressionsList ;
  @lstring mAltSymbol ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#          += instruction (without luint assignment)                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeAppendInstruction extends @typeInstruction
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpressionList mSourceExpressions ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#          ++ instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeIncrementInstruction extends @typeInstruction
  @typeCplusPlusName mTargetVarCppName ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#          += instruction (with luint assignment)                           *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeAppendInstructionWithAssignment extends @typeInstruction
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpressionList mSourceExpressions ;
  @typeCplusPlusName m_luint_TargetVarCppName ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                Instruction d'appel d'action extern                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelActionExterne extends @typeInstruction
  @lstring aNomAction ;
  @typeExpressionList mExpressionsList ;
  @L_signature aListeTypesParametresFormels ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C A S E S    L I S T    F O R    M A T C H    I N S T R U C T I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_matchInstructionCasesList
  @lstring mCase1_name ;
  @lstring mCase2_name ;
  @typeInstructionsList mInstructionsList ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#     M A T C H    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMatchInstruction extends @typeInstruction
  @location aIndicatif1 ;
  @location aIndicatif2 ;
  @typeCplusPlusName aNomCppVariable1 ;
  @typeCplusPlusName aNomCppVariable2 ;
  @lstring aNomTypeBase1 ;
  @lstring aNomTypeBase2 ;
  @bool mOperand1_isEnumeration ;
  @bool mOperand2_isEnumeration ;
  @L_matchInstructionCasesList aListeCas ;
  @typeInstructionsList mElseInstructionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'foreach map ...'                          *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionItererTable extends @typeInstruction
  @location mLocationOffset ;
  @typeCplusPlusName aNomCppTable ;
  @lstring aNomTypeTable ;
  @typeCplusPlusName aNomCppClef ;
  @typeInstructionsList mInstructionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'foreach list ...' (1 list)                *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionItererListeSimple extends @typeInstruction
  @location mLocationOffset ;
  @typeCplusPlusName aNomCppListe ;
  @lstring aNomTypeListe ;
  @typeInstructionsList mInstructionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'foreach list ...' (2 lists)               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionItererListeDouble extends @typeInstruction
  @location aIndicatif1 ;
  @typeCplusPlusName aNomCppListe1 ;
  @lstring aNomTypeListe1 ;
  @location aIndicatif2 ;
  @typeCplusPlusName aNomCppListe2 ;
  @lstring aNomTypeListe2 ;
  @typeInstructionsList mInstructionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'extract ...'                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeSimpleExtractInstruction extends @typeInstruction
  @typeCplusPlusName aNomVariable ;
  @lstring aNomClasse ;
  @L_assignedVariables aListeAffectationParametresEffectifs ;
  @typeExpression mErrorLocationExpression ;
  @lstring aNomMessage ;
end class ;

#----------------------------------------------------------------------*
#                                                                      *
#                    Structured instruction 'extract ...'              *
#                                                                      *
#----------------------------------------------------------------------*

list @typeStructuredExtractCasesList
  @lstring mClassName ;
  @location mResultVarID ;
  @typeInstructionsList mInstructionsList ;
  @bool mNoUsedParameter ;
end list ;

#----------------------------------------------------------------------*

class @typeStructuredExtractInstructionWithElse extends @typeInstruction
  @typeCplusPlusName mVariableName ;
  @typeStructuredExtractCasesList mCasesList ;
  @typeInstructionsList mElseInstructionList ;
  
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Routine call instruction                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeRoutineCallInstruction extends @typeInstruction
  @lstring aNomRoutine ;
  @typeExpressionList mExpressionsList ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    'drop ...' instruction                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeDropInstruction extends @typeInstruction
  @typeCplusPlusName aVariableConsommee ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#            Table des routines déclarées par un prototype                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableNomRoutinesDeclarees
  insert insertKey error message "the routine '" . * . "' is already declared" ;
  key @lstring ;
end map ;

#---------------------------------------------------------------------------*
#                                                                           *
#              Entités à engendrer                                          *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeEntityToGenerate
  include header ;
end class ;

#---------------------------------------------------------------------------*

class @typeExternTypeToGenerate extends @typeEntityToGenerate
#--- Class name
  @lstring mName ;

#--- C++ class name
  @lstring mCppClassName ;
end class ;

#---------------------------------------------------------------------------*

class @setTypeToGenerate extends @typeEntityToGenerate
  @lstring mSetTypeName ;
  @lstring mEnumElementTypeName ;
end class ;

#---------------------------------------------------------------------------*

class @typeRoutineAengendrer extends @typeEntityToGenerate
  @lstring aNomRoutine ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionsList mInstructionsList ;
end class ;

#---------------------------------------------------------------------------*

class @C_listTypeToImplement extends @typeEntityToGenerate
  @lstring aNomListe ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
end class ;

#---------------------------------------------------------------------------*

class @typeDefinitionTableAimplementer extends @typeEntityToGenerate
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @lstring aNomClasseGenerique ;
  @typeTableMethodesInsererChercher aTableMethodesInserer ;
  @typeTableMethodesInsererChercher aTableMethodesChercher ;
  @typeTableBlocsDeTable aTableMethodesSurcharger ;
  @lstring mKeyTypeName ;
end class ;

#---------------------------------------------------------------------------*

map @stateMap
  insert insertKey error message "the '" . * . "' state is already declared"  ;
  search searchKey error message "the '" . * . "' state is not declared" ;
  key @lstring ;
end map ;

#---------------------------------------------------------------------------*

class @C_mapToImplement extends @typeEntityToGenerate
  @stateMap mStateMap ;
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @L_nameWithType mExternAttributesList ;
  @typeTableMethodesInsererChercher aTableMethodesInserer ;
  @typeTableMethodesInsererChercher aTableMethodesChercher ;
  @lstring mKeyTypeName ;
end class ;

#---------------------------------------------------------------------------*

class @typeDefClasseAbstraiteAimplementer extends @typeEntityToGenerate
  @lstring aNomClasse ;

#--- Liste de tous les attributs not externes, y compris ceux définis dans une classe mère
  @typeListeAttributsSemantiques aListeTousAttributsNonExternes ;  

#--- Table de toutes les méthodes, y compris celles héritées
  @typeTableMethodes aTableToutesMethodes ;

#-- Nom du fichier dont l'inclusion apparaît dans la déclaration C++ de la classe
  @bool mGenerateIncludeHeader ;  

#--- Table des méthodes de la classe abstract
  @typeTableMethodesAimplementer mMethodsMap ;

#--- Liste des attributs sémantiques not externes définis dans cette classe
  @typeListeAttributsSemantiques aListeAttributsCourants ;

#--- Liste des attributs externes définis dans cette classe
  @L_nameWithType aListeExternesCourants ;

#--- Table des classes ancêtre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;

#--- Table des messages
  @typeClassMessagesMap mMessagesMap ;
end class ;

#---------------------------------------------------------------------------*

class @typeDefClasseNonAbstraiteAimplementer extends @typeEntityToGenerate
  @lstring aNomClasse ;

#--- Liste de tous les attributs not externes, y compris ceux définis dans une classe mère
  @typeListeAttributsSemantiques aListeTousAttributsNonExternes ;  

#--- Table de toutes les méthodes, y compris celles héritées
  @typeTableMethodes aTableToutesMethodes ;

#--- Table des méthodes de la classe à implémenter
  @typeTableMethodesAimplementer mMethodsMap ;

#--- Liste des attributs sémantiques not externes définis dans cette classe
  @typeListeAttributsSemantiques aListeAttributsCourants ;

#--- Liste des attributs externes définis dans cette classe
  @L_nameWithType aListeExternesCourants ;

#--- Table des classes ancêtre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;  

#--- Table des messages concrets de la classe courante
  @typeClassMessagesMap mMessagesMap ;  

#-- Nom du fichier dont l'inclusion apparaît dans la déclaration C++ de la classe
  @bool mGenerateIncludeHeader ;  
end class ;

#---------------------------------------------------------------------------*

class @typeEntiteActionExterne extends @AC_semanticsEntity
  @L_signature aSignature ;
  message messageTypeEntite "an external action" ;
end class ;

#---------------------------------------------------------------------------*

class @typeActionExterneAengendrer extends @typeEntityToGenerate
  @lstring aNomAction ;
  @L_signature aSignature ;
end class ;

#---------------------------------------------------------------------------*
#                                                                           *
#              Liste des entités à engendrer                                *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeEntitiesToGenerateList
  @typeEntityToGenerate mEntityToGenerate ;
end list ;

#---------------------------------------------------------------------------*
#                                                                           *
#         E N T E R    B U I L T I N    T Y P E S                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterBuiltinTypes !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap :
  ioComponentSemanticsEntitiesMap := [@M_semanticsEntitiesForUse empty] ;

  @lstring name := [@lstring new !"lstring" !here] ;
  @AC_galgasType t := [@typeGalgas_lstring new] ;
  @AC_semanticsEntity e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"lbool" !here] ;
  t := [@typeGalgas_lbool new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"luint" !here] ;
  t := [@typeGalgas_luint new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"lsint" !here] ;
  t := [@typeGalgas_lsint new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"ldouble" !here] ;
  t := [@typeGalgas_ldouble new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"lchar" !here] ;
  t := [@typeGalgas_lchar new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"location" !here] ;
  t := [@typeGalgas_location new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"uint" !here] ;
  t := [@typeGalgas_uint new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"sint" !here] ;
  t := [@typeGalgas_sint new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"char" !here] ;
  t := [@typeGalgas_char new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"string" !here] ;
  t := [@typeGalgas_string new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"bool" !here] ;
  t := [@typeGalgas_bool new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;

  name := [@lstring new !"double" !here] ;
  t := [@typeGalgas_double new] ;
  e := [@typeEntiteType new !t] ;
  insert ioComponentSemanticsEntitiesMap.insertKey name (!e) ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumCstMessageStringMap
  insert insertKey error message "the message for '" . * . "' constant is already declared" ;
  search searchKey error message "the message for '" . * . "' constant is not declared" ;
  key @lstring ;
  @lstring mMessageString ;
end map ;

#---------------------------------------------------------------------------*

class @enumGalgasType extends @typeEntityToGenerate
  @lstring mEnumTypeName ;
  @typeEnumConstantesMap mConstantMap ;
  @typeEnumMessageMap mEnumMessageMap ;
end class ;

#---------------------------------------------------------------------------*

action appendJokersIfNeeded
 ?!@typeCplusPlusNameList ioAllVariablesList
 ?@uint inEffectiveParametersCount
 ?@uint inFormalArgumentsCount
 ?@typeCplusPlusName inNullName
;

#---------------------------------------------------------------------------*

end semantics ;
