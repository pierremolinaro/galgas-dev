#---------------------------------------------------------------------------*
#                                                                           *
#  Semantic decorated types for template generation                         *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics templateCodeGeneration :
  import "semanticExpressionGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

abstract method @templateInstructionForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@bool unused ioUseColumnMarker
;

#---------------------------------------------------------------------------*

routine templateCodeGenerationForListInstruction
  ??@templateInstructionListForGeneration inInstructionList
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
  foreach inInstructionList do
    [mInstruction templateCodeGeneration
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioUseColumnMarker
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

override method @templateInstructionStringForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset unused  ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@bool unused ioUseColumnMarker
:
  ioGeneratedCode .= "result << " . [mTemplateString utf8Representation] . " ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @templateInstructionExpressionForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool unused ioUseColumnMarker
:
#--- Expression
  @string cppName ;
  [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?cppName] ;
  ioGeneratedCode .= "result << " . cppName . ".stringValue () ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @templateBlockInstructionForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
#--- Expression
  @string indendationVarCppName ;
  [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?indendationVarCppName] ;
  ioGeneratedCode .= "if (" . indendationVarCppName . ".isValid ()) {\n" ;
  ioGeneratedCode .= "  result.incIndentation ((int32_t) " . indendationVarCppName . ".uintValue ()) ;\n" ;
  ioGeneratedCode .= "}\n" ;
  templateCodeGenerationForListInstruction
    !mBlockInstructionList
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioUseColumnMarker
  ;
  ioGeneratedCode .= "if (" . indendationVarCppName . ".isValid ()) {\n" ;
  ioGeneratedCode .= "  result.incIndentation (- ((int32_t) " . indendationVarCppName . ".uintValue ())) ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @templateInstructionGetColumnLocationForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
  ioUseColumnMarker := true ;
  ioGeneratedCode .= "columnMarker = result.currentColumn () ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @templateInstructionGotoColumnLocationForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
  ioUseColumnMarker := true ;
  ioGeneratedCode .= "result.appendSpacesUntilColumn (columnMarker) ;\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @templateInstructionForeachForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
#---
  @string foreachVarCppName ;
  [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?foreachVarCppName] ;
#--- Index
  if [mIndexCppName length] > 0 then
    ioGeneratedCode .= "GALGAS_uint " . mIndexCppName . " (0) ;\n" ;
  end if ;
#---
  ioGeneratedCode .= "if (" . foreachVarCppName . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= "cEnumerator_" . [[mExpression mResultType] identifierRepresentation] . " " . mEnumeratorCppName . " (" . foreachVarCppName . ", "
                  . if mIsAscending then "kEnumeration_up" else "kEnumeration_down" end . ") ;\n" ;
#--- Before
  if ([mBeforeInstructionList length] + [mAfterInstructionList length]) > 0 then
    ioGeneratedCode .= "const bool nonEmpty_" . mEnumeratorCppName . " = " . mEnumeratorCppName . ".hasCurrentObject () ;\n" ;
  end if ;
  if [mBeforeInstructionList length] > 0 then
    ioGeneratedCode .= "if (nonEmpty_" . mEnumeratorCppName . ") {\n" ;
    [!?ioGeneratedCode incIndentation !2] ;
    templateCodeGenerationForListInstruction
      !mBeforeInstructionList
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioUseColumnMarker
    ;
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "}\n" ;
  end if ;
  ioGeneratedCode .= "while (" . mEnumeratorCppName . ".hasCurrentObject ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
#--- Do
  templateCodeGenerationForListInstruction
    !mDoInstructionList
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioUseColumnMarker
  ;
#--- Between
  if [mBetweenInstructionList length] > 0 then
    ioGeneratedCode .= "if (" . mEnumeratorCppName . ".hasNextObject ()) {\n" ;
    [!?ioGeneratedCode incIndentation !2] ;
    templateCodeGenerationForListInstruction
      !mBetweenInstructionList
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioUseColumnMarker
    ;
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "}\n" ;
  end if ;
#--- Index
  if [mIndexCppName length] > 0 then
    ioGeneratedCode .= mIndexCppName . ".increment () ;\n" ;
  end if ;
#---
  ioGeneratedCode .= mEnumeratorCppName . ".gotoNextObject () ;\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
#--- After
  if [mAfterInstructionList length] > 0 then
    ioGeneratedCode .= "if (nonEmpty_" . mEnumeratorCppName . ") {\n" ;
    [!?ioGeneratedCode incIndentation !2] ;
    templateCodeGenerationForListInstruction
      !mAfterInstructionList
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioUseColumnMarker
    ;
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "}\n" ;
  end if ;
#---   
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @templateInstructionIfForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
  foreach mTemplateInstructionIfBranchList do
  #--- IF expression
    @string ifVarCppName ;
    [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?ifVarCppName] ;
    const @string testVar := "test_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
    ioGeneratedCode .= "const enumGalgasBool " . testVar . " = " . ifVarCppName . ".boolEnum () ;\n" ;
    ioGeneratedCode .= "if (kBoolTrue == " . testVar . ") {\n" ;
    [!?ioGeneratedCode incIndentation !2] ;
    templateCodeGenerationForListInstruction
      !mInstructionList
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioUseColumnMarker
    ;
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "}else if (kBoolFalse == " . testVar . ") {\n" ;
    [!?ioGeneratedCode incIndentation !2] ;
  end foreach ;
#--- else instructions
  templateCodeGenerationForListInstruction
    !mElseInstructionList
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !?ioUseColumnMarker
  ;
  foreach mTemplateInstructionIfBranchList do
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "}\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @templateInstructionSwitchForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
:
#--- Expression
  @string switchVarCppName ;
  [mSwitchExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?switchVarCppName] ;
#---
  ioGeneratedCode .= "switch (" . switchVarCppName . ".enumValue ()) {\n" ;
  ioGeneratedCode .= "case GALGAS_" . [[mSwitchExpression mResultType] identifierRepresentation] . "::kNotBuilt :\n" ;
  ioGeneratedCode .= "break ;\n" ;
#---
  foreach mTemplateInstructionSwitchBranchList do
    foreach mConstantList do
      ioGeneratedCode .= "case GALGAS_" . [[mSwitchExpression mResultType] identifierRepresentation] . "::kEnum_" . [[mValue string] identifierRepresentation] . " : {\n" ;
    end foreach ;
    [!?ioGeneratedCode incIndentation !2] ;
    templateCodeGenerationForListInstruction
      !mInstructionList
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !?ioUseColumnMarker
    ;
    [!?ioGeneratedCode decIndentation !2] ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
#---
  ioGeneratedCode .= "}\n" ;

end method ;

#---------------------------------------------------------------------------*

end semantics ;
