#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <metamodel_map_declaration>
  ?!@mapEntityMap ioMapEntityMap
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

rule <property_path>
  !@L_propertyPath outPath
label parse
;

rule <entity_declaration_list>
  ?!@entityToImplementMap ioEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

rule <entity_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <entity_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <entity_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <entity_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [empty] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [empty] ;
  @mapEntityMap mapEntityMap [empty] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [empty] ;
  <entity_declaration_list>
    !?entityMap
    !?mapEntityMap
    !?primitiveTypeAttributeNameSet
    !?mapAndEntityUniqueMap
  ;
  @bool isAbstract ;
  [!?entityMap searchKey !rootEntityName ?* ?isAbstract ?* ?* ?* ?* ?* ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Build semantic entities map
  @M_semanticsEntitiesForUse semanticsEntityMap [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??@bool kIsAbstract
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??@lstring kSuperEntityName
                     ??*
                     ??*
                     ??*
                     ??*
                     ??*) :
    @stringset superEntitySet [empty] ;
    buildSuperEntitySet !?entityMap !kSuperEntityName !?superEntitySet ;
    @AC_galgasType t := [@typeGalgas_singleEntity new
      !kEntityName
      !kAllPropertiesMap
      !kIsAbstract
      !kEntityPropertiesMap
      !kSuperEntityName
      !superEntitySet
    ] ;
    @AC_semanticsEntity e := [@typeEntiteType new !t] ;
    [!?semanticsEntityMap insertKey
     !kEntityName
     !e
    ] ;
  end foreach ;
#--- Check properties
  @stringset multiReferencedEntities [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??*
                     ??* 
                     ??* 
                     ??*
                     ??*
                     ??*) :
    foreach kEntityPropertiesMap (??@lstring kAttributeName
                                  ??@metamodelPropertyKind kKind
                                  ??@lstring kTypeName
                                  ??@L_ListOfPropertyPathes kPropertyOptionPathes) :
      if (kKind == [@metamodelPropertyKind singleReferenceProperty]) |
         (kKind == [@metamodelPropertyKind multipleReferenceProperty]) then
        @contextPropertyMap contextPropertyMap ;
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?* ?contextPropertyMap ?* ?* ?* ?*] ;
        multiReferencedEntities += ![kTypeName value] ;
      #--- Check context options
        if [kPropertyOptionPathes length] != [contextPropertyMap count] then
          error kAttributeName: "this reference has "
          . [[kPropertyOptionPathes length] string] . " context parameter(s), while corresponding entity has "
          . [[contextPropertyMap count] string] . " context attribute(s)" ;
        else
          foreach kPropertyOptionPathes (??@L_propertyPath kPath ??@location kEndPofPathLocation),
                  contextPropertyMap (??@lstring kContextAttributeName ??@lstring kContextAttributeEntityName) :
            @lstring typeName ;
            checkPath
              !?entityMap
              !?mapEntityMap
              !kAllPropertiesMap
              !kEntityName
              !kPath
              ?*
              ?typeName
              ?*
            ;
          #--- Check entity type name
            if [typeName value] != [kContextAttributeEntityName value] then
              error kEndPofPathLocation: "the path entity is '@"
              . [typeName value] . "', but its entity should be '@"
              . [kContextAttributeEntityName value] . "'" ;
            end if ;
          end foreach ;
        end if ;
      elsif kKind == [@metamodelPropertyKind contextProperty] then
        [!?mapAndEntityUniqueMap searchKey !kTypeName] ;
      elsif kKind == [@metamodelPropertyKind fetchedProperty] then
        foreach kPropertyOptionPathes (??@L_propertyPath kPath ??@location kEndPofPathLocation):
          @lstring typeName ;
          @metamodelPropertyKind kind ;
          checkPath
            !?entityMap
            !?mapEntityMap
            !kAllPropertiesMap
            !kEntityName
            !kPath
            ?kind
            ?typeName
            ?*
          ;
          if kind != [@metamodelPropertyKind mapProperty] then
            error kEndPofPathLocation: "this path does define a map property" ;
          end if ;
        end foreach ;
      end if ;
    end foreach ;
  end foreach ;
#--- Check fetched properties
  foreach entityMap (??@lstring kCurrentEntity
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??*
                     ??*
                     ??*
                     ??@fetchedPropertyMap kFetchedPropertyMap
                     ??*
                     ??*
                     ??*) :
    @entityPropertyMap allPropertiesMap := kAllPropertiesMap ;
    foreach kFetchedPropertyMap (??@lstring kFetchedPropertyName
                                 ??@lstring kFetchedEntityName
                                 ??@lstring kAttributeName
                                 ??@lstring kMapAttributeName) :
    #--- Check designated attribute in an @lstring
      @metamodelPropertyKind kind ;
      @lstring propertyTypeName ;
      [!?allPropertiesMap searchKey !kAttributeName ?kind ?propertyTypeName ?*] ;
      if kind != [@metamodelPropertyKind attributeProperty] then
        error kAttributeName: "this property is not an attribute" ;
      elsif [propertyTypeName value] != "lstring" then
        error kAttributeName: "this attribute should be an '@lstring' attribute" ;
      end if ;
      [!?allPropertiesMap searchKey !kMapAttributeName ?kind ?propertyTypeName ?*] ;
      if kind != [@metamodelPropertyKind contextProperty] then
        error kAttributeName: "this path does not designate a context property" ;
      else
        @lstring elementTypeName ;
        [!?mapEntityMap searchKey !propertyTypeName ?elementTypeName ?* ?*] ;
        if [kFetchedEntityName value] != [elementTypeName value] then
          error kMapAttributeName: "this property has '@"
          . [kFetchedEntityName value]
          . "', while '@" . [elementTypeName value] . "' was expected" ;
        end if ;
      end if ;
    end foreach ;
  end foreach ;
#--- Check inserted properties
  foreach entityMap (??@lstring kCurrentEntity
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??*
                     ??*
                     ??*
                     ??*
                     ??*
                     ??@insertedPropertyMap kInsertedPropertyMap
                     ??*) :
    @entityPropertyMap allPropertiesMap := kAllPropertiesMap ;
    foreach kInsertedPropertyMap (??@lstring kInsertedAttributeName
                                  ??@insertionMap kInsertionMap) :
      foreach kInsertionMap (??@lstring kInsertionMapName) :
        @lstring mapTypeName ;
        @metamodelPropertyKind kind ;
        [!?allPropertiesMap searchKey !kInsertionMapName ?kind ?mapTypeName ?*] ;
        if not [mapEntityMap hasKey ![mapTypeName value]] then
           error kInsertionMapName: "this reference does not designate a map" ;
         else
           @lstring elementEntity ;
           [!?mapEntityMap searchKey !mapTypeName ?elementEntity ?* ?*] ;
           if [elementEntity value] != [kCurrentEntity value] then
             error kInsertionMapName : "the type of the map is '@" . [kCurrentEntity value]
             . "', but should be '@" . [elementEntity value] . "'" ;
           end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_metamodel
    !?entityMap
    !metamodelName
    !multiReferencedEntities
    !rootEntityName
    !?mapEntityMap
  ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName value]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !semanticsEntityMap
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  ?!@entityToImplementMap outEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
  repeat
  while
    <metamodel_map_declaration>
      !?ioMapEntityMap
      !?ioMapAndEntityUniqueMap
    ;
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
      !?ioMapAndEntityUniqueMap
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <metamodel_map_declaration>
  ?!@mapEntityMap ioMapEntityMap
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
  $map$ ;
  @lstring mapIdentifier ;
  $type_name$ ? mapIdentifier ;
  [!?ioMapAndEntityUniqueMap insertKey !mapIdentifier] ;
  $of$ ;
  @lstring mapElementIdentifier ;
  $type_name$ ? mapElementIdentifier ;
  ${$ ;
  $insert$ ;
  $error$ ;
  $message$ ;
  @lstring insertErrorMessage ;
  $literal_string$ ? insertErrorMessage ;
  action check_KL_escapeCharacters !insertErrorMessage ;
  $;$ ;
  $search$ ;
  $error$ ;
  $message$ ;
  @lstring searchErrorMessage ;
  $literal_string$ ? searchErrorMessage ;
  action check_K_escapeCharacters !searchErrorMessage ;
  $;$ ;
  $}$ ;
  [!?ioMapEntityMap insertKey
    !mapIdentifier
    !mapElementIdentifier
    !insertErrorMessage
    !searchErrorMessage
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $entity$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
  [!?ioMapAndEntityUniqueMap insertKey !entityName] ;
#--- Context properties, or super entity (or nothing)
  @entityPropertyMap entityPropertyMap [empty] ;
  @fetchedPropertyMap allFetchedPropertyMap ;
  @contextPropertyMap allContextPropertyMap [empty] ;
  @insertedPropertyMap allInsertedPropertyMap ;
  @entityPropertyMap allPropertyMap ;
  @lstring superEntity ;
  select
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
    allFetchedPropertyMap := [@fetchedPropertyMap empty] ;
    allInsertedPropertyMap := [@insertedPropertyMap  empty] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [!?ioEntityMap searchKey
      !superEntity
      ?*
      ?*
      ?allPropertyMap
      ?*
      ?allContextPropertyMap
      ?*
      ?allFetchedPropertyMap
      ?*
      ?allInsertedPropertyMap
    ] ;
  or
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
    allFetchedPropertyMap := [@fetchedPropertyMap empty] ;
    allInsertedPropertyMap := [@insertedPropertyMap  empty] ;
    $($ ;
    repeat
      @lstring entityName ;
      $type_name$ ? entityName ;
      @lstring contextPropertyName ;
      $identifier$ ? contextPropertyName ;
      [!?allContextPropertyMap insertKey !contextPropertyName !entityName] ;
      [!?allPropertyMap insertKey
        !contextPropertyName
        ![@metamodelPropertyKind contextProperty]
        !entityName
        ![@L_ListOfPropertyPathes empty]
      ] ;
      [!?entityPropertyMap insertKey
        !contextPropertyName
        ![@metamodelPropertyKind contextProperty]
        !entityName
        ![@L_ListOfPropertyPathes empty]
      ] ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  end select ;
#--- Property declarations
  @fetchedPropertyMap fetchedPropertyMap [empty] ;
  @relationMap relationMap [empty] ;
  @insertedPropertyMap insertedPropertyMap [empty] ;
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    @metamodelPropertyKind k ;
    @lstring attributeName ;
    select
    #--- Multiple reference
      $[$ ;
      $]$ ;
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
        error propertyTypeName : "the '@" . [propertyTypeName value]
        . "' is not an entity name, but a predefined type name" ;
      end if ;
      $identifier$ ? attributeName ;
      k := [@metamodelPropertyKind multipleReferenceProperty] ;
    or
    #--- Map reference
      $<$ ;
      $>$ ;
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
        error propertyTypeName : "the '@" . [propertyTypeName value]
        . "' is not an entity name, but a predefined type name" ;
      end if ;
      $identifier$ ? attributeName ;
      k := [@metamodelPropertyKind mapProperty] ;
    or
      $identifier$ ? attributeName ;
    #--- Single reference or attribute ?
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
      #--- Attribute
        k := [@metamodelPropertyKind attributeProperty] ;
      else 
      #--- Single Reference
        k := [@metamodelPropertyKind singleReferenceProperty] ;
      end if ;
    end select ;
  #--- Path options
    @L_ListOfPropertyPathes propertyOptionPathes [empty] ;
    select
      #--- No option
    or
      $insert$ ;
      if [propertyTypeName value] != "lstring" then
        error here: "only an @lstring attribute can be inserted in a map" ;
      end if ;
      @insertionMap maps [empty] ;
      repeat
        @lstring mapName ;
        $identifier$ ? mapName ;
        [!?maps insertKey !mapName] ;
      while
        $,$ ;
      end repeat ;
      [!?insertedPropertyMap insertKey !attributeName !maps] ;
      [!?allInsertedPropertyMap insertKey !attributeName !maps] ;
    or
      $search$ ;
      if k != [@metamodelPropertyKind singleReferenceProperty] then
        error here: "attribute property or multiple reference property cannot accept 'search' construct" ;
      end if ;
      k := [@metamodelPropertyKind fetchedProperty] ;
      @lstring fetchedAttributeName ;
      $identifier$ ? fetchedAttributeName ;
      $in$ ;
      @lstring mapPropertyName ;
      $identifier$ ? mapPropertyName ;
      [!?fetchedPropertyMap insertKey
        !attributeName
        !propertyTypeName
        !fetchedAttributeName
        !mapPropertyName
      ] ;
    or
      $($ ;
      if (k != [@metamodelPropertyKind singleReferenceProperty])
       & (k != [@metamodelPropertyKind multipleReferenceProperty]) then
        error here:"only a reference property accepts context parameters" ;
      end if ;
      repeat
        select
          $self$ ;
          @L_propertyPath path [empty] ;
          propertyOptionPathes += !path !here ;
        or
          @L_propertyPath path ;
          <property_path> ?path ;
          propertyOptionPathes += !path !here ;
        end select ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
    [!?allPropertyMap insertKey !attributeName !k !propertyTypeName !propertyOptionPathes] ;
    [!?entityPropertyMap insertKey !attributeName !k !propertyTypeName !propertyOptionPathes] ;
    $;$ ;
  while
    $relation$ ;
    @lstring relationIdentifier ;
    $identifier$ ? relationIdentifier ;
    $[$ ;
    @relationVarMap relationVarMap [empty] ;
    repeat
      @lstring localVar ;
      $identifier$ ? localVar ;
      $:$ ;
      @L_propertyPath path ;
      <property_path> ?path ;
      [!?relationVarMap insertKey !localVar !path] ;
    while
      $,$ ;
    end repeat ;
    $]$ ;
    $:=$ ;
    @metamodelRelationExpression e ;
    <entity_relation_expression> !?relationVarMap ?e ;
    $;$ ;
    [!?relationMap insertKey !relationIdentifier !relationVarMap!e] ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey
    !entityName
    !allPropertyMap
    !isAbstract
    !entityPropertyMap
    !superEntity
    !allContextPropertyMap
    !fetchedPropertyMap
    !allFetchedPropertyMap
    !insertedPropertyMap
    !allInsertedPropertyMap
   ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath empty] ;
  repeat
    select
      @lstring pathElement ;
      $identifier$ ? pathElement ;
      outPath += !pathElement ;
    or
      @lstring pathElement ;
      $type_name$ ? pathElement ;
      outPath += ![@lstring new !".". [pathElement value] ![pathElement location]] ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  <entity_relation_term> !?ioRelationVariableMap ?outExpression ;
  repeat
  while
    $|$ ;
    @metamodelRelationExpression e ;
    <entity_relation_term> !?ioRelationVariableMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  <entity_relation_factor> !?ioRelationVariableMap ?outExpression ;
  repeat
  while
    $&$ ;
    @metamodelRelationExpression e ;
    <entity_relation_factor> !?ioRelationVariableMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  select
    <entity_relation_primary> !?ioRelationVariableMap ?outExpression ;
  or
    $not$ ;
    <entity_relation_primary> !?ioRelationVariableMap ?outExpression ;
    outExpression := [@metamodelRelationNot new !outExpression] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  select
    $true$ ;
    outExpression := [@metamodelRelationTrue new] ;
  or
    $false$ ;
    outExpression := [@metamodelRelationFalse new] ;
  or
    $($ ;
    <entity_relation_expression> !?ioRelationVariableMap ?outExpression ;
    $)$ ;
  or
    ${$ ;
    @lstring localVar ;
    $identifier$ ? localVar ;
    @luint variableIndex ;
    [!?ioRelationVariableMap searchKeyAndGetIndex !localVar ?variableIndex ?*] ;
    $==$ ;
    @L_propertyPath path ;
    <property_path> ?path ;
    $}$ ;
    outExpression := [@metamodelRelationPrimary new !localVar !variableIndex !path] ;
#  or
#   $do$ ;
#    $($ ;
#     @L_propertyPath path ;
#     <property_path> ?path ;
#    $[$ ;
#    repeat
#      @lstring parameter ;
#      $identifier$ ? parameter ;
#    while
#      $,$ ;
#    end repeat ;
#    $]$ ;
#    $:$ ;
#    select
#      $|$ ;
#    or
#      $&$ ;
#    end select ;
#    $)$ ;
  end select ;
end rule ;

#-------------------------------------------------------------------*


end syntax ;
