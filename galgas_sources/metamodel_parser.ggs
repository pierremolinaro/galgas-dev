#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

rule <entity_declaration_list>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [emptySet] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $mda_type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [emptyMap] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [emptyMap] ;
  <entity_declaration_list>
    !?entityMap
    !?primitiveTypeAttributeNameSet
    !?mapAndEntityUniqueMap
  ;
  @bool isAbstract ;
  [entityMap searchKey !rootEntityName ?* ?isAbstract ?* ?* ?* ?* ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Check properties
  @stringset multiReferencedEntities [emptySet] ;
  foreach entityMap (@lstring kEntityName
                     @entityPropertyMap kAllPropertiesMap
                     *
                     @entityPropertyMap kEntityPropertiesMap
                     *
                     *
                     *
                     *
                     *) :
    foreach kEntityPropertiesMap (@lstring kAttributeName
                                  @metamodelProperty kProperty) :
      extract kProperty :
      when @metamodelSingleReferenceProperty (@lstring kReferenceEntityName) ->
        [entityMap searchKey !kReferenceEntityName ?* ?* ?* ?* ?* ?* ?* ?*] ;
      when @metamodelMultipleReferenceProperty (@lstring kReferenceEntityName * *) ->
        [entityMap searchKey !kReferenceEntityName ?* ?* ?* ?* ?* ?* ?* ?*] ;
        multiReferencedEntities += ![kReferenceEntityName string] ;
      else
      end extract ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_metamodel
    !entityMap
    !metamodelName
    !multiReferencedEntities
    !rootEntityName
  ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName string]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !entityMap
      !multiReferencedEntities
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  ?!@entityToImplementMap outEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
  repeat
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
      !?ioMapAndEntityUniqueMap
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $class$ ;
  @lstring entityName ;
  $mda_type_name$ ? entityName ;
  [!?ioMapAndEntityUniqueMap insertKey !entityName] ;
#--- Context properties, or super entity (or nothing)
  @entityPropertyMap allMetamodelPropertyMap ;
  @lstring superEntity ;
  @stringset superEntitySet ;
  select
    superEntity := [@lstring new !"" !here] ;
    allMetamodelPropertyMap := [@entityPropertyMap emptyMap] ;
    superEntitySet := [@stringset emptySet] ;
  or
    $extends$ ;
    $mda_type_name$ ? superEntity ;
    [ioEntityMap searchKey
      !superEntity
      ?allMetamodelPropertyMap
      ?*
      ?*
      ?*
      ?*
      ?superEntitySet
      ?*
      ?*
    ] ;
    superEntitySet += ![superEntity string] ;
  end select ;
#--- Property declarations
  @entityPropertyMap currentEntityPropertyMap [emptyMap] ;
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    if not [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName string]] then
      error propertyTypeName : "the '@" . [propertyTypeName string]
      . "' is not a predefined type name" ;
    end if ;
    @lstring attributeName ;
    $identifier$ ? attributeName ;
    @metamodelProperty k := [@metamodelAttributeProperty new !propertyTypeName] ;
    [!?currentEntityPropertyMap insertKey !attributeName !k] ; 
    [!?allMetamodelPropertyMap insertKey !attributeName !k] ; 
    $;$ ;
  while
    @lstring propertyTypeName ;
    $mda_type_name$ ? propertyTypeName ;
    @metamodelProperty k ;
    @lstring attributeName ;
    select
    #--- Multiple reference
      @luint lowerBound ;
      @luint higherBound ;
      $[$ ;
      select
        $unsigned_literal_integer$ ? lowerBound ;
        select
          $,$ ;
          select
            $unsigned_literal_integer$ ? higherBound ;
            if ([lowerBound uint] == 0) & ([higherBound uint] == 0) then
              error lowerBound: "if lower bound is zero, higher bound should be greater than zero" ;
            elsif ([lowerBound uint] > 0) & ([higherBound uint] < [lowerBound uint]) then
              error lowerBound: "higher bound should be greater or equal than lower bound" ;
            end if ;
          or
            $*$ ;
            higherBound := [@luint new !0 !here] ;            
          end select ;
        or
          higherBound := lowerBound ;
          if [lowerBound uint] == 0 then
            error lowerBound: "if higher bound is implicit, lower bound should be greater than zero" ;
          end if ;
        end select ;
      or
        lowerBound := [@luint new !0 !here] ;
        higherBound := [@luint new !0 !here] ;
      end select ;
      $]$ ;
      $identifier$ ? attributeName ;
      k := [@metamodelMultipleReferenceProperty new !propertyTypeName !lowerBound !higherBound] ;
    or
    #--- Single Reference
      $identifier$ ? attributeName ;
      k := [@metamodelSingleReferenceProperty new !propertyTypeName] ;
    end select ;
    [!?currentEntityPropertyMap insertKey !attributeName !k] ; 
    [!?allMetamodelPropertyMap insertKey !attributeName !k] ; 
    $;$ ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey
    !entityName
    !allMetamodelPropertyMap
    !isAbstract
    !currentEntityPropertyMap
    !superEntity
    ![@entityPropertyMap emptyMap] # Current constraints
    !superEntitySet
    ![@entityPropertyMap emptyMap] # Current and super constraints
    !allMetamodelPropertyMap
   ] ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
