#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ??@bool inGenerateMetamodelCode
label parse
;

nonterminal <entity_declaration_list>
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
label parse
;

nonterminal <entity_declaration>
  ??@stringset inMetamodelClassSet
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
label parseForEnumeratingClasses
  ?!@stringset ioMetamodelClassSet
label parse
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap !true ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap !false ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap !false ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap !false ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ??@bool inGenerateMetamodelCode
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [emptyMap] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [emptyMap] ;
  @M_semanticsEntitiesForUse semanticsEntitiesMap ;
  @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
  enterBuiltinTypes ?semanticsEntitiesMap ;
  <entity_declaration_list>
    !semanticsEntitiesMap
    !?entityMap
    !?mapAndEntityUniqueMap
    !?listeEntitesAengendrer
  ;
  @bool isAbstract ;
  [entityMap searchKey !rootEntityName ?* ?isAbstract ?4*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Check properties
  @stringset multiReferencedEntities [emptySet] ;
  foreach entityMap (@lstring kEntityName
                     @entityPropertyMap kAllPropertiesMap
                     *
                     @entityPropertyMap kEntityPropertiesMap
                     3*) :
    foreach kEntityPropertiesMap (@lstring kAttributeName
                                  @metamodelProperty kProperty) :
      extract kProperty :
      when @metamodelSingleReferenceProperty (@lstring kReferenceEntityName) ->
        [entityMap searchKey !kReferenceEntityName ?6*] ;
      when @metamodelMultipleReferenceProperty (@lstring kReferenceEntityName * *) ->
        [entityMap searchKey !kReferenceEntityName ?6*] ;
        multiReferencedEntities += ![kReferenceEntityName string] ;
      else
      end extract ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  if inGenerateMetamodelCode then
    action generate_metamodel
      !entityMap
      !metamodelName
      !listeEntitesAengendrer
      !rootEntityName
    ;
  end if ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName string]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !entityMap
      !multiReferencedEntities
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap outEntityMap
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
:
  @stringset metamodelClassSet [emptySet] ;
  parse
  do
    repeat
    while
      <entity_declaration> parseForEnumeratingClasses
        !?metamodelClassSet
      ;
    end repeat ;
  rewind
    repeat
    while
      <entity_declaration>
        !metamodelClassSet
        !inSemanticsEntitiesMap
        !?outEntityMap
        !?ioMapAndEntityUniqueMap
        !?listeEntitesAengendrer
      ;
    end repeat ;
  end parse ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ??@stringset inMetamodelClassSet
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $class$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
  [!?ioMapAndEntityUniqueMap insertKey !entityName] ;
#--- Context properties, or super entity (or nothing)
  @entityPropertyMap allMetamodelPropertyMap ;
  @lstring superEntity ;
  @typeSuperClassesMap superEntityMap ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
  select
    superEntity := [@lstring new !"" !here] ;
    allMetamodelPropertyMap := [@entityPropertyMap emptyMap] ;
    superEntityMap := [@typeSuperClassesMap emptyMap] ;
    listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [ioEntityMap searchKey
      !superEntity
      ?allMetamodelPropertyMap
      ?*
      ?*
      ?*
      ?superEntityMap
      ?listeTousAttributsSemantiques
    ] ;
    [!?superEntityMap insertKey !superEntity] ;
  end select ;
#--- Property declarations
  @entityPropertyMap currentEntityPropertyMap [emptyMap] ;
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants [emptyList] ;
  ${$ ;
  repeat
  while
    @lstring propertyOrEntityTypeName ;
    $type_name$ ? propertyOrEntityTypeName ;
    select
      @lstring attributeName ;
      $identifier$ ? attributeName ;
      @AC_galgasType propertyType ;
      if [inMetamodelClassSet hasKey ![propertyOrEntityTypeName string]] then
        @metamodelProperty k := [@metamodelSingleReferenceProperty new !propertyOrEntityTypeName] ;
        [!?currentEntityPropertyMap insertKey !attributeName !k] ; 
        [!?allMetamodelPropertyMap insertKey !attributeName !k] ;
        propertyType := [@typeGalgas_singleReferenceEntity new !propertyOrEntityTypeName] ;
      else
        @AC_semanticsEntity entity ;
        [inSemanticsEntitiesMap searchKey !propertyOrEntityTypeName ?entity] ;
        extract entity->@typeEntiteType (?propertyType) error propertyOrEntityTypeName : messageTypeEntite ;
        @metamodelProperty k := [@metamodelAttributeProperty new !propertyType] ;
        [!?currentEntityPropertyMap insertKey !attributeName !k] ; 
        [!?allMetamodelPropertyMap insertKey !attributeName !k] ;
      end if ;
      listeTousAttributsSemantiques += !propertyType !attributeName ;
      listeAttributsSemantiquesCourants += !propertyType !attributeName ;
    or
      @luint lowerBound ;
      @luint higherBound ;
      $[$ ;
      select
        $unsigned_literal_integer$ ? lowerBound ;
        select
          $,$ ;
          select
            $unsigned_literal_integer$ ? higherBound ;
            if ([lowerBound uint] == 0) & ([higherBound uint] == 0) then
              error lowerBound: "if lower bound is zero, higher bound should be greater than zero" ;
            elsif ([lowerBound uint] > 0) & ([higherBound uint] < [lowerBound uint]) then
              error lowerBound: "higher bound should be greater or equal than lower bound" ;
            end if ;
          or
            $*$ ;
            higherBound := [@luint new !0 !here] ;            
          end select ;
        or
          higherBound := lowerBound ;
          if [lowerBound uint] == 0 then
            error lowerBound: "if higher bound is implicit, lower bound should be greater than zero" ;
          end if ;
        end select ;
      or
        lowerBound := [@luint new !0 !here] ;
        higherBound := [@luint new !0 !here] ;
      end select ;
      $]$ ;
      @lstring attributeName ;
      $identifier$ ? attributeName ;
      @metamodelProperty k := [@metamodelMultipleReferenceProperty new !propertyOrEntityTypeName !lowerBound !higherBound] ;
      [!?currentEntityPropertyMap insertKey !attributeName !k] ; 
      [!?allMetamodelPropertyMap insertKey !attributeName !k] ; 
      @AC_galgasType propertyType := [@typeGalgas_multipleReferenceEntity new
        !propertyOrEntityTypeName
        !lowerBound
        !higherBound
      ] ;
      listeTousAttributsSemantiques += !propertyType !attributeName ;
      listeAttributsSemantiquesCourants += !propertyType !attributeName ;
    end select ;
    $;$ ;
  end repeat ;
  $}$ ;
  @luint metamodelClassID ;
  [!?ioEntityMap insertKeyAndGetID
    !entityName
    ?metamodelClassID
    !allMetamodelPropertyMap
    !isAbstract
    !currentEntityPropertyMap
    !superEntity
    !superEntityMap
    !listeTousAttributsSemantiques
  ] ;
#--- Define entity type generation
  @typeEntityToGenerate def := [@C_metamodelEntityToImplement new 
    !entityName
    !isAbstract
    !listeTousAttributsSemantiques
    !listeAttributsSemantiquesCourants
    !superEntityMap
    ![metamodelClassID uint]
  ] ;
  listeEntitesAengendrer += !def ;
label parseForEnumeratingClasses
  ?!@stringset ioMetamodelClassSet
:
#--- Abstract ?
  select
  or
    $abstract$ ;
  end select ;
#--- Entity Name
  $class$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
  ioMetamodelClassSet += ![entityName string] ;
#--- Super entity (or nothing)
  select
  or
    $extends$ ;
    $type_name$ ? * ;
  end select ;
#--- Property declarations
  ${$ ;
  repeat
  while
    $type_name$ ? * ;
    select
      $identifier$ ? * ;
    or
      $[$ ;
      select
        $unsigned_literal_integer$ ? * ;
        select
          $,$ ;
          select
            $unsigned_literal_integer$ ? * ;
          or
            $*$ ;
          end select ;
        or
        end select ;
      or
      end select ;
      $]$ ;
      $identifier$ ? * ;
    end select ;
    $;$ ;
  end repeat ;
  $}$ ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
