#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  !@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

#-------------------------------------------------------------------*
#                   Lexical component                               *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [empty] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [empty] ;
  <entity_declaration_list> ?entityMap !?primitiveTypeAttributeNameSet ;
  @bool isAbstract ;
  [!?entityMap searchKey !rootEntityName ?* ?isAbstract ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Check that reference entities are declared
  @stringset multiReferencedEntities [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??*
                     ??*
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??*) :
    foreach kEntityPropertiesMap (??* ??@metamodelPropertyKind kKind ??@lstring kTypeName) :
      if kKind == [@metamodelPropertyKind singleReferenceProperty] then
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?*] ;
      elsif kKind == [@metamodelPropertyKind multipleReferenceProperty] then
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?*] ;
        multiReferencedEntities += ![kTypeName value] ;
      end if ;
    end foreach ;
  end foreach ;
  action generate_metamodel
    !?entityMap
    !metamodelName
    !multiReferencedEntities
  ;
#--- Build semantic entities map
  @M_semanticsEntitiesForUse semanticsEntityMap [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??@bool kIsAbstract
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??@lstring kSuperEntityName) :
    @stringset superEntitySet [empty] ;
    buildSuperEntitySet !?entityMap !kSuperEntityName !?superEntitySet ;
    @AC_galgasType t := [@typeGalgas_singleEntity new
      !kEntityName
      !kAllPropertiesMap
      !kIsAbstract
      !kEntityPropertiesMap
      !kSuperEntityName
      !superEntitySet
    ] ;
    @AC_semanticsEntity e := [@typeEntiteType new !t] ;
    [!?semanticsEntityMap insertKey
     !kEntityName
     !e
    ] ;
  end foreach ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName value]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !semanticsEntityMap
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  !@entityToImplementMap outEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
  outEntityMap := [@entityToImplementMap empty] ;
  repeat
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $entity$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
#--- Super entity
  @entityPropertyMap allPropertyMap ;
  @lstring superEntity ;
  select
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [!?ioEntityMap searchKey !superEntity ?* ?* ?allPropertyMap ?*] ;
  end select ;
#--- Property declarations
  @entityPropertyMap entityPropertyMap [empty] ;
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    @metamodelPropertyKind k ;
    @lstring attributeName ;
    select
    #--- Multiple reference
      $[$ ;
      $]$ ;
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
        error propertyTypeName : "the '@" . [propertyTypeName value]
        . "' is not an entity name, but a predefined type name" ;
      end if ;
      $identifier$ ? attributeName ;
      k := [@metamodelPropertyKind multipleReferenceProperty] ;
    or
      $identifier$ ? attributeName ;
    #--- Single reference or attribute ?
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
      #--- Attribute
        k := [@metamodelPropertyKind attributeProperty] ;
      else 
      #--- Single Reference
        k := [@metamodelPropertyKind singleReferenceProperty] ;
      end if ;
    end select ;
    [!?allPropertyMap insertKey !attributeName !k ! propertyTypeName] ;
    [!?entityPropertyMap insertKey !attributeName !k ! propertyTypeName] ;
    $;$ ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey !entityName !allPropertyMap !isAbstract !entityPropertyMap !superEntity] ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
