#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

rule <property_path>
  !@L_propertyPath outPath
label parse
;

rule <entity_declaration_list>
  !@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [empty] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [empty] ;
  <entity_declaration_list> ?entityMap !?primitiveTypeAttributeNameSet ;
  @bool isAbstract ;
  [!?entityMap searchKey !rootEntityName ?* ?isAbstract ?* ?* ?* ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Build semantic entities map
  @M_semanticsEntitiesForUse semanticsEntityMap [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??@bool kIsAbstract
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??@lstring kSuperEntityName
                     ??*
                     ??*
                     ??*) :
    @stringset superEntitySet [empty] ;
    buildSuperEntitySet !?entityMap !kSuperEntityName !?superEntitySet ;
    @AC_galgasType t := [@typeGalgas_singleEntity new
      !kEntityName
      !kAllPropertiesMap
      !kIsAbstract
      !kEntityPropertiesMap
      !kSuperEntityName
      !superEntitySet
    ] ;
    @AC_semanticsEntity e := [@typeEntiteType new !t] ;
    [!?semanticsEntityMap insertKey
     !kEntityName
     !e
    ] ;
  end foreach ;
#--- Check that reference entities are declared
  @stringset multiReferencedEntities [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??*
                     ??*
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??*
                     ??* 
                     ??*
                     ??*) :
    foreach kEntityPropertiesMap (??@lstring kAttributeName
                                  ??@metamodelPropertyKind kKind
                                  ??@lstring kTypeName
                                  ??@L_ListOfPropertyPathes kPropertyOptionPathes) :
      if (kKind == [@metamodelPropertyKind singleReferenceProperty]) |
         (kKind == [@metamodelPropertyKind multipleReferenceProperty]) then
        @contextPropertyMap contextPropertyMap ;
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?* ?* ?* ?contextPropertyMap] ;
        multiReferencedEntities += ![kTypeName value] ;
      #--- Check context options
        if [kPropertyOptionPathes length] != [contextPropertyMap count] then
          error kAttributeName: "this reference has "
          . [[kPropertyOptionPathes length] string] . " context parameter(s), while corresponding entity has "
          . [[contextPropertyMap count] string] . " context attribute(s)" ;
        else
          foreach kPropertyOptionPathes (??@L_propertyPath kPath ??@location kEndPofPathLocation),
                  contextPropertyMap (??@lstring kContextAttributeName ??@lstring kContextAttributeEntityName) :
            @entityPropertyMap currentMap := kEntityPropertiesMap ;
            @lstring typeName := kEntityName ;
            foreach kPath (??@lstring kPathElement) :
              @metamodelPropertyKind kind  ;
              [!?currentMap searchKey !kPathElement ?kind ?typeName ?*] ;
              [!?entityMap searchKey !typeName ?currentMap ?* ?* ?* ?* ?* ?*] ;
            end foreach ;
          #--- Check entity type name
            if [typeName value] != [kContextAttributeEntityName value] then
              error kEndPofPathLocation: "the path entity is '@"
              . [typeName value] . "', but its entity should be '@"
              . [kContextAttributeEntityName value] . "'" ;
            end if ;
          end foreach ;
        end if ;
      elsif kKind == [@metamodelPropertyKind contextProperty] then
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?* ?* ?* ?*] ;
      end if ;
    end foreach ;
  end foreach ;
#--- Check map definitions
  foreach entityMap (??@lstring kCurrentEntity
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??*
                     ??*
                     ??@mapPropertyMap kMapPropertyMap
                     ??*
                     ??*) :
    foreach kMapPropertyMap (??@lstring kMapName
                             ??@lstring kEntityName
                             ??@L_ListOfPropertyPathes kListOfPropertyPathes
                             ...) :
      foreach kListOfPropertyPathes (??@L_propertyPath kPath ??@location kEndOfPathLocation):
        @entityPropertyMap currentMap := kAllPropertiesMap ;
        @lstring lastEntityName := kCurrentEntity ;
        @string returnedTypeName := "" ;
        foreach kPath (??@lstring kPathElement) :
          @metamodelPropertyKind kind ;
          @lstring typeName ;
          [!?currentMap searchKey !kPathElement ?kind ?typeName ?*] ;
          if kind == [@metamodelPropertyKind attributeProperty] then
            returnedTypeName := [typeName value] ;
            currentMap := [@entityPropertyMap empty] ;
          elsif kind == [@metamodelPropertyKind singleReferenceProperty] then
            lastEntityName := typeName ;
            [!?entityMap searchKey !typeName ?currentMap ?* ?* ?* ?* ?* ?*] ;
          elsif kind == [@metamodelPropertyKind multipleReferenceProperty] then
            lastEntityName := typeName ;
            [!?entityMap searchKey !typeName ?currentMap ?* ?* ?* ?* ?* ?*] ;
          elsif kind == [@metamodelPropertyKind mapProperty] then
            error kPathElement : "A map property can be named in a property path" ;
            currentMap := [@entityPropertyMap empty] ;
          end if ;
        end foreach ;
        if returnedTypeName != "lstring" then
          error kEndOfPathLocation: "the path does not specify an @lstring attribute" ;
        end if ;
        @stringset superEntitySet [empty] ;
        buildSuperEntitySet !?entityMap !lastEntityName !?superEntitySet ;
        if not [superEntitySet hasKey ![kEntityName value]] then
          error kEndOfPathLocation:
            "the path names an attribute whose owner entity ('@" .
            [lastEntityName value] . "') does not inherit from '@" . 
            [kEntityName value] . "'" ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_metamodel
    !?entityMap
    !metamodelName
    !multiReferencedEntities
    !rootEntityName
  ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName value]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !semanticsEntityMap
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  !@entityToImplementMap outEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
  outEntityMap := [@entityToImplementMap empty] ;
  repeat
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $entity$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
#--- Context properties, or super entity (or nothing)
  @contextPropertyMap allContextPropertyMap ;
  @entityPropertyMap allPropertyMap ;
  @lstring superEntity ;
  @contextPropertyMap currentClassContextPropertyMap [empty] ;
  select
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
    allContextPropertyMap := [@contextPropertyMap empty] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [!?ioEntityMap searchKey !superEntity ?* ?* ?allPropertyMap ?* ?* ?* ?allContextPropertyMap] ;
  or
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
    allContextPropertyMap := [@contextPropertyMap empty] ;
    $($ ;
    repeat
      @lstring entityName ;
      $type_name$ ? entityName ;
      @lstring contextPropertyName ;
      $identifier$ ? contextPropertyName ;
      [!? currentClassContextPropertyMap insertKey !contextPropertyName !entityName] ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  end select ;
#--- Enter context properties
  @entityPropertyMap entityPropertyMap [empty] ;
  foreach currentClassContextPropertyMap (??@lstring kContextPropertyName ??@lstring kEntityName) :
    [!?allContextPropertyMap insertKey
       !kContextPropertyName
       !kEntityName
    ] ;
    [!?allPropertyMap insertKey
      !kContextPropertyName
      ![@metamodelPropertyKind contextProperty]
      !kEntityName
      ![@L_ListOfPropertyPathes empty]
    ] ;
    [!?entityPropertyMap insertKey
      !kContextPropertyName
      ![@metamodelPropertyKind contextProperty]
      !kEntityName
      ![@L_ListOfPropertyPathes empty]
    ] ;
  end foreach ;
#--- Property declarations
  @mapPropertyMap mapPropertyMap [empty] ;
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    @metamodelPropertyKind k ;
    @lstring attributeName ;
    select
    #--- Multiple reference
      $[$ ;
      $]$ ;
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
        error propertyTypeName : "the '@" . [propertyTypeName value]
        . "' is not an entity name, but a predefined type name" ;
      end if ;
      $identifier$ ? attributeName ;
      k := [@metamodelPropertyKind multipleReferenceProperty] ;
    or
      $identifier$ ? attributeName ;
    #--- Single reference or attribute ?
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
      #--- Attribute
        k := [@metamodelPropertyKind attributeProperty] ;
      else 
      #--- Single Reference
        k := [@metamodelPropertyKind singleReferenceProperty] ;
      end if ;
    end select ;
  #--- Path options
    @L_ListOfPropertyPathes propertyOptionPathes [empty] ;
    select
    or
      $in$ ;
      if [propertyTypeName value] != "lstring" then
        error here: "only an '@lstring' attribute accepts the 'in' option" ;
      end if ;
      @L_propertyPath path ;
      <property_path> ?path ;
      propertyOptionPathes += !path !here ;
    or
      $($ ;
      repeat
        select
          $self$ ;
          @L_propertyPath path [empty] ;
          propertyOptionPathes += !path !here ;
        or
          @L_propertyPath path ;
          <property_path> ?path ;
          propertyOptionPathes += !path !here ;
        end select ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
    [!?allPropertyMap insertKey !attributeName !k !propertyTypeName !propertyOptionPathes] ;
    [!?entityPropertyMap insertKey !attributeName !k !propertyTypeName !propertyOptionPathes] ;
    $;$ ;
  while
    $map$ ;
    @lstring entityName ;
    $type_name$ ? entityName ;
    @lstring mapPropertyName ;
    $identifier$ ? mapPropertyName ;
    @metamodelPropertyKind k [mapProperty] ;
    [!?allPropertyMap insertKey
      !mapPropertyName
      !k
      !entityName
      ![@L_ListOfPropertyPathes empty]
    ] ;
    [!?entityPropertyMap insertKey
      !mapPropertyName
      !k
      !entityName
      ![@L_ListOfPropertyPathes empty]
    ] ;
    ${$ ;
    @L_ListOfPropertyPathes listOfPropertyPathes [empty] ;
    repeat
      @L_propertyPath path ;
      <property_path> ?path ;
      listOfPropertyPathes += !path !here ;
    while 
      $,$ ;
    end repeat ;
    $}$ ;
    $insert$ ;
    $error$ ;
    $message$ ;
    @lstring insertErrorMessage ;
    $literal_string$ ? insertErrorMessage ;
    $search$ ;
    $error$ ;
    $message$ ;
    @lstring searchErrorMessage ;
    $literal_string$ ? searchErrorMessage ;
    $;$ ;
    [!?mapPropertyMap insertKey
      !mapPropertyName
      !entityName
      !listOfPropertyPathes
      !insertErrorMessage
      !searchErrorMessage
    ] ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey
    !entityName
    !allPropertyMap
    !isAbstract
    !entityPropertyMap
    !superEntity
    !mapPropertyMap
    !currentClassContextPropertyMap
    !allContextPropertyMap
   ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath empty] ;
  repeat
    @lstring pathElement ;
    $identifier$ ? pathElement ;
    outPath += !pathElement ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
