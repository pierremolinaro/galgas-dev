#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

rule <entity_declaration_list>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
label parse
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [emptySet] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [emptyMap] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [emptyMap] ;
  <entity_declaration_list>
    !?entityMap
    !?primitiveTypeAttributeNameSet
    !?mapAndEntityUniqueMap
  ;
  @bool isAbstract ;
  [entityMap searchKey !rootEntityName ?* ?isAbstract ?* ?* ?* ?* ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Build semantic entities map
  @M_semanticsEntitiesForUse semanticsEntityMap [emptyMap] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??@bool kIsAbstract
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??@lstring kSuperEntityName
                     ??@stringset kSuperEntitySet
                     ??*
                     ??*
                     ??*) :
     @AC_galgasType t := [@typeGalgas_singleEntity new
      !kEntityName
      !kAllPropertiesMap
      !kIsAbstract
      !kEntityPropertiesMap
      !kSuperEntityName
      !kSuperEntitySet
    ] ;
    @AC_semanticsEntity e := [@typeEntiteType new !t] ;
    [!?semanticsEntityMap insertKey
     !kEntityName
     !e
    ] ;
  end foreach ;
#--- Check properties
  @stringset multiReferencedEntities [emptySet] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??*
                     ??*
                     ??*
                     ??*
                     ??*) :
    foreach kEntityPropertiesMap (??@lstring kAttributeName
                                  ??@metamodelPropertyKind kKind
                                  ??@lstring kTypeName) :
      switch kKind 
      when attributeProperty :
      when singleReferenceProperty, multipleReferenceProperty :
        [entityMap searchKey !kTypeName ?* ?* ?* ?* ?* ?* ?* ?*] ;
        multiReferencedEntities += ![kTypeName string] ;
      end switch ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_metamodel
    !?entityMap
    !metamodelName
    !multiReferencedEntities
    !rootEntityName
  ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName string]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !semanticsEntityMap
      !entityMap
      !multiReferencedEntities
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  ?!@entityToImplementMap outEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
  repeat
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
      !?ioMapAndEntityUniqueMap
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
  ?!@mapAndEntityUniqueMap ioMapAndEntityUniqueMap
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $entity$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
  [!?ioMapAndEntityUniqueMap insertKey !entityName] ;
#--- Context properties, or super entity (or nothing)
  @entityPropertyMap allPropertyMap ;
  @lstring superEntity ;
  @stringset superEntitySet ;
  select
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap emptyMap] ;
    superEntitySet := [@stringset emptySet] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [ioEntityMap searchKey
      !superEntity
      ?*
      ?*
      ?allPropertyMap
      ?*
      ?superEntitySet
      ?*
      ?*
      ?*
    ] ;
    superEntitySet += ![superEntity string] ;
  end select ;
#--- Property declarations
  @entityPropertyMap entityPropertyMap [emptyMap] ;
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    @metamodelPropertyKind k ;
    @lstring attributeName ;
    select
    #--- Multiple reference
      $[$ ;
      $]$ ;
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName string]] then
        error propertyTypeName : "the '@" . [propertyTypeName string]
        . "' is not an entity name, but a predefined type name" ;
      end if ;
      $identifier$ ? attributeName ;
      k := [@metamodelPropertyKind multipleReferenceProperty] ;
    or
      $identifier$ ? attributeName ;
    #--- Single reference or attribute ?
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName string]] then
      #--- Attribute
        k := [@metamodelPropertyKind attributeProperty] ;
      else 
      #--- Single Reference
        k := [@metamodelPropertyKind singleReferenceProperty] ;
      end if ;
    end select ;
    [!?entityPropertyMap insertKey !attributeName !k !propertyTypeName] ; 
    [!?allPropertyMap insertKey !attributeName !k !propertyTypeName] ; 
    $;$ ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey
    !entityName
    !allPropertyMap
    !isAbstract
    !entityPropertyMap
    !superEntity
    !superEntitySet
    !false # is not defined implicitly
    ![@constrainedPropertyList emptyList]
    ![@constrainedPropertyList emptyList]
   ] ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
