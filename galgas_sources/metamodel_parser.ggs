#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  !@entityMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

#-------------------------------------------------------------------*
#                   Lexical component                               *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [empty] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityMap entityMap [empty] ;
  <entity_declaration_list> ?entityMap !?primitiveTypeAttributeNameSet ;
  @bool isAbstract ;
  [!?entityMap searchKey !rootEntityName ?isAbstract ?* ?* ?* ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Check that reference entities are declared
  foreach entityMap (??@lstring kEntityName
                     ??*
                     ??*
                     ??@entityAttributeMap kEntityAttributeMap
                     ??@entitySingleReferenceMap kSingleReferenceMap
                     ??@entityMultipleReferenceMap kMultipleReferenceMap
                     ??*) :
    foreach kSingleReferenceMap (??* ??@lstring kSingleReferenceType) :
      [!?entityMap searchKey !kSingleReferenceType ?* ?* ?* ?* ?* ?*] ;
    end foreach ;
    foreach kMultipleReferenceMap (??* ??@lstring kMultipleReferenceType) :
      [!?entityMap searchKey !kMultipleReferenceType ?* ?* ?* ?* ?* ?*] ;
    end foreach ;
  end foreach ;
  action generate_metamodel
    !?entityMap
    !metamodelName
  ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $metamodel$ ;
  $identifier$ ?* ;
  $root$ ;
  $type_name$ ? * ;
  $:$ ;
  <entity_declaration_list> parse ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
:
  $metamodel$ ;
  $identifier$ ? * ;
  $root$ ;
  $type_name$ ? * ;
  $:$ ;
  <entity_declaration_list> parse ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
:
  $metamodel$ ;
  $identifier$ ? * ;
  $root$ ;
  $type_name$ ? * ;
  $:$ ;
  <entity_declaration_list> parse ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
:
  $metamodel$ ;
  $identifier$ ? * ;
  $root$ ;
  $type_name$ ? * ;
  $:$ ;
  <entity_declaration_list> parse ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $metamodel$ ;
  $identifier$ ? * ;
  $root$ ;
  $type_name$ ? * ;
  $:$ ;
  <entity_declaration_list> parse ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  !@entityMap outEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
  outEntityMap := [@entityMap empty] ;
  repeat
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $entity$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
#--- Super entity
  @entityAttributeMap entityAttributeMap ;
  @entitySingleReferenceMap singleReferenceMap ;
  @entityMultipleReferenceMap multipleReferenceMap ;
  @entityAttributeAndReferenceMap m ;
  @lstring superEntity ;
  select
    superEntity := [@lstring new !"" !here] ;
    entityAttributeMap := [@entityAttributeMap empty] ;
    singleReferenceMap := [@entitySingleReferenceMap empty] ;
    multipleReferenceMap := [@entityMultipleReferenceMap empty] ;
    m := [@entityAttributeAndReferenceMap empty] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [!?ioEntityMap searchKey !superEntity ?* ?* ?entityAttributeMap ?singleReferenceMap ?multipleReferenceMap ?m] ;
  end select ;
#--- Property declarations
  ${$ ;
  repeat
  while
    $attribute$ ;
    @lstring attributeTypeName ;
    $type_name$ ? attributeTypeName ;
    if not [ioPrimitiveTypeAttributeNameSet hasKey ![attributeTypeName value]] then
      error attributeTypeName : "the '@" . [attributeTypeName value] . "' is not a predefined attribute type" ;
    end if ;
    @lstring attributeName ;
    $identifier$ ? attributeName ;
    [!?m insertKey !attributeName] ;
    [!?entityAttributeMap insertKey !attributeName !attributeTypeName] ;
    $;$ ;
  while
    $ref$ ;
    @lstring referenceEntityName ;
    $type_name$ ? referenceEntityName ;
    @lstring referenceName ;
    $identifier$ ? referenceName ;
    [!?m insertKey !referenceName] ;
    [!?singleReferenceMap insertKey !referenceName !referenceEntityName] ;
    $;$ ;
  while
    $list$ ;
    @lstring entityName ;
    $type_name$ ? entityName ;
    @lstring referenceName ;
    $identifier$ ? referenceName ;
    [!?m insertKey !referenceName] ;
    [!?multipleReferenceMap insertKey !referenceName !entityName] ;
    $;$ ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey !entityName !isAbstract !superEntity
                           !entityAttributeMap !singleReferenceMap !multipleReferenceMap !m] ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
