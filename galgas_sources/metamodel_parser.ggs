#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

rule <property_path>
  !@L_propertyPath outPath
label parse
;

rule <entity_declaration_list>
  !@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
label parse
;

rule <entity_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <entity_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <entity_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <entity_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
label parse 
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  <parse_metamodel> !?ioMetamodelComponentMap ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
#--- Metamodel header
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
#--- Build primitive attribute type name set
  @stringset primitiveTypeAttributeNameSet [empty] ;
  primitiveTypeAttributeNameSet += !"bool" ;
  primitiveTypeAttributeNameSet += !"char" ;
  primitiveTypeAttributeNameSet += !"uint" ;
  primitiveTypeAttributeNameSet += !"sint" ;
  primitiveTypeAttributeNameSet += !"double" ;
  primitiveTypeAttributeNameSet += !"string" ;
  primitiveTypeAttributeNameSet += !"lbool" ;
  primitiveTypeAttributeNameSet += !"lchar" ;
  primitiveTypeAttributeNameSet += !"luint" ;
  primitiveTypeAttributeNameSet += !"lsint" ;
  primitiveTypeAttributeNameSet += !"ldouble" ;
  primitiveTypeAttributeNameSet += !"lstring" ;
  primitiveTypeAttributeNameSet += !"location" ;
#--- Root entity
  $root$ ;
  @lstring rootEntityName ;
  $type_name$ ? rootEntityName ;
  $:$ ;
  @entityToImplementMap entityMap [empty] ;
  <entity_declaration_list> ?entityMap !?primitiveTypeAttributeNameSet ;
  @bool isAbstract ;
  [!?entityMap searchKey !rootEntityName ?* ?isAbstract ?* ?* ?* ?* ?* ?*] ;
  if isAbstract then
    error rootEntityName : "the root entity cannot be abstract" ;
  end if ;
#--- Build semantic entities map
  @M_semanticsEntitiesForUse semanticsEntityMap [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??@bool kIsAbstract
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??@lstring kSuperEntityName
                     ??*
                     ??*
                     ??*
                     ??*) :
    @stringset superEntitySet [empty] ;
    buildSuperEntitySet !?entityMap !kSuperEntityName !?superEntitySet ;
    @AC_galgasType t := [@typeGalgas_singleEntity new
      !kEntityName
      !kAllPropertiesMap
      !kIsAbstract
      !kEntityPropertiesMap
      !kSuperEntityName
      !superEntitySet
    ] ;
    @AC_semanticsEntity e := [@typeEntiteType new !t] ;
    [!?semanticsEntityMap insertKey
     !kEntityName
     !e
    ] ;
  end foreach ;
#--- Check properties
  @stringset multiReferencedEntities [empty] ;
  foreach entityMap (??@lstring kEntityName
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??@entityPropertyMap kEntityPropertiesMap
                     ??*
                     ??* 
                     ??*
                     ??*
                     ??*) :
    foreach kEntityPropertiesMap (??@lstring kAttributeName
                                  ??@metamodelPropertyKind kKind
                                  ??@lstring kTypeName
                                  ??@L_ListOfPropertyPathes kPropertyOptionPathes) :
      if (kKind == [@metamodelPropertyKind singleReferenceProperty]) |
         (kKind == [@metamodelPropertyKind multipleReferenceProperty]) then
        @contextPropertyMap contextPropertyMap ;
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?* ?* ?contextPropertyMap ?* ?*] ;
        multiReferencedEntities += ![kTypeName value] ;
      #--- Check context options
        if [kPropertyOptionPathes length] != [contextPropertyMap count] then
          error kAttributeName: "this reference has "
          . [[kPropertyOptionPathes length] string] . " context parameter(s), while corresponding entity has "
          . [[contextPropertyMap count] string] . " context attribute(s)" ;
        else
          foreach kPropertyOptionPathes (??@L_propertyPath kPath ??@location kEndPofPathLocation),
                  contextPropertyMap (??@lstring kContextAttributeName ??@lstring kContextAttributeEntityName) :
            @lstring typeName ;
            checkPath
              !?entityMap
              !kAllPropertiesMap
              !kEntityName
              !kPath
              ?*
              ?typeName
              ?*
            ;
          #--- Check entity type name
            if [typeName value] != [kContextAttributeEntityName value] then
              error kEndPofPathLocation: "the path entity is '@"
              . [typeName value] . "', but its entity should be '@"
              . [kContextAttributeEntityName value] . "'" ;
            end if ;
          end foreach ;
        end if ;
      elsif kKind == [@metamodelPropertyKind contextProperty] then
        [!?entityMap searchKey !kTypeName ?* ?* ?* ?* ?* ?* ?* ?*] ;
      elsif kKind == [@metamodelPropertyKind fetchedProperty] then
        foreach kPropertyOptionPathes (??@L_propertyPath kPath ??@location kEndPofPathLocation):
          @lstring typeName ;
          @metamodelPropertyKind kind ;
          checkPath
            !?entityMap
            !kAllPropertiesMap
            !kEntityName
            !kPath
            ?kind
            ?typeName
            ?*
          ;
          if kind != [@metamodelPropertyKind mapProperty] then
            error kEndPofPathLocation: "this path does define a map property" ;
          end if ;
        end foreach ;
      end if ;
    end foreach ;
  end foreach ;
#--- Check fetched properties
  foreach entityMap (??@lstring kCurrentEntity
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??*
                     ??*
                     ??*
                     ??*
                     ??@fetchedPropertyMap kFetchedPropertyMap
                     ??*) :
    @entityPropertyMap allPropertiesMap := kAllPropertiesMap ;
    foreach kFetchedPropertyMap (??@lstring kFetchedPropertyName
                                 ??@lstring kFetchedEntityName
                                 ??@lstring kAttributeName
                                 ??@L_propertyPath kPath
                                 ??@location kEndOfPathLocation) :
    #--- Check designated attribute in an @lstring
      @metamodelPropertyKind kind ;
      @lstring attributeTypeName ;
      [!?allPropertiesMap searchKey !kAttributeName ?kind ?attributeTypeName ?*] ;
      if kind != [@metamodelPropertyKind attributeProperty] then
        error kAttributeName: "this property is not an attribute" ;
      elsif [attributeTypeName value] != "lstring" then
        error kAttributeName: "this attribute should be an '@lstring' attribute" ;
      end if ;
    #--- Check path
      @lstring typeName ;
      checkPath
        !?entityMap
        !kAllPropertiesMap
        !kCurrentEntity
        !kPath
        ?kind
        ?typeName
        ?*
      ;
      if kind != [@metamodelPropertyKind mapProperty] then
        error kEndOfPathLocation: "this path does not designate a map property" ;
      elsif [kFetchedEntityName value] != [typeName value] then
        error kAttributeName: "this property has '@"
        . [kFetchedEntityName value]
        . "', while '@" . [typeName value] . "' was expected" ;
      end if ;
    end foreach ;
  end foreach ;
#--- Check map definitions
  foreach entityMap (??@lstring kCurrentEntity
                     ??@entityPropertyMap kAllPropertiesMap
                     ??*
                     ??*
                     ??*
                     ??@mapPropertyMap kMapPropertyMap
                     ??*
                     ??*
                     ??*) :
    foreach kMapPropertyMap (??@lstring kMapName
                             ??@lstring kEntityName
                             ??@L_ListOfPropertyPathes kListOfPropertyPathes
                             ...) :
      foreach kListOfPropertyPathes (??@L_propertyPath kPath ??@location kEndOfPathLocation):
        @lstring typeName ;
        @metamodelPropertyKind kind ;
        @lstring lastEntityTypeName ;
        checkPath
          !?entityMap
          !kAllPropertiesMap
          !kEntityName
          !kPath
          ?kind
          ?typeName
          ?lastEntityTypeName
        ;
        if [typeName value] != "lstring" then
          error kEndOfPathLocation: "the path does not specify an @lstring attribute" ;
        end if ;
        @stringset superEntitySet [empty] ;
        buildSuperEntitySet !?entityMap !lastEntityTypeName !?superEntitySet ;
        if not [superEntitySet hasKey ![kEntityName value]] then
          error kEndOfPathLocation:
            "the path names an attribute whose owner entity ('@" .
            [lastEntityTypeName value] . "') does not inherit from '@" . 
            [kEntityName value] . "'" ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_metamodel
    !?entityMap
    !metamodelName
    !multiReferencedEntities
    !rootEntityName
  ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName value]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !semanticsEntityMap
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  !@entityToImplementMap outEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
  outEntityMap := [@entityToImplementMap empty] ;
  repeat
  while
    <entity_declaration>
      !?outEntityMap
      !?ioPrimitiveTypeAttributeNameSet
    ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@stringset ioPrimitiveTypeAttributeNameSet
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Name
  $entity$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
#--- Context properties, or super entity (or nothing)
  @entityPropertyMap entityPropertyMap [empty] ;
  @fetchedPropertyMap allFetchedPropertyMap ;
  @contextPropertyMap allContextPropertyMap [empty] ;
  @entityPropertyMap allPropertyMap ;
  @lstring superEntity ;
  select
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
    allFetchedPropertyMap := [@fetchedPropertyMap empty] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [!?ioEntityMap searchKey
      !superEntity
      ?*
      ?*
      ?allPropertyMap
      ?*
      ?*
      ?allContextPropertyMap
      ?*
      ?allFetchedPropertyMap
    ] ;
  or
    superEntity := [@lstring new !"" !here] ;
    allPropertyMap := [@entityPropertyMap empty] ;
    allFetchedPropertyMap := [@fetchedPropertyMap empty] ;
    $($ ;
    repeat
      @lstring entityName ;
      $type_name$ ? entityName ;
      @lstring contextPropertyName ;
      $identifier$ ? contextPropertyName ;
      [!?allContextPropertyMap insertKey !contextPropertyName !entityName] ;
      [!?allPropertyMap insertKey
        !contextPropertyName
        ![@metamodelPropertyKind contextProperty]
        !entityName
        ![@L_ListOfPropertyPathes empty]
      ] ;
      [!?entityPropertyMap insertKey
        !contextPropertyName
        ![@metamodelPropertyKind contextProperty]
        !entityName
        ![@L_ListOfPropertyPathes empty]
      ] ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  end select ;
#--- Property declarations
  @fetchedPropertyMap fetchedPropertyMap [empty] ;
  @mapPropertyMap mapPropertyMap [empty] ;
  @relationMap relationMap [empty] ;
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    @metamodelPropertyKind k ;
    @lstring attributeName ;
    select
    #--- Multiple reference
      $[$ ;
      $]$ ;
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
        error propertyTypeName : "the '@" . [propertyTypeName value]
        . "' is not an entity name, but a predefined type name" ;
      end if ;
      $identifier$ ? attributeName ;
      k := [@metamodelPropertyKind multipleReferenceProperty] ;
    or
      $identifier$ ? attributeName ;
    #--- Single reference or attribute ?
      if [ioPrimitiveTypeAttributeNameSet hasKey ![propertyTypeName value]] then
      #--- Attribute
        k := [@metamodelPropertyKind attributeProperty] ;
      else 
      #--- Single Reference
        k := [@metamodelPropertyKind singleReferenceProperty] ;
      end if ;
    end select ;
  #--- Path options
    @L_ListOfPropertyPathes propertyOptionPathes [empty] ;
    select
      #--- No option
    or
      $search$ ;
      if k != [@metamodelPropertyKind singleReferenceProperty] then
        error here: "attribute property or multiple reference property cannot accept 'search' construct" ;
      end if ;
      k := [@metamodelPropertyKind fetchedProperty] ;
      @lstring fetchedAttributeName ;
      $identifier$ ? fetchedAttributeName ;
      $in$ ;
      @L_propertyPath path ;
      <property_path> ?path ;
      [!?fetchedPropertyMap insertKey
        !attributeName
        !propertyTypeName
        !fetchedAttributeName
        !path
        !here
      ] ;
    or
      $($ ;
      if (k != [@metamodelPropertyKind singleReferenceProperty])
       & (k != [@metamodelPropertyKind multipleReferenceProperty]) then
        error here:"only a reference property accepts context parameters" ;
      end if ;
      repeat
        select
          $self$ ;
          @L_propertyPath path [empty] ;
          propertyOptionPathes += !path !here ;
        or
          @L_propertyPath path ;
          <property_path> ?path ;
          propertyOptionPathes += !path !here ;
        end select ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
    [!?allPropertyMap insertKey !attributeName !k !propertyTypeName !propertyOptionPathes] ;
    [!?entityPropertyMap insertKey !attributeName !k !propertyTypeName !propertyOptionPathes] ;
    $;$ ;
  while
    $map$ ;
    @lstring entityName ;
    $type_name$ ? entityName ;
    @lstring mapPropertyName ;
    $identifier$ ? mapPropertyName ;
    @metamodelPropertyKind k [mapProperty] ;
    [!?allPropertyMap insertKey
      !mapPropertyName
      !k
      !entityName
      ![@L_ListOfPropertyPathes empty]
    ] ;
    [!?entityPropertyMap insertKey
      !mapPropertyName
      !k
      !entityName
      ![@L_ListOfPropertyPathes empty]
    ] ;
    ${$ ;
    @L_ListOfPropertyPathes listOfPropertyPathes [empty] ;
    repeat
      @L_propertyPath path ;
      <property_path> ?path ;
      listOfPropertyPathes += !path !here ;
    while 
      $,$ ;
    end repeat ;
    $}$ ;
    $insert$ ;
    $error$ ;
    $message$ ;
    @lstring insertErrorMessage ;
    $literal_string$ ? insertErrorMessage ;
    action check_KL_escapeCharacters !insertErrorMessage ;
    $search$ ;
    $error$ ;
    $message$ ;
    @lstring searchErrorMessage ;
    $literal_string$ ? searchErrorMessage ;
    action check_K_escapeCharacters !searchErrorMessage ;
    $;$ ;
    [!?mapPropertyMap insertKey
      !mapPropertyName
      !entityName
      !listOfPropertyPathes
      !insertErrorMessage
      !searchErrorMessage
    ] ;
  while
    $relation$ ;
    @lstring relationIdentifier ;
    $identifier$ ? relationIdentifier ;
    $[$ ;
    @relationVarMap relationVarMap [empty] ;
    repeat
      @lstring localVar ;
      $identifier$ ? localVar ;
      $:$ ;
      @L_propertyPath path ;
      <property_path> ?path ;
      [!?relationVarMap insertKey !localVar !path] ;
    while
      $,$ ;
    end repeat ;
    $]$ ;
    $:=$ ;
    @metamodelRelationExpression e ;
    <entity_relation_expression> !?relationVarMap ?e ;
    $;$ ;
    [!?relationMap insertKey !relationIdentifier !relationVarMap!e] ;
  end repeat ;
  $}$ ;
  [!?ioEntityMap insertKey
    !entityName
    !allPropertyMap
    !isAbstract
    !entityPropertyMap
    !superEntity
    !mapPropertyMap
    !allContextPropertyMap
    !fetchedPropertyMap
    !allFetchedPropertyMap
   ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath empty] ;
  repeat
    select
      @lstring pathElement ;
      $identifier$ ? pathElement ;
      outPath += !pathElement ;
    or
      @lstring pathElement ;
      $type_name$ ? pathElement ;
      outPath += ![@lstring new !".". [pathElement value] ![pathElement location]] ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  <entity_relation_term> !?ioRelationVariableMap ?outExpression ;
  repeat
  while
    $|$ ;
    @metamodelRelationExpression e ;
    <entity_relation_term> !?ioRelationVariableMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  <entity_relation_factor> !?ioRelationVariableMap ?outExpression ;
  repeat
  while
    $&$ ;
    @metamodelRelationExpression e ;
    <entity_relation_factor> !?ioRelationVariableMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  select
    <entity_relation_primary> !?ioRelationVariableMap ?outExpression ;
  or
    $not$ ;
    <entity_relation_primary> !?ioRelationVariableMap ?outExpression ;
    outExpression := [@metamodelRelationNot new !outExpression] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  !@metamodelRelationExpression outExpression
:
  select
    $true$ ;
    outExpression := [@metamodelRelationTrue new] ;
  or
    $false$ ;
    outExpression := [@metamodelRelationFalse new] ;
  or
    $($ ;
    <entity_relation_expression> !?ioRelationVariableMap ?outExpression ;
    $)$ ;
  or
    ${$ ;
    @lstring localVar ;
    $identifier$ ? localVar ;
    @luint variableIndex ;
    [!?ioRelationVariableMap searchKeyAndGetIndex !localVar ?variableIndex ?*] ;
    $==$ ;
    @L_propertyPath path ;
    <property_path> ?path ;
    $}$ ;
    outExpression := [@metamodelRelationPrimary new !localVar !variableIndex !path] ;
#  or
#   $do$ ;
#    $($ ;
#     @L_propertyPath path ;
#     <property_path> ?path ;
#    $[$ ;
#    repeat
#      @lstring parameter ;
#      $identifier$ ? parameter ;
#    while
#      $,$ ;
#    end repeat ;
#    $]$ ;
#    $:$ ;
#    select
#      $|$ ;
#    or
#      $&$ ;
#    end select ;
#    $)$ ;
  end select ;
end rule ;

#-------------------------------------------------------------------*


end syntax ;
