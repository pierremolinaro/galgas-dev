semantics lexiqueSemantics :
import semantics lexiqueMetamodel in "lexiqueMetamodel.gSemantics" ;

#---------------------------------------------------------------------------*

enum @lexicalTypeEnum {
  constructor lexicalType_string ;
  constructor lexicalType_char ;
  constructor lexicalType_uint ;
  constructor lexicalType_uint64 ;
  constructor lexicalType_sint ;
  constructor lexicalType_sint64 ;
  constructor lexicalType_double ;
}{
  reader lexicalTypeName :
    lexicalType_string -> "@string" ;
    lexicalType_char   -> "@char" ;
    lexicalType_uint   -> "@uint" ;
    lexicalType_uint64 -> "@uint64" ;
    lexicalType_sint   -> "@sint" ;
    lexicalType_sint64 -> "@sint64" ;
    lexicalType_double -> "@double" ;
  end reader ;

  reader cppTypeName :
    lexicalType_string -> "C_String" ;
    lexicalType_char   -> "utf32" ;
    lexicalType_uint   -> "uint32" ;
    lexicalType_uint64 -> "uint64" ;
    lexicalType_sint   -> "sint32" ;
    lexicalType_sint64 -> "sint64" ;
    lexicalType_double -> "double" ;
  end reader ;

  reader appendMethodName :
    lexicalType_string -> "appendCLiteralStringConstant" ;
    lexicalType_char   -> "appendUnicodeCharacter" ;
    lexicalType_uint   -> "appendUnsigned" ;
    lexicalType_uint64 -> "appendUnsigned64" ;
    lexicalType_sint   -> "appendSigned" ;
    lexicalType_sint64 -> "appendSigned64" ;
    lexicalType_double -> "appendDouble" ;
  end reader ;

  reader appendArgumentOfMethod :
    lexicalType_string -> "" ;
    lexicalType_char   -> " COMMA_HERE" ;
    lexicalType_uint   -> "" ;
    lexicalType_uint64 -> "" ;
    lexicalType_sint   -> "" ;
    lexicalType_sint64 -> "" ;
    lexicalType_double -> "" ;
  end reader ;

  reader exportedCPPTypeName :
    lexicalType_string -> "GGS_lstring" ;
    lexicalType_char   -> "GGS_lchar" ;
    lexicalType_uint   -> "GGS_luint" ;
    lexicalType_uint64 -> "GGS_luint64" ;
    lexicalType_sint   -> "GGS_lsint" ;
    lexicalType_sint64 -> "GGS_lsint64" ;
    lexicalType_double -> "GGS_ldouble" ;
  end reader ;

  reader initialization :
    lexicalType_string -> ".setLengthToZero ()" ;
    lexicalType_char   -> " = TO_UNICODE (0)" ;
    lexicalType_uint   -> " = 0" ;
    lexicalType_uint64 -> " = 0" ;
    lexicalType_sint   -> " = 0" ;
    lexicalType_sint64 -> " = 0" ;
    lexicalType_double -> " = 0.0" ;
  end reader ;
}

#---------------------------------------------------------------------------*

list @lexicalTypeList {
  @lexicalTypeEnum mLexicalType ;
}

#---------------------------------------------------------------------------*

map @lexicalTypeMap {
  @lexicalTypeEnum mLexicalType ;
  insert insertKey error message "the '@%K' lexical type is already declared in %L" ;
  search searchKey error message "there is no '@%K' lexical type" ;
}

#---------------------------------------------------------------------------*

map @lexicalAttributeMap {
  @lexicalTypeEnum mLexicalType ;
  insert insertKey error message "the '%K' lexical attribute has been already declared in %L" ;
  search searchKey error message "the '%K' lexical attribute is not declared" ;
}

#---------------------------------------------------------------------------*

list @lexicalSentValueList {
  @string mAttributeName ;
  @lexicalTypeEnum mLexicalType ;
}

#---------------------------------------------------------------------------*

map @terminalMap {
  @lexicalSentValueList mSentAttributeList ;
  insert insertKey error message "the '%K' terminal has been already declared in %L" ;
  search searchKey error message "the '%K' terminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @terminalList {
  @lstring mTerminalName ;
  @lexicalSentValueList mSentAttributeList ;
  @string mSyntaxErrorMessage ;
}

#---------------------------------------------------------------------------*

map @lexicalExplicitTokenListMap {
  @lstring mTerminal ;
  @lstringlist mFeatureList ;
  insert insertKey error message "the '%K' terminal has been already declared in the list" ;
  search searchKey error message "the '%K' terminal is not declared" ;
}

#---------------------------------------------------------------------------*

sortedlist @tokenSortedlist {
  @uint mLength ;
  @string mName ;
  @string mTerminalName ;
}{
  mLength <, mName <
}

#---------------------------------------------------------------------------*

map @lexicalExplicitTokenListMapMap {
  @lexicalExplicitTokenListMap mExplicitTokenListMap ;
  @tokenSortedlist mTokenSortedList ;
  insert insertKey error message "the '%K' token list has been already declared in %L" ;
  search searchKey error message "the '%K' token list is not declared" ;
}

#---------------------------------------------------------------------------*

map @lexicalMessageMap {
  @lstring mLexicalMessage ;
  @bool mMessageIsUsed ;
  insert insertKey error message "the '%K' message has been already declared in %L" ;
  search searchKey error message "the '%K' message is not declared" ;
}

#---------------------------------------------------------------------------*

list @lexicalRoutineFormalArgumentList {
  @lexicalArgumentMode mLexicalFormalArgumentMode ;
  @lexicalTypeEnum mLexicalFormalArgumentType ;
  @string mArgumentNameForComment ;
 }

#---------------------------------------------------------------------------*

map @lexicalRoutineMap {
  @lexicalRoutineFormalArgumentList mLexicalRoutineFormalArgumentList ;
  @stringlist mErrorMessageList ;
  @string mReplacementRoutineName ; # If obsolete, the name of replacement routine
  @bool mIsExtern ;
  insert insertKey error message "the '%K' lexical routine has been already declared" ;
  search searchKey error message "the '%K' lexical routine is not declared" ;
}

#---------------------------------------------------------------------------*

list @lexicalFunctionFormalArgumentList {
  @lexicalTypeEnum mLexicalType ;
  @string mArgumentNameForComment ;
}

#---------------------------------------------------------------------------*

map @lexicalFunctionMap {
  @lexicalFunctionFormalArgumentList mLexicalTypeList ;
  @lexicalTypeEnum mReturnedLexicalType ;
  @string mReplacementFunctionName ; # If obsolete, the name of replacement routine
  @bool mIsExtern ;
  insert insertKey error message "the '%K' lexical function has been already declared" ;
  search searchKey error message "the '%K' lexical function is not declared" ;
}


#---------------------------------------------------------------------------*

struct @lexiqueAnalysisContext {
  @lexicalRoutineMap mLexicalRoutineMessageMap ;
  @lexicalFunctionMap mLexicalFunctionMap ;
  @lexicalMessageMap mLexicalMessageMap ;
  @terminalMap mTerminalMap ;
  @terminalList mTerminalList ;
  @lexicalAttributeMap mLexicalAttributeMap ;
  @lexicalExplicitTokenListMapMap mLexicalTokenListMap ;
  @stringset mUnicodeStringToGenerate ;
}

#---------------------------------------------------------------------------*

end semantics ;