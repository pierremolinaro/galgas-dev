semantics lexiqueSemantics :
import "lexiqueTypesForAST.gSemantics" ;

#---------------------------------------------------------------------------*

enum @lexicalTypeEnum {
  lexicalType_string, lexicalType_char, lexicalType_uint,
  lexicalType_uint64, lexicalType_sint, lexicalType_sint64,
  lexicalType_double
}{
  reader lexicalTypeBaseName :
    lexicalType_string -> "string" ;
    lexicalType_char   -> "char" ;
    lexicalType_uint   -> "uint" ;
    lexicalType_uint64 -> "uint64" ;
    lexicalType_sint   -> "sint" ;
    lexicalType_sint64 -> "sint64" ;
    lexicalType_double -> "double" ;
  end reader ;

  reader cppTypeName :
    lexicalType_string -> "C_String" ;
    lexicalType_char   -> "utf32" ;
    lexicalType_uint   -> "PMUInt32" ;
    lexicalType_uint64 -> "PMUInt64" ;
    lexicalType_sint   -> "PMSInt32" ;
    lexicalType_sint64 -> "PMSInt64" ;
    lexicalType_double -> "double" ;
  end reader ;

  reader appendMethodName :
    lexicalType_string -> "appendCLiteralStringConstant" ;
    lexicalType_char   -> "appendUnicodeCharacter" ;
    lexicalType_uint   -> "appendUnsigned" ;
    lexicalType_uint64 -> "appendUnsigned64" ;
    lexicalType_sint   -> "appendSigned" ;
    lexicalType_sint64 -> "appendSigned64" ;
    lexicalType_double -> "appendDouble" ;
  end reader ;

  reader appendArgumentOfMethod :
    lexicalType_string -> "" ;
    lexicalType_char   -> " COMMA_HERE" ;
    lexicalType_uint   -> "" ;
    lexicalType_uint64 -> "" ;
    lexicalType_sint   -> "" ;
    lexicalType_sint64 -> "" ;
    lexicalType_double -> "" ;
  end reader ;

  reader initialization :
    lexicalType_string -> ".setLengthToZero ()" ;
    lexicalType_char   -> " = TO_UNICODE (0)" ;
    lexicalType_uint   -> " = 0" ;
    lexicalType_uint64 -> " = 0" ;
    lexicalType_sint   -> " = 0" ;
    lexicalType_sint64 -> " = 0" ;
    lexicalType_double -> " = 0.0" ;
  end reader ;

  reader cocoaTypeName :
    lexicalType_string -> "NSMutableString *" ;
    lexicalType_char   -> "UInt32" ;
    lexicalType_uint   -> "UInt32" ;
    lexicalType_uint64 -> "UInt64" ;
    lexicalType_sint   -> "SInt32" ;
    lexicalType_sint64 -> "SInt64" ;
    lexicalType_double -> "double" ;
  end reader ;

  reader cocoaInitializationCode :
    lexicalType_string -> "[[NSMutableString alloc] init]" ;
    lexicalType_char   -> "0" ;
    lexicalType_uint   -> "0" ;
    lexicalType_uint64 -> "0" ;
    lexicalType_sint   -> "0" ;
    lexicalType_sint64 -> "0" ;
    lexicalType_double -> "0.0" ;
  end reader ;

  reader cocoaResetPrefix :
    lexicalType_string -> "[" ;
    lexicalType_char   -> "" ;
    lexicalType_uint   -> "" ;
    lexicalType_uint64 -> "" ;
    lexicalType_sint   -> "" ;
    lexicalType_sint64 -> "" ;
    lexicalType_double -> "" ;
  end reader ;

  reader cocoaReset :
    lexicalType_string -> " setString:@\"\"]" ;
    lexicalType_char   -> " = 0" ;
    lexicalType_uint   -> " = 0" ;
    lexicalType_uint64 -> " = 0" ;
    lexicalType_sint   -> " = 0" ;
    lexicalType_sint64 -> " = 0" ;
    lexicalType_double -> " = 0.0" ;
  end reader ;
}

#---------------------------------------------------------------------------*

list @lexicalTypeList {
  @lexicalTypeEnum mLexicalType ;
}

#---------------------------------------------------------------------------*

map @lexicalTypeMap {
  @lexicalTypeEnum mLexicalType ;
  insert insertKey error message "the '@%K' lexical type is already declared in %L" ;
  search searchKey error message "there is no '@%K' lexical type" ;
}

#---------------------------------------------------------------------------*

map @lexicalAttributeMap {
  @lexicalTypeEnum mLexicalType ;
  insert insertKey error message "the '%K' lexical attribute has been already declared in %L" ;
  search searchKey error message "the '%K' lexical attribute is not declared" ;
}

#---------------------------------------------------------------------------*

list @lexicalSentValueList {
  @string mLexicalAttributeName ;
  @lexicalTypeEnum mLexicalType ;
}

#---------------------------------------------------------------------------*

map @terminalMap {
  @lexicalSentValueList mSentAttributeList ;
  insert insertKey error message "the '%K' terminal has been already declared in %L" ;
  search searchKey error message "the '%K' terminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @terminalList {
  @lstring mTerminalName ;
  @lexicalSentValueList mSentAttributeList ;
  @string mSyntaxErrorMessage ;
  @bool mIsEndOfTemplateMark ;
  @bool mAtomicSelection ; # True if atomic selection in source editor
  @uint mStyleIndex ; # 0 if default style
}

#---------------------------------------------------------------------------*

map @lexicalExplicitTokenListMap {
  @lstring mTerminal ;
  @lstringlist mFeatureList ;
  insert insertKey error message "the '%K' terminal has been already declared in the list" ;
  search searchKey error message "the '%K' terminal is not declared" ;
}

#---------------------------------------------------------------------------*

sortedlist @tokenSortedlist {
  @uint mLength ;
  @string mName ;
  @string mTerminalName ;
}{
  mLength <, mName <
}

#---------------------------------------------------------------------------*

map @lexicalExplicitTokenListMapMap {
  @lexicalExplicitTokenListMap mExplicitTokenListMap ;
  @tokenSortedlist mTokenSortedList ;
  @bool mShouldBeGenerated ;
  insert insertKey error message "the '%K' token list has been already declared in %L" ;
  search searchKey error message "the '%K' token list is not declared" ;
}

#---------------------------------------------------------------------------*

map @lexicalMessageMap {
  @lstring mLexicalMessage ;
  @bool mMessageIsUsed ;
  insert insertKey error message "the '%K' message has been already declared in %L" ;
  search searchKey error message "the '%K' message is not declared" ;
}

#---------------------------------------------------------------------------*

list @lexicalRoutineFormalArgumentList {
  @lexicalArgumentModeAST mLexicalFormalArgumentMode ;
  @lexicalTypeEnum mLexicalFormalArgumentType ;
  @string mArgumentNameForComment ;
 }

#---------------------------------------------------------------------------*

map @lexicalRoutineMap {
  @lexicalRoutineFormalArgumentList mLexicalRoutineFormalArgumentList ;
  @stringlist mErrorMessageList ;
  @bool mIsExtern ;
  insert insertKey error message "the '%K' lexical routine has been already declared" ;
  search searchKey error message "the '%K' lexical routine is not declared" ;
}

#---------------------------------------------------------------------------*

list @lexicalFunctionFormalArgumentList {
  @lexicalTypeEnum mLexicalType ;
  @string mArgumentNameForComment ;
}

#---------------------------------------------------------------------------*

map @lexicalFunctionMap {
  @lexicalFunctionFormalArgumentList mLexicalTypeList ;
  @lexicalTypeEnum mReturnedLexicalType ;
  @string mReplacementFunctionName ; # If obsolete, the name of replacement routine
  @bool mIsExtern ;
  insert insertKey error message "the '%K' lexical function has been already declared" ;
  search searchKey error message "the '%K' lexical function is not declared" ;
}


#---------------------------------------------------------------------------*

list @templateDelimitorList {
  @lstring mStartString ;
  @lstring mEndString ;
  @bool mPreservesStartDelimiter ;
}

#------------------------------------------------------------------*
#                       Styles map                                 *
#------------------------------------------------------------------*

map @styleMap {
  @lstring mComment ;
  @uint mStyleIndex ; # Allways > 0
  insert insertKey error message "the '%K' style is already declared in %L" ;
  search searchKey error message "the '%K' style is not declared" ;
}

#------------------------------------------------------------------*

map @lexicalTagMap {
  insert insertKey error message "the '%K' tag is already declared in %L",
                                 "the '%K' tag declaration shadows the tag declared in %L" ;
  search searchKey error message "the '%K' tag is not declared" ;
}

#---------------------------------------------------------------------------*

struct @lexiqueAnalysisContext {
  @lexicalRoutineMap mLexicalRoutineMessageMap ;
  @lexicalFunctionMap mLexicalFunctionMap ;
  @lexicalMessageMap mLexicalMessageMap ;
  @terminalMap mTerminalMap ;
  @terminalList mTerminalList ;
  @lexicalAttributeMap mLexicalAttributeMap ;
  @lexicalExplicitTokenListMapMap mLexicalTokenListMap ;
  @stringset mUnicodeStringToGenerate ;
  @templateDelimitorList mTemplateDelimitorList ;
  @styleMap mStyleMap ;
  @stringset mExternUnicodeTestFunctions ;
}

#---------------------------------------------------------------------------*

end semantics ;