#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueCocoaGeneration :
import "predefinedLexicalActions.gSemantics" ;

import semantics lexiqueMetamodel in "lexiqueMetamodel.gSemantics" ;
import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
import semantics predefinedLexicalActions in "predefinedLexicalActions.gSemantics" ;
import grammar lexiqueLL1grammar in "lexiqueLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*
#   L E X I C A L    E X P R E S S I O N    C O D E    G E N E R A T I O N  *
#---------------------------------------------------------------------------*

abstract reader @lexicalExpression generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalOrExpression generateCocoaConditionCode
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := [mLeftOperand generateCocoaConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= " || " ;
  outGeneratedCode .= [mRightOperand generateCocoaConditionCode !inLexiqueAnalysisContext] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterIntervalMatch generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  outGeneratedCode := "[self testForInputFromChar:" ;
  outGeneratedCode .= [[[mLowerBound char] uint] string] ;
  outGeneratedCode .= " toChar:" ;
  outGeneratedCode .= [[[mUpperBound char] uint] string] ;
  outGeneratedCode .= "]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringMatch generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self testForInputString:@" . [mString CStringConstantRepresentation] ;
  outGeneratedCode .= " advance:YES]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringNotMatch generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self notTestForInputString:@" ;
  outGeneratedCode .= [mString CStringConstantRepresentation] ;
  outGeneratedCode .= " error:& mNoLexicalError]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterMatch generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self testForInputChar:" ;
  outGeneratedCode .= [[[mCharacter char] uint] string] ;
  outGeneratedCode .= "]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterSetMatch generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self testForCharWithFunction:" ;
  outGeneratedCode .= mCharacterSetName ;
  outGeneratedCode .= "]" ;
end reader ;

#---------------------------------------------------------------------------*
#     R O U T I N E    O R    F U N C T I O N    A R G U M E N T            *
#---------------------------------------------------------------------------*

abstract reader @lexicalRoutineOrFunctionFormalInputArgument generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputArgument generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "mLexicalAttribute_" . mAttributeName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterInputArgument generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[[mCharacter char] uint] string] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalUnsignedInputArgument generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[mUnsigned uint] string] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCurrentCharacterInputArgument generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "mPreviousChar" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFunctionInputArgument generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanner_cocoa_function_" . mFunctionName . " (" ;
  foreach mFunctionActualArgumentList
  do outGeneratedCode .= [mLexicalActualInputArgument generateCocoaRoutineOrFunctionArgument] ;
  between outGeneratedCode .= ", " ;  end foreach ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*
#                   R O U T I N E    A R G U M E N T                        *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRoutineActualArgument generateCocoaRoutineArgument
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputOutputArgument generateCocoaRoutineArgument
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:  @lexicalTypeEnum lexicalType ;
  [[inLexiqueAnalysisContext mLexicalAttributeMap] searchKey !mAttributeName ?lexicalType] ;
  outGeneratedCode := "" ;  if lexicalType != [@lexicalTypeEnum lexicalType_string] then    outGeneratedCode .= "& " ;  end if ;
  outGeneratedCode .= "mLexicalAttribute_" . mAttributeName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFormalInputArgument generateCocoaRoutineArgument
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := [mRoutineOrFunctionFormalInputArgument generateCocoaRoutineOrFunctionArgument] ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    S E N D  I N S T R U C T I O N    D E F A U L T         *
#---------------------------------------------------------------------------*

abstract reader @lexicalSendDefaultAction generateCocoaDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalSendTerminalByDefault generateCocoaDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "mTokenCode = " . inScannerClassName . "_1_" . mDefaultSentTerminal . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorByDefault generateCocoaDefaultSendCode
  ?@string unused inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "mNoLexicalError = NO ;\n" ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    I N S T R U C T I O N    C O D E    G E N E R A T I O N *
#---------------------------------------------------------------------------*

abstract reader @lexicalInstruction generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalStructuredSendInstruction generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  foreach mLexicalSendSearchList do
    outGeneratedCode .= "if (mTokenCode == -1) {\n" ;
    outGeneratedCode .= "  mTokenCode = search_into_" . mSearchListName . " (mLexicalAttribute_" . mAttributeName . ") ;\n" ;
    outGeneratedCode .= "}\n" ;
  end foreach ;
  outGeneratedCode .= "if (mTokenCode == -1) {\n" ;
  outGeneratedCode .= "  " . [mLexicalSendDefaultAction generateCocoaDefaultSendCode !inScannerClassName] ;
  outGeneratedCode .= "}\n" ;
  outGeneratedCode .= "/* enterToken (token) ; */\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSimpleSendInstruction generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mTokenCode = " . inScannerClassName . "_1_" . [mSentTerminal identifierRepresentation] . " ;\n" ;
  outGeneratedCode .= "/* enterToken (token) ; */\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRepeatInstruction generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "do {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
#--- Repeated instruction
  foreach mRepeatedInstructionList do
    outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
#---
  foreach mLexicalWhileBranchList
  do
    outGeneratedCode .= "if (mNoLexicalError && (" ;
    outGeneratedCode .= [mWhileExpression generateCocoaConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ")) {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mWhileInstructionList do
      outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
  outGeneratedCode .= "}else{\n"
                      "  mLoop = NO ;\n"
                      "}\n" ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}while (mLoop && mNoLexicalError) ;\n"
                      "mLoop = YES ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSelectInstruction generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
#---
  foreach mLexicalSelectBranchList
  do
    outGeneratedCode .= "if (mNoLexicalError && (" ;
    outGeneratedCode .= [mSelectExpression generateCocoaConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ")) {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mSelectInstructionList do
      outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
#--- Default branch
  if [mDefaultInstructionList length] > 0 then
    outGeneratedCode .= "}else{\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mDefaultInstructionList do
      outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  end if ;
  outGeneratedCode .= "}\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRoutineInstruction generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanner_cocoa_routine_" . mRoutineName . " (& mNoLexicalError" ;
  foreach mActualArgumentList do
    outGeneratedCode .= ", " . [mLexicalRoutineActualArgument generateCocoaRoutineArgument !inLexiqueAnalysisContext] ;
  end foreach ;
  outGeneratedCode .= ") ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalDropInstruction generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ; # No generated code
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorInstruction generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mNoLexicalError = NO ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalWarningInstruction generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ; # No generated code
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalTagInstruction generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "const UInt32 locationForTag_" . mLexicalTagName . " = mCurrentLocation ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRewindInstruction generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mCurrentLocation = locationForTag_" . mLexicalTagName . " ;\n" ;
  outGeneratedCode .= "mTokenCode = " . inScannerClassName . "_1_" . [mTerminalName identifierRepresentation] . " ;\n" ;
  outGeneratedCode .= "/* enterToken (token) ; */\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalLogInstruction generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "/* lexicalLog (LINE_AND_SOURCE_FILE) ; */\n" ;
end reader ;

#---------------------------------------------------------------------------*
#        L E X I C A L    R U L E    C O D E    G E N E R A T I O N         *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRule generateCocoaCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalImplicitRule generateCocoaCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  @tokenSortedlist tokenSortedList ;
  [[inLexiqueAnalysisContext mLexicalTokenListMap] searchKey !mListName ?* ?tokenSortedList ?*] ;
  outGeneratedCode := "" ;
  foreach > tokenSortedList do
    outGeneratedCode .= "if (mNoLexicalError && [self testForInputString:@" ;
    outGeneratedCode .= [mName CStringConstantRepresentation] ;
    outGeneratedCode .= " advance:YES]) {\n" ;
    outGeneratedCode .= "  mTokenCode = " . inScannerClassName . "_1_" . [mTerminalName identifierRepresentation] . " ;\n" ;
    outGeneratedCode .= "  /* enterToken (token) ; */\n" ;
    outGeneratedCode .= "}else " ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalExplicitRule generateCocoaCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "if (mNoLexicalError && (" ;
  outGeneratedCode .= [mLexicalRuleExpression generateCocoaConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= ")) {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
  foreach mInstructionList do
    outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}else " ;
end reader ;

#---------------------------------------------------------------------------*

end semantics ;