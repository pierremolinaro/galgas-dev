#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueCocoaGeneration :
import "predefinedLexicalActions.gSemantics" ;

#---------------------------------------------------------------------------*
#   L E X I C A L    E X P R E S S I O N    C O D E    G E N E R A T I O N  *
#---------------------------------------------------------------------------*

abstract reader @lexicalExpressionAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalOrExpressionAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := [mLeftOperand generateCocoaConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= " || " ;
  outGeneratedCode .= [mRightOperand generateCocoaConditionCode !inLexiqueAnalysisContext] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterIntervalMatchAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  outGeneratedCode := "[self testForInputFromChar:" ;
  outGeneratedCode .= [[[mLowerBound char] uint] string] ;
  outGeneratedCode .= " toChar:" ;
  outGeneratedCode .= [[[mUpperBound char] uint] string] ;
  outGeneratedCode .= "]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringMatchAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self testForInputString:@" . [[mString string] utf8Representation] ;
  outGeneratedCode .= " advance:YES]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringNotMatchAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self notTestForInputString:@" ;
  outGeneratedCode .= [[mString string] utf8Representation] ;
  outGeneratedCode .= " error:& scanningOk]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterMatchAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self testForInputChar:" ;
  outGeneratedCode .= [[[mCharacter char] uint] string] ;
  outGeneratedCode .= "]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterSetMatchAST generateCocoaConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self testForCharWithFunction:" ;
  outGeneratedCode .= [mCharacterSetName string] ;
  outGeneratedCode .= "]" ;
end reader ;

#---------------------------------------------------------------------------*
#     R O U T I N E    O R    F U N C T I O N    A R G U M E N T            *
#---------------------------------------------------------------------------*

abstract reader @lexicalRoutineOrFunctionFormalInputArgumentAST generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputArgumentAST generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "mLexicalAttribute_" . mAttributeName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterInputArgumentAST generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[[mCharacter char] uint] string] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalUnsignedInputArgumentAST generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[mUnsigned uint] string] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCurrentCharacterInputArgumentAST generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "mPreviousChar" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFunctionInputArgumentAST generateCocoaRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanner_cocoa_function_" . mFunctionName . " (" ;
  foreach mFunctionActualArgumentList
  do outGeneratedCode .= [mLexicalActualInputArgument generateCocoaRoutineOrFunctionArgument] ;
  between outGeneratedCode .= ", " ;
  end foreach ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*
#                   R O U T I N E    A R G U M E N T                        *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRoutineActualArgumentAST generateCocoaRoutineArgument
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputOutputArgumentAST generateCocoaRoutineArgument
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  @lexicalTypeEnum lexicalType ;
  [[inLexiqueAnalysisContext mLexicalAttributeMap] searchKey !mAttributeName ?lexicalType] ;
  outGeneratedCode := "" ;
  if lexicalType != [@lexicalTypeEnum lexicalType_string] then
    outGeneratedCode .= "& " ;
  end if ;
  outGeneratedCode .= "mLexicalAttribute_" . mAttributeName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFormalInputArgumentAST generateCocoaRoutineArgument
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := [mRoutineOrFunctionFormalInputArgument generateCocoaRoutineOrFunctionArgument] ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    S E N D  I N S T R U C T I O N    D E F A U L T         *
#---------------------------------------------------------------------------*

abstract reader @lexicalSendDefaultActionAST generateCocoaDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalSendTerminalByDefaultAST generateCocoaDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "mTokenCode = " . inScannerClassName . "_1_" . [[mDefaultSentTerminal string] identifierRepresentation] . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorByDefaultAST generateCocoaDefaultSendCode
  ?@string unused inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanningOk = NO ;\n" ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    I N S T R U C T I O N    C O D E    G E N E R A T I O N *
#---------------------------------------------------------------------------*

abstract reader @lexicalInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalStructuredSendInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  foreach mLexicalSendSearchList do
    outGeneratedCode .= "if (mTokenCode == 0) {\n" ;
    outGeneratedCode .= "  mTokenCode = search_into_" . [inScannerClassName identifierRepresentation] . "_" . mSearchListName . " (mLexicalAttribute_" . mAttributeName . ") ;\n" ;
    outGeneratedCode .= "}\n" ;
  end foreach ;
  outGeneratedCode .= "if (mTokenCode == 0) {\n" ;
  outGeneratedCode .= "  " . [mLexicalSendDefaultAction generateCocoaDefaultSendCode !inScannerClassName] ;
  outGeneratedCode .= "}\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSimpleSendInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mTokenCode = " . inScannerClassName . "_1_" . [[mSentTerminal string] identifierRepresentation] . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRepeatInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "do {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
#--- Repeated instruction
  foreach mRepeatedInstructionList do
    outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
#---
  foreach mLexicalWhileBranchList
  do
    outGeneratedCode .= "if (scanningOk && (" ;
    outGeneratedCode .= [mWhileExpression generateCocoaConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ")) {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mWhileInstructionList do
      outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
  outGeneratedCode .= "}else{\n"
                      "  mLoop = NO ;\n"
                      "}\n" ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}while (mLoop && scanningOk) ;\n"
                      "mLoop = YES ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSelectInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
#---
  foreach mLexicalSelectBranchList
  do
    outGeneratedCode .= "if (scanningOk && (" ;
    outGeneratedCode .= [mSelectExpression generateCocoaConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ")) {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mSelectInstructionList do
      outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
#--- Default branch
  if [mDefaultInstructionList length] > 0 then
    outGeneratedCode .= "}else{\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mDefaultInstructionList do
      outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  end if ;
  outGeneratedCode .= "}\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRoutineInstructionAST generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanner_cocoa_routine_" . mRoutineName . " (& scanningOk" ;
  foreach mActualArgumentList do
    outGeneratedCode .= ", " . [mLexicalRoutineActualArgument generateCocoaRoutineArgument !inLexiqueAnalysisContext] ;
  end foreach ;
  outGeneratedCode .= ") ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalDropInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mTokenCode = " . inScannerClassName . "_1_" . [[mTerminalName string] identifierRepresentation] . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorInstructionAST generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanningOk = NO ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalWarningInstructionAST generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ; # No generated code
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalTagInstructionAST generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "scanningPointStructForCocoa locationForTag_" . mLexicalTagName . " ;\n" ;
  outGeneratedCode .= "[self saveScanningPoint: & locationForTag_" . mLexicalTagName . "] ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRewindInstructionAST generateCocoaInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "[self restoreScanningPoint: & locationForTag_" . mLexicalTagName . "] ;\n" ;
  outGeneratedCode .= "mTokenCode = " . inScannerClassName . "_1_" . [[mTerminalName string] identifierRepresentation] . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalLogInstructionAST generateCocoaInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "/* lexicalLog (LINE_AND_SOURCE_FILE) ; */\n" ;
end reader ;

#---------------------------------------------------------------------------*
#        L E X I C A L    R U L E    C O D E    G E N E R A T I O N         *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRuleAST generateCocoaCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalImplicitRuleAST generateCocoaCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  @tokenSortedlist tokenSortedList ;
  [[inLexiqueAnalysisContext mLexicalTokenListMap] searchKey !mListName ?* ?tokenSortedList ?*] ;
  outGeneratedCode := "" ;
  foreach \down tokenSortedList do
    outGeneratedCode .= "if (scanningOk && [self testForInputString:@" ;
    outGeneratedCode .= [mName utf8Representation] ;
    outGeneratedCode .= " advance:YES]) {\n" ;
    outGeneratedCode .= "  mTokenCode = " . inScannerClassName . "_1_" . [mTerminalName identifierRepresentation] . " ;\n" ;
    outGeneratedCode .= "}else " ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalExplicitRuleAST generateCocoaCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "if (scanningOk && (" ;
  outGeneratedCode .= [mLexicalRuleExpression generateCocoaConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= ")) {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
  foreach mInstructionList do
    outGeneratedCode .= [mInstruction generateCocoaInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}else " ;
end reader ;

#---------------------------------------------------------------------------*

end semantics ;