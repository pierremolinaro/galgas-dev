#---------------------------------------------------------------------------*
#                                                                           *
#  Build pure BNF production list                                           *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics buildPureBNFproductions :
import "grammarMetamodel.gSemantics" ;

import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;

#---------------------------------------------------------------------------*

list @syntaxRuleListForGrammar {
  @string mSyntaxComponentName ;
  @lstring mLeftNonTerminal ;
  @syntaxInstructionList mSyntaxInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    P U R E    R U L E    L I S T                               *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction buildPureSyntaxInstruction
  ??@string inSyntaxComponent
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList ioPureSyntaxInstructionList
  ?!@stringlist ioAddedNonTerminalList
  ?!@uint ioAddedRuleIndex
;

#---------------------------------------------------------------------------*

routine buildPureSyntaxInstructionList
  ??@string inSyntaxComponent
  ??@syntaxInstructionList inSyntaxInstructionList
  !@syntaxInstructionList outPureSyntaxInstructionList
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  ?!@stringlist ioAddedNonTerminalList
  ?!@uint ioAddedRuleIndex
:
  outPureSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  foreach inSyntaxInstructionList do
    [mInstruction buildPureSyntaxInstruction
      !inSyntaxComponent
      !?ioPureSyntaxRuleListForGrammar
      !?outPureSyntaxInstructionList
      !?ioAddedNonTerminalList
      !?ioAddedRuleIndex
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

override method @semanticInstruction buildPureSyntaxInstruction
  ??@string unused inSyntaxComponent
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList unused ioPureSyntaxInstructionList
  ?!@stringlist unused ioAddedNonTerminalList
  ?!@uint unused ioAddedRuleIndex
:
  error here : "internal error (use debug tool)" ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction buildPureSyntaxInstruction
  ??@string unused inSyntaxComponent
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList ioPureSyntaxInstructionList
  ?!@stringlist unused ioAddedNonTerminalList
  ?!@uint unused ioAddedRuleIndex
:
  ioPureSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction buildPureSyntaxInstruction
  ??@string unused inSyntaxComponent
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList ioPureSyntaxInstructionList
  ?!@stringlist unused ioAddedNonTerminalList
  ?!@uint unused ioAddedRuleIndex
:
  ioPureSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction buildPureSyntaxInstruction
  ??@string inSyntaxComponent
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList ioPureSyntaxInstructionList
  ?!@stringlist ioAddedNonTerminalList
  ?!@uint ioAddedRuleIndex
:
#--- How the sequence 'A ; repeat X while Y while Z ... end repeat ; B' is translated into pure BNF productions
# A new non terminal, call it <T> is created (in fact, in the BNF file, this non terminal has a mangled
# name from source file, location line and column : <select_repeat_SOURCEFILE_LINE_COLUMN>)
#
# The sequence is translated into 'A ; X ; <T> ; B'.
#
# 1 empty production is added :
#         <T> -> .
#
# Every while branch gives a new production :
#         <T> -> Y X <T>
#         <T> -> Z X <T>
#         ...
#
#--- Create new non terminal symbols
  @string addedNonTerminalString := "select_repeat_" . inSyntaxComponent . "_" . [ioAddedRuleIndex string] ;
  ioAddedRuleIndex ++ ;
  @lstring selectRepeatAddedNonTerminal [new
    !addedNonTerminalString
    !mRepeatInstructionLocation
  ] ;
  ioAddedNonTerminalList += !addedNonTerminalString ;
#--- Build 'X' transformed in pure BNF
  @syntaxInstructionList repeatedPureInstructionList ;
  buildPureSyntaxInstructionList
    !inSyntaxComponent
    !mRepeatedInstructionList
    ?repeatedPureInstructionList
    !?ioPureSyntaxRuleListForGrammar
    !?ioAddedNonTerminalList
    !?ioAddedRuleIndex
  ;
#--- Append pure syntax instruction to current pure instruction list
  ioPureSyntaxInstructionList .= repeatedPureInstructionList ;
  ioPureSyntaxInstructionList += ![@nonterminalCallInstruction new
    !selectRepeatAddedNonTerminal
    ![@lstring new !"" !here] # no Label
    ![@actualParameterList emptyList]
  ] ;
#--- Add Empty production
  ioPureSyntaxRuleListForGrammar +=
    !inSyntaxComponent
    !selectRepeatAddedNonTerminal
    ![@syntaxInstructionList emptyList]
  ;
#--- Create "repeat_..." rules
  foreach mRepeatBranchList do
    @syntaxInstructionList pureInstructionList ;
    buildPureSyntaxInstructionList
      !inSyntaxComponent
      !mSyntaxInstructionList
      ?pureInstructionList
      !?ioPureSyntaxRuleListForGrammar
      !?ioAddedNonTerminalList
      !?ioAddedRuleIndex
    ;
    pureInstructionList .= repeatedPureInstructionList ;
    pureInstructionList += ![@nonterminalCallInstruction new
      !selectRepeatAddedNonTerminal
      ![@lstring new !"" !here] # no Label
      ![@actualParameterList emptyList]
    ] ;
    ioPureSyntaxRuleListForGrammar +=
      !inSyntaxComponent
      !selectRepeatAddedNonTerminal
      !pureInstructionList
    ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction buildPureSyntaxInstruction
  ??@string inSyntaxComponent
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList ioPureSyntaxInstructionList
  ?!@stringlist ioAddedNonTerminalList
  ?!@uint ioAddedRuleIndex
:
  @string addedNonTerminalString := "select_" . inSyntaxComponent . "_" . [ioAddedRuleIndex string] ;
  ioAddedRuleIndex ++ ;
  @lstring selectAddedNonTerminal [new
    !addedNonTerminalString
    !mSelectInstructionLocation
  ] ;
  ioAddedNonTerminalList += !addedNonTerminalString ;
  ioPureSyntaxInstructionList += ![@nonterminalCallInstruction new
    !selectAddedNonTerminal
    ![@lstring new !"" !here] # no Label
    ![@actualParameterList emptyList]
  ] ;
  foreach mSelectBranchList do
    @syntaxInstructionList pureSyntaxInstructionList ;
    buildPureSyntaxInstructionList
      !inSyntaxComponent
      !mSyntaxInstructionList
      ?pureSyntaxInstructionList
      !?ioPureSyntaxRuleListForGrammar
      !?ioAddedNonTerminalList
      !?ioAddedRuleIndex
    ;
    ioPureSyntaxRuleListForGrammar +=
      !inSyntaxComponent
      !selectAddedNonTerminal
      !pureSyntaxInstructionList
    ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction  buildPureSyntaxInstruction
  ??@string unused inSyntaxComponent
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList unused ioPureSyntaxInstructionList
  ?!@stringlist unused ioAddedNonTerminalList
  ?!@uint unused ioAddedRuleIndex
:
  error here : "internal error (use debug tool)" ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction buildPureSyntaxInstruction
  ??@string unused inSyntaxComponent
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  ?!@syntaxInstructionList unused ioPureSyntaxInstructionList
  ?!@stringlist unused ioAddedNonTerminalList
  ?!@uint unused ioAddedRuleIndex
:
  error here : "internal error (use debug tool)" ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
