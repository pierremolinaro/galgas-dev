#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS grammar component definition                                      *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax grammar_parser :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

#---------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
label getLexiqueName
  !@lstring outLexiqueName
label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

nonterminal <parse_syntax_for_importing>
  ??@lstring inFileName
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

extern routine analyzeGrammar
  ?!@lstring inGrammarName
  ??@lstring inGrammarClass
  ?!@luint startSymbolIndex
  ?!@lstring inLexiqueName
  ??@location endOfSourceFile
  ??@M_terminalSymbolsMapForUse ioTerminalSymbolMap
  ??@L_syntaxComponents_ForGrammar ioSyntaxComponentsList
  ??@M_nonTerminalSymbolsForGrammar ioNonterminalSymbolsMapForGrammar
  ??@M_unusedNonTerminalSymbolsForGrammar inUnusedNonTerminalSymbolsForGrammar
;

#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  $grammar$ ;
#--- Grammar name
  @lstring grammarName ;
  $identifier$ ? grammarName ;
  @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [grammarName string] != basename then
    warning grammarName: "GALGAS 1.7.5 and later checks "
      "the component name ('" . [grammarName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
  @lstring grammarClass ;
  $literal_string$ ? grammarClass ;
  $:$ ;
#--- Parse lexique reference
  @M_terminalSymbolsMapForUse terminalSymbolMap ;
  @lstring lexiqueName ;
  <get_lexique_infos>
    ?terminalSymbolMap
    !?ioLexiqueMapForUse
    ?lexiqueName
  ;
#--- Parse syntax components references
  @stringset classesNamesSet [emptySet] ;
  @L_syntaxComponents_ForGrammar syntaxComponentsList [emptyList] ;
  @M_nonTerminalSymbolsForGrammar nonterminalSymbolsMapForGrammar [emptyMap] ;
  repeat
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [emptyMap] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      $;$ ;
      if not [ioOptionsComponentsMap hasKey ![optionComponentName string]] then
        [!?ioOptionsComponentsMap insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
      end if ;
    or
      $syntax$ ;
      @lstring syntaxComponentName ;
      $identifier$ ? syntaxComponentName ;
      @M_syntaxComponents syntaxComponentsMap ;
      select
        syntaxComponentsMap := ioSyntaxComponentsMap ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        syntaxComponentsMap := [@M_syntaxComponents emptyMap] ;
        <parse_syntax_for_importing>
          !fileName
          !?syntaxComponentsMap
          !?ioSemanticContext
        ;
      end select ;
      $;$ ;
    #--- Search for syntax component
      @M_nonTerminalSymbolsForGrammar importedNonterminalSymbolsMap ;
      @L_productionRules_ForGrammarComponent importedProductionRulesList ;
      @lstring importedLexiqueComponentName ;
      [syntaxComponentsMap searchKey !syntaxComponentName
        ?importedNonterminalSymbolsMap
        ?importedProductionRulesList
        ?importedLexiqueComponentName
      ] ;
    #--- Verify lexical component name
      if [lexiqueName string] != [importedLexiqueComponentName string] then
        error syntaxComponentName : "this component does not use the previously declared lexique" ;
      end if ;
    #--- Add syntax component to syntax components list
      syntaxComponentsList += !importedNonterminalSymbolsMap
                              !importedProductionRulesList
                              !syntaxComponentName ;
    #--- Build nonterminal symbol map for grammar
      foreach importedNonterminalSymbolsMap (@lstring ntSymbol @M_nonterminalSymbolAltsForGrammar importedAltSignaturesMap) do
        if [nonterminalSymbolsMapForGrammar hasKey ![ntSymbol string]] then
          @M_nonterminalSymbolAltsForGrammar altSignatureMap ;
          [nonterminalSymbolsMapForGrammar searchKey !ntSymbol ?altSignatureMap] ;
          foreach altSignatureMap (@lstring altName @L_signature altSignature) do
            @M_nonterminalSymbolAltsForGrammar temp := importedAltSignaturesMap ;
            @L_signature importedAltSignature ;
            [temp searchKey !altName ?importedAltSignature] ;
            checkSignature_ForGrammarComponent !importedAltSignature !altSignature ![ntSymbol location] ![altName location] ;
          end foreach ;
          foreach importedAltSignaturesMap (@lstring importedAltName @L_signature importedAltSignature) do
            if [importedAltName string] != "parse" then
              [altSignatureMap searchKey !importedAltName ?*] ;
            end if ;
          end foreach ;
        else
          [!?nonterminalSymbolsMapForGrammar insertKey !ntSymbol !importedAltSignaturesMap] ;
        end if ;
      end foreach ;
    end select ;
  while
  end repeat ;
#--- Grammar start symbol
  $root$ ;
  @lstring startSymbolName ;
  $non_terminal_symbol$ ? startSymbolName ;
#--- (added 8/13/2004, modified 3/19/2006)
  @M_nonterminalSymbolAltsForGrammar grammarAltMap [emptyMap] ;
  @lstring altName [new !"" !here] ;
  repeat
    @L_signature signature ;
    <formal_arguments_list> importGrammarForSemantics ?signature ;
    [!?grammarAltMap insertKey !altName !signature] ;
  while
    $label$ ;
    $identifier$ ? altName ;
  end repeat ;
  $;$ ;
#--- Search start symbol in non terminal map
  @M_nonterminalSymbolAltsForGrammar startSymbolAltMap ;
  @luint startSymbolIndex ;
  [nonterminalSymbolsMapForGrammar searchKeyGetID !startSymbolName ?startSymbolIndex ?startSymbolAltMap] ;
#--- Check signatures (added 8/13/2004)
  foreach startSymbolAltMap (@lstring cstAltName @L_signature cstAltMap) do
    @L_signature altMap ;
    [grammarAltMap searchKey !cstAltName ?altMap] ;
    checkSignature_ForGrammarComponent !cstAltMap !altMap !here ![cstAltName location] ;
  end foreach ;
  foreach grammarAltMap (@lstring cstAltName ...) do
    [startSymbolAltMap searchKey !cstAltName ?*] ;
  end foreach ;
#--- Unused symbols declaration
  @M_unusedNonTerminalSymbolsForGrammar unusedNonTerminalSymbolsForGrammar [emptyMap] ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? @lstring nonterminalSymbolName ;
     @luint nonterminalIndex ;
     [nonterminalSymbolsMapForGrammar searchKeyGetID !nonterminalSymbolName ?nonterminalIndex ?*] ;
     [!?unusedNonTerminalSymbolsForGrammar insertKey !nonterminalSymbolName !nonterminalIndex] ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
#--- Analyze grammar
  analyzeGrammar
    !?grammarName
    !grammarClass
    !?startSymbolIndex
    !?lexiqueName
    !here
    !terminalSymbolMap
    !syntaxComponentsList
    !nonterminalSymbolsMapForGrammar
    !unusedNonTerminalSymbolsForGrammar
  ;
#--- insert grammar in grammars map
  [!?ioGrammarComponentsMap insertKey
    !grammarName
    !startSymbolAltMap
    !lexiqueName
    !ioOptionsComponentsMap
  ] ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  repeat
    <formal_arguments_list> parse ;
  while
    $label$ ;
    $identifier$ ? * ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  repeat
    <formal_arguments_list> parse ;
  while
    $label$ ;
    $identifier$ ? * ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  repeat
    <formal_arguments_list> parse ;
  while
    $label$ ;
    $identifier$ ? * ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $grammar$ ;
  @lstring grammarName ;
  $identifier$ ? grammarName ;
  $literal_string$ ? * ; # Ignore grammar class
  $:$ ;
   @lstring lexiqueName ;
  <get_lexique_infos> getLexiqueName ?lexiqueName ;
  @M_nonterminalSymbolAltsForGrammar grammarAltMap [emptyMap] ;
  repeat
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [emptyMap] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      $;$ ;
      if not [ioOptionsComponentsMap hasKey ![optionComponentName string]] then
        [!?ioOptionsComponentsMap insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
      end if ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  @lstring altName := [@lstring new !"" !here] ;
  repeat
    @L_signature signature ;
    <formal_arguments_list> importGrammarForSemantics ?signature ;
    [!?grammarAltMap insertKey
      !altName
      !signature
    ] ;
  while
    $label$ ;
    $identifier$ ? altName ;
  end repeat ;
  [!?ioGrammarComponentsMap insertKey !grammarName !grammarAltMap !lexiqueName !ioOptionsComponentsMap] ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  repeat
    <formal_arguments_list> parse ;
  while
    $label$ ;
    $identifier$ ? * ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
