#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS grammar component definition                                      *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax grammar_parser :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;
import semantics grammarSemantics in "grammarSemantics.gSemantics" ;

#---------------------------------------------------------------------------*
#                     fixSyntaxInstructionList_V1                           *
#---------------------------------------------------------------------------*

abstract method @abstractSyntaxInstructionForGrammarAnalysis fixSyntaxInstructionList_V1
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
;

#---------------------------------------------------------------------------*

routine fixSyntaxInstructionList_V1
  ??@syntaxInstructionListForGrammarAnalysis inInstructionList
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  !@syntaxInstructionListForGrammarAnalysis outSyntaxInstructionList
:
  outSyntaxInstructionList := [@syntaxInstructionListForGrammarAnalysis emptyList] ;
  foreach inInstructionList do
    [mInstruction fixSyntaxInstructionList_V1
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalSymbolMap
      !?ioAddedNonTerminalIndex
      !?outSyntaxInstructionList
   ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

override method @terminalInstructionForGrammarAnalysis fixSyntaxInstructionList_V1
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis unused inNonTerminalSymbolMap
  ?!@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @uint terminalSymbolIndex ;
  with !?ioActuallyUsedTerminalSymbolMap hasKey ![mTerminalSymbolName string] do
    terminalSymbolIndex := mTerminalIndex ;
  else
    terminalSymbolIndex := [ioActuallyUsedTerminalSymbolMap count] ;
    [!?ioActuallyUsedTerminalSymbolMap insertKey !mTerminalSymbolName !terminalSymbolIndex] ;
  end with ;
  ioSyntaxInstructionList += ![@terminalInstructionForGrammarAnalysis new
    !mStartLocation
    !mTerminalSymbolName
    !terminalSymbolIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonTerminalInstructionForGrammarAnalysis fixSyntaxInstructionList_V1
  ?!@terminalSymbolsMapForGrammarAnalysis unused ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @uint nonTerminalSymbolIndex ;
  [inNonTerminalSymbolMap searchKey !mNonterminalSymbolName ?nonTerminalSymbolIndex ?*] ;
  ioSyntaxInstructionList += ![@nonTerminalInstructionForGrammarAnalysis new
    !mStartLocation
    !mNonterminalSymbolName
    !nonTerminalSymbolIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstructionForGrammarAnalysis fixSyntaxInstructionList_V1
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  const @uint addedNonTerminalIndex := ioAddedNonTerminalIndex ;
  ioAddedNonTerminalIndex ++ ;
  @branchListForGrammarAnalysis repeatBranchList [emptyList] ;
  foreach mRepeatBranchList do
    @syntaxInstructionListForGrammarAnalysis syntaxInstructionList ;
    fixSyntaxInstructionList_V1
      !mSyntaxInstructionList
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalSymbolMap
      !?ioAddedNonTerminalIndex
      ?syntaxInstructionList
    ;
    repeatBranchList += !syntaxInstructionList ;
  end foreach ;
  ioSyntaxInstructionList += ![@repeatInstructionForGrammarAnalysis new
    !mStartLocation
    !repeatBranchList
    !addedNonTerminalIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstructionForGrammarAnalysis fixSyntaxInstructionList_V1
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  const @uint addedNonTerminalIndex := ioAddedNonTerminalIndex ;
  ioAddedNonTerminalIndex ++ ;
  @branchListForGrammarAnalysis selectBranchList [emptyList] ;
  foreach mSelectBranchList do
    @syntaxInstructionListForGrammarAnalysis syntaxInstructionList ;
    fixSyntaxInstructionList_V1
      !mSyntaxInstructionList
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalSymbolMap
      !?ioAddedNonTerminalIndex
      ?syntaxInstructionList
    ;
    selectBranchList += !syntaxInstructionList ;
  end foreach ;
  ioSyntaxInstructionList += ![@selectInstructionForGrammarAnalysis new
    !mStartLocation
    !selectBranchList
    !addedNonTerminalIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
label getLexiqueName
  !@lstring outLexiqueName
label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@signatureForGrammarAnalysis outSignature
label importGrammarForSemantics
  !@signatureForGrammarAnalysis outSignature
label parse
;

nonterminal <parse_syntax_for_importing>
  ??@lstring inFileName
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  $grammar$ ;
#--- Grammar name
  $identifier$ ? @lstring grammarName ;
  error here: "in GALGAS 1.9.3 and later, uses '.gGrammar' extension instead of '.ggs'" ;
  @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [grammarName string] != basename then
    error grammarName: "GALGAS 1.7.5 and later checks "
      "the component name ('" . [grammarName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
  @lstring grammarClass ;
  $literal_string$ ? grammarClass ;
  $:$ ;
#--- Ignore new importation syntax
  repeat
  while
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
#--- Parse lexique reference
  @M_terminalSymbolsMapForUse terminalSymbolMap ;
  @lstring lexiqueName ;
  <get_lexique_infos>
    ?terminalSymbolMap
    !?ioLexiqueMapForUse
    ?lexiqueName
  ;
#--- Parse syntax components references
  @stringset classesNamesSet [emptySet] ;
  @syntaxComponentListForGrammarAnalysis syntaxComponentsList [emptyList] ;
  @nonTerminalSymbolMapForGrammarAnalysis nonterminalSymbolsMapForGrammar [emptyMap] ;
  repeat
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [emptyMap] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      $;$ ;
      if not [ioOptionsComponentsMap hasKey ![optionComponentName string]] then
        [!?ioOptionsComponentsMap insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
      end if ;
    or
      $syntax$ ;
      @lstring syntaxComponentName ;
      $identifier$ ? syntaxComponentName ;
      @M_syntaxComponents syntaxComponentsMap ;
      select
        syntaxComponentsMap := ioSyntaxComponentsMap ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        syntaxComponentsMap := [@M_syntaxComponents emptyMap] ;
        <parse_syntax_for_importing>
          !fileName
          !?syntaxComponentsMap
          !?ioSemanticContext
        ;
      end select ;
      $;$ ;
    #--- Search for syntax component
      @nonTerminalSymbolMapForGrammarAnalysis importedNonterminalSymbolsMap ;
      @productionRuleListForGrammarAnalysis importedProductionRulesList ;
      @lstring importedLexiqueComponentName ;
      [syntaxComponentsMap searchKey !syntaxComponentName
        ?importedNonterminalSymbolsMap
        ?importedProductionRulesList
        ?importedLexiqueComponentName
      ] ;
    #--- Verify lexical component name
      if [lexiqueName string] != [importedLexiqueComponentName string] then
        error syntaxComponentName : "this component does not use the previously declared lexique" ;
      end if ;
    #--- Add syntax component to syntax components list
      syntaxComponentsList +=
        !importedProductionRulesList
        !syntaxComponentName
      ;
    #--- Build nonterminal symbol map for grammar
      foreach importedNonterminalSymbolsMap prefixedby first_ do
        if [nonterminalSymbolsMapForGrammar hasKey ![first_key string]] then
          @nonterminalSymbolLabelMapForGrammarAnalysis altSignatureMap ;
          [nonterminalSymbolsMapForGrammar searchKey !first_key ?* ?altSignatureMap] ;
          foreach altSignatureMap do
            @nonterminalSymbolLabelMapForGrammarAnalysis temp := first_mNonterminalSymbolParametersMap ;
            @signatureForGrammarAnalysis importedAltSignature ;
            [temp searchKey !key ?importedAltSignature] ;
            checkSignature_ForGrammarComponent !importedAltSignature !mFormalParametersList ![key location] ![key location] ;
          end foreach ;
          foreach first_mNonterminalSymbolParametersMap prefixedby others_ do
            if [others_key string] != "parse" then
              [altSignatureMap searchKey !others_key ?*] ;
            end if ;
          end foreach ;
        else
          [!?nonterminalSymbolsMapForGrammar insertKey !first_key ![nonterminalSymbolsMapForGrammar count] !first_mNonterminalSymbolParametersMap] ;
        end if ;
      end foreach ;
    end select ;
  while
  end repeat ;
#--- Grammar start symbol
  $root$ ;
  @lstring startSymbolName ;
  $non_terminal_symbol$ ? startSymbolName ;
#---
  @bool startSymbolHasParseLabel := false ;
  @nonterminalSymbolLabelMapForGrammarAnalysis grammarAltMap [emptyMap] ;
  @signatureForGrammarAnalysis signature ;
  <formal_arguments_list> importGrammarForSemantics ?signature ;
  [!?grammarAltMap insertKey ![@lstring new !"" !here] !signature] ;
  repeat
  while
    $label$ ;
    select
      $identifier$ ?@lstring altName ;
      @signatureForGrammarAnalysis labelSignature ;
      <formal_arguments_list> importGrammarForSemantics ?labelSignature ;
      [!?grammarAltMap insertKey !altName !labelSignature] ;
    or
      $parse$ ;
      if startSymbolHasParseLabel then
        error here : "'parse' label has been already declared" ;
      end if ;
      startSymbolHasParseLabel := true ;
    end select ;
  end repeat ;
  $;$ ;
#--- Fix terminal and non terminal infos in production rules
  @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap [emptyMap] ;
  @uint addedNonTerminalCount := 0 ;
  @syntaxComponentListForGrammarAnalysis syntaxComponentsListWithFixedInfos [emptyList] ;
  foreach syntaxComponentsList do
    @productionRuleListForGrammarAnalysis fixedProductionRuleList [emptyList] ;
    foreach mProductionRulesList do
      @syntaxInstructionListForGrammarAnalysis fixedInstructionList ;
      fixSyntaxInstructionList_V1
        !mInstructionList
        !?actuallyUsedTerminalSymbolMap
        !nonterminalSymbolsMapForGrammar
        !?addedNonTerminalCount
        ?fixedInstructionList
      ;
      @uint nonTerminalIndex ;
      [nonterminalSymbolsMapForGrammar searchKey !mLeftNonterminalSymbol ?nonTerminalIndex ?*] ;
      fixedProductionRuleList +=
        !mLeftNonterminalSymbol
        !nonTerminalIndex
        !fixedInstructionList
        !mProductionIndex
      ;
    end foreach ;
    syntaxComponentsListWithFixedInfos +=
      !fixedProductionRuleList
      !mSyntaxComponentName
    ;
  end foreach ;
#--- Search start symbol in non terminal map
  @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap ;
  @uint startSymbolIndex ;
  [nonterminalSymbolsMapForGrammar searchKey !startSymbolName ?startSymbolIndex ?startSymbolAltMap] ;
#--- Check signatures (added 8/13/2004)
  foreach startSymbolAltMap do
    @signatureForGrammarAnalysis altMap ;
    [grammarAltMap searchKey !key ?altMap] ;
    checkSignature_ForGrammarComponent !mFormalParametersList !altMap !here ![key location] ;
  end foreach ;
  foreach grammarAltMap do
    [startSymbolAltMap searchKey !key ?*] ;
  end foreach ;
#--- Unused symbols declaration
  @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar [emptyMap] ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? @lstring nonterminalSymbolName ;
     @uint nonterminalIndex ;
     [nonterminalSymbolsMapForGrammar searchKey !nonterminalSymbolName ?nonterminalIndex ?*] ;
     [!?unusedNonTerminalSymbolsForGrammar insertKey !nonterminalSymbolName !nonterminalIndex] ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
#--- Analyze grammar
  analyzeGrammar
    !grammarName
    !grammarClass
    !startSymbolIndex
    ![lexiqueName string]
    !here
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentsListWithFixedInfos
    !nonterminalSymbolsMapForGrammar
    !unusedNonTerminalSymbolsForGrammar
    ![[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/GALGAS_OUTPUT"
    ![[@string stringWithSourceFilePath] stringByDeletingLastPathComponent]
  ;
#--- insert grammar in grammars map
  [!?ioGrammarComponentsMap insertKey
    !grammarName
    !startSymbolAltMap
    !lexiqueName
    !ioOptionsComponentsMap
  ] ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  repeat
  while
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  <formal_arguments_list> parse ;
  repeat
  while
    $label$ ;
    select
      $identifier$ ? * ;
      <formal_arguments_list> parse ;
    or
      $parse$ ;
    end select ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  repeat
  while
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  <formal_arguments_list> parse ;
  repeat
  while
    $label$ ;
    select
      $identifier$ ? * ;
      <formal_arguments_list> parse ;
    or
      $parse$ ;
    end select ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  repeat
  while
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  <formal_arguments_list> parse ;
  repeat
  while
    $label$ ;
    select
      $identifier$ ? * ;
      <formal_arguments_list> parse ;
    or
      $parse$ ;
    end select ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $grammar$ ;
  @lstring grammarName ;
  $identifier$ ? grammarName ;
  $literal_string$ ? * ; # Ignore grammar class
  $:$ ;
#--- Ignore new importation syntax
  repeat
  while
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
   @lstring lexiqueName ;
  <get_lexique_infos> getLexiqueName ?lexiqueName ;
  @nonterminalSymbolLabelMapForGrammarAnalysis grammarAltMap [emptyMap] ;
  repeat
    $import$ ;
    select
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [emptyMap] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      $;$ ;
      if not [ioOptionsComponentsMap hasKey ![optionComponentName string]] then
        [!?ioOptionsComponentsMap insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
      end if ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  @bool startSymbolHasParseLabel := false ;
  @signatureForGrammarAnalysis signature ;
  <formal_arguments_list> importGrammarForSemantics ?signature ;
  [!?grammarAltMap insertKey
    ![@lstring new !"" !here]
    !signature
  ] ;
  repeat
  while
    $label$ ;
    select
    $identifier$ ? @lstring altName ;
    @signatureForGrammarAnalysis signature ;
    <formal_arguments_list> importGrammarForSemantics ?signature ;
    [!?grammarAltMap insertKey
      !altName
      !signature
    ] ;
    or
      $parse$ ;
      startSymbolHasParseLabel := true ;
    end select ;
  end repeat ;
  [!?ioGrammarComponentsMap insertKey
    !grammarName
    !grammarAltMap
    !lexiqueName
    !ioOptionsComponentsMap
  ] ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $grammar$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Ignore new importation syntax
  repeat
  while
    $with$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
  <get_lexique_infos> parse ;
  repeat
    $import$ ;
    select
      $option$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $syntax$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_syntax_for_importing> parse ;
      end select ;
      $;$ ;
    end select ;
  while
  end repeat ;
  $root$ ;
  $non_terminal_symbol$ ? * ;
  <formal_arguments_list> parse ;
  repeat
  while
    $label$ ;
    select
      $identifier$ ? * ;
      <formal_arguments_list> parse ;
    or
      $parse$ ;
    end select ;
  end repeat ;
  $;$ ;
  repeat
  while
   $unused$ ;
   repeat
     $non_terminal_symbol$ ? * ;
   while
     $,$ ;
   end repeat ;
   $;$ ;
  end repeat ;
  $end$ ;
  $grammar$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
