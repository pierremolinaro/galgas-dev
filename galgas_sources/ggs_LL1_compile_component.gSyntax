#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS compile component definition (call the LL(1) grammar)             *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax ggs_LL1_compile_component :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;
import semantics XcodeProjectGeneration in "XcodeProjectGeneration.gSemantics" ;

import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          File List Template                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

filewrapper EXfileListTemplateFileWrapper in "../creation_templates/file_list_template" {
 "mke"
} {
#--- Project
  template EXfileListTemplate "/file_list_template.mke"
    ?@string HAND_CODED_SOURCES_SUB_DIRS
    ?@string GALGAS_SOURCE_LIST
    ?@string HAND_CODED_SOURCE_LIST
  ;
}

#------------------------------------------------------------------------------*
#                                                                              *
#          Production rules declaration                                        *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <parse_lexique_for_importing>
  ??@lstring inFileName
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label parse
;

nonterminal <parse_syntax_for_importing>
  ??@lstring inFileName
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

#------------------------------------------------------------------------------*

listmap @EXtargetFileListMap (@stringlist) ;

#------------------------------------------------------------------------------*

enum @EXsourceFileKind {
  constructor externSourceFile ;
  constructor lexiqueSourceFile ;
  constructor guiSourceFile ;
  constructor optionSourceFile ;
  constructor syntaxSourceFile ;
  constructor semanticsSourceFile ;
  constructor grammarSourceFile ;
  constructor programSourceFile ;
}{
}

#------------------------------------------------------------------------------*

map @EXsourceFileMap {
  @string mFullPath ;
  @EXsourceFileKind mSourceKind ;
  insert insertKey error message "the '%K' source base name has been already declared in %L" ;
  search searchKey error message "the '%K' source base name is not declared" ;
}

#------------------------------------------------------------------------------*
#                                                                              *
#          Project component                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $project$ ;
  @EXsourceFileMap sourceFileMap [emptyMap] ;
  @EXtargetFileListMap targetFileListMap [emptyMap] ;
  repeat
  while
    @EXsourceFileKind sourceFileKind ;
    select
      $extern$ ;
      sourceFileKind := [@EXsourceFileKind externSourceFile] ;
    or
      $gui$ ;
      sourceFileKind := [@EXsourceFileKind guiSourceFile] ;
    or
      $lexique$ ;
      sourceFileKind := [@EXsourceFileKind lexiqueSourceFile] ;
    or
      $option$ ;
      sourceFileKind := [@EXsourceFileKind optionSourceFile] ;
    or
      $semantics$ ;
      sourceFileKind := [@EXsourceFileKind semanticsSourceFile] ;
    or
      $syntax$ ;
      sourceFileKind := [@EXsourceFileKind syntaxSourceFile] ;
    or
      $grammar$ ;
      sourceFileKind := [@EXsourceFileKind grammarSourceFile] ;
    or
      $program$ ;
      sourceFileKind := [@EXsourceFileKind programSourceFile] ;
    end select ;
  #--- Source name
    $literal_string$ ?@lstring fileName ;
    @string baseName := [[[fileName string] lastPathComponent] stringByDeletingPathExtension] ;
  #--- Enter in source file map
    [!?sourceFileMap insertKey ![@lstring new !baseName ![fileName location]] ![fileName string] !sourceFileKind] ;
  #--- Targets
    select
    or
      $:$ ;
      repeat
        $identifier$ ? @lstring targetName ;
        targetFileListMap += ![targetName string] !baseName ;
        if ([targetName string] != "makefile") & ([targetName string] != "xcode") then
          error targetName: "the target name should be \"makefile\" or \"xcode\"" ;
        end if ;
      while
        $,$ ;
      end repeat ;
    end select ;
    if [option.verbose_output] & (sourceFileKind != [@EXsourceFileKind externSourceFile]) then
      message "------ Compile file '" . [fileName string] . "'\n" ;
    end if ;
  #--- Compile file
    if sourceFileKind != [@EXsourceFileKind externSourceFile] then
      grammar galgas_LL1_grammar label compileFile in fileName ("dep") ;
    end if ;
    $;$ ;
  end repeat ;
  $end$ ;
  $project$ ;
  $;$ ;
  if [option .verbose_output] then
    message "------ Project\n" ;
  end if ;
#--- Build galgas_sources/GALGAS_OUTPUT/file_list.mke
  @stringlist makefileFiles := [targetFileListMap listForKey !"makefile"] ;
  if [makefileFiles length] > 0 then
    @string externSourceFileList := "" ;
    @string galgasSourceList := "" ;
    @stringset pathSet [emptySet] ;
    pathSet += !"SOURCES_DIR += ../hand_coded_sources\n" ;
    foreach makefileFiles do
      @string fullPath ;
      @EXsourceFileKind sourceKind ;
      [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
      @string filePath := [fullPath stringByDeletingLastPathComponent] ;
      if sourceKind == [@EXsourceFileKind externSourceFile] then
        if [filePath firstCharacterOrNul] == '/' then
          pathSet += !"SOURCES_DIR += " . filePath . "\n" ;
        elsif filePath != "" then
          pathSet += !"SOURCES_DIR += ../hand_coded_sources/" . filePath . "\n" ;
        end if ;
        externSourceFileList .= "SOURCES += " . [fullPath lastPathComponent] . "\n" ;
      else
        galgasSourceList .= "SOURCES += " . [[fullPath lastPathComponent] stringByDeletingPathExtension] . ".cpp\n" ;
      end if ;
    end foreach ;
    @string pathesString := "" ;
    foreach pathSet do
      pathesString .= key ;
    end foreach ;
    @string newFileListContents := [filewrapper EXfileListTemplateFileWrapper.EXfileListTemplate
      !pathesString
      !galgasSourceList
      !externSourceFileList
    ] ;
    @string fileListPath := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/GALGAS_OUTPUT/file_list.mke" ;
    [newFileListContents writeToFileWhenDifferentContents !fileListPath ?*] ;
  end if ;
#---- Convert old files
  @string oldCommonFile := [[[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] . "/common_files_for_make/makefile.mke" ;
  if [oldCommonFile fileExists] & ([@uint errorCount] == 0) then
    message "**** Converting old-style makefile ****\n" ;
    @string projectDir := [[[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] ;
    @stringlist projectDirectories := [projectDir directories !false] ;
    @bool ok := true ;
    foreach projectDirectories do
      if (mValue != "common_files_for_make") & (mValue != "makefile_macosx_universal") then
        @string fullDirPath := projectDir . "/" . mValue . "/" ;
      #--- makefile
        @string makefilePath := fullDirPath . "makefile" ;
        if [makefilePath fileExists] then
          @stringlist c := [[@string stringWithContentsOfFile !makefilePath] componentsSeparatedByString !"include ../common_files_for_make/makefile.mke"] ;
          if [c length] == 2 then
            message "  ok: '" . makefilePath . "' can be converted\n" ;
          else
            message "  error: '" . makefilePath . "' cannot be converted\n" ;
            ok := false ;
          end if ;
        end if ;
      #--- makefile64
        @string makefile64Path := fullDirPath . "makefile64" ;
        if [makefile64Path fileExists] then
          @stringlist c := [[@string stringWithContentsOfFile ! makefile64Path] componentsSeparatedByString !"include ../common_files_for_make/makefile.mke"] ;
          if [c length] == 2 then
            message "  ok: '" . makefile64Path . "' can be converted\n" ;
          else
            message "  error: '" . makefile64Path . "' cannot be converted\n" ;
            ok := false ;
          end if ;
        end if ;
      #--- makefile.mke
        @string makefileMkePath := fullDirPath . "makefile.mke" ;
        if [makefileMkePath fileExists] then
          @stringlist c := [[@string stringWithContentsOfFile ! makefileMkePath] componentsSeparatedByString !"include ../common_files_for_make/makefile.mke"] ;
          if [c length] == 2 then
            message "  ok: '" . makefileMkePath . "' can be converted\n" ;
          else
            message "  error: '" . makefileMkePath . "' cannot be converted\n" ;
            ok := false ;
          end if ;
        end if ;
      end if ;
    end foreach ;
    if ok then
      message "Perform conversion...\n" ;
      @string projectDir := [[[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] ;
      @stringlist projectDirectories := [projectDir directories !false] ;
      foreach projectDirectories do
        if (mValue != "common_files_for_make") & (mValue != "makefile_macosx_universal") then
          @string fullDirPath := projectDir . "/" . mValue . "/" ;
        #--- makefile
          @string makefilePath := fullDirPath . "makefile" ;
          if [makefilePath fileExists] then
            message "  converting '" . makefilePath . "'...\n" ;
            @stringlist c := [[@string stringWithContentsOfFile !makefilePath] componentsSeparatedByString !"include ../common_files_for_make/makefile.mke"] ;
            @string newContents := [@string componentsJoinedByString !c !"include ../galgas_sources/GALGAS_OUTPUT/file_list.mke"] ;
            [newContents writeToFile ! makefilePath] ;
          end if ;
        #--- makefile64
          @string makefile64Path := fullDirPath . "makefile64" ;
          if [makefile64Path fileExists] then
            message "  converting '" . makefile64Path . "'...\n" ;
            @stringlist c := [[@string stringWithContentsOfFile ! makefile64Path] componentsSeparatedByString !"include ../common_files_for_make/makefile.mke"] ;
            @string newContents := [@string componentsJoinedByString !c !"include ../galgas_sources/GALGAS_OUTPUT/file_list.mke"] ;
            [newContents writeToFile ! makefile64Path] ;
          end if ;
        #--- makefile.mke
          @string makefileMkePath := fullDirPath . "makefile.mke" ;
          if [makefileMkePath fileExists] then
            message "  converting '" . makefileMkePath . "'...\n" ;
            @stringlist c := [[@string stringWithContentsOfFile ! makefileMkePath] componentsSeparatedByString !"include ../common_files_for_make/makefile.mke"] ;
            @string newContents := [@string componentsJoinedByString !c !"include ../galgas_sources/GALGAS_OUTPUT/file_list.mke"] ;
            [newContents writeToFile ! makefileMkePath] ;
          end if ;
        end if ;
      end foreach ;
    #--- Delete old makefile
      @string oldDir := [oldCommonFile stringByDeletingLastPathComponent] ;
      message "  Removing directory '" . oldDir . "' and its contents...\n" ;
      [@string removeDirectoryRecursively !oldDir] ;
      message "**** Conversion done with success *****\n" ;
    else
      message "****** No conversion performed ********\n" ;
    end if ;
  end if ;
#--- Handle Xcode Project
  if not [option galgas_cli_options.doNotGenerateXcodeProject] then
  @stringlist xcodeFiles := [targetFileListMap listForKey !"xcode"] ;
  if ([@uint errorCount] == 0) & ([xcodeFiles length] > 0) then
    @string XcodeProjectDir := [[[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] . "/project_xcode" ;
    #log XcodeProjectDir ;
    @stringlist iconFiles := [XcodeProjectDir regularFilesWithExtensions !false ![@stringlist listWithValue !"icns"]] ;
    @stringlist xcodeProjects := [XcodeProjectDir directoriesWithExtensions !false ![@stringlist listWithValue !"xcodeproj"]] ;
    #log xcodeProjects ;
    if [xcodeProjects length] == 0 then
      message "****** Cannot update Xcode project, no project found in '" . XcodeProjectDir . "' directory. ********\n" ;
    elsif [xcodeProjects length] > 1 then
      message "****** Cannot update Xcode project, more than one project exist in '" . XcodeProjectDir . "' directory. ********\n" ;
    elsif [xcodeProjects length] == 1 then
      @string name ; [xcodeProjects first ?name] ;
      @string fullXcodePath := XcodeProjectDir . "/" . name . "/project.pbxproj" ;
      @stringset externSourceSet [emptySet] ;
      @stringset guiSourceSet [emptySet] ;
      @stringset scannerSourceSet [emptySet] ;
      @stringset optionSourceSet [emptySet] ;
      @stringset semanticsSourceSet [emptySet] ;
      @stringset syntaxSourceSet [emptySet] ;
      @stringset grammarSourceSet [emptySet] ;
      @stringset programSourceSet [emptySet] ;
    #--- Build intermediate list
      @string intermediateString := "# Intermediate file for Xcode Project\n" ;
      foreach xcodeFiles do
        intermediateString .= mValue . "\n" ;
      end foreach ;
    #--- Update intermediate file
      @string intermediateFilePath := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/GALGAS_OUTPUT/file_list_for_xcode_project.txt" ;
      @bool written ;
      [intermediateString writeToFileWhenDifferentContents !intermediateFilePath ?written] ;
    #--- If intermediate file did change, update Xcode project
      if written then
        foreach xcodeFiles do
          @string fullPath ;
          @EXsourceFileKind sourceKind ;
          [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
          switch sourceKind 
          when externSourceFile :
            externSourceSet += !fullPath ;
          when lexiqueSourceFile :
            scannerSourceSet += !mValue ;
          when guiSourceFile :
            guiSourceSet += !mValue ;
          when optionSourceFile :
            optionSourceSet += !mValue ;
          when syntaxSourceFile :
            syntaxSourceSet += !mValue ;
          when semanticsSourceFile :
            semanticsSourceSet += !mValue ;
          when grammarSourceFile :
            grammarSourceSet += !mValue ;
          when programSourceFile :
            programSourceSet += !mValue ;
          end switch ;
        end foreach ;
      #--- Build intermediate
        generateXcodeProject
          !externSourceSet
          !guiSourceSet
          !scannerSourceSet
          !optionSourceSet
          !semanticsSourceSet
          !syntaxSourceSet
          !grammarSourceSet
          !programSourceSet
          ![name stringByDeletingPathExtension] # XCode project base name
          ![fullXcodePath stringByDeletingLastPathComponent] # Full Path of xxx.xcodeproj file
          !iconFiles
        ;
      end if ;
    end if ;
  end if ;
  end if ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $project$ ;
  repeat
  while
    select
      $extern$ ;
    or
      $gui$ ;
    or
      $lexique$ ;
    or
      $option$ ;
    or
      $semantics$ ;
    or
      $syntax$ ;
    or
      $grammar$ ;
    or
      $program$ ;
    end select ;
    $literal_string$ ?* ;
    select
    or
      $:$ ;
      repeat
        $identifier$ ?* ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
  $end$ ;
  $project$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $project$ ;
  repeat
  while
    select
      $extern$ ;
    or
      $gui$ ;
    or
      $lexique$ ;
    or
      $option$ ;
    or
      $semantics$ ;
    or
      $syntax$ ;
    or
      $grammar$ ;
    or
      $program$ ;
    end select ;
    $literal_string$ ? * ;
    select
    or
      $:$ ;
      repeat
        $identifier$ ?* ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
  $end$ ;
  $project$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $project$ ;
  repeat
  while
    select
      $extern$ ;
    or
      $gui$ ;
    or
      $lexique$ ;
    or
      $option$ ;
    or
      $semantics$ ;
    or
      $syntax$ ;
    or
      $grammar$ ;
    or
      $program$ ;
    end select ;
    $literal_string$ ? * ;
    select
    or
      $:$ ;
      repeat
        $identifier$ ?* ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
  $end$ ;
  $project$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $project$ ;
  repeat
  while
    select
      $extern$ ;
    or
      $gui$ ;
    or
      $lexique$ ;
    or
      $option$ ;
    or
      $semantics$ ;
    or
      $syntax$ ;
    or
      $grammar$ ;
    or
      $program$ ;
    end select ;
    $literal_string$ ? * ;
    select
    or
      $:$ ;
      repeat
        $identifier$ ?* ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
  $end$ ;
  $project$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $project$ ;
  repeat
  while
    select
      $extern$ ;
    or
      $gui$ ;
    or
      $lexique$ ;
    or
      $option$ ;
    or
      $semantics$ ;
    or
      $syntax$ ;
    or
      $grammar$ ;
    or
      $program$ ;
    end select ;
    $literal_string$ ? * ;
    select
    or
      $:$ ;
      repeat
        $identifier$ ?* ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
  $end$ ;
  $project$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Compile file component                                              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $compile$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;
  if [option.verbose_output] then
    message "------ Compile file '" . [fileName string] . "'\n" ;
  end if ;
  grammar galgas_LL1_grammar label compileFile in fileName ("dep") ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $compile$ ;
  $literal_string$ ? * ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $compile$ ;
  $literal_string$ ? * ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $compile$ ;
  $literal_string$ ? * ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $compile$ ;
  $literal_string$ ? * ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $compile$ ;
  $literal_string$ ? * ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Parse lexique component for importing                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <parse_lexique_for_importing>
  ??@lstring inFileName
  ?!@M_lexiqueComponents ioLexiqueMapForUse
:
  grammar galgas_LL1_grammar label importLexique in inFileName
    !?ioLexiqueMapForUse
  ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Parse syntax component for importing                                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <parse_syntax_for_importing>
  ??@lstring inFileName
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  grammar galgas_LL1_grammar label importSyntax in inFileName
    !?ioSyntaxComponentsMap
    !?ioSemanticContext
  ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Parse grammar component for importing                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@EXsemanticContext ioSemanticContext
:
  grammar galgas_LL1_grammar label importGrammarForSemantics in inFileName
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMapForUse
    !?ioSemanticContext
  ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Parse option component for importing                                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
:
  grammar galgas_LL1_grammar label importOptions in inFileName
    !? ioOptionsComponentsMap
  ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
