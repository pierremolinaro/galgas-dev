#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueGeneration :
import "predefinedLexicalActions.gSemantics" ;

import semantics lexiqueTypesForAST in "lexiqueTypesForAST.gSemantics" ;
import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
import semantics predefinedLexicalActions in "predefinedLexicalActions.gSemantics" ;
import grammar lexiqueLL1grammar in "lexiqueLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*
#   L E X I C A L    E X P R E S S I O N    C O D E    G E N E R A T I O N  *
#---------------------------------------------------------------------------*

abstract reader @lexicalExpressionAST generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalOrExpressionAST generateConditionCode
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := [mLeftOperand generateConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= " || " ;
  outGeneratedCode .= [mRightOperand generateConditionCode !inLexiqueAnalysisContext] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterIntervalMatchAST generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  outGeneratedCode := "testForInputUTF32CharRange (" ;
  outGeneratedCode .= [[mLowerBound char] utf32CharConstantRepresentation] ;
  outGeneratedCode .= ", " ;
  outGeneratedCode .= [[mUpperBound char] utf32CharConstantRepresentation] ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringMatchAST generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "testForInputUTF32String (kUnicodeString_" . [mString identifierRepresentation] ;
  outGeneratedCode .= ", " ;
  outGeneratedCode .= [[mString length] string] ;
  outGeneratedCode .= ", true)" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringNotMatchAST generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "notTestForInputUTF32String (kUnicodeString_" ;
  outGeneratedCode .= [mString identifierRepresentation] ;
  outGeneratedCode .= ", " ;
  outGeneratedCode .= [[mString length] string] ;
  outGeneratedCode .= ", gLexicalMessage_" ;
  outGeneratedCode .= [mErrorMessage string] ;
  outGeneratedCode .= " COMMA_LINE_AND_SOURCE_FILE)" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterMatchAST generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "testForInputUTF32Char (" ;
  outGeneratedCode .= [[mCharacter char] utf32CharConstantRepresentation] ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterSetMatchAST generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "testForCharWithFunction (" ;
  outGeneratedCode .= [mCharacterSetName string] ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*
#     R O U T I N E    O R    F U N C T I O N    A R G U M E N T            *
#---------------------------------------------------------------------------*

abstract reader @lexicalRoutineOrFunctionFormalInputArgumentAST generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputArgumentAST generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mLexicalAttribute_" . [mAttributeName identifierRepresentation] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterInputArgumentAST generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[mCharacter char] utf32CharConstantRepresentation] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalUnsignedInputArgumentAST generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[mUnsigned uint] string] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCurrentCharacterInputArgumentAST generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "previousChar ()" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFunctionInputArgumentAST generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "::scanner_function_" . mFunctionName . " (*this" ;
  foreach mFunctionActualArgumentList do
    outGeneratedCode .= ", " . [mLexicalActualInputArgument generateRoutineOrFunctionArgument] ;
  end foreach ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*
#                   R O U T I N E    A R G U M E N T                        *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRoutineActualArgumentAST generateRoutineArgument
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputOutputArgumentAST generateRoutineArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mLexicalAttribute_" . [mAttributeName identifierRepresentation] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFormalInputArgumentAST generateRoutineArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [mRoutineOrFunctionFormalInputArgument generateRoutineOrFunctionArgument] ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    S E N D  I N S T R U C T I O N    D E F A U L T         *
#---------------------------------------------------------------------------*

abstract reader @lexicalSendDefaultActionAST generateDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalSendTerminalByDefaultAST generateDefaultSendCode
  ?@string unused inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mTokenCode = kToken_" . mDefaultSentTerminal . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorByDefaultAST generateDefaultSendCode
  ?@string unused inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalError (gLexicalMessage_" . mDefaultErrorMessageName . " COMMA_LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    I N S T R U C T I O N    C O D E    G E N E R A T I O N *
#---------------------------------------------------------------------------*

abstract reader @lexicalInstructionAST generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalStructuredSendInstructionAST generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  foreach mLexicalSendSearchList do
    outGeneratedCode .= "if (token.mTokenCode == -1) {\n" ;
    outGeneratedCode .= "  token.mTokenCode = search_into_" . mSearchListName . " (token.mLexicalAttribute_" . [mAttributeName identifierRepresentation] . ") ;\n" ;
    outGeneratedCode .= "}\n" ;
  end foreach ;
  outGeneratedCode .= "if (token.mTokenCode == -1) {\n" ;
  outGeneratedCode .= "  " . [mLexicalSendDefaultAction generateDefaultSendCode !inScannerClassName] ;
  outGeneratedCode .= "}\n" ;
  outGeneratedCode .= "enterToken (token) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSimpleSendInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mTokenCode = kToken_" . [mSentTerminal identifierRepresentation] . " ;\n" ;
  outGeneratedCode .= "enterToken (token) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRepeatInstructionAST generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "do {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
#--- Repeated instruction
  foreach mRepeatedInstructionList do
    outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
#---
  foreach mLexicalWhileBranchList
  do
    outGeneratedCode .= "if (" ;
    outGeneratedCode .= [mWhileExpression generateConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ") {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mWhileInstructionList do
      outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
  outGeneratedCode .= "}else{\n"
                      "  mLoop = false ;\n"
                      "}\n" ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}while (mLoop) ;\n"
                      "mLoop = true ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSelectInstructionAST generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
#---
  foreach mLexicalSelectBranchList
  do
    outGeneratedCode .= "if (" ;
    outGeneratedCode .= [mSelectExpression generateConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ") {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mSelectInstructionList do
      outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
#--- Default branch
  if [mDefaultInstructionList length] > 0 then
    outGeneratedCode .= "}else{\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mDefaultInstructionList do
      outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  end if ;
  outGeneratedCode .= "}\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRoutineInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "::scanner_routine_" . mRoutineName . " (*this" ;
  foreach mActualArgumentList do
    outGeneratedCode .= ", " . [mLexicalRoutineActualArgument generateRoutineArgument] ;
  end foreach ;
  foreach mErrorMessageList do
    outGeneratedCode .= ", gLexicalMessage_" . mValue ;
  end foreach ;
  outGeneratedCode .= ") ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalDropInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ; # No generated code
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalError (gLexicalMessage_" . mErrorMessageName . " COMMA_LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalWarningInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalWarning (gLexicalMessage_" . mWarningMessageName . " COMMA_LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalTagInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "const C_LocationInSource locationForTag_" . mLexicalTagName . " = mCurrentLocation ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRewindInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mCurrentLocation = locationForTag_" . mLexicalTagName . " ;\n" ;
  outGeneratedCode .= "token.mTokenCode = kToken_" . [mTerminalName identifierRepresentation] . " ;\n" ;
  outGeneratedCode .= "enterToken (token) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalLogInstructionAST generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalLog (LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*
#        L E X I C A L    R U L E    C O D E    G E N E R A T I O N         *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRuleAST generateCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalImplicitRuleAST generateCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  @tokenSortedlist tokenSortedList ;
  [[inLexiqueAnalysisContext mLexicalTokenListMap] searchKey !mListName ?* ?tokenSortedList ?*] ;
  outGeneratedCode := "" ;
  foreach > tokenSortedList do
    outGeneratedCode .= "if (testForInputUTF32String (kUnicodeString_" ;
    outGeneratedCode .= [mName identifierRepresentation] ;
    outGeneratedCode .= ", " ;
    outGeneratedCode .= [[mName length] string] ;
    outGeneratedCode .= ", true)) {\n" ;
    outGeneratedCode .= "  token.mTokenCode = kToken_" . [mTerminalName identifierRepresentation] . " ;\n" ;
    outGeneratedCode .= "  enterToken (token) ;\n" ;
    outGeneratedCode .= "}else " ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalExplicitRuleAST generateCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "if (" ;
  outGeneratedCode .= [mLexicalRuleExpression generateConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= ") {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
  foreach mInstructionList do
    outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}else " ;
end reader ;

#---------------------------------------------------------------------------*

end semantics ;