#---------------------------------------------------------------------------*
#                                                                           *
#  'program' component parser, as model builder                             *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax programModelBuilder ("galgas_scanner.gLexique")  feature translate:

import "semanticsTypesForAST.gSemantics" ;
import "programMetamodel.gSemantics" ;

#---------------------------------------------------------------------------*

nonterminal <semantic_instruction_list> !@semanticInstructionListAST outInstructionsList ;

nonterminal <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations
;

#---------------------------------------------------------------------------*
#                                                                           *
#   P R O G R A M    C O M P O N E N T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <program_component_start_symbol> !@programComponentAST outProgramComponentRoot :
  $program$ :> ?@string sep ?* ;
  send sep ;
  $identifier$ ? @lstring mProgramName :> ?* ?* ;
  $:$  :> ?* ?* ;
#--- Loop on import declarations
  @lstringlist importedComponentFileNameList [emptyList] ;
  repeat
  while
    $import$  :> ?* ?* ;
    $literal_string$ ? @lstring importedComponentFileName  :> ?* ?* ;
    importedComponentFileNameList += !importedComponentFileName ;
    $;$ :> ?* ?* ;
  end repeat ;
#--- Program rules
  @semanticDeclarationListAST mSemanticDeclarations [emptyList] ;
  @programRuleList mProgramRules [emptyList] ;
  @prologueEpilogueList prologueList [emptyList] ; # Zero or one is correct
  @prologueEpilogueList epilogueList [emptyList] ; # zero or one is correct
  repeat
  while
    $before$ ;
    ${$ ;
    @semanticInstructionListAST prologueInstructionList ;
    <semantic_instruction_list> ? prologueInstructionList ;
    const @location endOfPrologue := here ;
    $}$ ;
    prologueList += !prologueInstructionList !endOfPrologue ;
  while
    $after$ ;
    ${$ ;
    @semanticInstructionListAST epilogueInstructionList ;
    <semantic_instruction_list> ? epilogueInstructionList ;
    const @location endOfEpilogue := here ;
    $}$ ;
    epilogueList += !epilogueInstructionList !endOfEpilogue ;
  while
    $when$ ;
    $.$ ;
    $literal_string$ ? @lstring mSourceFileExtension ;
    $message$ ;
    $literal_string$ ? @lstring mSourceFileHelp ;
  #--- Indexing
    @lstring indexingGrammar ; # Empty string if no indexing
    select
      indexingGrammar := ["" nowhere] ;
    or
      $indexing$ ;
      $with$ ;
      $identifier$ ? indexingGrammar indexing grammarComponentReference ;
    end select ;
  #--- Source file
    $??$ ;
    $type_name$ ? @lstring typeName ;
    @bool isUnused ;
    select
      isUnused := false ;
    or
      $unused$ ;
      isUnused := true ;
    end select ;
    if [typeName string] != "lstring" then
      error typeName : "the only type allowed here is '@lstring'" ;
    end if ;
    $identifier$ ? @lstring mSourceFileVariableName ;
  #---
    ${$ ;
    @semanticInstructionListAST mInstructionList ;
    <semantic_instruction_list> ? mInstructionList ;
    const @location endOfInstructionList := here ;
    $}$ ;
    mProgramRules +=
      !mSourceFileExtension
      !mSourceFileHelp
      !mSourceFileVariableName
      !isUnused
      !indexingGrammar
      !mInstructionList
      !endOfInstructionList
    ;
  while
    <semantic_declaration> !?mSemanticDeclarations ;
  end repeat ;
#---
  $end$ :> ?* ?* ;
  const @location endOfSourceFile := here ;
  $program$ :> ?* ?* ;
  $;$ :> ?* ?* ;
  outProgramComponentRoot := [@programComponentAST new
    !mProgramName
    !importedComponentFileNameList
    !prologueList
    !epilogueList
    !mProgramRules
    !mSemanticDeclarations
    !endOfSourceFile
  ] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;