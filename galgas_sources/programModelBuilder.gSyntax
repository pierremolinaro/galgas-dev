#---------------------------------------------------------------------------*
#                                                                           *
#  'program' component parser, as model builder                             *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax programModelBuilder :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics semanticsTypesForAST in "semanticsTypesForAST.gSemantics" ;
import semantics programMetamodel in "programMetamodel.gSemantics" ;

#---------------------------------------------------------------------------*

nonterminal <program_component_start_symbol> !@programComponentRoot outProgramComponentRoot ;

nonterminal <semantic_instruction_list> !@semanticInstructionListAST outInstructionsList ;

nonterminal <semantic_declaration>
 ?!@semanticDeclarationStructAST ioSemanticDeclarations
;

#---------------------------------------------------------------------------*
#                                                                           *
#   P R O G R A M    C O M P O N E N T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <program_component_start_symbol> !@programComponentRoot outProgramComponentRoot :
  $program$ ;
  $identifier$ ? @lstring mProgramName ;
  $literal_string$ ? @lstring mVersionString ;
  $:$ ;
#--- Loop on import declarations
  repeat
  while
    $import__$ ;
    $literal_string$ ? * ;
    $;$ ;
  while
    $import$ ;
    select
      $semantics$ ;
    or
      $lexique$ ;
   or
      $grammar$ ;
    or
      $syntax$ ;
    or
      $option$ ;
    end select ;
    $identifier$ ?* ;
    $in$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
#--- Prologue
  $before$ ;
  ${$ ;
  @semanticInstructionListAST mPrologueInstructionList [emptyList] ;
  <semantic_instruction_list> ? mPrologueInstructionList ;
  $}$ ;
#--- Program rules
  @semanticDeclarationStructAST mSemanticDeclarations [new
    ![@semanticDeclarationListAST emptyList]
    ![@abstractMultiMethodListMapAST emptyMap]
    ![@multiMethodListMapAST emptyMap]
    ![@overridingMultiMethodListMapAST emptyMap]
    ![@abstractMultiReaderListMapAST emptyMap]
    ![@multiReaderListMapAST emptyMap]
    ![@overridingMultiReaderListMapAST emptyMap]
  ] ;
  @programRuleList mProgramRules [emptyList] ;
  repeat
  while
    $when$ ;
    $.$ ;
    $literal_string$ ? @lstring mSourceFileExtension ;
    $message$ ;
    $literal_string$ ? @lstring mSourceFileHelp ;
    $??$ ;
    $type_name$ ? @lstring typeName ;
    if [typeName string] != "lstring" then
      error typeName : "the only type allowed here is '@lstring'" ;
    end if ;
    $identifier$ ? @lstring mSourceFileVariableName ;
    ${$ ;
    @semanticInstructionListAST mInstructionList ;
    <semantic_instruction_list> ? mInstructionList ;
    $}$ ;
    mProgramRules +=
      !mSourceFileExtension
      !mSourceFileHelp
      !mSourceFileVariableName
      !mInstructionList
    ;
  while
    <semantic_declaration> !?mSemanticDeclarations ;
  end repeat ;
#--- Epilogue
  $after$ ;
  ${$ ;
  @semanticInstructionListAST mEpilogueInstructionList ;
  <semantic_instruction_list> ? mEpilogueInstructionList ;
  $}$ ;
#---
  $end$ ;
  $program$ ;
  $;$ ;
  outProgramComponentRoot := [@programComponentRoot new
    !mProgramName
    !mVersionString
    !mPrologueInstructionList
    !mEpilogueInstructionList
    !mProgramRules
    !mSemanticDeclarations
  ] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;