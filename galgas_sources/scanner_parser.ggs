#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS scanner component parser definition                               *
#                                                                           *
#  Copyright (C) 1997-2004 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax scanner_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics scanner_semantics in "scanner_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

action buildLexicalRulesFromList
  ?!@typeTableMotsReserves keyWordsMap
  ?!@typeListeTestsEtInstructions outLexicalRulesList ;

rule <style_declaration>
  ?!@M_styles ioStylesMap
label parse
;

rule <attribute_or_terminal_symbol_declaration>
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeLexicalAttributesMap table_attributs
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ?!@lexicalTypeMap inLexicalTypeMap
  ?!@M_styles ioStylesMap
label parse
;

rule <key_words_list_declaration>
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ?!@M_styles ioStylesMap
label parse
;

rule <lexical_error_message_declaration>
  ?!@typeTableMessagesErreurs tableMessagesErreurs
label parse
;

rule <while_branches_list>
  !@typeListeTestsEtInstructions liste_tests_et_instructions
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
label parse
;

rule <lexical_rule>
  ?!@typeListeTestsEtInstructions ioLexicalRulesList
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
label parse
;

rule <lexical_instructions_list>
  !@tListeInstructionsLexicales listeInstructions
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
label parse
;

rule <lexical_when_branches_list>
  !@typeListeTestsEtInstructions lexicalRulesList
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
label parse
;

rule <lexical_default_branch>
  !@tListeInstructionsLexicales liste_instructions_sinon
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
label parse
;

rule <lexical_test_expression>
  !@typeListeConditionsLexicales listeConditionsLexicales
label parse
;

rule <lexical_test_term>
  !@typeConditionLexicale conditionLexicale
label parse
;

rule <up_boundary>
  ?@lchar caractere
  !@typeConditionLexicale conditionLexicale
label parse
;

rule <lexical_parameters_non_empty_list>
  !@typeListeArgumentsRoutExterne listeArgumentsRoutExterne
  ?!@typeLexicalAttributesMap tableDesAttributs
label parse
;

rule <lexical_error_messages_list>
  ?!@typeListeMessagesErreur listeMessagesErreur
  ?!@typeTableMessagesErreurs tableMessagesErreurs
label parse
;

rule <lexical_send_or_error>
  !@typeEmissionParDefaut emissionParDefaut
  ?!@typeTableMessagesErreurs tableMessagesErreurs
label parse
;

rule <lexical_parameter>
  !@typeArgumentRoutineExterne argumentRoutineExterne
  ?!@typeLexicalAttributesMap table_attributs
label parse
;

rule <lexical_send_instruction>
  !@typeInstructionLexicale instruction
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
label parse
;

action generate_scanner
  ?!@lstring lexiqueName 
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@typeListeTestsEtInstructions lexicalRulesList
  ?!@typeTableMessagesErreurs table_messages
  ?!@M_styles stylesMap
;
routine buildLexicalTypeMap !@lexicalTypeMap lexicalTypeMap :
  lexicalTypeMap := [@lexicalTypeMap empty] ;
  @AC_galgasType t := [@typeGalgas_lstring new] ;
  @lstring typeName := [@lstring new !"lstring" !here] ;
  [!?lexicalTypeMap insertKey !typeName !t] ;
  t := [@typeGalgas_lchar new] ;
  typeName := [@lstring new !"lchar" !here] ;
  [!?lexicalTypeMap insertKey !typeName !t] ;

  t := [@typeGalgas_luint new] ;
  typeName := [@lstring new !"luint" !here] ;
  [!?lexicalTypeMap insertKey !typeName !t] ;

  t := [@typeGalgas_lsint new] ;
  typeName := [@lstring new !"lsint" !here] ;
  [!?lexicalTypeMap insertKey !typeName !t] ;

  t := [@typeGalgas_lbool new] ;
  typeName := [@lstring new !"lbool" !here] ;
  [!?lexicalTypeMap insertKey !typeName !t] ;

  t := [@typeGalgas_ldouble new] ;
  typeName := [@lstring new !"ldouble" !here] ;
  [!?lexicalTypeMap insertKey !typeName !t] ;
end routine ;

#-------------------------------------------------------------------*
#                   Lexical component                               *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
#--- Lexique header
  $lexique$ ;
  @lstring lexiqueName ;
  $identifier$ ? lexiqueName ;
  $:$ ;
#--- Errors messages, key words, attributes, terminal symbols and rules
  @M_terminalSymbolsMapForUse terminalSymbolsMapForUse [empty] ;
  @typeLexicalAttributesMap table_attributs [empty] ;
  @typeTableDefinitionTerminaux table_des_terminaux [empty] ;
  @typeTableMessagesErreurs table_messages [empty] ;
  @typeTableTablesDeMotsReserves table_tables_mots_reserves [empty] ;
  @typeListeTestsEtInstructions lexicalRulesList [empty] ;
#--- Define lexical types
  @lexicalTypeMap lexicalTypeMap ;
  buildLexicalTypeMap ?lexicalTypeMap ;

#-- Styles map
  @M_styles stylesMap [empty] ;
  @lstring defaultStyleName [new !"Default style" !here] ;
  @lstring defaultStringIdentifier [new !"" !here] ;
  [!?stylesMap insertKey !defaultStringIdentifier !defaultStyleName] ;
  repeat
  while 
    <style_declaration> !?stylesMap ;
  while
    <attribute_or_terminal_symbol_declaration>
      !? table_des_terminaux
      !? table_attributs
      !? terminalSymbolsMapForUse
      !? lexicalTypeMap
      !? stylesMap
    ;
  while
    <key_words_list_declaration>
      !? table_tables_mots_reserves
      !?table_des_terminaux
      !?terminalSymbolsMapForUse
      !?stylesMap
    ;
  while
    <lexical_error_message_declaration>
      !?table_messages
    ;
  while
    $rule$ ;
    <lexical_rule>
      !?lexicalRulesList
      !?table_des_terminaux
      !?table_messages
      !?table_attributs
      !?table_tables_mots_reserves
    ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
#--- Enter lexique in lexique map
  [!?ioLexiqueMapForUse insertKey !lexiqueName !terminalSymbolsMapForUse] ;
#--- Generate scanner
  action generate_scanner
    !?lexiqueName 
    !?table_attributs
    !?table_des_terminaux
    !?table_tables_mots_reserves
    !?lexicalRulesList
    !?table_messages
    !?stylesMap
  ;
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
:
  $lexique$ ;
  @lstring lexiqueName ;
  $identifier$ ? lexiqueName ;
  $:$ ;
  @M_terminalSymbolsMapForUse terminalSymbolsMapForUse [empty] ;
  @typeLexicalAttributesMap table_attributs [empty] ;
  @typeTableDefinitionTerminaux table_des_terminaux [empty] ;
  @typeTableMessagesErreurs table_messages [empty] ;
  @typeTableTablesDeMotsReserves table_tables_mots_reserves [empty] ;
  @typeListeTestsEtInstructions lexicalRulesList [empty] ;
#--- Define lexical types
  @lexicalTypeMap lexicalTypeMap ;
  buildLexicalTypeMap ?lexicalTypeMap ;
#-- Styles map
  @M_styles stylesMap [empty] ;
  @lstring defaultStyleName [new !"Default style" !here] ;
  @lstring defaultStringIdentifier [new !"" !here] ;
  [!?stylesMap insertKey !defaultStringIdentifier !defaultStyleName] ;
  repeat
  while 
    <style_declaration> !? stylesMap ;
  while
    <attribute_or_terminal_symbol_declaration>
      !?table_des_terminaux
      !?table_attributs
      !?terminalSymbolsMapForUse
      !?lexicalTypeMap
      !?stylesMap
    ;
  while
    <key_words_list_declaration>
      !? table_tables_mots_reserves
      !?table_des_terminaux
      !?terminalSymbolsMapForUse
      !?stylesMap
    ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
#--- Enter lexique in lexique map
  [!?ioLexiqueMapForUse insertKey !lexiqueName !terminalSymbolsMapForUse] ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
:
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <style_declaration> parse;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
:
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <style_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
:
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <style_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <style_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#   S T Y L E    D E C L A R A T I O N                              *
#-------------------------------------------------------------------*

rule <style_declaration>
  ?!@M_styles ioStylesMap
:
  $style$ ;
  repeat
    @lstring styleMap ;
    $identifier$ ? styleMap ;
    $->$ ;
    @lstring title ;
    $literal_string$ ? title ;
    [!?ioStylesMap insertKey !styleMap !title] ;
  while $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#           Attribute or terminal symbol declaration                *
#-------------------------------------------------------------------*

rule <attribute_or_terminal_symbol_declaration>
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeLexicalAttributesMap table_des_attributs
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ?!@lexicalTypeMap inLexicalTypeMap
  ?!@M_styles ioStylesMap
:
  select
  #--- semantics attribut
    @lstring typeName ;
    $type_name$ ? typeName ;
    @AC_galgasType attributeType ;
    [!?inLexicalTypeMap searchKey !typeName ?attributeType] ;
    @lstring attributeName ;
    $identifier$ ?attributeName ;
    [!?table_des_attributs insertKey !attributeName !attributeType] ;
  #--- Terminal symbol
  or
    @lstring nomTerminal ;
    $terminal$ ? nomTerminal ;
    @typeListeAttributsSemantiques l [empty];
    repeat
    while
      $!$ ;
      @lstring idf ;
      $identifier$ ? idf ;
      @AC_galgasType t ;
      [!?table_des_attributs searchKey !idf ?t] ;
      l += !t !idf ;
    end repeat ;
    @lstring errorMessage ;
    $error$ ;
    $message$ ;
    $literal_string$ ? errorMessage ;
    [!?ioTerminalSymbolsMapForUse insertKey !nomTerminal !l] ;
  #--- Style ?
    @lstring styleName ;
    select
     styleName := [@lstring new !"" !here] ;
    or
      $style$ ;
      $identifier$ ? styleName ;
    end select ;
    @luint styleIndex ;
    [!?ioStylesMap searchKeyGetIndex !styleName ?styleIndex ?*] ;
    @string errorMessageString := [errorMessage value] ;
    [!?table_des_terminaux insertKey !nomTerminal !errorMessageString !l !styleIndex] ;
  end select ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#                déclaration des listes de mots réservés            *
#-------------------------------------------------------------------*

rule <key_words_list_declaration>
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ?!@M_styles ioStylesMap
:
  $list$ ;
  @typeTableMotsReserves entriesMap [empty] ;
#--- List name
  @lstring listName ;
  $identifier$ ? listName ;
#--- Error message
  $error$ ;
  $message$ ;
  @L_stringList errorMessageElementsList [empty] ;
  repeat
    select
      $*$ ;
      errorMessageElementsList += !"\1" ;
    or
      @lstring messageElement ;
      $literal_string$ ? messageElement ;
      errorMessageElementsList += ![messageElement value] ;
    end select ;
  while
    $.$ ;
  end repeat ;
#--- Style
  @lstring styleName ;
  select
    styleName := [@lstring new !"" !here] ;
  or
    $style$ ;
    $identifier$ ? styleName ;
  end select ;
  @luint styleIndex ;
  [!?ioStylesMap searchKeyGetIndex !styleName ?styleIndex ?*] ;
#--- List of entries
  $:$ ;
  @typeListeAttributsSemantiques attributesList [empty] ; # Always empty
  repeat
    @lstring listEntry ;
    $literal_string$ ?listEntry ;
  #--- Associated terminal symbol
    @lstring terminalSymbolName ;
    select
      $->$ ;
      $terminal$ ?terminalSymbolName ;
    or
      terminalSymbolName := listEntry ;
    end select ;
  #--- Build error message
    @string specificErrorMessageString := "" ;
    foreach errorMessageElementsList (??@string element) :
      if element == "\1" then
        specificErrorMessageString := specificErrorMessageString . [terminalSymbolName value] ;
      else
        specificErrorMessageString := specificErrorMessageString . element ;
      end if ;
    end foreach ;
  #--- Insert terminal in terminal symbols map
    [!?table_des_terminaux insertKey !terminalSymbolName !specificErrorMessageString
                                                         !attributesList
                                                         !styleIndex] ;
    [!?ioTerminalSymbolsMapForUse insertKey !terminalSymbolName !attributesList] ;
  #--- Insert entry in the entries map
    [!?entriesMap insertKey !listEntry !terminalSymbolName] ;
  while
    $,$ ;
  end repeat ;
  [!?table_tables_mots_reserves insertKey !listName !entriesMap] ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#             déclaration de la list des messages d'error           *
#-------------------------------------------------------------------*

rule <lexical_error_message_declaration>
  ?!@typeTableMessagesErreurs table_messages
:
  $message$ ;
  @lstring nom ;
  $identifier$ ? nom ;
  $:$ ;
  @lstring errorMessage ;
  $literal_string$ ?errorMessage ;
  [!?table_messages insertKey !nom !errorMessage] ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <while_branches_list>
  !@typeListeTestsEtInstructions liste_tests_et_instructions
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  liste_tests_et_instructions := [@typeListeTestsEtInstructions empty] ;
  $while$ ;
  repeat
    @typeListeConditionsLexicales lcl ;
    <lexical_test_expression> ? lcl ;
    $:$ ;
    @tListeInstructionsLexicales li ;
    <lexical_instructions_list> ?li
                        !?table_des_terminaux
                        !?table_des_messages_erreur
                        !?table_attributs
                        !?table_tables_mots_reserves ;
    liste_tests_et_instructions += !lcl !li ;
  while
    $while$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_expression>
 !@typeListeConditionsLexicales liste_test
:
  liste_test := [@typeListeConditionsLexicales empty] ;
  repeat
    @typeConditionLexicale c ;
    <lexical_test_term> ?c ;
    liste_test += !c ;
  while
    $|$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_term>
  !@typeConditionLexicale tt
:
  @lstring ch ;
  $literal_string$ ? ch ;
  tt := [@typeConditionChaine new !ch] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_term>
  !@typeConditionLexicale tt
:
  @lchar c ;
  $literal_char$ ? c ;
  <up_boundary> !c ?tt ;
end rule ;

#-------------------------------------------------------------------*

rule <up_boundary>
  ?@lchar th
  !@typeConditionLexicale ts
:
  select
    ts := [@typeConditionCaractere new !th] ;
  or
    $->$ ;
    @lchar bs ;
    $literal_char$ ? bs ; # borne sup de l'intervalle
    ts := [@typeConditionIntervalle new !th !bs] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_rule>
  ?!@typeListeTestsEtInstructions ioLexicalRulesList
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  @typeListeConditionsLexicales lcl ;
  <lexical_test_expression> ? lcl ;
  $:$ ;
  @tListeInstructionsLexicales li ;
  <lexical_instructions_list> ?li
                      !?table_des_terminaux
                      !?table_des_messages_erreur
                      !?table_attributs
                      !?table_tables_mots_reserves ;
  ioLexicalRulesList += !lcl !li ;
  $end$ ;
  $rule$ ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_rule>
  ?!@typeListeTestsEtInstructions ioLexicalRulesList
  ?!@typeTableDefinitionTerminaux unused table_des_terminaux
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@typeLexicalAttributesMap unused table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  $list$ ;
#--- Get list name
  @lstring listName ;
  $identifier$ ?listName ;
#--- Search list name
  @typeTableMotsReserves keyWordsMap ;
  [!?table_tables_mots_reserves searchKey !listName ?keyWordsMap] ;
#--- Build lexical analyser rules
  action buildLexicalRulesFromList !?keyWordsMap !?ioLexicalRulesList ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_instructions_list>
  !@tListeInstructionsLexicales li
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  li := [@tListeInstructionsLexicales empty] ;
  repeat
  while
    @lstring nom_routine_externe ;
    $identifier$ ? nom_routine_externe ;
    @typeListeArgumentsRoutExterne lare ;
    <lexical_parameters_non_empty_list> ? lare !?table_attributs ;
    @typeListeMessagesErreur lme [empty] ;
    <lexical_error_messages_list> !?lme !?table_des_messages_erreur ;
    $;$ ;
    @typeInstructionLexicale e := [@typeInstructionActionExterne new !nom_routine_externe !lare !lme] ;
    li += !e ;
  while
    $select$ ;
    @typeListeTestsEtInstructions list_branches_si ;
    <lexical_when_branches_list> ?list_branches_si
                       !?table_des_terminaux
                       !?table_des_messages_erreur
                       !?table_attributs
                       !?table_tables_mots_reserves ;
    @tListeInstructionsLexicales liste_instructions_sinon ;
    <lexical_default_branch> ?liste_instructions_sinon
                   !?table_des_terminaux
                   !?table_des_messages_erreur
                   !?table_attributs
                   !?table_tables_mots_reserves ;
    $end$ ;
    $select$ ;
    $;$ ;
    @typeInstructionLexicale e ;
    e := [@typeInstructionSiLexical new !list_branches_si !liste_instructions_sinon] ;
    li += !e ;
  while
    $repeat$ ;
    @tListeInstructionsLexicales lii ;
    <lexical_instructions_list> ?lii
                        !?table_des_terminaux
                        !?table_des_messages_erreur
                        !?table_attributs
                        !?table_tables_mots_reserves ;
    @typeListeTestsEtInstructions ltq ;
    <while_branches_list> ?ltq
                             !?table_des_terminaux
                             !?table_des_messages_erreur
                             !?table_attributs
                             !?table_tables_mots_reserves ;
    $end$ ;
    $repeat$ ;
    $;$ ;
    @typeInstructionLexicale e ;
    e := [@typeInstructionRepetitionLexicale new !lii !ltq] ;
    li += !e ;
  while
    $send$ ;
    @typeInstructionLexicale e ;
    <lexical_send_instruction> ?e
                         !?table_des_terminaux
                         !?table_des_messages_erreur
                         !?table_attributs
                         !?table_tables_mots_reserves ;
    $;$ ;
    li += !e ;
  while
    $error$ ;
    @lstring errorMessageName ;
    $identifier$ ?errorMessageName ;
    @luint errorMessageIndex ;
    [!?table_des_messages_erreur searchKeyGetIndex !errorMessageName ?errorMessageIndex ?*] ;
    $;$ ;
    @typeInstructionLexicale e := [@typeInstructionErreurLexicale new !errorMessageIndex] ;
    li += !e ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_error_messages_list>
  ?!@typeListeMessagesErreur unused lme
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
:
end rule ;

#-------------------------------------------------------------------*

rule <lexical_error_messages_list>
  ?!@typeListeMessagesErreur lme
  ?!@typeTableMessagesErreurs table_des_messages_erreur
:
  $error$ ;
  repeat
    @lstring errorMessageName ;
    $identifier$ ?errorMessageName ;
    @luint errorMessageIndex ;
    [!?table_des_messages_erreur searchKeyGetIndex !errorMessageName ?errorMessageIndex ?*] ;
    lme += !errorMessageIndex ;
  while
    $,$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameters_non_empty_list>
  !@typeListeArgumentsRoutExterne laf
  ?!@typeLexicalAttributesMap table_attributs
:
  $($ ;
  laf := [@typeListeArgumentsRoutExterne empty] ;
  repeat
    @typeArgumentRoutineExterne a ;
    <lexical_parameter> ?a !?table_attributs ;
    laf += !a ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap unused table_attributs
:
  $*$ ; # le caractère courant
  a := [@typeArgumentCaractereCourant new] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap unused table_attributs
:
  @lchar c ;
  $literal_char$ ? c ; # un caractère particulier
  a := [@typeArgumentCaractere new !c] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap unused table_attributs
:
  @luint n ;
  $unsigned_literal_integer$ ? n ; # un nombre particulier
  a := [@typeArgumentEntier new !n] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap table_attributs
:
  @lstring nom ;
  $identifier$ ? nom ; # an attribute or function call
  select
    @AC_galgasType t ;
    [!?table_attributs searchKey !nom ?t] ;
    a := [@typeArgumentAttribut new !nom !t] ;
  or
    @typeListeArgumentsRoutExterne lare ;
    <lexical_parameters_non_empty_list> ?lare !?table_attributs ;
    a := [@typeArgumentRoutine new !nom !lare] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_when_branches_list>
  !@typeListeTestsEtInstructions lbs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  lbs := [@typeListeTestsEtInstructions empty] ;
  $when$ ;
  repeat
    @typeListeConditionsLexicales lcl ;
    <lexical_test_expression> ? lcl ;
    $:$ ;
    @tListeInstructionsLexicales li ;
    <lexical_instructions_list> ?li
                        !?table_des_terminaux
                        !?table_des_messages_erreur
                        !?table_attributs
                        !?table_tables_mots_reserves ;
    lbs += !lcl !li ;
  while
    $when$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_default_branch>
  !@tListeInstructionsLexicales liste_instructions_sinon
  ?!@typeTableDefinitionTerminaux unused table_des_terminaux
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@typeLexicalAttributesMap unused table_attributs
  ?!@typeTableTablesDeMotsReserves unused table_tables_mots_reserves
:
  liste_instructions_sinon := [@tListeInstructionsLexicales empty] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_default_branch>
  !@tListeInstructionsLexicales liste_instructions_sinon
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  $default$ ;
  <lexical_instructions_list> ?liste_instructions_sinon
                      !?table_des_terminaux
                      !?table_des_messages_erreur
                      !?table_attributs
                      !?table_tables_mots_reserves ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_instruction>
  !@typeInstructionLexicale instruction
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@typeLexicalAttributesMap unused table_attributs
  ?!@typeTableTablesDeMotsReserves unused table_tables_mots_reserves
:
  @lstring nomTerminal ;
  $terminal$ ?nomTerminal ;
  [!?table_des_terminaux searchKey !nomTerminal ?* ?* ?*] ;
  instruction := [@typeInstructionEmettreSimple new !nomTerminal] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_instruction>
  !@typeInstructionLexicale instruction
  ?!@typeTableDefinitionTerminaux unused table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
:
  $search$ ;
  @typeListeRecherche lr [empty] ;
  repeat
    @lstring nomAttribut ;
    $identifier$ ?nomAttribut ; # nom d'attribut
    @AC_galgasType natureAttribut ;
    [!?table_attributs searchKey !nomAttribut ?natureAttribut] ;
    extract natureAttribut->@typeGalgas_lstring () error nomAttribut : messageGalgasType ;
    $in$ ;
    @lstring listName ;
    $identifier$ ?listName ;
    [!?table_tables_mots_reserves searchKey !listName ?*] ;
    $default$ ;
    lr += !nomAttribut !listName ;
  while
    $search$ ;
  end repeat ;
  @typeEmissionParDefaut ee ;
  <lexical_send_or_error> ? ee !?table_des_messages_erreur ;
  instruction := [@typeInstructionEmettre new !lr !ee] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_or_error>
  !@typeEmissionParDefaut emissionParDefaut
  ?!@typeTableMessagesErreurs unused tableMessagesErreurs
:
  @lstring nomTerminal ;
  $terminal$ ?nomTerminal ;
  emissionParDefaut := [@typeEmissionTerminalParDefaut new !nomTerminal] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_or_error>
  !@typeEmissionParDefaut emissionParDefaut
  ?!@typeTableMessagesErreurs tableMessagesErreurs
:
  $error$ ;
  @lstring errorMessageName ;
  $identifier$ ?errorMessageName ;
  @luint errorMessageIndex ;
  [!?tableMessagesErreurs searchKeyGetIndex !errorMessageName ?errorMessageIndex ?*] ;
  emissionParDefaut := [@typeEmissionErreurParDefaut new !errorMessageIndex] ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
