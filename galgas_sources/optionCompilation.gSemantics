#---------------------------------------------------------------------------*
#                                                                           *
#  Treewalking for generating option header file                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics optionCompilation :
import "optionMetamodel.gSemantics" ;
import "optionSemantics.gSemantics" ;
import semantics optionMetamodel in "optionMetamodel.gSemantics" ;
import semantics optionSemantics in "optionSemantics.gSemantics" ;
import grammar optionLL1grammar in "optionLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*
#         G E N E R A T I O N    T E M P L A T E S                          *
#---------------------------------------------------------------------------*

filewrapper optionGenerationTemplates in "../generation_templates/option_generation" {
} {
  template optionHeaderZone2 "option-header-zone2.gTemplate"
    ?@string OPTION_COMPONENT_NAME
  ;
  template optionHeaderZone3 "option-header-zone3.gTemplate"
    ?@string OPTION_COMPONENT_NAME
    ?@commandLineOptionMap BOOL_OPTION_MAP
    ?@commandLineOptionMap UINT_OPTION_MAP
    ?@commandLineOptionMap STRING_OPTION_MAP
  ;
  template optionImplementation "option-implementation.gTemplate"
    ?@string OPTION_COMPONENT_NAME
    ?@commandLineOptionMap BOOL_OPTION_MAP
    ?@commandLineOptionMap UINT_OPTION_MAP
    ?@commandLineOptionMap STRING_OPTION_MAP
  ;
}

#---------------------------------------------------------------------------*

routine compileOptionComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
:
#--- Parse option component
  @optionComponentRoot optionComponentRoot ;
  grammar optionLL1grammar in inSourceFile ?optionComponentRoot ;
#--- Check component name
  @lstring componentName := [optionComponentRoot mOptionComponentName] ;
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be the same"
    ;
  end if ; 
#--- Check component name
  @string baseName := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [[optionComponentRoot mOptionComponentName] string] != baseName then
    error [optionComponentRoot mOptionComponentName]: "the component name is '"
    . [optionComponentRoot mOptionComponentName] . "' should be the file base name '"
    . baseName . "'" ;
  end if ;
#--- Treewalking for defining option map
  @commandLineOptionMap boolOptionMap [emptyMap] ;
  @commandLineOptionMap uintOptionMap [emptyMap] ;
  @commandLineOptionMap stringOptionMap [emptyMap] ;
  @stringset optionNameSet [emptySet] ;
  foreach [optionComponentRoot mOptions] do
    if [optionNameSet hasKey ![mOptionInternalName string]] then
      error mOptionInternalName: "the '" . [mOptionInternalName string] . "' command line option has been already declared" ;
    elsif [mOptionTypeName string] == "bool" then
      [!?boolOptionMap insertKey
        !mOptionInternalName
        !mOptionInvocationLetter
        !mOptionInvocationString
        !mOptionComment
      ] ;
    elsif [mOptionTypeName string] == "uint" then
      [!?uintOptionMap insertKey
        !mOptionInternalName
        !mOptionInvocationLetter
        !mOptionInvocationString
        !mOptionComment
      ] ;
    elsif [mOptionTypeName string] == "string" then
      [!?stringOptionMap insertKey
        !mOptionInternalName
        !mOptionInvocationLetter
        !mOptionInvocationString
        !mOptionComment
      ] ;
    else
      error mOptionTypeName: "only the @bool, @uint or @string types are allowed here" ;
    end if ;
    optionNameSet += ![mOptionInternalName string] ;
  end foreach ;
#--- Generate header
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      ![[optionComponentRoot mOptionComponentName] string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper optionGenerationTemplates.optionHeaderZone2
        ![[optionComponentRoot mOptionComponentName] string]
      ]
      !"\n\n" # Defaut user zone2
      ![filewrapper optionGenerationTemplates.optionHeaderZone3
        ![[optionComponentRoot mOptionComponentName] string]
        !boolOptionMap
        !uintOptionMap
        !stringOptionMap
      ]
    ] ;
  end if ;
#--- Generate Implementation
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      ![[optionComponentRoot mOptionComponentName] string] . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper optionGenerationTemplates.optionImplementation
        ![[optionComponentRoot mOptionComponentName] string]
        !boolOptionMap
        !uintOptionMap
        !stringOptionMap
      ]
      !"\n\n" # Defaut user zone2
      !"\n\n" # User Zone 3
    ] ;
 end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;