#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS constraint component parser definition                            *
#                                                                           *
#  Copyright (C) 2006, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax constraint_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

nonterminal <constraint_class_override_declarations>
  ?@lstring inRootClass
  ?@entityToImplementMap inOriginalMetamodelEntityMap 
  !@entityToImplementMap outMetamodelEntityMap
  !@stringset outOverriddenClassSet
label parse
;

nonterminal <constraint_map_declaration>
  ??@stringset inOverriddenClassSet
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
label parse
;

nonterminal <parse_constraint_document>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

nonterminal <constraints_on_entity_declaration>
  ??@lstring inConstraintName
  ??@stringset inOverriddenClassSet
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstrainedEntityMap
  ?!@constraintInstructionListMap ioConstraintInstructionListMap
label parse
;

nonterminal <semantic_instructions_list>
  ??@typeTableEnAvant inTableEnAvant
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionsList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

#-------------------------------------------------------------------*
#                   Constraint component                            *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_constraint_document> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @M_constraintComponents constraintComponentMap [emptyMap] ;
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?constraintComponentMap
  ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_constraint_document> parse ;
end rule ;

#-------------------------------------------------------------------*

routine checkCallInstruction 
  ??@entityToImplementMap inConstrainedEntityMap
  ??@lstring inTestedReferenceName
  ??@callInstructionSharedPropertySignatureMap inCallInstructionSharedPropertySignatureMap
  ??@lstring inTestedPropertyName
  ??@entityPropertyMap inAllAvailablePropertiesMap
  ??@location inEndOfInstructionList
:
  if [inConstrainedEntityMap hasKey ![inTestedReferenceName string]] then
    if [inCallInstructionSharedPropertySignatureMap hasKey ![inTestedPropertyName string]] then
      # warning endOfInstructionList:"checking 'call " . [inTestedPropertyName string] . "' instruction..." ;
    #--- Build formal parameter type list
      @entityPropertyMap allContraintsPropertyMap ;
      [inConstrainedEntityMap searchKey !inTestedReferenceName ?* ?* ?* ?* ?* ?* ?allContraintsPropertyMap ?*] ;
      @metamodelPropertyList formalParameterTypeList [emptyList] ;
      foreach allContraintsPropertyMap (* @metamodelProperty property) :
        extract property :
        when @metamodelSharedMapProperty (@lstring kMapTypeName *) ->
          formalParameterTypeList += !property ;
          #formalParameterTypeList += ![@metamodelMapProperty new !kMapTypeName] ;
        else
        end extract ;
      end foreach ;
    #--- Build effective argument type list
      @L_lstringList effectiveArgumentList ;
      @location endOfCallInstruction ;
      [inCallInstructionSharedPropertySignatureMap searchKey ! inTestedPropertyName ?effectiveArgumentList ?endOfCallInstruction] ;
      @metamodelPropertyList effectiveArgumentTypeList [emptyList] ;
      foreach effectiveArgumentList (@lstring kEffectiveArgumentName) :
        @metamodelProperty property ;
        [inAllAvailablePropertiesMap searchKey !kEffectiveArgumentName ?property] ;
         effectiveArgumentTypeList += !property ;
      end foreach ;
    #--- Check types
      if [formalParameterTypeList length] != [effectiveArgumentTypeList length] then
        error endOfCallInstruction: "the call instruction names "
          . [[effectiveArgumentTypeList length] string] . " argument(s) instead of "
          . [[formalParameterTypeList length] string] ;
      else
        @uint argumentIndex := 0 ;
        foreach formalParameterTypeList (@metamodelProperty kFormalProperty), effectiveArgumentTypeList (@metamodelProperty kEffectiveProperty) :
          argumentIndex ++ ;
          match kFormalProperty :: kEffectiveProperty :
          when @metamodelSharedMapProperty (@lstring kFormalTypeName *) :: @metamodelMapProperty (@lstring kEffectiveTypeName *) :
            if [kFormalTypeName string] != [kEffectiveTypeName string] then
              error endOfCallInstruction: "for argument " . [argumentIndex string]
                 . ", the effective argument map type (" . [kEffectiveTypeName string]
                 . ") is incompatible with formal parameter map type (" . [kFormalTypeName string]
                 . ")" ;
            end if ;
          when @metamodelSharedMapProperty (@lstring kFormalTypeName *) :: @metamodelSharedMapProperty (@lstring kEffectiveTypeName *) :
            if [kFormalTypeName string] != [kEffectiveTypeName string] then
              error endOfCallInstruction: "for argument " . [argumentIndex string]
                 . ", the effective argument map type (" . [kEffectiveTypeName string]
                 . ") is incompatible with formal parameter map type (" . [kFormalTypeName string]
                 . ")" ;
            end if ;
          else
            error endOfCallInstruction: "for argument " . [argumentIndex string]
               . ", the effective argument type (" . [kEffectiveProperty messageProperty]
               . ") is incompatible with formal parameter type (" . [kFormalProperty messageProperty]
               . ")" ;
          end match ;
        end foreach ;
      end if ; 
      #log effectiveArgumentList, allContraintsPropertyMap, effectiveArgumentTypeList, formalParameterTypeList ;
    else
      error inEndOfInstructionList:"the instruction list should have a 'call " . [inTestedPropertyName string] . "' instruction" ;
    end if ;
  elsif [inCallInstructionSharedPropertySignatureMap hasKey ![inTestedPropertyName string]] then
    error inEndOfInstructionList:"the instruction list should not have a 'call " . [inTestedPropertyName string] . "' instruction" ;
  end if ;
end routine ;

#-------------------------------------------------------------------*

rule <parse_constraint_document>
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
#--- Constraint component header
  $constraint$ ;
  @lstring constraintName ;
  $identifier$ ? constraintName ;
  $:$ ;
#--- Imported Metamodel
  $import$ ;
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
  $in$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;  
  @M_semanticsComponents unusedSemanticsMapForUse [emptyMap] ;
  @M_metamodelsComponents metamodelComponentMap [emptyMap] ;
  <parse_semantics_component_for_importing>
    !fileName
    !?unusedSemanticsMapForUse
    !?metamodelComponentMap
    !?ioConstraintComponentMap
  ;
#--- Search imported metamodel
  @lstring rootEntity ;
  @entityToImplementMap originalMetamodelEntityMap ;
  [metamodelComponentMap searchKey
    !metamodelName
    ?rootEntity
    ?originalMetamodelEntityMap
    ?*
  ] ;
#--- -1- Parse override declarations
  @entityToImplementMap metamodelEntityMap ;
  @stringset overriddenClassSet ;
  <constraint_class_override_declarations>
    !rootEntity
    !originalMetamodelEntityMap 
    ?metamodelEntityMap
    ?overriddenClassSet
  ;
#--- -2- Parse map declarations
  @mapEntityMap mapEntityMap [emptyMap] ;
  repeat
  while
    <constraint_map_declaration>
      !overriddenClassSet
      !metamodelEntityMap
      !?mapEntityMap
    ;
  end repeat ;
#--- -3- Parse constraint implementation
  @entityToImplementMap constrainedEntityMap [emptyMap] ;
  @constraintInstructionListMap constraintInstructionListMap [emptyMap] ;
  repeat
    <constraints_on_entity_declaration>
      !constraintName
      !overriddenClassSet
      !metamodelEntityMap
      !?mapEntityMap
      !?constrainedEntityMap
      !?constraintInstructionListMap
    ;
  while
  end repeat ;
  $end$ ;
#--- Check all overridden classes are actually defined
  foreach overriddenClassSet (@string kClassName) :
    if not [constrainedEntityMap hasKey ! kClassName] then
      error here : "the '%" . kClassName . "' is declared as overridden, but is not defined" ;
    end if ;
  end foreach ;
#--- Root entity is defined ?
  if not [constrainedEntityMap hasKey ![rootEntity string]] then
    error here:"the @" . [rootEntity string] . " root entity should be defined" ;
  end if ;
#--- Build representative entity map
  @representativeEntityMap representativeEntityMap [emptyMap] ;
  foreach metamodelEntityMap (@lstring kEntityName * * * * * @stringset kSuperEntitySet ...) :
    @lstring representativeTypeName ;
    computeRepresentativeEntityName
      !metamodelEntityMap
      !constrainedEntityMap
      !kEntityName
      ?representativeTypeName
    ;
    @stringset superEntitySet := kSuperEntitySet ;
    superEntitySet += ![kEntityName string] ;
    [!?representativeEntityMap insertKey !kEntityName !representativeTypeName !superEntitySet] ;
  end foreach ;
#--- Redefine the super classes not redefined by user
##--- Build actual constraint entity map
#  @entityToImplementMap actualConstrainedEntityMap [emptyMap] ;
  @stringset multiReferencedEntities [emptySet] ;
  foreach constrainedEntityMap (
    @lstring kEntityName
    @entityPropertyMap kAllMetamodelPropertyMap
    @bool kIsAbstract
    @entityPropertyMap kCurrentMetamodelPropertyMap
    @lstring kSuperEntityName
    @entityPropertyMap kCurrentContraintsPropertyMap
    @stringset kSuperClassSet
    @entityPropertyMap kAllContraintsPropertyMap
    @entityPropertyMap kAllAvailablePropertyMap
  ) :
#  #--- Check constrained parameters of super entity (should be the same)
#    if [kSuperEntityName string] != "" then
#      @bool superEntityIsImplicitlyDefined ;
#      @constrainedPropertyList superEntityConstrainedParameterPropertyToImplementList ;
#      [constrainedEntityMap searchKey
#        !kSuperEntityName
#        ?*
#        ?*
#        ?*
#        ?*
#        ?*
#        ?superEntityIsImplicitlyDefined
#        ?*
#        ?superEntityConstrainedParameterPropertyToImplementList
#        ?*
#        ?*
#      ] ;
#      @bool identical := [kConstrainedParameterPropertyToImplementList length] == [superEntityConstrainedParameterPropertyToImplementList length] ;
#      foreach kConstrainedParameterPropertyToImplementList (@lstring kPropertyType1 @lstring kPropertyName1),
#              superEntityConstrainedParameterPropertyToImplementList (@lstring kPropertyType2 @lstring kPropertyName2)
#      while identical :
#         identical := ([kPropertyType1 string] == [kPropertyType2 string]) & ([kPropertyName1 string] == [kPropertyName2 string]) ;
#      end foreach ;
#      if not identical then
#        @string m := "parameter error: the '@" . [kEntityName string] . "' entity" ;
#        if kIsImplicitlyDefined then
#          m := m . " (implicitly defined)" ;
#        end if ;
#        m := m . " should have the same parameters as '@" . [kSuperEntityName string] . "' entity" ;
#        if superEntityIsImplicitlyDefined then
#          m := m . " (implicitly defined)" ;
#        end if ;
#        error here: m ;
#      end if ;
#    end if ;
#  #---
#   @entityPropertyMap newAllPropertiesMap [emptyMap] ;
    foreach kAllMetamodelPropertyMap (@lstring kKey @metamodelProperty kProperty) :
      extract kProperty :
#      when @metamodelSingleReferenceProperty (@lstring kTypeName) :
#        @lstring representativeTypeName ;
#        computeRepresentativeEntityName
#          !metamodelEntityMap
#          !constrainedEntityMap
#          !kTypeName
#          ?representativeTypeName
#        ;
#        if [representativeTypeName string] != "" then
#          multiReferencedEntities += ![representativeTypeName string] ;
#        end if ;
      when @metamodelMultipleReferenceProperty (@lstring kTypeName * *) ->
        @lstring representativeTypeName ;
        computeRepresentativeEntityName
          !metamodelEntityMap
          !constrainedEntityMap
          !kTypeName
          ?representativeTypeName
        ;
        if [representativeTypeName string] != "" then
          multiReferencedEntities += ![representativeTypeName string] ;
        end if ;
      else
      end extract ;
    end foreach ;
#    @entityPropertyMap newPropertiesMap [emptyMap] ;
#    foreach kEntityPropertiesMap (@lstring kKey @metamodelPropertyKind kKind @lstring kTypeName) :
#      switch kKind 
#      when attributeProperty, entityMapProperty :
#        [!?newPropertiesMap insertKey !kKey !kKind !kTypeName] ;
#      when singleReferenceProperty, multipleReferenceProperty :
#        @lstring representativeTypeName ;
#        computeRepresentativeEntityName
#          !metamodelEntityMap
#          !constrainedEntityMap
#          !kTypeName
#          ?representativeTypeName
#        ;
#        if [representativeTypeName string] != "" then
#          [!?newPropertiesMap insertKey !kKey !kKind !representativeTypeName] ;
#          multiReferencedEntities += ![representativeTypeName string] ;
#        end if ;
#      end switch ;
#    end foreach ;
#    [!?actualConstrainedEntityMap insertKey
#      !kEntityName
#      !newAllPropertiesMap
#      !kIsAbstract
#      !newPropertiesMap
#      !kSuperEntityName
#      !kSuperClassSet
#      !kIsImplicitlyDefined
#      !kConstrainedAttributePropertyToImplementList
#      !kConstrainedParameterPropertyToImplementList
#      !kAllIndexMap
#      !kCurrentIndexMap
#    ] ;
  end foreach ;
#--- Check call instructions
  foreach constrainedEntityMap (
    @lstring kEntityName
    *
    *
    @entityPropertyMap kEntityPropertiesMap
    *
    *
    *
    *
    @entityPropertyMap kAllAvailablePropertiesMap
  ) :
  #--- loop throught properties
    @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap ; # [emptyMap] ;
    @location endOfInstructionList ;
    [constraintInstructionListMap searchKey !kEntityName ?* ?callInstructionSharedPropertySignatureMap ?endOfInstructionList] ;
    foreach kEntityPropertiesMap (@lstring kPropertyName @metamodelProperty kProperty) :
      extract kProperty :
      when @metamodelSingleReferenceProperty (@lstring kSingleReferenceTypeName) ->
        checkCallInstruction 
          !constrainedEntityMap
          !kSingleReferenceTypeName
          !callInstructionSharedPropertySignatureMap
          !kPropertyName
          !kAllAvailablePropertiesMap
          !endOfInstructionList
        ;
      when @metamodelMultipleReferenceProperty (@lstring kMultipleReferenceTypeName * *) ->
        checkCallInstruction 
          !constrainedEntityMap
          !kMultipleReferenceTypeName
          !callInstructionSharedPropertySignatureMap
          !kPropertyName
          !kAllAvailablePropertiesMap
          !endOfInstructionList
        ;
      else
      end extract ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_constraints
    !metamodelEntityMap
    !mapEntityMap
    !metamodelName
    !constraintName
    !constrainedEntityMap
    !multiReferencedEntities
    !rootEntity
    !representativeEntityMap
    !constraintInstructionListMap
  ;
  $constraint$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_map_declaration>
  ??@stringset inOverriddenClassSet
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
:
  $map$ ;
  @lstring mapIdentifier ;
  $mda_type_name$ ? mapIdentifier ;
  if [inMetamodelEntityMap hasKey ![mapIdentifier string]] then
    error mapIdentifier: "An entity has been declared with this name" ;
  end if ;
  $of$ ;
  @lstring mapElementIdentifier ;
  $mda_type_name$ ? mapElementIdentifier ;
  @bool isElementTypeOverridden := [inOverriddenClassSet hasKey ![mapElementIdentifier string]] ;
  ${$ ;
  $insert$ ;
  $error$ ;
  $message$ ;
  @lstring insertErrorMessage ;
  $literal_string$ ? insertErrorMessage ;
  action check_KL_escapeCharacters !insertErrorMessage ;
  $;$ ;
  $search$ ;
  $error$ ;
  $message$ ;
  @lstring searchErrorMessage ;
  $literal_string$ ? searchErrorMessage ;
  action check_K_escapeCharacters !searchErrorMessage ;
  $;$ ;
  $}$ ;
  [!?ioMapEntityMap insertKey
    !mapIdentifier
    !mapElementIdentifier
    !insertErrorMessage
    !searchErrorMessage
    !isElementTypeOverridden
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <constraints_on_entity_declaration>
  ??@lstring inConstraintName
  ??@stringset inOverriddenClassSet
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstrainedEntityMap
  ?!@constraintInstructionListMap ioConstraintInstructionListMap
:
#--- Entity Name
  $class$ ;
  @lstring entityName ;
  $mda_type_name$ ? entityName ;
#--- Get entity properties
  @lstring superEntity ;
  @entityPropertyMap allMetamodelPropertyMap ;
  @stringset superClassSet ;
  @entityPropertyMap currentMetamodelPropertyMap ;
  @entityPropertyMap allConstraintPropertyMap ;
  @entityPropertyMap allAvailablePropertyMap ;
  [inEntityMap searchKey
    !entityName
    ?allMetamodelPropertyMap
    ?* # Abstract
    ?currentMetamodelPropertyMap
    ?superEntity
    ?* # currentConstraintPropertyMap
    ?superClassSet
    ?allConstraintPropertyMap
    ?allAvailablePropertyMap
   ] ;
#--- Get inherited properties from super class constraints
#  @constrainedPropertyList constrainedParameterPropertyToImplementList [emptyList] ;
#  @indexMap allIndexes [emptyMap] ;
  if [superEntity string] == "" then

  elsif [ioConstrainedEntityMap hasKey ![superEntity string]] then
    @entityPropertyMap inheritedConstraintPropertyMap ;
    [ioConstrainedEntityMap searchKey
      !superEntity
      ?* #allMetamodelPropertyMap
      ?* # Abstract
      ?* #currentMetamodelPropertyMap
      ?* # Super entity
      ?inheritedConstraintPropertyMap
      ?* # Super Class set
      ?allConstraintPropertyMap
      ?* #allAvailablePropertyMap
    ] ;
    foreach inheritedConstraintPropertyMap (@lstring kKey @metamodelProperty kProperty) :
      [!?allAvailablePropertyMap insertKey !kKey !kProperty] ;
    end foreach ;
  else
    error entityName:
        "constraints for super entity ('@" . [superEntity string] . "') should be previously defined" ;
  end if ;
  @entityPropertyMap currentConstraintPropertyMap [emptyMap] ;
#--- Properties as parameters
    select
    or
      $($ ;
      if [superEntity string] != "" then
        error here: "as the '@" . [entityName string]
        . "' entity has a super entity, you cannot define any shared property" ;
      end if ;
      repeat
        @lstring typeName ;
        $mda_type_name$ ? typeName ;
        @lstring elementTypeName ;
        [ioMapEntityMap searchKey !typeName ?elementTypeName ?* ?* ?*] ;
        @metamodelProperty property := [@metamodelSharedMapProperty new !typeName !elementTypeName] ;
        @lstring propertyName ;
        $identifier$ ? propertyName ;
        [!?currentConstraintPropertyMap insertKey !propertyName !property] ;
        [!?allConstraintPropertyMap insertKey !propertyName !property] ;
        [!?allAvailablePropertyMap insertKey !propertyName !property] ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
  #--- Properties as attributes
    @indexMap currentIndexMap [emptyMap] ;
    ${$ ;
    repeat
    while
      @lstring typeName ;
      $mda_type_name$ ?typeName ;
      @lstring elementTypeName ;
      [ioMapEntityMap searchKey !typeName ?elementTypeName ?* ?* ?*] ;
      @metamodelProperty property := [@metamodelMapProperty new !typeName !elementTypeName] ;
      @lstring propertyName ;
      $identifier$ ? propertyName ;
      [!?currentConstraintPropertyMap insertKey !propertyName !property] ;
      [!?allConstraintPropertyMap insertKey !propertyName !property] ;
      [!?allAvailablePropertyMap insertKey !propertyName !property] ;
      $;$ ;
    while
      $mapindex$ ;
      @lstring mapIndexName ;
      $identifier$ ? mapIndexName ;
      $on$ ;
      @lstring mapAttributeName ;
      $identifier$ ? mapAttributeName ;
      @metamodelProperty propertyOfMapAttributeName ;
      [allConstraintPropertyMap searchKey !mapAttributeName ?propertyOfMapAttributeName] ;
      @metamodelProperty property ;
      extract propertyOfMapAttributeName :
      when @metamodelMapProperty (@lstring kMapTypeName *) ->
        property := [@mapIndexProperty new !kMapTypeName !mapAttributeName] ;
      when @metamodelSharedMapProperty (@lstring kMapTypeName *) ->
        property := [@mapIndexProperty new !kMapTypeName !mapAttributeName] ;
      else
        error mapAttributeName: "this property should be a map" -> property ;
      end extract ;
      [!?currentConstraintPropertyMap insertKey !mapIndexName !property] ;
      [!?allConstraintPropertyMap insertKey !mapIndexName !property] ;
      [!?allAvailablePropertyMap insertKey !mapIndexName !property] ;
      $;$ ;
    end repeat ;
    $}$ ;
    ${$ ;
  #--- Enter attributes metamodels as constants
    @typeVariablesMap variablesMap [emptyMap] ;
    foreach allAvailablePropertyMap (@lstring kKey @metamodelProperty kProperty) :
      extract kProperty :
      when @mapIndexProperty (@lstring kMapTypeName @lstring kMapAttributeName) ->
        @AC_galgasType t := [@typeGalgas_mapIndexInInstruction new ![kMapAttributeName string]] ;
        @typeCplusPlusName cppName := [@typeDirectName new !kKey] ;
        [!?variablesMap insertOutProperty !kKey !t !cppName] ;
      when @metamodelAttributeProperty (@lstring kAttributeTypeName) ->
        @typeCplusPlusName cppName := [@typeDirectName new !kKey] ;
        if [kAttributeTypeName string] == "lstring" then
          @AC_galgasType t := [@typeGalgas_lstring new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "string" then
          @AC_galgasType t := [@typeGalgas_string new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lchar" then
          @AC_galgasType t := [@typeGalgas_lchar new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "char" then
          @AC_galgasType t := [@typeGalgas_char new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "luint" then
          @AC_galgasType t := [@typeGalgas_luint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "uint" then
          @AC_galgasType t := [@typeGalgas_uint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lsint" then
          @AC_galgasType t := [@typeGalgas_lsint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "sint" then
          @AC_galgasType t := [@typeGalgas_sint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lbool" then
          @AC_galgasType t := [@typeGalgas_lbool new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "bool" then
          @AC_galgasType t := [@typeGalgas_bool new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "location" then
          @AC_galgasType t := [@typeGalgas_location new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        else
          error here : "internal error (@" . [kAttributeTypeName string] . " type not handled" ;
        end if ;
      else
      end extract ;
    end foreach ;
#--- Add constraint property as routines variables
  # message "************" . [entityName string] . "************\n" ;
  foreach allConstraintPropertyMap (@lstring kKey @metamodelProperty kType) :
    # log kKey, kType ;
    extract kType :
    when @metamodelSharedMapProperty (@lstring kMapTypeName @lstring kMapElementTypeName) ->
      @string overrideConstraint ;
      if [inOverriddenClassSet hasKey ![kMapElementTypeName string]] then
        overrideConstraint := [inConstraintName string] ;
      else
        overrideConstraint := "" ;
      end if ;
      @AC_galgasType t := [@typeGalgas_mapEntityInInstruction new ![kMapTypeName string] ![kMapElementTypeName string] !overrideConstraint] ;
      @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"(* " . [kKey string] . ")" !here]] ;
      [!?variablesMap insertUsedInOutArgument !kKey !t !cppName] ;
    else
    end extract ;
  end foreach ;
#--- Add "self" variable
  @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"this" !here]] ;
  @AC_galgasType t := [@typeGalgas_entityInInstruction new ![entityName string] ![inConstraintName string]] ;
  [!?variablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !t !cppName] ;
#--- Instructions
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap [emptyMap] ;
  @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @typeInstructionList instructionsList [emptyList] ;
  @stringset constraintPropertyDefinitionSet [emptySet] ;
  @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  <semantic_instructions_list>
    !tableEnAvant
    !?componentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !optionsComponentsMapForUse
    !?variablesMap
    !?instructionsList
    !?allAvailablePropertyMap
    !?constraintPropertyDefinitionSet
    !?callInstructionSharedPropertySignatureMap
  ;
  $}$ ;
  [!?ioConstraintInstructionListMap insertKey
    !entityName
    !instructionsList
    !callInstructionSharedPropertySignatureMap
    !here
  ] ;
#--- Enter in constraint entity map
  [!?ioConstrainedEntityMap insertKey
    !entityName
    !allMetamodelPropertyMap
    !false # Is not abstract
    !currentMetamodelPropertyMap
    !superEntity
    !currentConstraintPropertyMap
    !superClassSet
    !allConstraintPropertyMap
    !allAvailablePropertyMap
  ] ;
end rule ;

#-------------------------------------------------------------------*

routine buildUsefullPropertyMap
 ??@entityPropertyMap inInputPropertyMap
 ??@stringset inUsefullClassSet
 !@entityPropertyMap outOutputPropertyMap
:
  outOutputPropertyMap := [@entityPropertyMap emptyMap] ;
  foreach inInputPropertyMap (@lstring kPropertyName @metamodelProperty kProperty) :
    extract kProperty:
    when @metamodelSingleReferenceProperty (@lstring kReferenceClassName)->
      if [inUsefullClassSet hasKey ![kReferenceClassName string]] then
        [!?outOutputPropertyMap insertKey !kPropertyName !kProperty] ;
      end if ;
    when @metamodelMultipleReferenceProperty (@lstring kReferenceClassName * *)->
      if [inUsefullClassSet hasKey ![kReferenceClassName string]] then
        [!?outOutputPropertyMap insertKey !kPropertyName !kProperty] ;
      end if ;
    else
      [!?outOutputPropertyMap insertKey !kPropertyName !kProperty] ;
    end extract ;
  end foreach ;
end routine ;

#-------------------------------------------------------------------*

rule <constraint_class_override_declarations>
  ?@lstring inRootClass
  ?@entityToImplementMap inOriginalMetamodelEntityMap 
  !@entityToImplementMap outMetamodelEntityMap
  !@stringset outOverriddenClassSet
:
#--- Parse override class declarations
  outOverriddenClassSet := [@stringset  emptySet] ;
  repeat
    $override$ ;
    @lstring metamodelClass ;
    $mda_type_name$ ? metamodelClass ;
    [inOriginalMetamodelEntityMap searchKey !metamodelClass ?* ?* ?* ?* ?* ?* ?* ?*] ;
    if [outOverriddenClassSet hasKey ![metamodelClass string]] then
      error metamodelClass:"this class is already declared as overridden" ;
    else
      outOverriddenClassSet += ![metamodelClass string] ;
    end if ;
    $;$ ;
  while
  end repeat ;
#--- Check root class is declared as overridden
  if not [outOverriddenClassSet hasKey ![inRootClass string]] then
    error here:"the '%" . [inRootClass string] . "' root class should be declared as overridden" ;
  end if ;
#--- Build useful class set
  @stringset usefulClassSet [setWithString ![inRootClass string]] ;
  @bool continue := true ;
  loop [inOriginalMetamodelEntityMap count] + 1 :
  while continue do
    continue := false ;
    foreach outOverriddenClassSet (@string kClassName) :
      @entityPropertyMap allAvailablePropertyMap ;
      @lstring superEntityName ;
      [inOriginalMetamodelEntityMap searchKey
        ![@lstring new !kClassName !here]
        ?*
        ?*
        ?*
        ?superEntityName
        ?*
        ?*
        ?*
        ?allAvailablePropertyMap
      ] ;
    #--- If super class is usefull and class is overriden, class is usefull
      if [usefulClassSet hasKey ![superEntityName string]] & not [usefulClassSet hasKey !kClassName] then
        continue := true ;
        usefulClassSet += !kClassName ;
      end if ;
      if [usefulClassSet hasKey !kClassName] then
      #--- If a class is usefull, its super class is also usefull
        if ([superEntityName string] != "") & not [usefulClassSet hasKey ![superEntityName string]] then
          continue := true ;
          usefulClassSet += ![superEntityName string] ;
        end if ;
        foreach allAvailablePropertyMap (* @metamodelProperty kProperty) :
          extract kProperty:
          when @metamodelSingleReferenceProperty (@lstring kReferenceClassName)->
            if [outOverriddenClassSet hasKey ![kReferenceClassName string]] & not [usefulClassSet hasKey ![kReferenceClassName string]] then
              continue := true ;
              usefulClassSet += ![kReferenceClassName string] ;
            end if ;
          when @metamodelMultipleReferenceProperty (@lstring kReferenceClassName * *)->
            if [outOverriddenClassSet hasKey ![kReferenceClassName string]] & not [usefulClassSet hasKey ![kReferenceClassName string]] then
              continue := true ;
              usefulClassSet += ![kReferenceClassName string] ;
            end if ;
          else
          end extract ;
        end foreach ;
      end if ;
    end foreach ;
  end loop ;
#  log usefulClassSet ;
#--- Check for missing classes
  @stringset missingClasses := usefulClassSet - outOverriddenClassSet ;
  foreach missingClasses (@string kMissingClassName) :
    error here: "the '%" . kMissingClassName . "' class should be overriden" ;
  end foreach ;
#--- Warn for useless classes
  @stringset uselessClasses := outOverriddenClassSet - usefulClassSet ;
  foreach uselessClasses (@string kUselessClassName) :
    error here: "it is useless to override '%" . kUselessClassName . "' class" ;
  end foreach ;
#--- Build new metamodel class map : filter out useless properties
  outMetamodelEntityMap := [@entityToImplementMap emptyMap] ;
  foreach inOriginalMetamodelEntityMap (
    @lstring kClassName
    @entityPropertyMap kAllMetamodelPropertyMap
    @bool kIsAbstract
    @entityPropertyMap kCurrentMetamodelPropertyMap
    @lstring kSuperEntityName
    @entityPropertyMap kCurrentConstraintPropertyMap
    @stringset kSuperEntitySet
    @entityPropertyMap kAllConstraintPropertyMap
    @entityPropertyMap kAllAvailablePropertyMap
  ) :
    if [usefulClassSet hasKey ![kClassName string]] then
      @entityPropertyMap allMetamodelPropertyMap ;
      buildUsefullPropertyMap !kAllMetamodelPropertyMap !usefulClassSet ?allMetamodelPropertyMap ;
      @entityPropertyMap currentMetamodelPropertyMap ;
      buildUsefullPropertyMap !kCurrentMetamodelPropertyMap !usefulClassSet ?currentMetamodelPropertyMap ;
      @entityPropertyMap currentConstraintPropertyMap ;
      buildUsefullPropertyMap !kCurrentConstraintPropertyMap !usefulClassSet ?currentConstraintPropertyMap ;
      @entityPropertyMap allConstraintPropertyMap ;
      buildUsefullPropertyMap !kAllConstraintPropertyMap !usefulClassSet ?allConstraintPropertyMap ;
      @entityPropertyMap allAvailablePropertyMap ;
      buildUsefullPropertyMap !kAllAvailablePropertyMap !usefulClassSet ?allAvailablePropertyMap ;
      [!?outMetamodelEntityMap insertKey
        !kClassName
        !allMetamodelPropertyMap
        !kIsAbstract
        !currentMetamodelPropertyMap
        !kSuperEntityName
        !currentConstraintPropertyMap
        !kSuperEntitySet
        !allConstraintPropertyMap
        !allAvailablePropertyMap
      ] ;
    end if ;
  end foreach ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
