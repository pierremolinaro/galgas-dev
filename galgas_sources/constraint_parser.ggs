#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS constraint component parser definition                            *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax constraint_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <constraint_class_override_declarations>
  ?@lstring inRootClass
  ?@entityToImplementMap inOriginalMetamodelEntityMap 
  !@entityToImplementMap outMetamodelEntityMap
label parse
;

rule <constraint_map_declaration>
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
label parse
;

rule <parse_constraint_document>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <property_path_for_constraint>
  !@L_propertyPath outPath
label parse
;

rule <constraints_on_entity_declaration>
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstrainedEntityMap
  ?!@constraintInstructionListMap ioConstraintInstructionListMap
label parse
;

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionsList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

#-------------------------------------------------------------------*
#                   Constraint component                            *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_constraint_document> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @M_constraintComponents constraintComponentMap [emptyMap] ;
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?constraintComponentMap
  ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_constraint_document> parse ;
end rule ;

#-------------------------------------------------------------------*

routine checkCallInstruction 
  ??@entityToImplementMap inConstrainedEntityMap
  ??@lstring inTestedReferenceName
  ??@callInstructionSharedPropertySignatureMap inCallInstructionSharedPropertySignatureMap
  ??@lstring inTestedPropertyName
  ??@entityPropertyMap inAllAvailablePropertiesMap
  ??@location inEndOfInstructionList
:
  if [inConstrainedEntityMap hasKey ![inTestedReferenceName string]] then
    if [inCallInstructionSharedPropertySignatureMap hasKey ![inTestedPropertyName string]] then
      # warning endOfInstructionList:"checking 'call " . [inTestedPropertyName string] . "' instruction..." ;
    #--- Build formal parameter type list
      @entityPropertyMap allContraintsPropertyMap ;
      [inConstrainedEntityMap searchKey !inTestedReferenceName ?* ?* ?* ?* ?* ?* ?allContraintsPropertyMap ?*] ;
      @metamodelPropertyList formalParameterTypeList [emptyList] ;
      foreach allContraintsPropertyMap (* @metamodelProperty property) :
        extract property :
        when @metamodelSharedMapProperty (@lstring kMapTypeName) ->
          formalParameterTypeList += !property ;
          #formalParameterTypeList += ![@metamodelMapProperty new !kMapTypeName] ;
        else
        end extract ;
      end foreach ;
    #--- Build effective argument type list
      @L_lstringList effectiveArgumentList ;
      @location endOfCallInstruction ;
      [inCallInstructionSharedPropertySignatureMap searchKey ! inTestedPropertyName ?effectiveArgumentList ?endOfCallInstruction] ;
      @metamodelPropertyList effectiveArgumentTypeList [emptyList] ;
      foreach effectiveArgumentList (@lstring kEffectiveArgumentName) :
        @metamodelProperty property ;
        [inAllAvailablePropertiesMap searchKey !kEffectiveArgumentName ?property] ;
         effectiveArgumentTypeList += !property ;
      end foreach ;
    #--- Check types
      if [formalParameterTypeList length] != [effectiveArgumentTypeList length] then
        error endOfCallInstruction: "the call instruction names "
          . [[effectiveArgumentTypeList length] string] . " argument(s) instead of "
          . [[formalParameterTypeList length] string] ;
      else
        @uint argumentIndex := 0 ;
        foreach formalParameterTypeList (@metamodelProperty kFormalProperty), effectiveArgumentTypeList (@metamodelProperty kEffectiveProperty) :
          argumentIndex ++ ;
          match kFormalProperty :: kEffectiveProperty :
          when @metamodelSharedMapProperty (@lstring kFormalTypeName) :: @metamodelMapProperty (@lstring kEffectiveTypeName) :
            if [kFormalTypeName string] != [kEffectiveTypeName string] then
              error endOfCallInstruction: "for argument " . [argumentIndex string]
                 . ", the effective argument map type (" . [kEffectiveTypeName string]
                 . ") is incompatible with formal parameter map type (" . [kFormalTypeName string]
                 . ")" ;
            end if ;
          when @metamodelSharedMapProperty (@lstring kFormalTypeName) :: @metamodelSharedMapProperty (@lstring kEffectiveTypeName) :
            if [kFormalTypeName string] != [kEffectiveTypeName string] then
              error endOfCallInstruction: "for argument " . [argumentIndex string]
                 . ", the effective argument map type (" . [kEffectiveTypeName string]
                 . ") is incompatible with formal parameter map type (" . [kFormalTypeName string]
                 . ")" ;
            end if ;
          else
            error endOfCallInstruction: "for argument " . [argumentIndex string]
               . ", the effective argument type (" . [kEffectiveProperty messageProperty]
               . ") is incompatible with formal parameter type (" . [kFormalProperty messageProperty]
               . ")" ;
          end match ;
        end foreach ;
      end if ; 
      #log effectiveArgumentList, allContraintsPropertyMap, effectiveArgumentTypeList, formalParameterTypeList ;
    else
      error inEndOfInstructionList:"the instruction list should have a 'call " . [inTestedPropertyName string] . "' instruction" ;
    end if ;
  elsif [inCallInstructionSharedPropertySignatureMap hasKey ![inTestedPropertyName string]] then
    error inEndOfInstructionList:"the instruction list should not have a 'call " . [inTestedPropertyName string] . "' instruction" ;
  end if ;
end routine ;

#-------------------------------------------------------------------*

rule <parse_constraint_document>
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
#--- Constraint component header
  $constraint$ ;
  @lstring constraintName ;
  $identifier$ ? constraintName ;
  $:$ ;
#--- Imported Metamodel
  $import$ ;
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
  $in$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;  
  @M_semanticsComponents unusedSemanticsMapForUse [emptyMap] ;
  @M_metamodelsComponents metamodelComponentMap [emptyMap] ;
  <parse_semantics_component_for_importing>
    !fileName
    !?unusedSemanticsMapForUse
    !?metamodelComponentMap
    !?ioConstraintComponentMap
  ;
#--- Search imported metamodel
  @lstring rootEntity ;
  @entityToImplementMap originalMetamodelEntityMap ;
  [metamodelComponentMap searchKey
    !metamodelName
    ?rootEntity
    ?originalMetamodelEntityMap
    ?*
  ] ;
#--- -1- Parse override declarations
  @entityToImplementMap metamodelEntityMap ;
  <constraint_class_override_declarations>
    !rootEntity
    !originalMetamodelEntityMap 
    ?metamodelEntityMap
  ;
#--- -2- Parse map declarations
  @mapEntityMap mapEntityMap [emptyMap] ;
  repeat
  while
    <constraint_map_declaration>
      !metamodelEntityMap
      !?mapEntityMap
    ;
  end repeat ;
#--- -3- Parse constraint implementation
  @entityToImplementMap constrainedEntityMap [emptyMap] ;
  @constraintInstructionListMap constraintInstructionListMap [emptyMap] ;
  repeat
    <constraints_on_entity_declaration>
      !metamodelEntityMap
      !?mapEntityMap
      !?constrainedEntityMap
      !?constraintInstructionListMap
    ;
  while
  end repeat ;
  $end$ ;
#--- Root entity is defined ?
  if not [constrainedEntityMap hasKey ![rootEntity string]] then
    error here:"the @" . [rootEntity string] . " root entity should be defined" ;
  end if ;
#--- Build representative entity map
  @representativeEntityMap representativeEntityMap [emptyMap] ;
  foreach metamodelEntityMap (@lstring kEntityName * * * * * @stringset kSuperEntitySet ...) :
    @lstring representativeTypeName ;
    computeRepresentativeEntityName
      !metamodelEntityMap
      !constrainedEntityMap
      !kEntityName
      ?representativeTypeName
    ;
    @stringset superEntitySet := kSuperEntitySet ;
    superEntitySet += ![kEntityName string] ;
    [!?representativeEntityMap insertKey !kEntityName !representativeTypeName !superEntitySet] ;
  end foreach ;
#--- Redefine the super classes not redefined by user
##--- Build actual constraint entity map
#  @entityToImplementMap actualConstrainedEntityMap [emptyMap] ;
  @stringset multiReferencedEntities [emptySet] ;
  foreach constrainedEntityMap (
    @lstring kEntityName
    @entityPropertyMap kAllMetamodelPropertyMap
    @bool kIsAbstract
    @entityPropertyMap kCurrentMetamodelPropertyMap
    @lstring kSuperEntityName
    @entityPropertyMap kCurrentContraintsPropertyMap
    @stringset kSuperClassSet
    @entityPropertyMap kAllContraintsPropertyMap
    @entityPropertyMap kAllAvailablePropertyMap
  ) :
#  #--- Check constrained parameters of super entity (should be the same)
#    if [kSuperEntityName string] != "" then
#      @bool superEntityIsImplicitlyDefined ;
#      @constrainedPropertyList superEntityConstrainedParameterPropertyToImplementList ;
#      [constrainedEntityMap searchKey
#        !kSuperEntityName
#        ?*
#        ?*
#        ?*
#        ?*
#        ?*
#        ?superEntityIsImplicitlyDefined
#        ?*
#        ?superEntityConstrainedParameterPropertyToImplementList
#        ?*
#        ?*
#      ] ;
#      @bool identical := [kConstrainedParameterPropertyToImplementList length] == [superEntityConstrainedParameterPropertyToImplementList length] ;
#      foreach kConstrainedParameterPropertyToImplementList (@lstring kPropertyType1 @lstring kPropertyName1),
#              superEntityConstrainedParameterPropertyToImplementList (@lstring kPropertyType2 @lstring kPropertyName2)
#      while identical :
#         identical := ([kPropertyType1 string] == [kPropertyType2 string]) & ([kPropertyName1 string] == [kPropertyName2 string]) ;
#      end foreach ;
#      if not identical then
#        @string m := "parameter error: the '@" . [kEntityName string] . "' entity" ;
#        if kIsImplicitlyDefined then
#          m := m . " (implicitly defined)" ;
#        end if ;
#        m := m . " should have the same parameters as '@" . [kSuperEntityName string] . "' entity" ;
#        if superEntityIsImplicitlyDefined then
#          m := m . " (implicitly defined)" ;
#        end if ;
#        error here: m ;
#      end if ;
#    end if ;
#  #---
#   @entityPropertyMap newAllPropertiesMap [emptyMap] ;
    foreach kAllMetamodelPropertyMap (@lstring kKey @metamodelProperty kProperty) :
      extract kProperty :
#      when @metamodelSingleReferenceProperty (@lstring kTypeName) :
#        @lstring representativeTypeName ;
#        computeRepresentativeEntityName
#          !metamodelEntityMap
#          !constrainedEntityMap
#          !kTypeName
#          ?representativeTypeName
#        ;
#        if [representativeTypeName string] != "" then
#          multiReferencedEntities += ![representativeTypeName string] ;
#        end if ;
      when @metamodelMultipleReferenceProperty (@lstring kTypeName * *) ->
        @lstring representativeTypeName ;
        computeRepresentativeEntityName
          !metamodelEntityMap
          !constrainedEntityMap
          !kTypeName
          ?representativeTypeName
        ;
        if [representativeTypeName string] != "" then
          multiReferencedEntities += ![representativeTypeName string] ;
        end if ;
      else
      end extract ;
    end foreach ;
#    @entityPropertyMap newPropertiesMap [emptyMap] ;
#    foreach kEntityPropertiesMap (@lstring kKey @metamodelPropertyKind kKind @lstring kTypeName) :
#      switch kKind 
#      when attributeProperty, entityMapProperty :
#        [!?newPropertiesMap insertKey !kKey !kKind !kTypeName] ;
#      when singleReferenceProperty, multipleReferenceProperty :
#        @lstring representativeTypeName ;
#        computeRepresentativeEntityName
#          !metamodelEntityMap
#          !constrainedEntityMap
#          !kTypeName
#          ?representativeTypeName
#        ;
#        if [representativeTypeName string] != "" then
#          [!?newPropertiesMap insertKey !kKey !kKind !representativeTypeName] ;
#          multiReferencedEntities += ![representativeTypeName string] ;
#        end if ;
#      end switch ;
#    end foreach ;
#    [!?actualConstrainedEntityMap insertKey
#      !kEntityName
#      !newAllPropertiesMap
#      !kIsAbstract
#      !newPropertiesMap
#      !kSuperEntityName
#      !kSuperClassSet
#      !kIsImplicitlyDefined
#      !kConstrainedAttributePropertyToImplementList
#      !kConstrainedParameterPropertyToImplementList
#      !kAllIndexMap
#      !kCurrentIndexMap
#    ] ;
  end foreach ;
#--- Check call instructions
  foreach constrainedEntityMap (
    @lstring kEntityName
    *
    *
    @entityPropertyMap kEntityPropertiesMap
    *
    *
    *
    *
    @entityPropertyMap kAllAvailablePropertiesMap
  ) :
  #--- loop throught properties
    @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap ; # [emptyMap] ;
    @location endOfInstructionList ;
    [constraintInstructionListMap searchKey !kEntityName ?* ?callInstructionSharedPropertySignatureMap ?endOfInstructionList] ;
    foreach kEntityPropertiesMap (@lstring kPropertyName @metamodelProperty kProperty) :
      extract kProperty :
      when @metamodelSingleReferenceProperty (@lstring kSingleReferenceTypeName) ->
        checkCallInstruction 
          !constrainedEntityMap
          !kSingleReferenceTypeName
          !callInstructionSharedPropertySignatureMap
          !kPropertyName
          !kAllAvailablePropertiesMap
          !endOfInstructionList
        ;
      when @metamodelMultipleReferenceProperty (@lstring kMultipleReferenceTypeName * *) ->
        checkCallInstruction 
          !constrainedEntityMap
          !kMultipleReferenceTypeName
          !callInstructionSharedPropertySignatureMap
          !kPropertyName
          !kAllAvailablePropertiesMap
          !endOfInstructionList
        ;
      else
      end extract ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_constraints
    !metamodelEntityMap
    !mapEntityMap
    !metamodelName
    !constraintName
    !constrainedEntityMap
    !multiReferencedEntities
    !rootEntity
    !representativeEntityMap
    !constraintInstructionListMap
  ;
  $constraint$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_map_declaration>
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
:
  $map$ ;
  @lstring mapIdentifier ;
  $mda_type_name$ ? mapIdentifier ;
  if [inMetamodelEntityMap hasKey ![mapIdentifier string]] then
    error mapIdentifier: "An entity has been declared with this name" ;
  end if ;
  $of$ ;
  @lstring mapElementIdentifier ;
  $mda_type_name$ ? mapElementIdentifier ;
  ${$ ;
  $insert$ ;
  $error$ ;
  $message$ ;
  @lstring insertErrorMessage ;
  $literal_string$ ? insertErrorMessage ;
  action check_KL_escapeCharacters !insertErrorMessage ;
  $;$ ;
  $search$ ;
  $error$ ;
  $message$ ;
  @lstring searchErrorMessage ;
  $literal_string$ ? searchErrorMessage ;
  action check_K_escapeCharacters !searchErrorMessage ;
  $;$ ;
  $}$ ;
  [!?ioMapEntityMap insertKey
    !mapIdentifier
    !mapElementIdentifier
    !insertErrorMessage
    !searchErrorMessage
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <constraints_on_entity_declaration>
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstrainedEntityMap
  ?!@constraintInstructionListMap ioConstraintInstructionListMap
:
#--- Entity Name
  $class$ ;
  @lstring entityName ;
  $mda_type_name$ ? entityName ;
#--- Get entity properties
  @lstring superEntity ;
  @entityPropertyMap allMetamodelPropertyMap ;
  @stringset superClassSet ;
  @entityPropertyMap currentMetamodelPropertyMap ;
  @entityPropertyMap allConstraintPropertyMap ;
  @entityPropertyMap allAvailablePropertyMap ;
  [inEntityMap searchKey
    !entityName
    ?allMetamodelPropertyMap
    ?* # Abstract
    ?currentMetamodelPropertyMap
    ?superEntity
    ?* # currentConstraintPropertyMap
    ?superClassSet
    ?allConstraintPropertyMap
    ?allAvailablePropertyMap
   ] ;
#--- Get inherited properties from super class constraints
#  @constrainedPropertyList constrainedParameterPropertyToImplementList [emptyList] ;
#  @indexMap allIndexes [emptyMap] ;
  if [superEntity string] == "" then

  elsif [ioConstrainedEntityMap hasKey ![superEntity string]] then
    @entityPropertyMap inheritedConstraintPropertyMap ;
    [ioConstrainedEntityMap searchKey
      !superEntity
      ?* #allMetamodelPropertyMap
      ?* # Abstract
      ?* #currentMetamodelPropertyMap
      ?* # Super entity
      ?inheritedConstraintPropertyMap
      ?* # Super Class set
      ?allConstraintPropertyMap
      ?* #allAvailablePropertyMap
    ] ;
    foreach inheritedConstraintPropertyMap (@lstring kKey @metamodelProperty kProperty) :
      [!?allAvailablePropertyMap insertKey !kKey !kProperty] ;
    end foreach ;
  else
    error entityName:
        "constraints for super entity ('@" . [superEntity string] . "') should be previously defined" ;
  end if ;
  @entityPropertyMap currentConstraintPropertyMap [emptyMap] ;
#--- Properties as parameters
    select
    or
      $($ ;
      if [superEntity string] != "" then
        error here: "as the '@" . [entityName string]
        . "' entity has a super entity, you cannot define any shared property" ;
      end if ;
      repeat
        @lstring typeName ;
        $mda_type_name$ ? typeName ;
        [ioMapEntityMap searchKey !typeName ?* ?* ?*] ;
        @metamodelProperty property := [@metamodelSharedMapProperty new !typeName] ;
        @lstring propertyName ;
        $identifier$ ? propertyName ;
        [!?currentConstraintPropertyMap insertKey !propertyName !property] ;
        [!?allConstraintPropertyMap insertKey !propertyName !property] ;
        [!?allAvailablePropertyMap insertKey !propertyName !property] ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
  #--- Properties as attributes
    @indexMap currentIndexMap [emptyMap] ;
    ${$ ;
    repeat
    while
      @lstring typeName ;
      $mda_type_name$ ? typeName ;
      [ioMapEntityMap searchKey !typeName ?* ?* ?*] ;
      @metamodelProperty property := [@metamodelMapProperty new !typeName] ;
      @lstring propertyName ;
      $identifier$ ? propertyName ;
      [!?currentConstraintPropertyMap insertKey !propertyName !property] ;
      [!?allConstraintPropertyMap insertKey !propertyName !property] ;
      [!?allAvailablePropertyMap insertKey !propertyName !property] ;
      $;$ ;
#    while
#      $mapindex$ ;
#      @lstring mapIndexName ;
#      $identifier$ ? mapIndexName ;
##      [!?constraintAllPropertiesMap insertKey ! mapIndexName] ;
#      $on$ ;
#      @lstring mapAttributeName ;
#      $identifier$ ? mapAttributeName ;
##      [allMapsAsConstraintPropertyMap searchKey !mapPropertyName ?* ?* ?* ?* ?*] ;
#      [!?currentIndexMap insertKey !mapIndexName !mapAttributeName] ;
#      [!?allIndexes insertKey !mapIndexName !mapAttributeName] ;
#      $;$ ;
    end repeat ;
    $}$ ;
    ${$ ;
  #--- Enter attributes metamodels as constants
    @typeVariablesMap variablesMap [emptyMap] ;
    foreach allAvailablePropertyMap (@lstring kKey @metamodelProperty kProperty) :
      extract kProperty :
      when @metamodelAttributeProperty (@lstring kAttributeTypeName) ->
        # message "attribute '" . [kKey value] . "' has type '@" . [kAttributeTypeName value] . "'\n" ;
        @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"_mMetamodelObject->" . [kKey string] ![kKey location]]] ;
        if [kAttributeTypeName string] == "lstring" then
          @AC_galgasType t := [@typeGalgas_lstring new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "string" then
          @AC_galgasType t := [@typeGalgas_string new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lchar" then
          @AC_galgasType t := [@typeGalgas_lchar new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "char" then
          @AC_galgasType t := [@typeGalgas_char new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "luint" then
          @AC_galgasType t := [@typeGalgas_luint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "uint" then
          @AC_galgasType t := [@typeGalgas_uint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lsint" then
          @AC_galgasType t := [@typeGalgas_lsint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "sint" then
          @AC_galgasType t := [@typeGalgas_sint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lbool" then
          @AC_galgasType t := [@typeGalgas_lbool new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "bool" then
          @AC_galgasType t := [@typeGalgas_bool new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "location" then
          @AC_galgasType t := [@typeGalgas_location new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        else
          error here : "internal error (@" . [kAttributeTypeName string] . " type not handled" ;
        end if ;
      else
      end extract ;
    end foreach ;
#  #--- Enter constraint attribute properties of current constraint
#    foreach constrainedAttributePropertyToImplementList (@lstring kPropertyTypeName @lstring kPropertyName) :
#      @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"(* " . [kPropertyName string] . ")" !here]] ;
#      @AC_galgasType t := [@typeGalgas_mapEntityInInstruction new ![kPropertyName string] ![kPropertyTypeName string]] ;
#      [!?variablesMap insertUsedInOutArgument !kPropertyName !t !cppName] ;
#    end foreach ;
#  #--- Enter constraint parameter properties of current constraint
#    foreach constrainedParameterPropertyToImplementList (@lstring kPropertyTypeName @lstring kPropertyName) :
#      @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"(* " . [kPropertyName string] . ")" !here]] ;
#      @AC_galgasType t := [@typeGalgas_mapEntityInInstruction new ![kPropertyName string] ![kPropertyTypeName string]] ;
#      [!?variablesMap insertUsedInOutArgument !kPropertyName !t !cppName] ;
#    end foreach ;
#  #--- Enter indexes
#    foreach allIndexes (@lstring kIndexName @lstring kMapTypeName) :
#      @typeCplusPlusName cppName := [@typeDirectName new !kIndexName] ;
#      @AC_galgasType t := [@typeGalgas_mapIndexInInstruction new ![kMapTypeName string]] ;
#      if [currentIndexMap hasKey ![kIndexName string]] then
#        [!?variablesMap insertOutProperty !kIndexName !t !cppName] ;
#      else
#        [!?variablesMap insertUsedConstInArgument !kIndexName !t !cppName] ;
#      end if ;
#    end foreach ;
#--- Add "self" variable
  @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"_mMetamodelObject" !here]] ;
  @AC_galgasType t := [@typeGalgas_entityInInstruction new ![entityName string]] ;
  [!?variablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !t !cppName] ;
#--- Instructions
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap [emptyMap] ;
  @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @typeInstructionList instructionsList [emptyList] ;
  @stringset constraintPropertyDefinitionSet [emptySet] ;
  @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
  <semantic_instructions_list>
    !?componentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !optionsComponentsMapForUse
    !?variablesMap
    !?instructionsList
    !?allAvailablePropertyMap
    !?constraintPropertyDefinitionSet
    !?callInstructionSharedPropertySignatureMap
  ;
  $}$ ;
  [!?ioConstraintInstructionListMap insertKey
    !entityName
    !instructionsList
    !callInstructionSharedPropertySignatureMap
    !here
  ] ;
#    [!?constrainedEntityPassMap insertKey
#      !passName
#      !instructionsList 
#      !sharedPropertyList
#      !constraintPropertyDefinitionSet
#      !callInstructionSharedPropertySignatureMap
#    ] ;
##--- If the entity has no super entity, define the set of defined passes
#  if [superEntity string] == "" then
#    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
#      passesDefinedByInheritanceTreeRootEntity += ![kPassName string] ;
#    end foreach ;
#  end if ;
##--- If the entity has super entity, check that only passes defined by
##    inheritance tree root entity are defined
#  if [superEntity string] != "" then
#    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
#      if not [passesDefinedByInheritanceTreeRootEntity hasKey ![kPassName string]] then
#       error here: "pass '" . [kPassName string]
#       . "' cannot be defined because it is not defined by the constraint on '@"
#       . [superEntity string] . "' entity" ;
#      end if ;
#    end foreach ;
#  end if ;
#--- Enter in constraint entity map
  [!?ioConstrainedEntityMap insertKey
    !entityName
    !allMetamodelPropertyMap
    !false # Is not abstract
    !currentMetamodelPropertyMap
    !superEntity
    !currentConstraintPropertyMap
    !superClassSet
    !allConstraintPropertyMap
    !allAvailablePropertyMap
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path_for_constraint>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath emptyList] ;
  repeat
    select
      @lstring pathElement ;
      $identifier$ ? pathElement ;
      outPath += !pathElement ;
    or
      @lstring pathElement ;
      $type_name$ ? pathElement ;
      outPath += ![@lstring new !".". [pathElement string] ![pathElement location]] ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_term>
    !?ioRelationVariableMap
    !?ioIndexMap
    ?outExpression ;
  repeat
  while
    $|$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_term> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  repeat
  while
    $&$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  or
    $not$ ;
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    outExpression := [@metamodelRelationNot new !outExpression] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    $true$ ;
    outExpression := [@metamodelRelationTrue new] ;
  or
    $false$ ;
    outExpression := [@metamodelRelationFalse new] ;
  or
    $($ ;
    <constraint_relation_expression> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    $)$ ;
  or
    ${$ ;
    @lstring localVar ;
    $identifier$ ? localVar ;
    @luint variableIndex ;
    @lstring domainVariable ;
    [ioRelationVariableMap searchKeyAndGetIndex !localVar ?variableIndex ?domainVariable] ;
    $==$ ;
    @lstring indexVariableName ;
    $identifier$ ? indexVariableName ;
    @lstring domainVariableFromIndex ;
    [ioIndexMap searchKey !indexVariableName ?domainVariableFromIndex] ;
    if [domainVariable string] != [domainVariableFromIndex string] then
      error indexVariableName: "this index refers to the '" . [domainVariableFromIndex string]
      . "' domain, while '" . [localVar  string] . "' relation variable refers to the '"
      . [domainVariable string] . "' domain" ;
    end if ;
    $}$ ;
    outExpression := [@metamodelRelationPrimary new !ioRelationVariableMap !localVar !variableIndex !indexVariableName !domainVariable] ;
  or
   $do$ ;
    $($ ;
     @L_propertyPath path ;
     <property_path_for_constraint> ?path ;
    $[$ ;
    @metamodelRelationParameterList parameterList [emptyList] ;
    repeat
      @lstring parameter ;
      $identifier$ ? parameter ;
      @luint parameterIndex ;
      @lstring domainVariable ;
      [ioRelationVariableMap searchKeyAndGetIndex !parameter ?parameterIndex ?domainVariable] ;
      parameterList += !parameter !parameterIndex !domainVariable ;
    while
      $,$ ;
    end repeat ;
    $]$ ;
    $:$ ;
    @lbool operationIsAnd ;
    select
      $|$ ;
      operationIsAnd := [@lbool new !false !here] ;
    or
      $&$ ;
      operationIsAnd := [@lbool new !true !here] ;
    end select ;
    $)$ ;
    outExpression := [@metamodelRelationDo new !ioRelationVariableMap !parameterList !path !operationIsAnd] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

routine buildUsefullPropertyMap
 ??@entityPropertyMap inInputPropertyMap
 ??@stringset inUsefullClassSet
 !@entityPropertyMap outOutputPropertyMap
:
  outOutputPropertyMap := [@entityPropertyMap emptyMap] ;
  foreach inInputPropertyMap (@lstring kPropertyName @metamodelProperty kProperty) :
    extract kProperty:
    when @metamodelSingleReferenceProperty (@lstring kReferenceClassName)->
      if [inUsefullClassSet hasKey ![kReferenceClassName string]] then
        [!?outOutputPropertyMap insertKey !kPropertyName !kProperty] ;
      end if ;
    when @metamodelMultipleReferenceProperty (@lstring kReferenceClassName * *)->
      if [inUsefullClassSet hasKey ![kReferenceClassName string]] then
        [!?outOutputPropertyMap insertKey !kPropertyName !kProperty] ;
      end if ;
    else
      [!?outOutputPropertyMap insertKey !kPropertyName !kProperty] ;
    end extract ;
  end foreach ;
end routine ;

#-------------------------------------------------------------------*

rule <constraint_class_override_declarations>
  ?@lstring inRootClass
  ?@entityToImplementMap inOriginalMetamodelEntityMap 
  !@entityToImplementMap outMetamodelEntityMap
:
#--- Parse override class declarations
  @stringset overriddenClassSet [emptySet] ;
  repeat
    $override$ ;
    @lstring metamodelClass ;
    $mda_type_name$ ? metamodelClass ;
    [inOriginalMetamodelEntityMap searchKey !metamodelClass ?* ?* ?* ?* ?* ?* ?* ?*] ;
    if [overriddenClassSet hasKey ![metamodelClass string]] then
      error metamodelClass:"this class is already declared as overridden" ;
    else
      overriddenClassSet += ![metamodelClass string] ;
    end if ;
    $;$ ;
  while
  end repeat ;
#--- Check root class is declared as overridden
  if not [overriddenClassSet hasKey ![inRootClass string]] then
    error here:"the '%" . [inRootClass string] . "' root class should be declared as overridden" ;
  end if ;
#--- Build useful class set
  @stringset usefulClassSet [setWithString ![inRootClass string]] ;
  @bool continue := true ;
  loop [inOriginalMetamodelEntityMap count] + 1 :
  while continue do
    continue := false ;
    foreach overriddenClassSet (@string kClassName) :
      @entityPropertyMap allAvailablePropertyMap ;
      @lstring superEntityName ;
      [inOriginalMetamodelEntityMap searchKey
        ![@lstring new !kClassName !here]
        ?*
        ?*
        ?*
        ?superEntityName
        ?*
        ?*
        ?*
        ?allAvailablePropertyMap
      ] ;
    #--- If super class is usefull and class is overriden, class is usefull
      if [usefulClassSet hasKey ![superEntityName string]] & not [usefulClassSet hasKey !kClassName] then
        continue := true ;
        usefulClassSet += !kClassName ;
      end if ;
      if [usefulClassSet hasKey !kClassName] then
      #--- If a class is usefull, its super class is also usefull
        if ([superEntityName string] != "") & not [usefulClassSet hasKey ![superEntityName string]] then
          continue := true ;
          usefulClassSet += ![superEntityName string] ;
        end if ;
        foreach allAvailablePropertyMap (* @metamodelProperty kProperty) :
          extract kProperty:
          when @metamodelSingleReferenceProperty (@lstring kReferenceClassName)->
            if [overriddenClassSet hasKey ![kReferenceClassName string]] & not [usefulClassSet hasKey ![kReferenceClassName string]] then
              continue := true ;
              usefulClassSet += ![kReferenceClassName string] ;
            end if ;
          when @metamodelMultipleReferenceProperty (@lstring kReferenceClassName * *)->
            if [overriddenClassSet hasKey ![kReferenceClassName string]] & not [usefulClassSet hasKey ![kReferenceClassName string]] then
              continue := true ;
              usefulClassSet += ![kReferenceClassName string] ;
            end if ;
          else
          end extract ;
        end foreach ;
      end if ;
    end foreach ;
  end loop ;
#  log usefulClassSet ;
#--- Check for missing classes
  @stringset missingClasses := usefulClassSet - overriddenClassSet ;
  foreach missingClasses (@string kMissingClassName) :
    error here: "the '%" . kMissingClassName . "' class should be overriden" ;
  end foreach ;
#--- Warn for useless classes
  @stringset uselessClasses := overriddenClassSet - usefulClassSet ;
  foreach uselessClasses (@string kUselessClassName) :
    error here: "it is useless to override '%" . kUselessClassName . "' class" ;
  end foreach ;
#--- Build new metamodel class map : filter out useless properties
  outMetamodelEntityMap := [@entityToImplementMap emptyMap] ;
  foreach inOriginalMetamodelEntityMap (
    @lstring kClassName
    @entityPropertyMap kAllMetamodelPropertyMap
    @bool kIsAbstract
    @entityPropertyMap kCurrentMetamodelPropertyMap
    @lstring kSuperEntityName
    @entityPropertyMap kCurrentConstraintPropertyMap
    @stringset kSuperEntitySet
    @entityPropertyMap kAllConstraintPropertyMap
    @entityPropertyMap kAllAvailablePropertyMap
  ) :
    if [usefulClassSet hasKey ![kClassName string]] then
      @entityPropertyMap allMetamodelPropertyMap ;
      buildUsefullPropertyMap !kAllMetamodelPropertyMap !usefulClassSet ?allMetamodelPropertyMap ;
      @entityPropertyMap currentMetamodelPropertyMap ;
      buildUsefullPropertyMap !kCurrentMetamodelPropertyMap !usefulClassSet ?currentMetamodelPropertyMap ;
      @entityPropertyMap currentConstraintPropertyMap ;
      buildUsefullPropertyMap !kCurrentConstraintPropertyMap !usefulClassSet ?currentConstraintPropertyMap ;
      @entityPropertyMap allConstraintPropertyMap ;
      buildUsefullPropertyMap !kAllConstraintPropertyMap !usefulClassSet ?allConstraintPropertyMap ;
      @entityPropertyMap allAvailablePropertyMap ;
      buildUsefullPropertyMap !kAllAvailablePropertyMap !usefulClassSet ?allAvailablePropertyMap ;
      [!?outMetamodelEntityMap insertKey
        !kClassName
        !allMetamodelPropertyMap
        !kIsAbstract
        !currentMetamodelPropertyMap
        !kSuperEntityName
        !currentConstraintPropertyMap
        !kSuperEntitySet
        !allConstraintPropertyMap
        !allAvailablePropertyMap
      ] ;
    end if ;
  end foreach ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
