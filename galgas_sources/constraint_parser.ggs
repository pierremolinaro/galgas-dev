#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS constraint component parser definition                            *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax constraint_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <constraint_map_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@mapEntityMap ioMapEntityMap
label parse
;

rule <parse_constraint_document>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <property_path_for_constraint>
  !@L_propertyPath outPath
label parse
;

rule <constraints_on_entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@constrainedEntityMap ioConstrainedEntityMap
  ?!@passMap ioPassMap
label parse
;

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionsList
  ?@string inConstraintCurrentPassName
  ?!@entityPropertyMap ioPropertyMap
  ?!@mapAsConstraintPropertyMap ioMapAsConstraintPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

#-------------------------------------------------------------------*
#                   Constraint component                            *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_constraint_document> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @M_constraintComponents constraintComponentMap [empty] ;
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?constraintComponentMap
  ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_constraint_document> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_constraint_document>
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
#--- Constraint component header
  $constraint$ ;
  @lstring constraintName ;
  $identifier$ ? constraintName ;
#--- Pass declaration
  @passMap passMap [empty] ;
  select
  or
    $($ ;
    repeat
     @lstring passName ;
     $identifier$ ? passName ;
     [!?passMap insertKey !passName] ;
    while
     $,$ ;
    end repeat ;
    $)$ ;
  end select ;
  $:$ ;
#--- Imported Metamodel
  $import$ ;
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
  $in$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;  
  @M_semanticsComponents unusedSemanticsMapForUse [empty] ;
  @M_metamodelsComponents metamodelComponentMap [empty] ;
  <parse_semantics_component_for_importing>
    !fileName
    !?unusedSemanticsMapForUse
    !?metamodelComponentMap
    !?ioConstraintComponentMap
  ;
#--- Search imported metamodel
  @lstring rootEntity ;
  @M_semanticsEntitiesForUse semanticsEntitiesMap ;
  @entityToImplementMap entityMap ;
  @stringset multiReferencedEntities ;
  [!?metamodelComponentMap searchKey
    !metamodelName
    ?rootEntity
    ?semanticsEntitiesMap
    ?entityMap
    ?multiReferencedEntities
  ] ;
#--- Parse Map Declarations
  @mapEntityMap mapEntityMap [empty] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [empty] ;
  repeat
  while
    <constraint_map_declaration>
      !?entityMap
      !?mapEntityMap
    ;
  end repeat ;
#--- Parse constraint declarations
  @constrainedEntityMap constrainedEntityMap [empty] ;
  repeat
  while
    <constraints_on_entity_declaration>
      !?entityMap
      !?mapEntityMap
      !?constrainedEntityMap
      !?passMap
    ;
  end repeat ;
  $end$ ;
#--- Check a constraint on root entity is defined
  @bool constraintOnRootEntity := [constrainedEntityMap hasKey ![rootEntity value]] ;
  if not constraintOnRootEntity then
    error here:"no constraint is defined on metamodel root entity" ;
  end if ;
#--- Check constraint on root entity
  if constraintOnRootEntity then
    @constrainedEntityPassMap constrainedEntityPassMapForRootEntity ;
    @location endOfConstraintLocation ;
    [!?constrainedEntityMap searchKey
      !rootEntity
      ?*
      ?constrainedEntityPassMapForRootEntity
      ?*
      ?*
      ?*
      ?endOfConstraintLocation
      ?*
      ?*
    ] ;
  #--- Check root entity constraint defines all passes
    if [constrainedEntityPassMapForRootEntity count] != [passMap count] then
      error endOfConstraintLocation: "the root entity constraint should define all passes" ;
    end if ;
  #--- Check root entity constraint passes have no shared property
    foreach constrainedEntityPassMapForRootEntity (??@lstring kPassName ??* ??@sharedPropertyList kSharedPropertyList ...) :
      if [kSharedPropertyList length] != 0 then
        error kPassName:"a pass of the root entity constraint should not define any shared prperty" ;
      end if ;
    end foreach ;
  end if ;
#--- Check all constraints
  foreach constrainedEntityMap (??@lstring kEntityName ??* ??@constrainedEntityPassMap kConstrainedEntityPassMap ??* ??@entityPropertyMap kEntityPropertiesMap ...) :
    @stringset definedPassSet := [kConstrainedEntityPassMap allKeys] ;
    foreach kEntityPropertiesMap (??@lstring kPropertyName ??@metamodelPropertyKind kKind  ??@lstring kPropertyEntityName) :
      if kKind != [@metamodelPropertyKind attributeProperty] then
        @constrainedEntityPassMap referencePropertyConstrainedEntityPassMap ;
        [!?constrainedEntityMap searchKey !kPropertyEntityName ?* ?referencePropertyConstrainedEntityPassMap ?* ?* ?* ?* ?* ?*] ;
        foreach referencePropertyConstrainedEntityPassMap (??@lstring kReferencePropertyPassName ??* ??* ??* ??*) :
          if not [kConstrainedEntityPassMap hasKey ![kReferencePropertyPassName value]] then
            error kEntityName:"this constraint should define the '" . [kReferencePropertyPassName value]
            . "' pass (due to '" . [kPropertyName value] . "' reference)" ;
          end if ;
        end foreach ;
        @stringset referencePassSet := [referencePropertyConstrainedEntityPassMap allKeys] ;
#message "---------------\n" ;
#message [kPropertyName description] ;
#message [referencePassSet description] ;
        foreach kConstrainedEntityPassMap (??@lstring kPassName
                                           ??*
                                           ??*
                                           ??@stringset kDefinedAttributeSet
                                           ??@callInstructionSharedPropertySignatureMap kCallInstructionSharedPropertySignatureMap) :
        #--- Check if shared property is correctly initialized
          if [kDefinedAttributeSet hasKey ![kPropertyName value]] & not [referencePassSet hasKey ![kPassName value]] then
            error kPassName:"this pass should not define the '" . [kPropertyName value] . "' property" ;
          elsif (not [kDefinedAttributeSet hasKey ![kPropertyName value]]) & [referencePassSet hasKey ![kPassName value]] then
            error kPassName:"this pass should define the '" . [kPropertyName value] . "' property" ;
          end if ;
        #--- check if shared properties in call instructions are correctly passed as parameters
          if [kCallInstructionSharedPropertySignatureMap hasKey ![kPropertyName value]] then
            @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap := kCallInstructionSharedPropertySignatureMap ;
            @sharedPropertyList signature ;
            @location signatureLocation ;
            [!?callInstructionSharedPropertySignatureMap searchKey !kPropertyName ?signature ?signatureLocation] ;
            @sharedPropertyList sharedPropertyList ;
            [!?referencePropertyConstrainedEntityPassMap searchKey !kPassName ?* ?sharedPropertyList ?* ?*] ;
            if [sharedPropertyList length] == [signature length] then
              foreach sharedPropertyList (??@lstring kTypeName ??@lstring kParameterName),
                      signature (??@lstring kSignatureTypeName ??@lstring kSignatureParameterName) :
                if [kTypeName value] != [kSignatureTypeName value] then
                  error kSignatureParameterName:"the type of the parameter is '@" . [kSignatureTypeName value] . "', while a '@"
                  . [kTypeName value] . "' type is expected" ;
                end if ;
              end foreach ;
            else
              error signatureLocation:" this instruction names " . [[signature length] string]
              . " shared property(ies) as parameters, while the constraint definition requires "
              . [[sharedPropertyList length] string] ;
            end if ;
#message "1---------------\n" ;
#message [kPassName description] ;
#message "2---------------\n" ;
#message [signature description] ;
#message "3---------------\n" ;
#message [sharedPropertyList description] ;
          end if ;
        end foreach ;
      end if ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  action generate_constraints
      !?passMap
      !?entityMap
      !?mapEntityMap
      !metamodelName
      !constraintName
      !?constrainedEntityMap
      !multiReferencedEntities
      !rootEntity
  ;
  $constraint$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_map_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@mapEntityMap ioMapEntityMap
:
  $map$ ;
  @lstring mapIdentifier ;
  $type_name$ ? mapIdentifier ;
  if [ioEntityMap hasKey ![mapIdentifier value]] then
    error mapIdentifier: "An entity has been declared with this name" ;
  end if ;
  $of$ ;
  @lstring mapElementIdentifier ;
  $type_name$ ? mapElementIdentifier ;
  ${$ ;
  $insert$ ;
  $error$ ;
  $message$ ;
  @lstring insertErrorMessage ;
  $literal_string$ ? insertErrorMessage ;
  action check_KL_escapeCharacters !insertErrorMessage ;
  $;$ ;
  $search$ ;
  $error$ ;
  $message$ ;
  @lstring searchErrorMessage ;
  $literal_string$ ? searchErrorMessage ;
  action check_K_escapeCharacters !searchErrorMessage ;
  $;$ ;
  $}$ ;
  [!?ioMapEntityMap insertKey
    !mapIdentifier
    !mapElementIdentifier
    !insertErrorMessage
    !searchErrorMessage
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <constraints_on_entity_declaration>
  ?!@entityToImplementMap ioEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@constrainedEntityMap ioConstrainedEntityMap
  ?!@passMap ioPassMap
:
#--- Entity Name
  $on$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
#--- Get entity properties
  @lstring superEntity ;
  @entityPropertyMap allPropertyMap ;
  @entityPropertyMap propertyMap ;
  [!?ioEntityMap searchKey
    !entityName
    ?allPropertyMap
    ?*
    ?propertyMap
    ?superEntity
   ] ;
  @stringset descendantEntitySet [empty] ;
  computeDescendantSet !?ioEntityMap !entityName !?descendantEntitySet ;
#--- Get inherited properties from super class constraints
  @mapAsConstraintPropertyMap  allMapsAsConstraintPropertyMap [empty] ;
  @constrainedEntityPassMap inheritedConstrainedEntityPassMap [empty] ;
  @stringset passesDefinedByInheritanceTreeRootEntity [empty] ;
  if [superEntity value] != "" then
    if [ioConstrainedEntityMap hasKey ![superEntity value]] then
      [!?ioConstrainedEntityMap searchKey
        !superEntity
        ?passesDefinedByInheritanceTreeRootEntity
        ?inheritedConstrainedEntityPassMap
        ?*
        ?*
        ?*
        ?*
        ?*
        ?allMapsAsConstraintPropertyMap
      ] ;
    else
      error entityName:
        "constraints for super entity ('@" . [superEntity value] . "') should be previously defined" ;
    end if ;
  end if ;
#--- Passes
  @mapAsConstraintPropertyMap mapAsConstraintPropertyMap [empty] ;
  ${$ ;
  @constrainedEntityPassMap constrainedEntityPassMap [empty] ;
  @uint currentIndex := 0 ;
  repeat
  while
    @lstring passName ;
    $identifier$ ? passName ;
    @luint index ;
    [!?ioPassMap searchKeyAndGetIndex !passName ?index] ;
    if [index value] < currentIndex then
      error passName:"the pass order is incorrect" ;
    end if ;
    currentIndex := [index value] ;
    @sharedPropertyList sharedPropertyList [empty] ;
  #--- Properties from owner
    select
      if [superEntity value] != "" then
        [!?inheritedConstrainedEntityPassMap searchKey !passName ?* ?sharedPropertyList ?* ?*] ;
      end if ;
    or
      $($ ;
      if [superEntity value] != "" then
        error here: "as the '@" . [entityName value]
        . "' entity has a super entity, you cannot define any shared property" ;
      end if ;
      repeat
        @lstring typeName ;
        $type_name$ ? typeName ;
        @lstring propertyName ;
        $identifier$ ? propertyName ;
        if [ioMapEntityMap hasKey ![typeName value]] then 
          @lstring elementTypeName ;
          [!?ioMapEntityMap searchKey !typeName ?elementTypeName ?* ?*] ;
          [!?mapAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentIndex ![passName value] !true] ;
          [!?allMapsAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentIndex ![passName value] !true] ;
          sharedPropertyList += !typeName !propertyName ;
        else
          error typeName:"unhandled type name" ;
        end if ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
  #--- Properties
    ${$ ;
    repeat
    while
      @lstring typeName ;
      $type_name$ ? typeName ;
      @lstring propertyName ;
      $identifier$ ? propertyName ;
      if [ioMapEntityMap hasKey ![typeName value]] then 
        @lstring elementTypeName ;
        [!?ioMapEntityMap searchKey !typeName ?elementTypeName ?* ?*] ;
        [!?mapAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentIndex ![passName value] !false] ;
        [!?allMapsAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentIndex ![passName value] !false] ;
      else
        error typeName:"unhandled type name" ;
      end if ;
      $;$ ;
    end repeat ;
    $}$ ;
  #--- Instructions
    ${$ ;
    @M_semanticsEntitiesForUse componentSemanticsEntitiesMap [empty] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [empty] ;
    @M_optionComponents optionsComponentsMapForUse [empty] ;
    @typeVariablesMap variablesMap [empty] ;
    @typeInstructionList instructionsList [empty] ;
    @stringset constraintPropertyDefinitionSet [empty] ;
    @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [empty] ;
    <semantic_instructions_list>
      !?componentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?optionsComponentsMapForUse
      !?variablesMap
      !?instructionsList
      ![passName value]
      !?propertyMap
      !?mapAsConstraintPropertyMap
      !?constraintPropertyDefinitionSet
      !?callInstructionSharedPropertySignatureMap
    ;
    $}$ ;
    [!?constrainedEntityPassMap insertKey
      !passName
      !instructionsList 
      !sharedPropertyList
      !constraintPropertyDefinitionSet
      !callInstructionSharedPropertySignatureMap
    ] ;
  end repeat ;
  $}$ ;
#--- If the entity has no super entity, define the set of defined passes
  if [superEntity value] == "" then
    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
      passesDefinedByInheritanceTreeRootEntity += ![kPassName value] ;
    end foreach ;
  end if ;
#--- If the entity has super entity, check that only passes defined by
#    inheritance tree root entity are defined
  if [superEntity value] != "" then
    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
      if not [passesDefinedByInheritanceTreeRootEntity hasKey ![kPassName value]] then
       error here: "pass '" . [kPassName value]
       . "' cannot be defined because it is not defined by the constraint on '@"
       . [superEntity value] . "' entity" ;
      end if ;
    end foreach ;
  end if ;
#--- Enter constraint in constraint map 
  [!?ioConstrainedEntityMap insertKey
    !entityName
    !passesDefinedByInheritanceTreeRootEntity
    !constrainedEntityPassMap
    !superEntity
    !propertyMap
    !descendantEntitySet
    !here
    !mapAsConstraintPropertyMap
    !allMapsAsConstraintPropertyMap
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path_for_constraint>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath empty] ;
  repeat
    select
      @lstring pathElement ;
      $identifier$ ? pathElement ;
      outPath += !pathElement ;
    or
      @lstring pathElement ;
      $type_name$ ? pathElement ;
      outPath += ![@lstring new !".". [pathElement value] ![pathElement location]] ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_term> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  repeat
  while
    $|$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_term> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  repeat
  while
    $&$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  or
    $not$ ;
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    outExpression := [@metamodelRelationNot new !outExpression] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    $true$ ;
    outExpression := [@metamodelRelationTrue new] ;
  or
    $false$ ;
    outExpression := [@metamodelRelationFalse new] ;
  or
    $($ ;
    <constraint_relation_expression> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    $)$ ;
  or
    ${$ ;
    @lstring localVar ;
    $identifier$ ? localVar ;
    @luint variableIndex ;
    @lstring domainVariable ;
    [!?ioRelationVariableMap searchKeyAndGetIndex !localVar ?variableIndex ?domainVariable] ;
    $==$ ;
    @lstring indexVariableName ;
    $identifier$ ? indexVariableName ;
    @lstring domainVariableFromIndex ;
    [!?ioIndexMap searchKey !indexVariableName ?domainVariableFromIndex] ;
    if [domainVariable value] != [domainVariableFromIndex value] then
      error indexVariableName: "this index refers to the '" . [domainVariableFromIndex value]
      . "' domain, while '" . [localVar  value] . "' relation variable refers to the '"
      . [domainVariable value] . "' domain" ;
    end if ;
    $}$ ;
    outExpression := [@metamodelRelationPrimary new !ioRelationVariableMap !localVar !variableIndex !indexVariableName !domainVariable] ;
  or
   $do$ ;
    $($ ;
     @L_propertyPath path ;
     <property_path_for_constraint> ?path ;
    $[$ ;
    @metamodelRelationParameterList parameterList [empty] ;
    repeat
      @lstring parameter ;
      $identifier$ ? parameter ;
      @luint parameterIndex ;
      @lstring domainVariable ;
      [!?ioRelationVariableMap searchKeyAndGetIndex !parameter ?parameterIndex ?domainVariable] ;
      parameterList += !parameter !parameterIndex !domainVariable ;
    while
      $,$ ;
    end repeat ;
    $]$ ;
    $:$ ;
    @lbool operationIsAnd ;
    select
      $|$ ;
      operationIsAnd := [@lbool new !false !here] ;
    or
      $&$ ;
      operationIsAnd := [@lbool new !true !here] ;
    end select ;
    $)$ ;
    outExpression := [@metamodelRelationDo new !ioRelationVariableMap !parameterList !path !operationIsAnd] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
