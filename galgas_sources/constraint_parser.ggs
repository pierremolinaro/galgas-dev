#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS constraint component parser definition                            *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax constraint_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <constraint_map_declaration>
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
label parse
;

rule <parse_constraint_document>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <property_path_for_constraint>
  !@L_propertyPath outPath
label parse
;

rule <constraints_on_entity_declaration>
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstrainedEntityMap
  ?!@constraintInstructionListMap ioConstraintInstructionListMap
label parse
;

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionsList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

#-------------------------------------------------------------------*
#                   Constraint component                            *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_constraint_document> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @M_constraintComponents constraintComponentMap [emptyMap] ;
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?constraintComponentMap
  ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_constraint_document> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_constraint_document>
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
#--- Constraint component header
  $constraint$ ;
  @lstring constraintName ;
  $identifier$ ? constraintName ;
  $:$ ;
#--- Imported Metamodel
  $import$ ;
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
  $in$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;  
  @M_semanticsComponents unusedSemanticsMapForUse [emptyMap] ;
  @M_metamodelsComponents metamodelComponentMap [emptyMap] ;
  <parse_semantics_component_for_importing>
    !fileName
    !?unusedSemanticsMapForUse
    !?metamodelComponentMap
    !?ioConstraintComponentMap
  ;
#--- Search imported metamodel
  @lstring rootEntity ;
  @entityToImplementMap metamodelEntityMap ;
  [metamodelComponentMap searchKey
    !metamodelName
    ?rootEntity
    ?metamodelEntityMap
    ?*
  ] ;
#--- Parse Declarations
  @mapEntityMap mapEntityMap [emptyMap] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [emptyMap] ;
  @entityToImplementMap constrainedEntityMap [emptyMap] ;
  @constraintInstructionListMap constraintInstructionListMap [emptyMap] ;
  repeat
  while
    <constraint_map_declaration>
      !metamodelEntityMap
      !?mapEntityMap
    ;
  while
    <constraints_on_entity_declaration>
      !metamodelEntityMap
      !?mapEntityMap
      !?constrainedEntityMap
      !?constraintInstructionListMap
    ;
  end repeat ;
  $end$ ;
#--- Root entity is defined ?
  if not [constrainedEntityMap hasKey ![rootEntity string]] then
    error here:"the @" . [rootEntity string] . " root entity should be defined" ;
  end if ;
#--- Build representative entity map
  @representativeEntityMap representativeEntityMap [emptyMap] ;
  foreach metamodelEntityMap (@lstring kEntityName * * * * * @stringset kSuperEntitySet ...) :
    @lstring representativeTypeName ;
    computeRepresentativeEntityName
      !metamodelEntityMap
      !constrainedEntityMap
      !kEntityName
      ?representativeTypeName
    ;
    [!?representativeEntityMap insertKey !kEntityName !representativeTypeName !kSuperEntitySet] ;
  end foreach ;
#--- Redefine the super classes not redefined by user
##--- Build actual constraint entity map
#  @entityToImplementMap actualConstrainedEntityMap [emptyMap] ;
  @stringset multiReferencedEntities [emptySet] ;
  foreach constrainedEntityMap (
    @lstring kEntityName
    @entityPropertyMap kAllMetamodelPropertyMap
    @bool kIsAbstract
    @entityPropertyMap kCurrentMetamodelPropertyMap
    @lstring kSuperEntityName
    @entityPropertyMap kCurrentContraintsPropertyMap
    @stringset kSuperClassSet
    @entityPropertyMap kAllContraintsPropertyMap
    @bool kIsImplicitlyDefined
    @entityPropertyMap kAllAvailablePropertyMap
  ) :
#  #--- Check constrained parameters of super entity (should be the same)
#    if [kSuperEntityName string] != "" then
#      @bool superEntityIsImplicitlyDefined ;
#      @constrainedPropertyList superEntityConstrainedParameterPropertyToImplementList ;
#      [constrainedEntityMap searchKey
#        !kSuperEntityName
#        ?*
#        ?*
#        ?*
#        ?*
#        ?*
#        ?superEntityIsImplicitlyDefined
#        ?*
#        ?superEntityConstrainedParameterPropertyToImplementList
#        ?*
#        ?*
#      ] ;
#      @bool identical := [kConstrainedParameterPropertyToImplementList length] == [superEntityConstrainedParameterPropertyToImplementList length] ;
#      foreach kConstrainedParameterPropertyToImplementList (@lstring kPropertyType1 @lstring kPropertyName1),
#              superEntityConstrainedParameterPropertyToImplementList (@lstring kPropertyType2 @lstring kPropertyName2)
#      while identical :
#         identical := ([kPropertyType1 string] == [kPropertyType2 string]) & ([kPropertyName1 string] == [kPropertyName2 string]) ;
#      end foreach ;
#      if not identical then
#        @string m := "parameter error: the '@" . [kEntityName string] . "' entity" ;
#        if kIsImplicitlyDefined then
#          m := m . " (implicitly defined)" ;
#        end if ;
#        m := m . " should have the same parameters as '@" . [kSuperEntityName string] . "' entity" ;
#        if superEntityIsImplicitlyDefined then
#          m := m . " (implicitly defined)" ;
#        end if ;
#        error here: m ;
#      end if ;
#    end if ;
#  #---
#   @entityPropertyMap newAllPropertiesMap [emptyMap] ;
    foreach kAllMetamodelPropertyMap (@lstring kKey @metamodelProperty kProperty) :
      extract kProperty :
#      when @metamodelSingleReferenceProperty (@lstring kTypeName) :
#        @lstring representativeTypeName ;
#        computeRepresentativeEntityName
#          !metamodelEntityMap
#          !constrainedEntityMap
#          !kTypeName
#          ?representativeTypeName
#        ;
#        if [representativeTypeName string] != "" then
#          multiReferencedEntities += ![representativeTypeName string] ;
#        end if ;
      when @metamodelMultipleReferenceProperty (@lstring kTypeName * *) ->
        @lstring representativeTypeName ;
        computeRepresentativeEntityName
          !metamodelEntityMap
          !constrainedEntityMap
          !kTypeName
          ?representativeTypeName
        ;
        if [representativeTypeName string] != "" then
          multiReferencedEntities += ![representativeTypeName string] ;
        end if ;
      else
      end extract ;
    end foreach ;
#    @entityPropertyMap newPropertiesMap [emptyMap] ;
#    foreach kEntityPropertiesMap (@lstring kKey @metamodelPropertyKind kKind @lstring kTypeName) :
#      switch kKind 
#      when attributeProperty, entityMapProperty :
#        [!?newPropertiesMap insertKey !kKey !kKind !kTypeName] ;
#      when singleReferenceProperty, multipleReferenceProperty :
#        @lstring representativeTypeName ;
#        computeRepresentativeEntityName
#          !metamodelEntityMap
#          !constrainedEntityMap
#          !kTypeName
#          ?representativeTypeName
#        ;
#        if [representativeTypeName string] != "" then
#          [!?newPropertiesMap insertKey !kKey !kKind !representativeTypeName] ;
#          multiReferencedEntities += ![representativeTypeName string] ;
#        end if ;
#      end switch ;
#    end foreach ;
#    [!?actualConstrainedEntityMap insertKey
#      !kEntityName
#      !newAllPropertiesMap
#      !kIsAbstract
#      !newPropertiesMap
#      !kSuperEntityName
#      !kSuperClassSet
#      !kIsImplicitlyDefined
#      !kConstrainedAttributePropertyToImplementList
#      !kConstrainedParameterPropertyToImplementList
#      !kAllIndexMap
#      !kCurrentIndexMap
#    ] ;
  end foreach ;
##--- Check call instructions
#  foreach actualConstrainedEntityMap (
#    @lstring kEntityName
#    *
#    *
#    @entityPropertyMap kEntityPropertiesMap
#    *
#    *
#    *
#    *
#    @constrainedPropertyList kConstrainedParameterPropertyToImplementList
#    *
#    *
#  ) :
#  #--- loop throught properties
#    foreach kEntityPropertiesMap (@lstring kPropertyName @metamodelPropertyKind kKind @lstring kTypeName) :
#      @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
#      if [constraintInstructionListMap hasKey ![kEntityName string]] then
#        [constraintInstructionListMap searchKey !kEntityName ?* ?callInstructionSharedPropertySignatureMap] ;
#      end if ;
#      switch kKind
#      when entityMapProperty :
#      when attributeProperty:
#        if [callInstructionSharedPropertySignatureMap hasKey ![kPropertyName string]] then
#          @location instructionLocation ;
#          [callInstructionSharedPropertySignatureMap searchKey !kPropertyName ?* ?instructionLocation] ;
#          error instructionLocation: "an attribute cannot be named here in a call instruction" ;
#        end if ;
#      when singleReferenceProperty, multipleReferenceProperty:
#        if [actualConstrainedEntityMap hasKey ![kTypeName string]] then
#          if [callInstructionSharedPropertySignatureMap hasKey ![kPropertyName string]] then
##            warning kEntityName:"checking 'call " . [kPropertyName string] . "' instruction..." ;
##            @L_lstringList effectiveArgumentList ;
##            @location signatureLocation ;
##            [callInstructionSharedPropertySignatureMap searchKey !kPropertyName ?effectiveArgumentList ?signatureLocation] ;
##            foreach effectiveArgumentList (??@lstring kInstructionParameterName) :
##              @metamodelPropertyKind property ;
##              [newAllPropertiesMap searchKey !kInstructionParameterName ?propertyKind ?*] ;
##            end foreach ;
#          else
#            error kEntityName:"the instruction list should have a 'call " . [kPropertyName string] . "' instruction" ;
#          end if ;
#        elsif [callInstructionSharedPropertySignatureMap hasKey ![kPropertyName string]] then
#          error kEntityName:"the instruction list should not have a 'call " . [kPropertyName string] . "' instruction" ;
#        end if ;
#      end switch ;
#    end foreach ;
#  end foreach ;
#--- Generate C++ code
  action generate_constraints
    !metamodelEntityMap
    !mapEntityMap
    !metamodelName
    !constraintName
    !constrainedEntityMap
#    !actualConstrainedEntityMap
    !multiReferencedEntities
    !rootEntity
    !representativeEntityMap
    !constraintInstructionListMap
  ;
  $constraint$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_map_declaration>
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
:
  $map$ ;
  @lstring mapIdentifier ;
  $mda_type_name$ ? mapIdentifier ;
  if [inMetamodelEntityMap hasKey ![mapIdentifier string]] then
    error mapIdentifier: "An entity has been declared with this name" ;
  end if ;
  $of$ ;
  @lstring mapElementIdentifier ;
  $mda_type_name$ ? mapElementIdentifier ;
  ${$ ;
  $insert$ ;
  $error$ ;
  $message$ ;
  @lstring insertErrorMessage ;
  $literal_string$ ? insertErrorMessage ;
  action check_KL_escapeCharacters !insertErrorMessage ;
  $;$ ;
  $search$ ;
  $error$ ;
  $message$ ;
  @lstring searchErrorMessage ;
  $literal_string$ ? searchErrorMessage ;
  action check_K_escapeCharacters !searchErrorMessage ;
  $;$ ;
  $}$ ;
  [!?ioMapEntityMap insertKey
    !mapIdentifier
    !mapElementIdentifier
    !insertErrorMessage
    !searchErrorMessage
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <constraints_on_entity_declaration>
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstrainedEntityMap
  ?!@constraintInstructionListMap unused ioConstraintInstructionListMap
:
#--- Entity Name
  $on$ ;
  @lstring entityName ;
  $mda_type_name$ ? entityName ;
#--- Get entity properties
  @lstring superEntity ;
  @entityPropertyMap allMetamodelPropertyMap ;
  @stringset superClassSet ;
  @entityPropertyMap currentMetamodelPropertyMap ;
  @entityPropertyMap allConstraintPropertyMap ;
  @entityPropertyMap allAvailablePropertyMap ;
  [inEntityMap searchKey
    !entityName
    ?allMetamodelPropertyMap
    ?* # Abstract
    ?currentMetamodelPropertyMap
    ?superEntity
    ?* # currentConstraintPropertyMap
    ?superClassSet
    ?allConstraintPropertyMap
    ?* # Implicitly defined ?
    ?allAvailablePropertyMap
   ] ;
#--- Get inherited properties from super class constraints
#  @constrainedPropertyList constrainedParameterPropertyToImplementList [emptyList] ;
#  @indexMap allIndexes [emptyMap] ;
  if [superEntity string] == "" then

  elsif [ioConstrainedEntityMap hasKey ![superEntity string]] then
    [ioConstrainedEntityMap searchKey
      !superEntity
      ?allMetamodelPropertyMap
      ?* # Abstract
      ?currentMetamodelPropertyMap
      ?* # Super entity
      ?* #currentConstraintPropertyMap
      ?* # Super Class set
      ?allConstraintPropertyMap
      ?* # Implicitly defined ?
      ?allAvailablePropertyMap
    ] ;
  else
    error entityName:
        "constraints for super entity ('@" . [superEntity string] . "') should be previously defined" ;
  end if ;
  @entityPropertyMap currentConstraintPropertyMap [emptyMap] ;
#--- Properties as parameters
    select
    or
      $($ ;
      if [superEntity string] != "" then
        error here: "as the '@" . [entityName string]
        . "' entity has a super entity, you cannot define any shared property" ;
      end if ;
      repeat
        @lstring typeName ;
        $mda_type_name$ ? typeName ;
        [ioMapEntityMap searchKey !typeName ?* ?* ?*] ;
        @metamodelProperty property := [@metamodelSharedMapProperty new !typeName] ;
        @lstring propertyName ;
        $identifier$ ? propertyName ;
        [!?currentConstraintPropertyMap insertKey !propertyName !property] ;
        [!?allConstraintPropertyMap insertKey !propertyName !property] ;
        [!?allAvailablePropertyMap insertKey !propertyName !property] ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
  #--- Properties as attributes
    @indexMap currentIndexMap [emptyMap] ;
    ${$ ;
    repeat
    while
      @lstring typeName ;
      $mda_type_name$ ? typeName ;
      [ioMapEntityMap searchKey !typeName ?* ?* ?*] ;
      @metamodelProperty property := [@metamodelMapProperty new !typeName] ;
      @lstring propertyName ;
      $identifier$ ? propertyName ;
      [!?currentConstraintPropertyMap insertKey !propertyName !property] ;
      [!?allConstraintPropertyMap insertKey !propertyName !property] ;
      [!?allAvailablePropertyMap insertKey !propertyName !property] ;
      $;$ ;
#    while
#      $mapindex$ ;
#      @lstring mapIndexName ;
#      $identifier$ ? mapIndexName ;
##      [!?constraintAllPropertiesMap insertKey ! mapIndexName] ;
#      $on$ ;
#      @lstring mapAttributeName ;
#      $identifier$ ? mapAttributeName ;
##      [allMapsAsConstraintPropertyMap searchKey !mapPropertyName ?* ?* ?* ?* ?*] ;
#      [!?currentIndexMap insertKey !mapIndexName !mapAttributeName] ;
#      [!?allIndexes insertKey !mapIndexName !mapAttributeName] ;
#      $;$ ;
    end repeat ;
    $}$ ;
    ${$ ;
  #--- Enter attributes metamodels as constants
    @typeVariablesMap variablesMap [emptyMap] ;
    foreach allAvailablePropertyMap (@lstring kKey @metamodelProperty kProperty) :
      extract kProperty :
      when @metamodelAttributeProperty (@lstring kAttributeTypeName) ->
        # message "attribute '" . [kKey value] . "' has type '@" . [kAttributeTypeName value] . "'\n" ;
        @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"_mMetamodelObject->" . [kKey string] ![kKey location]]] ;
        if [kAttributeTypeName string] == "lstring" then
          @AC_galgasType t := [@typeGalgas_lstring new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "string" then
          @AC_galgasType t := [@typeGalgas_string new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lchar" then
          @AC_galgasType t := [@typeGalgas_lchar new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "char" then
          @AC_galgasType t := [@typeGalgas_char new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "luint" then
          @AC_galgasType t := [@typeGalgas_luint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "uint" then
          @AC_galgasType t := [@typeGalgas_uint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lsint" then
          @AC_galgasType t := [@typeGalgas_lsint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "sint" then
          @AC_galgasType t := [@typeGalgas_sint new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "lbool" then
          @AC_galgasType t := [@typeGalgas_lbool new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "bool" then
          @AC_galgasType t := [@typeGalgas_bool new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        elsif [kAttributeTypeName string] == "location" then
          @AC_galgasType t := [@typeGalgas_location new] ;
          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
        else
          error here : "internal error (@" . [kAttributeTypeName string] . " type not handled" ;
        end if ;
      else
      end extract ;
    end foreach ;
#  #--- Enter constraint attribute properties of current constraint
#    foreach constrainedAttributePropertyToImplementList (@lstring kPropertyTypeName @lstring kPropertyName) :
#      @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"(* " . [kPropertyName string] . ")" !here]] ;
#      @AC_galgasType t := [@typeGalgas_mapEntityInInstruction new ![kPropertyName string] ![kPropertyTypeName string]] ;
#      [!?variablesMap insertUsedInOutArgument !kPropertyName !t !cppName] ;
#    end foreach ;
#  #--- Enter constraint parameter properties of current constraint
#    foreach constrainedParameterPropertyToImplementList (@lstring kPropertyTypeName @lstring kPropertyName) :
#      @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"(* " . [kPropertyName string] . ")" !here]] ;
#      @AC_galgasType t := [@typeGalgas_mapEntityInInstruction new ![kPropertyName string] ![kPropertyTypeName string]] ;
#      [!?variablesMap insertUsedInOutArgument !kPropertyName !t !cppName] ;
#    end foreach ;
#  #--- Enter indexes
#    foreach allIndexes (@lstring kIndexName @lstring kMapTypeName) :
#      @typeCplusPlusName cppName := [@typeDirectName new !kIndexName] ;
#      @AC_galgasType t := [@typeGalgas_mapIndexInInstruction new ![kMapTypeName string]] ;
#      if [currentIndexMap hasKey ![kIndexName string]] then
#        [!?variablesMap insertOutProperty !kIndexName !t !cppName] ;
#      else
#        [!?variablesMap insertUsedConstInArgument !kIndexName !t !cppName] ;
#      end if ;
#    end foreach ;
#--- Add "self" variable
  @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"_mMetamodelObject" !here]] ;
  @AC_galgasType t := [@typeGalgas_entityInInstruction new ![entityName string]] ;
  [!?variablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !t !cppName] ;
#--- Instructions
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap [emptyMap] ;
  @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @typeInstructionList instructionsList [emptyList] ;
  @stringset constraintPropertyDefinitionSet [emptySet] ;
  @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
  <semantic_instructions_list>
    !?componentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !?optionsComponentsMapForUse
    !?variablesMap
    !?instructionsList
    !?allAvailablePropertyMap
    !?constraintPropertyDefinitionSet
    !?callInstructionSharedPropertySignatureMap
  ;
#  [!?ioConstraintInstructionListMap insertKey
#    !entityName
#    !instructionsList
#    !callInstructionSharedPropertySignatureMap
#  ] ;
  $}$ ;
#    [!?constrainedEntityPassMap insertKey
#      !passName
#      !instructionsList 
#      !sharedPropertyList
#      !constraintPropertyDefinitionSet
#      !callInstructionSharedPropertySignatureMap
#    ] ;
##--- If the entity has no super entity, define the set of defined passes
#  if [superEntity string] == "" then
#    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
#      passesDefinedByInheritanceTreeRootEntity += ![kPassName string] ;
#    end foreach ;
#  end if ;
##--- If the entity has super entity, check that only passes defined by
##    inheritance tree root entity are defined
#  if [superEntity string] != "" then
#    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
#      if not [passesDefinedByInheritanceTreeRootEntity hasKey ![kPassName string]] then
#       error here: "pass '" . [kPassName string]
#       . "' cannot be defined because it is not defined by the constraint on '@"
#       . [superEntity string] . "' entity" ;
#      end if ;
#    end foreach ;
#  end if ;
#--- Enter in constraint entity map
  [!?ioConstrainedEntityMap insertKey
    !entityName
    !allMetamodelPropertyMap
    !false # Is not abstract
    !currentMetamodelPropertyMap
    !superEntity
    !currentConstraintPropertyMap
    !superClassSet
    !allConstraintPropertyMap
    !false # Is not implicitly defined
    !allAvailablePropertyMap
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path_for_constraint>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath emptyList] ;
  repeat
    select
      @lstring pathElement ;
      $identifier$ ? pathElement ;
      outPath += !pathElement ;
    or
      @lstring pathElement ;
      $type_name$ ? pathElement ;
      outPath += ![@lstring new !".". [pathElement string] ![pathElement location]] ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_term>
    !?ioRelationVariableMap
    !?ioIndexMap
    ?outExpression ;
  repeat
  while
    $|$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_term> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  repeat
  while
    $&$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  or
    $not$ ;
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    outExpression := [@metamodelRelationNot new !outExpression] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    $true$ ;
    outExpression := [@metamodelRelationTrue new] ;
  or
    $false$ ;
    outExpression := [@metamodelRelationFalse new] ;
  or
    $($ ;
    <constraint_relation_expression> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    $)$ ;
  or
    ${$ ;
    @lstring localVar ;
    $identifier$ ? localVar ;
    @luint variableIndex ;
    @lstring domainVariable ;
    [ioRelationVariableMap searchKeyAndGetIndex !localVar ?variableIndex ?domainVariable] ;
    $==$ ;
    @lstring indexVariableName ;
    $identifier$ ? indexVariableName ;
    @lstring domainVariableFromIndex ;
    [ioIndexMap searchKey !indexVariableName ?domainVariableFromIndex] ;
    if [domainVariable string] != [domainVariableFromIndex string] then
      error indexVariableName: "this index refers to the '" . [domainVariableFromIndex string]
      . "' domain, while '" . [localVar  string] . "' relation variable refers to the '"
      . [domainVariable string] . "' domain" ;
    end if ;
    $}$ ;
    outExpression := [@metamodelRelationPrimary new !ioRelationVariableMap !localVar !variableIndex !indexVariableName !domainVariable] ;
  or
   $do$ ;
    $($ ;
     @L_propertyPath path ;
     <property_path_for_constraint> ?path ;
    $[$ ;
    @metamodelRelationParameterList parameterList [emptyList] ;
    repeat
      @lstring parameter ;
      $identifier$ ? parameter ;
      @luint parameterIndex ;
      @lstring domainVariable ;
      [ioRelationVariableMap searchKeyAndGetIndex !parameter ?parameterIndex ?domainVariable] ;
      parameterList += !parameter !parameterIndex !domainVariable ;
    while
      $,$ ;
    end repeat ;
    $]$ ;
    $:$ ;
    @lbool operationIsAnd ;
    select
      $|$ ;
      operationIsAnd := [@lbool new !false !here] ;
    or
      $&$ ;
      operationIsAnd := [@lbool new !true !here] ;
    end select ;
    $)$ ;
    outExpression := [@metamodelRelationDo new !ioRelationVariableMap !parameterList !path !operationIsAnd] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
