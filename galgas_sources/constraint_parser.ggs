#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS constraint component parser definition                            *
#                                                                           *
#  Copyright (C) 2006 Pierre Molinaro.                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax constraint_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <constraint_map_declaration>
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
label parse
;

rule <parse_constraint_document>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <property_path_for_constraint>
  !@L_propertyPath outPath
label parse
;

rule <constraints_on_entity_declaration>
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap ioMapEntityMap
  ?!@entityToImplementMap ioConstainedEntityMap
label parse
;

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
label parse 
;

rule <semantic_instructions_list>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionsList
  ?!@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
  ?!@callInstructionSharedPropertySignatureMap ioCallInstructionSharedPropertySignatureMap
label parse
;

#-------------------------------------------------------------------*
#                   Constraint component                            *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_constraint_document> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @M_constraintComponents constraintComponentMap [emptyMap] ;
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?constraintComponentMap
  ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_constraint_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
  ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_constraint_document> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_constraint_document>
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
#--- Constraint component header
  $constraint$ ;
  @lstring constraintName ;
  $identifier$ ? constraintName ;
  $:$ ;
#--- Imported Metamodel
  $import$ ;
  $metamodel$ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
  $in$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;  
  @M_semanticsComponents unusedSemanticsMapForUse [emptyMap] ;
  @M_metamodelsComponents metamodelComponentMap [emptyMap] ;
  <parse_semantics_component_for_importing>
    !fileName
    !?unusedSemanticsMapForUse
    !?metamodelComponentMap
    !?ioConstraintComponentMap
  ;
#--- Search imported metamodel
  @lstring rootEntity ;
  @M_semanticsEntitiesForUse semanticsEntitiesMap ;
  @entityToImplementMap metamodelEntityMap ;
  [metamodelComponentMap searchKey
    !metamodelName
    ?rootEntity
    ?semanticsEntitiesMap
    ?metamodelEntityMap
    ?*
  ] ;
#--- Parse Declarations
  @mapEntityMap mapEntityMap [emptyMap] ;
  @mapAndEntityUniqueMap mapAndEntityUniqueMap [emptyMap] ;
  @entityToImplementMap constrainedEntityMap [emptyMap] ;
  repeat
  while
    <constraint_map_declaration>
      !metamodelEntityMap
      !?mapEntityMap
    ;
  while
    <constraints_on_entity_declaration>
      !metamodelEntityMap
      !?mapEntityMap
      !?constrainedEntityMap
    ;
  end repeat ;
  $end$ ;
##--- Check a constraint on root entity is defined
#  @bool constraintOnRootEntity := [constrainedEntityMap hasKey ![rootEntity string]] ;
#  if not constraintOnRootEntity then
#    error here:"no constraint is defined on metamodel root entity" ;
#  end if ;
##--- Check constraint on root entity
#  if constraintOnRootEntity then
#    @constrainedEntityPassMap constrainedEntityPassMapForRootEntity ;
#    @location endOfConstraintLocation ;
#    [constrainedEntityMap searchKey
#      !rootEntity
#      ?*
#      ?constrainedEntityPassMapForRootEntity
#      ?*
#      ?*
#      ?*
#      ?endOfConstraintLocation
#      ?*
#      ?*
#      ?*
#      ?*
#      ?*
#    ] ;
#  #--- Check root entity constraint passes have no shared property
#    foreach constrainedEntityPassMapForRootEntity (??@lstring kPassName ??* ??@sharedPropertyList kSharedPropertyList ...) :
#      if [kSharedPropertyList length] != 0 then
#        error kPassName:"a pass of the root entity constraint should not define any shared prperty" ;
#      end if ;
#    end foreach ;
#  end if ;
##--- Check all constraints
#  foreach constrainedEntityMap (??@lstring kEntityName ??* ??@constrainedEntityPassMap kConstrainedEntityPassMap ??* ??@entityPropertyMap kEntityPropertiesMap ...) :
#    @stringset definedPassSet := [kConstrainedEntityPassMap allKeys] ;
#    foreach kEntityPropertiesMap (??@lstring kPropertyName ??@metamodelPropertyKind kKind  ??@lstring kPropertyEntityName) :
#      if kKind != [@metamodelPropertyKind attributeProperty] then
#        @constrainedEntityPassMap referencePropertyConstrainedEntityPassMap ;
#        [constrainedEntityMap searchKey !kPropertyEntityName ?* ?referencePropertyConstrainedEntityPassMap ?* ?* ?* ?* ?* ?* ?* ?* ?*] ;
#        foreach referencePropertyConstrainedEntityPassMap (??@lstring kReferencePropertyPassName ??* ??* ??* ??*) :
#          if not [kConstrainedEntityPassMap hasKey ![kReferencePropertyPassName string]] then
#            error kEntityName:"this constraint should define the '" . [kReferencePropertyPassName string]
#            . "' pass (due to '" . [kPropertyName string] . "' reference)" ;
#          end if ;
#        end foreach ;
#        @stringset referencePassSet := [referencePropertyConstrainedEntityPassMap allKeys] ;
#        foreach kConstrainedEntityPassMap (??@lstring kPassName
#                                           ??*
#                                           ??*
#                                           ??@stringset kDefinedAttributeSet
#                                           ??@callInstructionSharedPropertySignatureMap kCallInstructionSharedPropertySignatureMap) :
#        #--- Check if shared property is correctly initialized
#          if [kDefinedAttributeSet hasKey ![kPropertyName string]] & not [referencePassSet hasKey ![kPassName string]] then
#            error kPassName:"this pass should not define the '" . [kPropertyName string] . "' property" ;
#          elsif (not [kDefinedAttributeSet hasKey ![kPropertyName string]]) & [referencePassSet hasKey ![kPassName string]] then
#            error kPassName:"this pass should define the '" . [kPropertyName string] . "' property" ;
#          end if ;
#        #--- check if shared properties in call instructions are correctly passed as parameters
#          if [kCallInstructionSharedPropertySignatureMap hasKey ![kPropertyName string]] then
#            @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap := kCallInstructionSharedPropertySignatureMap ;
#            @sharedPropertyList signature ;
#            @location signatureLocation ;
#            [callInstructionSharedPropertySignatureMap searchKey !kPropertyName ?signature ?signatureLocation] ;
#            @sharedPropertyList sharedPropertyList ;
#            [referencePropertyConstrainedEntityPassMap searchKey !kPassName ?* ?sharedPropertyList ?* ?*] ;
#            if [sharedPropertyList length] == [signature length] then
#              foreach sharedPropertyList (??@lstring kTypeName ??@lstring kParameterName),
#                      signature (??@lstring kSignatureTypeName ??@lstring kSignatureParameterName) :
#                if [kTypeName string] != [kSignatureTypeName string] then
#                  error kSignatureParameterName:"the type of the parameter is '@" . [kSignatureTypeName string] . "', while a '@"
#                  . [kTypeName string] . "' type is expected" ;
#                end if ;
#              end foreach ;
#            else
#              error signatureLocation:" this instruction names " . [[signature length] string]
#              . " shared property(ies) as parameters, while the constraint definition requires "
#              . [[sharedPropertyList length] string] ;
#            end if ;
#          end if ;
#        end foreach ;
#      end if ;
#    end foreach ;
#  end foreach ;
#--- Root entity is defined ?
  if not [constrainedEntityMap hasKey ![rootEntity string]] then
    error here:"the @" . [rootEntity string] . " root entity should be defined" ;
  end if ;
#--- Build representative entity map
  @representativeEntityMap representativeEntityMap [emptyMap] ;
  foreach metamodelEntityMap (??@lstring kEntityName ??* ??* ??* ??* ??@stringset kSuperEntitySet) :
    @lstring representativeTypeName ;
    computeRepresentativeEntityName
      !metamodelEntityMap
      !constrainedEntityMap
      !kEntityName
      ?representativeTypeName
    ;
    [!?representativeEntityMap insertKey !kEntityName !representativeTypeName !kSuperEntitySet] ;
  end foreach ;
#--- Redefine the super classes not redefined by user
  @bool performLoop := true ;
  loop [metamodelEntityMap count] + 1:
  while performLoop do
    performLoop := false ;
    @entityToImplementMap temporaryEntityMap := constrainedEntityMap ;
    foreach temporaryEntityMap (??@lstring kEntityName ??* ??* ??* ??@lstring kSuperEntityName ??*) :
      if ([kSuperEntityName string] != "") & not [constrainedEntityMap hasKey ![kSuperEntityName string]] then
        performLoop := true ;
        @entityPropertyMap allPropertiesMap ;
        @bool isAbstract ;
        @entityPropertyMap entityPropertiesMap ;
        @lstring superEntityName ;
        @stringset superClassSet ;
        [metamodelEntityMap searchKey
          !kSuperEntityName
          ?allPropertiesMap
          ?isAbstract
          ?entityPropertiesMap
          ?superEntityName
          ?superClassSet
        ] ;
        [!?constrainedEntityMap insertKey
          !kSuperEntityName
          !allPropertiesMap
          !isAbstract
          !entityPropertiesMap
          !superEntityName
          !superClassSet
        ] ;
      end if ;
    end foreach ;
  end loop ;
#--- Build actual constraint entity map
  @entityToImplementMap actualConstrainedEntityMap [emptyMap] ;
  @stringset multiReferencedEntities [emptySet] ;
  foreach constrainedEntityMap (
    ??@lstring kEntityName
    ??@entityPropertyMap kAllPropertiesMap
    ??@bool kIsAbstract
    ??@entityPropertyMap kEntityPropertiesMap
    ??@lstring kSuperEntityName
    ??@stringset kSuperClassSet
  ) :
  #---
   @entityPropertyMap newAllPropertiesMap [emptyMap] ;
    foreach kAllPropertiesMap (??@lstring kKey ??@metamodelPropertyKind kKind ??@lstring kTypeName) :
      if kKind == [@metamodelPropertyKind attributeProperty] then
        [!?newAllPropertiesMap insertKey !kKey !kKind !kTypeName] ;
      elsif (kKind == [@metamodelPropertyKind singleReferenceProperty]) | (kKind == [@metamodelPropertyKind multipleReferenceProperty]) then
        @lstring representativeTypeName ;
        computeRepresentativeEntityName
          !metamodelEntityMap
          !constrainedEntityMap
          !kTypeName
          ?representativeTypeName
        ;
        if [representativeTypeName string] != "" then
          [!?newAllPropertiesMap insertKey !kKey !kKind !representativeTypeName] ;
          multiReferencedEntities += ![representativeTypeName string] ;
        end if ;
      end if ;
    end foreach ;
    @entityPropertyMap newPropertiesMap [emptyMap] ;
    foreach kEntityPropertiesMap (??@lstring kKey ??@metamodelPropertyKind kKind ??@lstring kTypeName) :
      if kKind == [@metamodelPropertyKind attributeProperty] then
        [!?newPropertiesMap insertKey !kKey !kKind !kTypeName] ;
      elsif (kKind == [@metamodelPropertyKind singleReferenceProperty]) | (kKind == [@metamodelPropertyKind multipleReferenceProperty]) then
        @lstring representativeTypeName ;
        computeRepresentativeEntityName
          !metamodelEntityMap
          !constrainedEntityMap
          !kTypeName
          ?representativeTypeName
        ;
        if [representativeTypeName string] != "" then
          [!?newPropertiesMap insertKey !kKey !kKind !representativeTypeName] ;
          multiReferencedEntities += ![representativeTypeName string] ;
        end if ;
      end if ;
    end foreach ;
    [!?actualConstrainedEntityMap insertKey
      !kEntityName
      !newAllPropertiesMap
      !kIsAbstract
      !newPropertiesMap
      !kSuperEntityName
      !kSuperClassSet
    ] ;
  end foreach ;
#--- Generate C++ code
  action generate_constraints
      !metamodelEntityMap
      !mapEntityMap
      !metamodelName
      !constraintName
      !actualConstrainedEntityMap
      !multiReferencedEntities
      !rootEntity
      !representativeEntityMap
  ;
  $constraint$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_map_declaration>
  ?@entityToImplementMap inMetamodelEntityMap
  ?!@mapEntityMap ioMapEntityMap
:
  $map$ ;
  @lstring mapIdentifier ;
  $type_name$ ? mapIdentifier ;
  if [inMetamodelEntityMap hasKey ![mapIdentifier string]] then
    error mapIdentifier: "An entity has been declared with this name" ;
  end if ;
  $of$ ;
  @lstring mapElementIdentifier ;
  $type_name$ ? mapElementIdentifier ;
  ${$ ;
  $insert$ ;
  $error$ ;
  $message$ ;
  @lstring insertErrorMessage ;
  $literal_string$ ? insertErrorMessage ;
  action check_KL_escapeCharacters !insertErrorMessage ;
  $;$ ;
  $search$ ;
  $error$ ;
  $message$ ;
  @lstring searchErrorMessage ;
  $literal_string$ ? searchErrorMessage ;
  action check_K_escapeCharacters !searchErrorMessage ;
  $;$ ;
  $}$ ;
  [!?ioMapEntityMap insertKey
    !mapIdentifier
    !mapElementIdentifier
    !insertErrorMessage
    !searchErrorMessage
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <constraints_on_entity_declaration>
  ?@entityToImplementMap inEntityMap
  ?!@mapEntityMap unused ioMapEntityMap
  ?!@entityToImplementMap ioConstainedEntityMap
:
#--- Entity Name
  $on$ ;
  @lstring entityName ;
  $type_name$ ? entityName ;
#--- Get entity properties
  @lstring superEntity ;
  @bool isAbstract ;
  @entityPropertyMap allPropertyMap ;
  @stringset superClassSet ;
  @entityPropertyMap propertyMap [emptyMap] ;
  [inEntityMap searchKey
    !entityName
    ?allPropertyMap
    ?isAbstract
    ?propertyMap
    ?superEntity
    ?superClassSet
   ] ;
#  @stringset descendantEntitySet [emptySet] ;
#  computeDescendantSet !ioEntityMap !entityName !?descendantEntitySet ;
##--- Get inherited properties from super class constraints
#  @mapAsConstraintPropertyMap  allMapsAsConstraintPropertyMap [emptyMap] ;
#  @constrainedEntityPassMap inheritedConstrainedEntityPassMap [emptyMap] ;
#  @stringset passesDefinedByInheritanceTreeRootEntity [emptySet] ;
#  @constraintAllPropertiesMap constraintAllPropertiesMap [emptyMap] ;
#  @indexMap allIndexMap [emptyMap] ;
#  if [superEntity string] != "" then
#    if [ioConstrainedEntityMap hasKey ![superEntity string]] then
#      [ioConstrainedEntityMap searchKey
#        !superEntity
#        ?passesDefinedByInheritanceTreeRootEntity
#        ?inheritedConstrainedEntityPassMap
#        ?*
#        ?*
#        ?*
#        ?*
#        ?*
#        ?allMapsAsConstraintPropertyMap
#        ?constraintAllPropertiesMap
#        ?*
#        ?allIndexMap
#      ] ;
#    else
#      error entityName:
#        "constraints for super entity ('@" . [superEntity string] . "') should be previously defined" ;
#    end if ;
#  end if ;
##--- Passes
#  @indexMap indexMap [emptyMap] ;
#  @constrainedEntityPassMap constrainedEntityPassMap [emptyMap] ;
#    @uint currentPassIndex := 0 ;
#    @lstring passName [new !"premiere_passe" !here] ;
#    @sharedPropertyList sharedPropertyList [emptyList] ;
  #--- Properties from owner
    select
#      if [superEntity string] != "" then
#        [inheritedConstrainedEntityPassMap searchKey !passName ?* ?sharedPropertyList ?* ?*] ;
#      end if ;
    or
      $($ ;
#      if [superEntity string] != "" then
#        error here: "as the '@" . [entityName string]
#        . "' entity has a super entity, you cannot define any shared property" ;
#      end if ;
      repeat
        @lstring typeName ;
        $type_name$ ? typeName ;
        @lstring propertyName ;
        $identifier$ ? propertyName ;
#        [!?constraintAllPropertiesMap insertKey !propertyName] ;
#        if [ioMapEntityMap hasKey ![typeName string]] then 
#          @lstring elementTypeName ;
#          [ioMapEntityMap searchKey !typeName ?elementTypeName ?* ?*] ;
#          [!?mapAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentPassIndex ![passName string] !true] ;
#          [!?allMapsAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentPassIndex ![passName string] !true] ;
#          sharedPropertyList += !typeName !propertyName ;
#        else
#          error typeName:"unhandled type name" ;
#        end if ;
      while
        $,$ ;
      end repeat ;
      $)$ ;
    end select ;
  #--- Properties
    ${$ ;
    repeat
    while
      @lstring typeName ;
      $type_name$ ? typeName ;
      @lstring propertyName ;
      $identifier$ ? propertyName ;
#      [!?constraintAllPropertiesMap insertKey !propertyName] ;
#      if [ioMapEntityMap hasKey ![typeName string]] then 
#        @lstring elementTypeName ;
#        [ioMapEntityMap searchKey !typeName ?elementTypeName ?* ?*] ;
#        [!?mapAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentPassIndex ![passName string] !false] ;
#        [!?allMapsAsConstraintPropertyMap insertKey !propertyName !typeName !elementTypeName !currentPassIndex ![passName string] !false] ;
#      else
#        error typeName:"unhandled type name" ;
#      end if ;
      $;$ ;
    while
      $mapindex$ ;
      @lstring propertyName ;
      $identifier$ ? propertyName ;
#      [!?constraintAllPropertiesMap insertKey !propertyName] ;
      $on$ ;
      @lstring mapPropertyName ;
      $identifier$ ? mapPropertyName ;
#      [allMapsAsConstraintPropertyMap searchKey !mapPropertyName ?* ?* ?* ?* ?*] ;
#      [!?indexMap insertKey !propertyName !mapPropertyName !currentPassIndex] ;
#      [!?allIndexMap insertKey !propertyName !mapPropertyName !currentPassIndex] ;
      $;$ ;
    end repeat ;
    $}$ ;
    ${$ ;
#  #--- Enter attributes metamodels as constants
    @typeVariablesMap variablesMap [emptyMap] ;
#    foreach allPropertyMap (??@lstring kKey ??@metamodelPropertyKind kKind ??@lstring kTypeName) :
#      if kKind == [@metamodelPropertyKind  attributeProperty] then
#        # message "attribute '" . [kKey value] . "' has type '@" . [kTypeName value] . "'\n" ;
#        @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"_mMetamodelObject->" . [kKey string] ![kKey location]]] ;
#        if [kTypeName string] == "lstring" then
#          @AC_galgasType t := [@typeGalgas_lstring new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "string" then
#          @AC_galgasType t := [@typeGalgas_string new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "lchar" then
#          @AC_galgasType t := [@typeGalgas_lchar new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "char" then
#          @AC_galgasType t := [@typeGalgas_char new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "luint" then
#          @AC_galgasType t := [@typeGalgas_luint new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "uint" then
#          @AC_galgasType t := [@typeGalgas_uint new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "lsint" then
#          @AC_galgasType t := [@typeGalgas_lsint new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "sint" then
#          @AC_galgasType t := [@typeGalgas_sint new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "lbool" then
#          @AC_galgasType t := [@typeGalgas_lbool new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "bool" then
#          @AC_galgasType t := [@typeGalgas_bool new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        elsif [kTypeName string] == "location" then
#          @AC_galgasType t := [@typeGalgas_location new] ;
#          [!?variablesMap insertUsedConstInArgument !kKey !t !cppName] ;
#        else
#          error here : "internal error (@" . [kTypeName string] . " type not handled" ;
#        end if ;
#      end if ;
#    end foreach ;
#  #--- Enter attributes from previous passes as constants
#    foreach allMapsAsConstraintPropertyMap (??@lstring kPropertyName ??@lstring kTypeName ??@lstring kElementTypeName ??@uint kPassIndex ...) :
#      # message "Map " . [kPropertyName value] . " of type @" . [kTypeName value] . " defined in pass " . [kPassIndex string] . "\n" ;
#      @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"(* " . [kPropertyName string] . ")" !here]] ;
#      @AC_galgasType t := [@typeGalgas_mapEntityInInstruction new ![kTypeName string] ![kElementTypeName string]] ;
#      if (kPassIndex == currentPassIndex) & [mapAsConstraintPropertyMap hasKey ![kPropertyName string]] then
#        [!?variablesMap insertUsedInOutArgument !kPropertyName !t !cppName] ;
#      else
#        [!?variablesMap insertUsedConstInArgument !kPropertyName !t !cppName] ;
#      end if ;
#    end foreach ;
#  #--- Enter indexes
#    foreach allIndexMap (??@lstring kIndexName ??@lstring kMapTypeName ??@uint kPassIndex) :
#      @typeCplusPlusName cppName := [@typeDirectName new !kIndexName] ;
#      @AC_galgasType t := [@typeGalgas_mapIndexInInstruction new ![kMapTypeName string]] ;
#      if (kPassIndex == currentPassIndex) & [indexMap hasKey ![kIndexName string]] then
#        [!?variablesMap insertOutProperty !kIndexName !t !cppName] ;
#      else
#        [!?variablesMap insertUsedConstInArgument !kIndexName !t !cppName] ;
#      end if ;
#    end foreach ;
#  #--- Add "self" variable
#    @typeCplusPlusName cppName := [@typeDirectName new ![@lstring new !"_mMetamodelObject" !here]] ;
#    @AC_galgasType t := [@typeGalgas_entityInInstruction new ![entityName string]] ;
#    [!?variablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !t !cppName] ;
  #--- Instructions
    @M_semanticsEntitiesForUse componentSemanticsEntitiesMap [emptyMap] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
    @typeInstructionList instructionsList [emptyList] ;
    @stringset constraintPropertyDefinitionSet [emptySet] ;
    @callInstructionSharedPropertySignatureMap callInstructionSharedPropertySignatureMap [emptyMap] ;
    <semantic_instructions_list>
      !?componentSemanticsEntitiesMap
      !?listeEntitesAengendrer
      !?optionsComponentsMapForUse
      !?variablesMap
      !?instructionsList
      !?propertyMap
      !?constraintPropertyDefinitionSet
      !?callInstructionSharedPropertySignatureMap
    ;
    $}$ ;
#    [!?constrainedEntityPassMap insertKey
#      !passName
#      !instructionsList 
#      !sharedPropertyList
#      !constraintPropertyDefinitionSet
#      !callInstructionSharedPropertySignatureMap
#    ] ;
##--- If the entity has no super entity, define the set of defined passes
#  if [superEntity string] == "" then
#    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
#      passesDefinedByInheritanceTreeRootEntity += ![kPassName string] ;
#    end foreach ;
#  end if ;
##--- If the entity has super entity, check that only passes defined by
##    inheritance tree root entity are defined
#  if [superEntity string] != "" then
#    foreach constrainedEntityPassMap (??@lstring kPassName ??* ??* ??* ??*) :
#      if not [passesDefinedByInheritanceTreeRootEntity hasKey ![kPassName string]] then
#       error here: "pass '" . [kPassName string]
#       . "' cannot be defined because it is not defined by the constraint on '@"
#       . [superEntity string] . "' entity" ;
#      end if ;
#    end foreach ;
#  end if ;
##--- Enter constraint in constraint map 
#  [!?ioConstrainedEntityMap insertKey
#    !entityName
#    !passesDefinedByInheritanceTreeRootEntity
#    !constrainedEntityPassMap
#    !superEntity
#    !propertyMap
#    !descendantEntitySet
#    !here
#    !mapAsConstraintPropertyMap
#    !allMapsAsConstraintPropertyMap
#    !constraintAllPropertiesMap
#    !indexMap
#    !allIndexMap
#  ] ;
#--- Enter in constraint entity map
  [!?ioConstainedEntityMap insertKey
    !entityName
    !allPropertyMap
    !isAbstract
    !propertyMap
    !superEntity
    !superClassSet
  ] ;
end rule ;

#-------------------------------------------------------------------*

rule <property_path_for_constraint>
  !@L_propertyPath outPath
:
  outPath := [@L_propertyPath emptyList] ;
  repeat
    select
      @lstring pathElement ;
      $identifier$ ? pathElement ;
      outPath += !pathElement ;
    or
      @lstring pathElement ;
      $type_name$ ? pathElement ;
      outPath += ![@lstring new !".". [pathElement string] ![pathElement location]] ;
    end select ;
  while
    $.$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_expression>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_term>
    !?ioRelationVariableMap
    !?ioIndexMap
    ?outExpression ;
  repeat
  while
    $|$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_term> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_term>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  repeat
  while
    $&$ ;
    @metamodelRelationExpression e ;
    <constraint_relation_factor> !?ioRelationVariableMap !?ioIndexMap ?e ;
    outExpression := [@metamodelRelationOr new !outExpression !e] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_factor>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
  or
    $not$ ;
    <constraint_relation_primary> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    outExpression := [@metamodelRelationNot new !outExpression] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <constraint_relation_primary>
  ?!@relationVarMap ioRelationVariableMap
  ?!@indexMap ioIndexMap
  !@metamodelRelationExpression outExpression
:
  select
    $true$ ;
    outExpression := [@metamodelRelationTrue new] ;
  or
    $false$ ;
    outExpression := [@metamodelRelationFalse new] ;
  or
    $($ ;
    <constraint_relation_expression> !?ioRelationVariableMap !?ioIndexMap ?outExpression ;
    $)$ ;
  or
    ${$ ;
    @lstring localVar ;
    $identifier$ ? localVar ;
    @luint variableIndex ;
    @lstring domainVariable ;
    [ioRelationVariableMap searchKeyAndGetIndex !localVar ?variableIndex ?domainVariable] ;
    $==$ ;
    @lstring indexVariableName ;
    $identifier$ ? indexVariableName ;
    @lstring domainVariableFromIndex ;
    [ioIndexMap searchKey !indexVariableName ?domainVariableFromIndex ?*] ;
    if [domainVariable string] != [domainVariableFromIndex string] then
      error indexVariableName: "this index refers to the '" . [domainVariableFromIndex string]
      . "' domain, while '" . [localVar  string] . "' relation variable refers to the '"
      . [domainVariable string] . "' domain" ;
    end if ;
    $}$ ;
    outExpression := [@metamodelRelationPrimary new !ioRelationVariableMap !localVar !variableIndex !indexVariableName !domainVariable] ;
  or
   $do$ ;
    $($ ;
     @L_propertyPath path ;
     <property_path_for_constraint> ?path ;
    $[$ ;
    @metamodelRelationParameterList parameterList [emptyList] ;
    repeat
      @lstring parameter ;
      $identifier$ ? parameter ;
      @luint parameterIndex ;
      @lstring domainVariable ;
      [ioRelationVariableMap searchKeyAndGetIndex !parameter ?parameterIndex ?domainVariable] ;
      parameterList += !parameter !parameterIndex !domainVariable ;
    while
      $,$ ;
    end repeat ;
    $]$ ;
    $:$ ;
    @lbool operationIsAnd ;
    select
      $|$ ;
      operationIsAnd := [@lbool new !false !here] ;
    or
      $&$ ;
      operationIsAnd := [@lbool new !true !here] ;
    end select ;
    $)$ ;
    outExpression := [@metamodelRelationDo new !ioRelationVariableMap !parameterList !path !operationIsAnd] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
