#---------------------------------------------------------------------------*
#                                                                           *
#  semantics definitions for semantics component                            *
#                                                                           *
#  Copyright (C) 1997, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticsTypes :
import "semanticsTypesForAST.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#  U N I F I E D    T Y P E    M A P                                        *
#                                                                           *
#---------------------------------------------------------------------------*

list @unifiedTypeMapProxyList {
  @unifiedTypeMapProxy mType ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C O N S T R U C T O R    M A P                                           *
#                                                                           *
#---------------------------------------------------------------------------*

map @constructorMap {
  @unifiedTypeMapProxyList mArgumentTypeList ;
  @bool mHasCompilerArgument ;
  @unifiedTypeMapProxy mReturnedType ;
  insert insertKey error message "the '%K' constructor has been already defined" ;
  search searchKey error message "the '%K' constuctor is not declared" ;
}

#---------------------------------------------------------------------------*

enum @methodQualifier {
  isAbstract, isBasic, isBasicFinal, isInherited, isOverriding, isOverridingAbstract
}{
}

#---------------------------------------------------------------------------*
#                                                                           *
#  R E A D E R    M A P                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @readerMap {
  @bool mIsCategory ;
  @unifiedTypeMapProxyList mArgumentTypeList ;
  @location mDeclarationLocation ;
  @bool mHasCompilerArgument ;
  @unifiedTypeMapProxy mReturnedType ;
  @methodQualifier mQualifier ;
  @string mErrorMessage ; # If not empty, calling the method raises an error ith this message
 
  insert insertKey error message "the '%K' reader is already declared" ;
  search searchKey error message "the '%K' reader is not declared" ;

  insert or replace ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  M O D I F I E R    M A P                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

list @formalParameterSignature {
  @unifiedTypeMapProxy mFormalArgumentType ;
  @formalArgumentPassingModeAST mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*

map @modifierMap {
  @formalParameterSignature mParameterList ;
  @bool mHasCompilerArgument ;
  @methodQualifier mQualifier ;
  @string mErrorMessage ; # If not empty, calling the modifier raises an error ith this message
  insert or replace ;
  insert insertKey error message "the '%K' modifier is already declared" ;
  search searchKey error message "the '%K' modifier is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  M E T H O D    M A P                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @instanceMethodMap {
  @bool mIsCategory ;
  @formalParameterSignature mParameterList ;
  @location mDeclarationLocation ;
  @bool mHasCompilerArgument ;
  @methodQualifier mQualifier ;
  @string mErrorMessage ; # If not empty, calling the method raises an error ith this message
  insert insertKey error message "the '%K' instance method is already declared" ;
  search searchKey error message "the '%K' instance method is not declared" ;
  search searchInheritedKey error message "as the '%K' method is tagged as 'override', it should be declared in the super class" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C L A S S    M E T H O D    M A P                                        *
#                                                                           *
#---------------------------------------------------------------------------*

map @classMethodMap {
  @formalParameterSignature mParameterList ;
  @bool mHasCompilerArgument ;
  insert or replace ;
  insert insertKey error message "the '%K' class method is already declared" ;
  search searchKey error message "the '%K' class method is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  W I T H    A C C E S S O R    M A P                                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @withAccessorMap {
  @unifiedTypeMapProxy mArgumentType ;
  insert insertKey error message "the '%K' 'with' accessor is already declared" ;
  search searchKey error message "the '%K' 'with' accessor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M E R A T I O N    D E S C R I P T O R    L I S T                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @enumerationDescriptorList {
  @unifiedTypeMapProxy mEnumeratedType ;
  @string mEnumerationName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E D    A T T R I B U T E    L I S T                                *
#                                                                           *
#---------------------------------------------------------------------------*

list @typedAttributeList {
  @unifiedTypeMapProxy mAttributeTypeProxy ;
  @lstring mAttributeName ;
  @bool mHasSetter ;
  @bool mHasGetter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  P R E D E F I N E D    T Y P E    K I N D    E N U M E R A T I O N       *
#                                                                           *
#---------------------------------------------------------------------------*

enum @predefinedTypeKindEnum {
  predefined_uint,
  predefined_uint64,
  predefined_sint,
  predefined_sint64,
  predefined_char,
  predefined_double,
  predefined_string,
  predefined_stringset,
  predefined_bool,
  predefined_binaryset,
  predefined_function,
  predefined_location,
  predefined_type,
  predefined_object,
  predefined_data,
  predefined_filewrapper,
  predefined_application
}{
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    K I N D    E N U M E R A T I O N                              *
#                                                                           *
#---------------------------------------------------------------------------*

enum @typeKindEnum {
  classType,
  enumType,
  listType,
  sortedListType,
  mapType,
  uniqueMapType,
  mapProxyType,
  listMapType,
  structType,
  graphType,
  predefinedType
}{
  reader kind :
    classType -> "class" ;
    enumType -> "enumeration" ;
    listType -> "list" ;
    sortedListType -> "sorted list" ;
    mapType -> "map" ;
    uniqueMapType -> "unique map" ;
    mapProxyType -> "map proxy" ;
    listMapType -> "list map" ;
    structType -> "struct" ;
    graphType -> "graph" ;
    predefinedType -> "predefined" ;
  end reader ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  O P E R A T O R    F L A G S                                             *
#                                                                           *
# Theses masks are used for the mHandledOperatorFlags attribute of the      *
# @unifiedTypeMap map, for indicating the handled operators.                *
#---------------------------------------------------------------------------*

once binaryAddOperator -> @uint outMask : outMask := 1 ; end once ;
once binarySubOperator -> @uint outMask : outMask := 1 << 1 ; end once ;
once binaryMulOperator -> @uint outMask : outMask := 1 << 2 ; end once ;
once binaryDivOperator -> @uint outMask : outMask := 1 << 3 ; end once ;
once binaryModOperator -> @uint outMask : outMask := 1 << 4 ; end once ;
once binaryShiftOperator -> @uint outMask : outMask := 1 << 5 ; end once ;
once unaryPlusOperator -> @uint outMask : outMask := 1 << 6 ; end once ;
once unaryMinusOperator -> @uint outMask : outMask := 1 << 7 ; end once ;
once unaryTildeOperator -> @uint outMask : outMask := 1 << 8 ; end once ;
once incDecOperator -> @uint outMask : outMask := 1 << 9 ; end once ;

once binaryAndOperator -> @uint outMask : outMask := 1 << 10 ; end once ;
once binaryOrOperator -> @uint outMask : outMask := 1 << 11 ; end once ;
once binaryXorOperator -> @uint outMask : outMask := 1 << 12 ; end once ;
once unaryNotOperator -> @uint outMask : outMask := 1 << 13 ; end once ;

once binaryConcatOperator -> @uint outMask : outMask := 1 << 14 ; end once ; # exp1 . exp2
once dotAssignOperator -> @uint outMask : outMask := 1 << 15 ; end once ; # var .= exp ;
once isComparable -> @uint outMask : outMask := 1 << 16 ; end once ; # Supports <, <=, >, >= operators

once generateEnumerationHelperMethods -> @uint outMask : outMask := 1 << 28 ; end once ;
once doNotGenererateObjectCompare -> @uint outMask : outMask := 1 << 29 ; end once ;
once generateDescriptionReaderUtilityMethod -> @uint outMask : outMask := 1 << 30 ; end once ;
once generateCopyConstructorAndAssignmentOperator -> @uint outMask : outMask := 1 << 31 ; end once ;

#---------------------------------------------------------------------------*

map @attributeMap {
  @unifiedTypeMapProxy mAttributeType ;
  insert insertKey error message "the '%K' attribute has been already declared in %L" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U N I F I E D    T Y P E    M A P                                        *
#                                                                           *
#---------------------------------------------------------------------------*

uniquemap @unifiedTypeMap {
  @bool mIsConcrete ; # false if abstract class
  @unifiedTypeMapProxy mSuperType ;
  @typeKindEnum mTypeKindEnum ;
  @typedAttributeList mAllTypedAttributeList ;
  @attributeMap mAttributeMap ; # struct, class
  @typedAttributeList mCurrentTypedAttributeList ;
  @constructorMap mConstructorMap ;
  @readerMap mReaderMap ;
  @modifierMap mModifierMap ;
  @instanceMethodMap mInstanceMethodMap ;
  @classMethodMap mClassMethodMap ;
  @enumerationDescriptorList mEnumerationDescriptor ; # Empty List if cannot be enumerated
  @stringlist mEnumeratorVariants ; # Empty List if cannot be enumerated; first item is default item
  @uint mHandledOperatorFlags ;
  @unifiedTypeMapProxyList mAddAssignOperatorArguments ; # Empty list if += operator is not supported
  @stringset mEnumConstantSet ;
  @lstringlist mEnumConstantList ;
  @mapSearchMethodListAST mMapSearchMethodList ; # For a map, the list of search methods
  @mapSearchMethodListAST mMapProxySearchConstructorList ; # For a map proxy, the list of search methods of the associated map
  @withAccessorMap mWithAccessorMap ; # Method for with accessor
  @bool mGenerateHeaderInSeparateFile ; # Significant only for classes

  insert insertKey error message "the '@%K' type has been already declared in %L" ;
  search searchKey error message "the '@%K' type is not declared" ;
}

#---------------------------------------------------------------------------*

mapproxy @unifiedTypeMapProxy (@unifiedTypeMap) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A S T   C L A S S E S    F O R    P R E D E F I N E D   T Y P E S        *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @predefinedTypeAST extends @semanticDeclarationAST {
  @string mPredefinedTypeName ;
  @predefinedTypeKindEnum mKind ;
}

#---------------------------------------------------------------------------*

class @applicationPredefinedTypeAST extends @predefinedTypeAST {}

class @objectPredefinedTypeAST extends @predefinedTypeAST {}

class @filewrapperPredefinedTypeAST extends @predefinedTypeAST {}

class @binarysetPredefinedTypeAST extends @predefinedTypeAST {}

class @boolPredefinedTypeAST extends @predefinedTypeAST {}

class @uintPredefinedTypeAST extends @predefinedTypeAST {}

class @uint64PredefinedTypeAST extends @predefinedTypeAST {}

class @sintPredefinedTypeAST extends @predefinedTypeAST {}

class @sint64PredefinedTypeAST extends @predefinedTypeAST {}

class @charPredefinedTypeAST extends @predefinedTypeAST {}

class @doublePredefinedTypeAST extends @predefinedTypeAST {}

class @stringPredefinedTypeAST extends @predefinedTypeAST {}

class @locationPredefinedTypeAST extends @predefinedTypeAST {}

class @stringsetPredefinedTypeAST extends @predefinedTypeAST {}

class @functionPredefinedTypeAST extends @predefinedTypeAST {}

class @typePredefinedTypeAST extends @predefinedTypeAST {}

class @dataPredefinedTypeAST extends @predefinedTypeAST {}

#---------------------------------------------------------------------------*

method @predefinedTypeAST getConstructorMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outConstructorMap
:
  outConstructorMap := [@constructorMap emptyMap] ;
end method ;

#---------------------------------------------------------------------------*

method @predefinedTypeAST getReaderMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@readerMap outReaderMap
:
  outReaderMap := [@readerMap emptyMap] ;
end method ;

#---------------------------------------------------------------------------*

method @predefinedTypeAST getModifierMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@modifierMap outModifierMap
:
  outModifierMap := [@modifierMap emptyMap] ;
end method ;

#---------------------------------------------------------------------------*

method @predefinedTypeAST getInstanceMethodMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@instanceMethodMap outInstanceMethodMap
:
  outInstanceMethodMap := [@instanceMethodMap emptyMap] ;
end method ;

#---------------------------------------------------------------------------*

method @predefinedTypeAST getClassMethodMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@classMethodMap outClassMethodMap
:
  outClassMethodMap := [@classMethodMap emptyMap] ;
end method ;

#---------------------------------------------------------------------------*

reader @predefinedTypeAST getSupportedOperatorFlags
  ->@uint outFlags
:
  outFlags := 0 ; # No supported operator
end reader ;

#---------------------------------------------------------------------------*

method @predefinedTypeAST getAddAssignArgumentList
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@unifiedTypeMapProxyList outAddAssignArgumentList
:
  outAddAssignArgumentList := [@unifiedTypeMapProxyList emptyList] ; # += is not supported
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G E T    E N U M E R A T I O N    L I S T                                *
#                                                                           *
#---------------------------------------------------------------------------*

method @predefinedTypeAST getEnumerationList
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@enumerationDescriptorList outEnumerationList
  !@stringlist outEnumerationVariant
:
  outEnumerationList := [@enumerationDescriptorList emptyList] ; # Enumeration is not supported
  outEnumerationVariant := [@stringlist emptyList] ; # Enumeration is not supported
end method ;

#---------------------------------------------------------------------------*

end semantics ;
