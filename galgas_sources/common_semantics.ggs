#---------------------------------------------------------------------------*
#                                                                           *
#  Common semantics definitions                                             *
#                                                                           *
#  Copyright (C) 1997-2006 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics common_semantics :

#---------------------------------------------------------------------------*
#                                                                           *
#   L I S T    O F    L S T R I N G S                                       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_lstringList {
  @lstring mString ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    P A R A M E T E R S    P A S S I N G    M O D E S         *
#                                                                           *
#---------------------------------------------------------------------------*

enum @actualParametersPassingMode {
  parameterOut, parameterOutIn, parameterIn
}{
  message actualArgumentMessage :
    parameterOutIn -> "an output/input (!?) actual parameter" ;
    parameterIn -> "an input (?) actual parameter" ;
    parameterOut -> "an output (!) actual parameter" ;
  end message ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   F O R M A L    A R G U M E N T S    P A S S I N G    M O D E S          *
#                                                                           *
#---------------------------------------------------------------------------*

enum @formalArgumentPassingMode {
  argumentIn, argumentOut, argumentInOut, argumentConstantIn
}{
  message formalArgumentMessage :
    argumentConstantIn -> "a constant input (??) formal argument" ;
    argumentIn -> "an input (?) formal argument" ;
    argumentOut -> "an output (!) formal argument" ;
    argumentInOut -> "an input/output (?!) argument" ;
  end message ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A C T I O N ,    M E T H O D    S I G N A T U R E                       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_signature {
  @formalArgumentPassingMode mFormalArgumentPassingMode ;
  @lstring mGalgasTypeName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    L I S T    M O D E L                                          *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListModel {
  @lstring mTypeName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B O O L    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @BoolModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C H A R    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @CharModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U I N T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @UIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S I N T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @SIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U I N T 6 4    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @UInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S I N T 6 4    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @SInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  D O U B L E    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @DoubleModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S T R I N G    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @StringModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L B O O L    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LBoolModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L C H A R    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LCharModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L U I N T    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LUIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S I N T    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LSIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L U I N T 6 4    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LUInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S I N T 6 4    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LSInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L D O U B L E    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LDoubleModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S T R I N G    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LStringModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S T R I N G S E T    M O D E L                                           *
#                                                                           *
#---------------------------------------------------------------------------*

class @StringsetModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L O C A T I O N    M O D E L                                             *
#                                                                           *
#---------------------------------------------------------------------------*

class @LocationModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L I S T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @ListModel extends @TypeModel {
  @typeListModel mAttributeList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    M O D E L                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @MapModel extends @TypeModel {
  @typeListModel mAttributeList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @enumConstantMap {
  insert insertKey error message "the '%K' constant is already declared in %L" ;
  search searchKey error message "the '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

map @enumMessageMap {
  insert insertKey error message "the '%K' message name is already declared in %L" ;
  search searchKey error message "the '%K' message name is not declared" ;
}

#---------------------------------------------------------------------------*

class @EnumModel extends @TypeModel {
  @enumConstantMap mEnumConstantesMap ; #--- Enumeration constants map
  @enumMessageMap mMessagesMap ; #--- Messages map
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    T Y P E    M O D E L                                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @constructorMap {
  @typeListModel mFormalInputArgumentList ;
  insert insertKey error message "the '%K' constructor is already declared in %L" ;
  search searchKey error message "the '%K' constructor is not declared" ;
}

#---------------------------------------------------------------------------*

map @readerMap {
  @L_signature mReaderFormalArgumentList ;
  insert insertKey error message "the '%K' reader is already declared in %L" ;
  search searchKey error message "the '%K' reader is not declared" ;
}

#---------------------------------------------------------------------------*

map @modifierMap {
  @L_signature mModifierFormalArgumentList ;
  insert insertKey error message "the '%K' modifier is already declared in %L" ;
  search searchKey error message "the '%K' modifier is not declared" ;
}

#---------------------------------------------------------------------------*

class @ExternTypeModel extends @TypeModel {
  @constructorMap mExternTypeConstructorMap ;
  @readerMap mReaderMap ;
  @modifierMap mModifierMap ;
  @typeListModel mAddAssignFormalInputArgumentList ; # List is empty if += operator is not defined
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C L A S S    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @classMessageMap {
  insert insertKey error message "the '%K' message is already declared in %L" ;
  search searchKey error message "the '%K' message is not declared" ;
}

#---------------------------------------------------------------------------*

class @ClassModel extends @TypeModel {
  @bool mIsAbstract ;
  @stringset mSuperClasses ;
  @typeListModel mAttributeList ;
  @classMessageMap mMessageMap ;
}


#---------------------------------------------------------------------------*
#                                                                           *
#  M O D E L    M A P                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @ModelMap {
  @TypeModel mType ;
  insert insertKey error message "the '@%K' type has been already declared in %L" ;
  search searchKey error message "the '@%K' type is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    A C T I O N    A N D    R O U T I N E    M A P            *
#                                                                           *
#---------------------------------------------------------------------------*

map @ActionMap {
  @L_signature mSignature ;
  @bool mIsExtern ; # true for extern action, false for routines
  insert insertKey error message "the '%K' extern action has been already declared in %L" ;
  search searchKey error message "the '%K' action is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   F O R W A R D    T Y P E     D E C L A R A T I O N S                    *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_EXsignature ;
list @typeListeAttributsSemantiques ;

#---------------------------------------------------------------------------*

enum @localConstantBuildStyleEnum {
  listStyle, mapStyle, firstIsKeyOtherMapStyle
}{
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    T Y P E    ( A B S T R A C T    C L A S S )              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_galgasType {
#--- Get type name
  abstract method getTypeName !@string outTypeName ;

#--- By default, object does not accept assignment from 'here'
  method acceptAssignmentFromHere ??@lstring inErrorLocation :
    error inErrorLocation :
       "assignment from 'here' is not allowed for variables of this type" ;
  end method ;

#--- By default, object does not accept to be enumerated (foreach instruction)
  method acceptForeachInstruction
    ??@lstring inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
  :
    error inErrorLocation :
       "variables of this type cannot be enumerated by in 'foreach' instruction" -> outForeachList, outStyle ;
  end method ;

#--- By default, object does not accept modifier call
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
  end method ;

#--- By default, class does not accept reader instruction call
  method handleReaderInstructionCall
    ??@lstring unused inReadObjectName
    ??@lstring inReaderName
    !@L_EXsignature outReaderSignature
  :
    error inReaderName :
       "variables of this type do not support reader instruction"
       -> outReaderSignature ;
  end method ;

#--- By default, class does not accept class method call
  method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
  end method ;

#--- By default, class does not accept operator "-=" call
  method handleMinusAssignOperatorCall 
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    error inErrorLocation :
       "variables of this type do not support call of '-=' operator"
       -> outParametersList ;
  end method ;


#--- By default, class does not accept operator "+=" call
  method handleAddAssignOperatorCall 
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    error inErrorLocation :
       "variables of this type do not support call of '+=' operator"
       -> outParametersList ;
  end method ;

#--- By default, class does not accept "++" operator
  method handleIncrementOperatorCall 
    ??@location inErrorLocation
  :
    error inErrorLocation :
       "variables of this type do not support call of '++' operator" ;
  end method ;

#--- By default, class does not accept "--" operator
  method handleDecrementOperatorCall 
    ??@location inErrorLocation
  :
    error inErrorLocation :
       "variables of this type do not support call of '--' operator" ;
  end method ;

#--- By default, class does not accept to be silently converted to @location
  method checkAbilityToBeSilentlyConvertedToLocation 
  :
    error here : "variables of this type cannot be silently converted to @location value" ;
  end method ;

#--- Error message
  message messageGalgasType "any type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   P A R S E D    E N T I T Y    I N    M E T A M O D E L                  *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @metamodelProperty {
#--- Error message
  message messageProperty "any property" ;
}

#---------------------------------------------------------------------------*

list @metamodelPropertyList {
  @metamodelProperty mProperty ;
}

#---------------------------------------------------------------------------*

class @metamodelAttributeProperty extends @metamodelProperty {
  @lstring mAttributeTypeName ;
#  @AC_galgasType mAttributeType ;
#--- Error message
  message messageProperty "an attribute property" ;
}

#---------------------------------------------------------------------------*

class @metamodelSingleReferenceProperty extends @metamodelProperty {
  @lstring mReferenceEntityName ;
#--- Error message
  message messageProperty "a single reference property" ;
}

#---------------------------------------------------------------------------*

class @metamodelMultipleReferenceProperty extends @metamodelProperty {
  @lstring mReferenceEntityName ;
  @luint mLowerBound ;
  @luint mHigherBound ; # 0 means no bound
#--- Error message
  message messageProperty "a multiple reference property" ;
}

#---------------------------------------------------------------------------*

class @metamodelMapProperty extends @metamodelProperty {
  @lstring mMapTypeName ;
#--- Error message
  message messageProperty "a map property" ;
}

#---------------------------------------------------------------------------*

class @metamodelSharedMapProperty extends @metamodelProperty {
  @lstring mMapTypeName ;
#--- Error message
  message messageProperty "a shared map property" ;
}

#---------------------------------------------------------------------------*

list @L_propertyPath {
  @lstring mPathElement ;
}

#---------------------------------------------------------------------------*

list @L_ListOfPropertyPathes {
  @L_propertyPath mPath ;
  @location mEndOfPathLocation ;
}

#---------------------------------------------------------------------------*

map @entityPropertyMap {
  @metamodelProperty mProperty ;
  insert insertKey error message "the '%K' property has been already declared in %L" ;
  search searchKey error message "the '%K' property is not declared" ;
}

#---------------------------------------------------------------------------*

map @contextPropertyMap {
  @lstring mTypeName ;
  @bool mIsMap ; # true : map property, false : single reference
  insert insertKey error message "the '%K' context property has been already declared in %L" ;
  search searchKey error message "the '%K' context property is not declared" ;
}

#---------------------------------------------------------------------------*

map @contextParameterMap {
  @L_lstringList mContextParameterList ;
  insert insertKey error message "context parameter are already defined for the '%K' property" ;
  search searchKey error message "the '%K' context property is not declared" ;
}

#---------------------------------------------------------------------------*

map @mapPropertyMap {
  @lstring mTypeName ;
  insert insertKey error message "the '%K' map property has been already declared in %L" ;
  search searchKey error message "the '%K' map property is not declared" ;
}

#---------------------------------------------------------------------------*

map @insertionMap {
  @lstring mIndexName ;
  insert insertKey error message "the attribute is already inserted in the '%K' map" ;
#  search searchKey error message "the '%K' inserted attribute is not declared" ;
}

#---------------------------------------------------------------------------*

map @relationVarMap {
  @lstring mDomainVariableName ;
  insert insertKey error message "the '%K' relation variable has been already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' relation variable is not declared" ;
}

#---------------------------------------------------------------------------*

abstract class @metamodelRelationExpression {
}

#---------------------------------------------------------------------------*

class @metamodelRelationAnd extends @metamodelRelationExpression {
  @metamodelRelationExpression mLeftOperand ;
  @metamodelRelationExpression mRightOperand ;
}

#---------------------------------------------------------------------------*

class @metamodelRelationOr extends @metamodelRelationExpression {
  @metamodelRelationExpression mLeftOperand ;
  @metamodelRelationExpression mRightOperand ;
}

#---------------------------------------------------------------------------*

class @metamodelRelationNot extends @metamodelRelationExpression {
  @metamodelRelationExpression mOperand ;
}

#---------------------------------------------------------------------------*

class @metamodelRelationTrue extends @metamodelRelationExpression {
}

#---------------------------------------------------------------------------*

class @metamodelRelationFalse extends @metamodelRelationExpression {
}

#---------------------------------------------------------------------------*

class @metamodelRelationPrimary extends @metamodelRelationExpression {
  @relationVarMap mRelationVariableMap ;
  @lstring mVariable ;
  @luint mVariableIndex ;
  @lstring mVariableMap ;
  @lstring mDomainName ;
}

#---------------------------------------------------------------------------*

list @metamodelRelationParameterList {
  @lstring mParameter ;
  @luint mParameterIndex ;
  @lstring mDomainVariable ;
}

#---------------------------------------------------------------------------*

class @metamodelRelationDo extends @metamodelRelationExpression {
  @relationVarMap mRelationVariableMap ;
  @metamodelRelationParameterList mParameterList ;
  @L_propertyPath mPath ;
  @lbool mOperationIsAnd ; # Otherwise, is 'or'
}

#---------------------------------------------------------------------------*

map @relationMap {
  @relationVarMap mRelationVarMap ;
  @metamodelRelationExpression mExpression ;
  insert insertKey error message "the '%K' relation property has been already declared in %L" ;
  search searchKey error message "the '%K' relation property is not declared" ;
}

#---------------------------------------------------------------------------*

map @mapEntityMap {
  @lstring mElementEntityName ;
  @lstring mInsertErrorMessage ;
  @lstring mSearchErrorMessage ;
  insert insertKey error message "the '%K' map has been already declared in %L" ;
  search searchKey error message "the '%K' map is not declared" ;
}

#---------------------------------------------------------------------------*

map @mapAndEntityUniqueMap {
  insert insertKey error message "the '%K' entity or map has been already declared in %L" ;
  search searchKey error message "the '%K' entity or map is not declared" ;
}

#---------------------------------------------------------------------------*

map @indexMap {
  @lstring mMapAttributeName ;
  insert insertKey error message "the '%K' map index is already defined in %L" ;
  search searchKey error message "the '%K' map index attribute is not defined" ;
}

#---------------------------------------------------------------------------*

map @entityToImplementMap {
#--- All properties, those defined in super entities and defined in current entity 
  @entityPropertyMap mAllMetamodelPropertyMap ;
#--- Entity is abstract ?
  @bool mIsAbstract ;
#--- Only properties defined in current entity
  @entityPropertyMap mCurrentMetamodelPropertyMap ;
#--- 
  @lstring mSuperEntityName ;
#--- Only constraints defined in current constraint
  @entityPropertyMap mCurrentConstraintPropertyMap ;
#---
  @stringset mSuperEntitySet ;
#--- Constraints defined in current constraint and super constraints
  @entityPropertyMap mAllConstraintPropertyMap ;
#--- All Available properties
  @entityPropertyMap mAllAvailablePropertyMap ;
#--- Access methods
  insert insertKey error message "the '@%K' entity has been already declared in %L" ;
  search searchKey error message "the '@%K' entity is not declared" ;
}

#---------------------------------------------------------------------------*

action generate_metamodel
 ?@entityToImplementMap inEntityMap
 ?@lstring inMetamodelComponentName
 ?@stringset inMultiReferencedEntities
 ?@lstring inRootEntityName
;

#---------------------------------------------------------------------------*

class @typeGalgas_singleEntity extends @AC_galgasType {
  @lstring mEntityName ;
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mEntityName string] ;
  end method ;

#--- Error message
  message messageGalgasType "an entity" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_multipleEntity extends @AC_galgasType {
  @lstring mEntityName ;
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "_listOf_" . [mEntityName  string] ;
  end method ;

#--- Error message
  message messageGalgasType "a list of entities" ;
}

#---------------------------------------------------------------------------*
#                    Liste d'attributs semantiques                          *
#---------------------------------------------------------------------------*

list @typeListeAttributsSemantiques {
  @AC_galgasType mAttributType ;
  @lstring aNomAttribut ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   L I S T    O F    G A L G A S    T Y P E S                              *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeTypesList {
  @AC_galgasType mType ;
  @location mEndOfExpressionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# M E T H O D ,    A C T I O N ,   R O U T I N E    S I G N A T U R E       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_EXsignature {
  @AC_galgasType mType ;
  @formalArgumentPassingMode mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# M E T H O D ,    A C T I O N ,   R O U T I N E    S I G N A T U R E       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_actualParametersSignature {
  @AC_galgasType mType ;
  @actualParametersPassingMode mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A C C E S S O R    M A P                                                *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_accessors_map {
  @L_EXsignature mAccessorSignature ;
  @AC_galgasType mReturnedType ;
  insert insertKey error message "the '%K' accessor has been already declared in %L" ;
  search searchKey error message "the '%K' accessor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   L I S T    O F    S T R I N G S                                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_stringList {
  @string mErrorMessageElement ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    J O K E R    T Y P E                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_jokerInParameterList extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "" ;
  end method ;

#--- Error message
  message messageGalgasType "??" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I T E R A L    T Y P E S                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_bool extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "bool" ;
  end method ;

#--- Error message
  message messageGalgasType "a '@bool' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_string extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "string" ;
  end method ;

#--- By default, class does not accept reader instruction call
  override
  method handleReaderInstructionCall
    ??@lstring unused inReadObjectName
    ??@lstring inReaderName
    !@L_EXsignature outReaderSignature
  :
    if [inReaderName string] == "writeToFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inReaderName: "this reader is not defined" -> outReaderSignature ;
    end if ;
  end method ;

#--- string accepts constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "stringWithSourceFilePath" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithCurrentDirectory" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithMainFirstArgument" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithContentsOfFile" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithCurrentDateTime" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@string' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_sint extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "sint" ;
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructors 'min' and 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "min" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@sint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_sint64 extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "sint64" ;
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructors 'min' and 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "min" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@sint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_uint extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "uint" ;
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if ([inClassMethodName string] == "max") |
       ([inClassMethodName string] == "errorCount") |  
       ([inClassMethodName string] == "warningCount") then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@uint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_uint64 extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "uint64" ;
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@uint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_char extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "char" ;
  end method ;

#--- Error message
  message messageGalgasType "a '@char' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_double extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "double" ;
  end method ;

#--- Error message
  message messageGalgasType "a '@double' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S   P R I M I T I V E    T Y P E S                            *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @C_galgasPrimitiveType extends @AC_galgasType {
  message messageGalgasType "any primitive type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      G A L G A S    L O C A T I O N    T Y P E                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_location extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "location" ;
  end method ;

#--- Objects of this class accept assignment from 'here' keyword
  override method acceptAssignmentFromHere ??@lstring unused inErrorLocation :
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@location' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lstring extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lstring" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_location new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setString" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@lstring' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lchar extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lchar" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_char new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setChar" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_char new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@lchar' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lbool extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lbool" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_bool new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setBool" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_bool new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@lbool' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_luint extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "luint" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_uint new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setUint" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@luint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_luint64 extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "luint64" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_uint64 new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setUint64" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint64 new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@luint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lsint extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lsint" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_sint new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setSint" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_sint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@lsint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lsint64 extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lsint64" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_sint64 new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setSint64" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_sint64 new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@lsint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_ldouble extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "ldouble" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_double new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setDouble" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_double new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message messageGalgasType "a '@ldouble' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R I N G S E T    T Y P E                             *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_stringset extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "stringset" ;
  end method ;

#--- Class accepts constructor call 'emptySet'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "emptySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "setWithString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_string new] ;
      outAccessorTypesList += !t ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "empty" then
      error inClassMethodName : "in GALGAS 1.3.0 and later, use 'emptySet' constructor instead of 'empty' constructor" -> outAccessorTypesList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- stringset accepts operator "+=" call
  override
  method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    @AC_galgasType t := [@typeGalgas_string new] ;
    outParametersList += !t ![@lstring new !""! here] ;
  end method ;

#--- stringset accepts operator "-=" call
  override
  method handleMinusAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    @AC_galgasType t := [@typeGalgas_string new] ;
    outParametersList += !t ![@lstring new !""! here] ;
  end method ;

#--- stringset object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@lstring unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
  :
    @AC_galgasType keyType := [@typeGalgas_string new] ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += !keyType ![@lstring new !"mKey" !here] ; # Unused second argument
    outStyle := [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle] ;
  end method ;

#--- Error message
  message messageGalgasType "a '@stringset' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M E T H O D S    M A P                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodes {
  @L_EXsignature aListeTypesParametres ;
  insert insertKey error message "a reader named '%K' is already declared" ;
  search searchKey error message "there is no reader named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U N D E F I N E D    E X T E R N    T Y P E                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedExternType extends @AC_galgasType {
#--- Galgas class name
  @lstring mGalgasClassName ;

#--- C++ class name
  @lstring mCppClassName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mGalgasClassName string] ;
  end method ;

#--- Message
  message messageGalgasType "an undefined extern type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Extern type constructor map                                          *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_externTypeConstructorMap {
  @typeListeAttributsSemantiques aListeDesAttributs ;
  insert insertKey error message "the '%K' constructor is already declared in %L" ;
  search searchKey error message "the '%K' constructor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    T Y P E                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasExternType extends @typeGalgasUndefinedExternType {
#--- Constructor map
  @M_externTypeConstructorMap mConstructorMap ;

#--- Modifiers map
  @typeTableMethodes mModifiersMap ;  

#--- Readers map
  @typeTableMethodes mReadersInInstructionMap ;  

#--- Attributes for handling operator '+=' call
  @bool mAcceptAddAssignOperatorCall ;
  @typeListeAttributsSemantiques mAddAssignOperatorCallTypeList ;

#--- Constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    [mConstructorMap searchKey !inClassMethodName ?outAccessorTypesList] ;
  end method ;

#--- Handle modifier call : return modifier signature
  override method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifiersMap searchKey !inModifierName ?outModifierSignature] ; 
  end method ;

#--- By default, class does not accept reader instruction call
  override method handleReaderInstructionCall
    ??@lstring unused inReadObjectName
    ??@lstring inReaderName
    !@L_EXsignature outReaderSignature
  :
    [mReadersInInstructionMap searchKey !inReaderName ?outReaderSignature] ;
  end method ;

#--- Handle operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    if not mAcceptAddAssignOperatorCall then
      [super handleAddAssignOperatorCall !inErrorLocation ?outParametersList] ;
    else
      outParametersList := mAddAssignOperatorCallTypeList ;
    end if ;
  end method ;

#--- Message
  message messageGalgasType "an extern type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Terminal symbols map (for using in a syntax component)               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_terminalSymbolsMapForUse {
  @typeListeAttributsSemantiques aListeDesAttributs ;
  insert insertKey error message "the terminal symbol '$%K$' is already declared in %L" ;
  search searchKey, searchKeyGetIndex error message "the terminal symbol '$%K$' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Lexiques map (for using in a syntax component)                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_lexiqueComponents {
  @M_terminalSymbolsMapForUse mTerminalSymbolMap ;
  insert insertKey error message"the '%K' lexique is already declared in %L" ;
  search searchKey error message"the '%K' lexique is not defined" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                   Table des classes declarees 'enavant'                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableEnAvant {
  @AC_galgasType mType ;
  insert insertKey error message "the type '%K' is already declared in %L" ;
  search searchKey error message "the type '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Grammars map                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonterminalSymbolAlts {
  @L_EXsignature mFormalParametersList ;
  @lstring mReturnedEntity ;
  insert insertKey error message "the label '%K' has been already declared in %L" ;
  search searchKey error message "the label '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Semantics entity abstract type                                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_semanticsEntity {
  message messageTypeEntite  "any entity";
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Grammar as semantics entity                                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarForSemantics extends @AC_semanticsEntity {
  @M_nonterminalSymbolAlts mGrammarAltMap ;
  message messageTypeEntite  "a grammar entity";
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of semantics entities                                              *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_semanticsEntitiesForUse  {
  @AC_semanticsEntity aDefEntite ;
  insert insertKey error message "a semantics entity named '%K' is already declared in %L" ;
  search searchKey error message "there is no semantics entity named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   T Y P E S    S Y S T E M    F O R    G R A M M A R    C O M P O N E N T *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_typeForGrammarComponent {
  message typeForGrammarComponentMessage  "any type";
}

#---------------------------------------------------------------------------*

map @M_typesForGrammarComponent {
  @AC_typeForGrammarComponent mType ;
  insert insertKey error message "the '@%K' type is already declared in %L" ;
  search searchKey error message "the '@%K' type is not defined" ;
}

#---------------------------------------------------------------------------*

routine checkSignature_ForGrammarComponent
  ??@L_signature inFormalReferenceSignature
  ??@L_signature inFormalTestedSignature
  ??@location inFormalTestedLocation
  ??@location inFormalReferenceLocation
:
  if [inFormalReferenceSignature length] < [inFormalTestedSignature length] then
    error inFormalTestedLocation : "too much formal parameters (from prototype in " . [inFormalReferenceLocation locationString] . ")" ;
  elsif [inFormalReferenceSignature length] > [inFormalTestedSignature length] then
    error inFormalTestedLocation : "too much formal parameters (from prototype in " . [inFormalReferenceLocation locationString] . ")" ;
  else
    foreach inFormalReferenceSignature (@formalArgumentPassingMode passingMode1 @lstring kType1),
            inFormalTestedSignature  (@formalArgumentPassingMode passingMode2 @lstring kType2) :
      if passingMode1 != passingMode2 then
        error kType2 : "Prototype has " . [passingMode1 formalArgumentMessage] .
                       ", and " . [passingMode1 formalArgumentMessage] . " has been found" ;
      end if ;
      if [kType1 string] != [kType2 string] then
        error kType2 :  "I was expecting the '@" . [kType1 string] . "' type, I have got the '@" . [kType2 string] . "' type" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#         Instruction abstract class for grammar component                  *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_instruction_ForGrammar {
  @location mStartLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Syntax signature                                                   *
#      (sequence of terminal, nonterminal, select and repeat)               *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_ruleSyntaxSignature {
  @AC_instruction_ForGrammar mInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Grammars map                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @L_grammarsMap {
  @M_nonterminalSymbolAlts mStartSymbolParametersMap ;
  insert insertKey error message "the '%K' grammar is already defined in %L" ;
  search searchKey error message "the '%K' grammar is not defined" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T E R M I N A L    S Y M B O L    M A P                                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonterminalSymbolAltsForGrammar {
  @L_signature mFormalParametersList ;
  @lstring mReturnedEntityTypeName ;
  insert insertKey error message "the rule label '%K' has been already declared in %L" ;
  search searchKey error message "the rule label '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Production rules list (for a grammar component)                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_productionRules_ForGrammarComponent {
  @lstring mLeftNonterminalSymbol ;
  @uint mLeftNonterminalSymbolIndex ;
  @L_ruleSyntaxSignature mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#             nonterminal symbols map                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonTerminalSymbolsForGrammar {
  @M_nonterminalSymbolAltsForGrammar mNonterminalSymbolParametersMap ;
  insert insertKey error message "internal insert error" ;
  search searchKey, searchKeyGetIndex error message "internal search error" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of syntax components                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_syntaxComponents {
  @M_nonTerminalSymbolsForGrammar mNonterminalSymbolsMap ;
  @L_productionRules_ForGrammarComponent mProductionRulesList ;
  @lstring mLexiqueComponentName ;
  insert insertKey error message "a syntax component named '%K' is already declared in %L" ;
  search searchKey error message "there is no syntax component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Terminal call instruction (for a grammar component)                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_terminalInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @lstring mTerminalSymbolName ;
  @uint mTerminalSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Nonterminal call instruction (for a grammar component)                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_nonterminalInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @lstring mNonterminalSymbolName ;
  @uint mNonterminalSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# Liste of branches of a 'select' or 'repeat' instruction                   *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_branchList_ForGrammarComponent {
  @L_ruleSyntaxSignature mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   select instruction (for a grammar component)                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_selectInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @L_branchList_ForGrammarComponent mSelectList ;
  @uint mAddedNonterminalmSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   repeat instruction (for a grammar component)                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_repeatInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @L_branchList_ForGrammarComponent mRepeatList ;
  @uint mAddedNonterminalmSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    List of syntax components For Grammar                                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_syntaxComponents_ForGrammar {
  @M_nonTerminalSymbolsForGrammar mNonterminalSymbolsMap ;
  @L_productionRules_ForGrammarComponent mProductionRulesList ;
  @lstring mSyntaxComponentName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Map of entities and metamodels for start symbol labels       *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_startSymbolEntityAndMetamodel {
  @lstring mReturnedEntityName ;
  @lstring mReturnedMetamodelName ;
  insert insertKey error message "the label '%K' has been already declared in %L" ;
  search searchKey error message "the label '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                       Liste d'identificateurs                             *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_identifiers {
  @lstring aIdentificateur ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                   Super classes map of a class                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeSuperClassesMap {
  insert insertKey error message "the class '%K' is already a super class of the current class" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Class inherited messages map                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassInheritedMessagesMap {
  insert insertKey error message "the message '%K' is already declared in %L" ;
  search searchKey error message "the message '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Semantic attributes map                                        *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeSemanticAttributesMap {
  @AC_galgasType mAttributType ;
  insert insertKey error message "an attribut named '%K' is already declared in %L" ;
  search searchKey error message "there is no attribut named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Definition des tables des methodes d'insertion et de recherche         *
#                                                                           *
#---------------------------------------------------------------------------*

list @insertOrSearchMethodList {
  @lstring mMethodName ;
  @string mErrorMessage ;
  @bool mIsGetIndexMethod ;
  @string mShadowErrorMessage ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#             Classe abstract definissant une classe                        *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeDefEntiteUtilisable {
  message messageTypeEntite "any type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    L I S T    T Y P E                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedListType extends @AC_galgasType {
  @lstring mListTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListTypeName string] ;
  end method ;

  message messageGalgasType "an undefined list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I S T    T Y P E                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasListType extends @typeGalgasUndefinedListType {
#--- List of all attributes
  @typeListeAttributsSemantiques mNonExternAttributesList ;
#--- Extract Methods signature (for 'first', 'last', 'popFirst', 'popLast')
  @L_EXsignature mExtractSignature ;
#--- Input Methods signature (for 'prependValue')
  @L_EXsignature mInputSignature ;

#--- list object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@lstring unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
  :
    outForeachList := mNonExternAttributesList ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;
  
#--- Modifiers are 'popFirst' and 'popLast' methods
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "prependValue" then
      outModifierSignature := mInputSignature ;
    elsif ([inModifierName string] == "popFirst") | ([inModifierName string] == "popLast") then
      outModifierSignature := mExtractSignature ;
    else
      error inModifierName: "a list accepts only 'popFirst' and 'popLast' modifiers" -> outModifierSignature ;
    end if ;
  end method ;


#--- List accept 'first' and last' reader in instruction
  override
  method handleReaderInstructionCall
    ??@lstring unused inReadObjectName
    ??@lstring inReaderName
    !@L_EXsignature outReaderSignature
  :
    if ([inReaderName string] != "first") & ([inReaderName string] != "last") then
      error inReaderName: "a list accepts only 'first' and 'last' readers" ;
    end if ;
    outReaderSignature := mExtractSignature ;
  end method ;

#--- list accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := mNonExternAttributesList ;
  end method ;

#--- A list accepts 'emptyList' and 'listWithValue' constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "emptyList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "listWithValue" then
      outAccessorTypesList := mNonExternAttributesList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message messageGalgasType "a list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Definition des tables des methodes de surcharge                *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableBlocsDeTable {
  @L_EXsignature aSignatureDebut ;
  @L_EXsignature aSignatureFin ;
  insert insertKey error message "a block method named '%K' is already declared in %L" ;
  search searchKey error message "there is no block method named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#               Definition d'un type map utilisable                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedMapType extends @AC_galgasType {
  @lstring mMapTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mMapTypeName string] ;
  end method ;

  message messageGalgasType "an undefined map type" ;
}

#---------------------------------------------------------------------------*

map @mapMethodMap {
  @L_EXsignature mMethodSignature ;
  insert insertKey error message "an insert or a search method named '%K' is already declared in %L" ;
  search searchKey error message "there is no insert nor search method named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasMapType extends @typeGalgasUndefinedMapType {
#--- Liste de tous les attributs semantiques not externes
  @typeListeAttributsSemantiques mNonExternAttributesList ;

#--- Table de toutes les methodes de surcharge
  @typeTableBlocsDeTable aTableMethodesSurcharger ;

#--- Insert or Search (modifier) method map
  @mapMethodMap mModifierMethodMap ;

#--- Search (reader) method map
  @mapMethodMap mReaderMethodMap ;

#--- Modifiers are insert methods and (when map defines automaton) search methods
  override
  method handleModifierCall
    ??@lstring unused inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifierMethodMap searchKey !inModifierName ?outModifierSignature] ;
  end method ;

#--- Readers are search methods (when map defines no automaton)
  override
  method handleReaderInstructionCall
    ??@lstring unused inReadObjectName
    ??@lstring inReaderName
    !@L_EXsignature outReaderSignature
  :
    [mReaderMethodMap searchKey !inReaderName ? outReaderSignature] ;
  end method ;


#--- table object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@lstring unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
  :
    @AC_galgasType keyType := [@typeGalgas_lstring new] ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += !keyType ![@lstring new !"???" !here] ; # Unused second argument
    foreach mNonExternAttributesList (@AC_galgasType kAttributType @lstring kNomAttribut) :
      outForeachList += !kAttributType !kNomAttribut ;
    end foreach ;
    outStyle := [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle] ;
  end method ;

#--- A map accepts 'emptyMap' constructor
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if [inClassMethodName string] == "emptyMap" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "mapWithMapToOverride" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgasUndefinedMapType new !mMapTypeName] ![@lstring new !"???" !here] ; # Unused second argument
    elsif [inClassMethodName string] == "empty" then
      error inClassMethodName : "in GALGAS 1.3.0 and later, use 'emptyMap' constructor instead of 'empty' constructor" -> outAccessorTypesList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;
  
  message messageGalgasType "a map type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    T Y P E    " C L A S S "    D E F I N I T I O N                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedClassType extends @AC_galgasType {
  @lstring mClassTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mClassTypeName string] ;
  end method ;

  message messageGalgasType "an undefined class type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasNewClassType extends @typeGalgasUndefinedClassType {
#--- Super classes
  @typeSuperClassesMap mSuperClassMap ;  
}

#---------------------------------------------------------------------------*

class @typeGalgasClassType extends @typeGalgasUndefinedClassType {
#--- class reader map
  @typeTableMethodes mReaderMap ;

#--- Attributes list (those from inherited classes, followed by those from current class)
  @typeListeAttributsSemantiques mNonExternAttributesList ;  

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;  

#--- Table des messages
  @typeClassInheritedMessagesMap mMessagesMap ;

#--- Attributes map (those from inherited classes and those from current class)
  @typeSemanticAttributesMap mNonExternAttributesMap ;

#--- La classe est-elle abstract ?
  @bool mClassIsAbstract ;

#--- Handle method call : return method signature
  override
  method handleReaderInstructionCall
    ??@lstring unused inReadObjectName
    ??@lstring inMethodName
    !@L_EXsignature outMethodSignature
  :
    [mReaderMap searchKey !inMethodName ?outMethodSignature] ;
  end method ;

#--- Class accepts class method call 'new' if it is not abstract
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    if mClassIsAbstract then
      error inClassMethodName : "an abstract class cannot be instancied" -> outAccessorTypesList ;
    elsif [inClassMethodName string] == "new" then
      outAccessorTypesList := mNonExternAttributesList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a class type" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteType extends @AC_semanticsEntity {
  @AC_galgasType aDefType ;

  message messageTypeEntite "a type" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteRoutine extends @AC_semanticsEntity {
  @L_EXsignature aListeArgumentsFormels ;

  message messageTypeEntite "a routine" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   E N T I T Y    T Y P E    I N    I N S T R U C T I O N                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_entityInInstruction extends @AC_galgasType {
  @string mEntityName ;
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := mEntityName ;
  end method ;

#--- Error message
  message messageGalgasType "an entity" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A P    I N D E X    T Y P E    I N    I N S T R U C T I O N           *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_mapIndexInInstruction extends @AC_galgasType {
  @string mMapTypeName ;
#--- Get type name
  override
  method getTypeName !@string outTypeName :
    outTypeName := "" ;
  end method ;
#--- Error message
  message messageGalgasType "a map index" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A P    E N T I T Y    T Y P E    I N    I N S T R U C T I O N         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_mapEntityInInstruction extends @AC_galgasType {
  @string mEntityName ;
  @string mElementTypeName ;
#--- Get type name
  override
  method getTypeName !@string outTypeName :
    outTypeName := mEntityName ;
  end method ;

#--- Handle modifiers
  override
  method handleModifierCall
    ??@lstring inModifiedObjectName
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "insertKey" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      @AC_galgasType t := [@typeGalgas_lstring new] ;
      outModifierSignature += !t ![@formalArgumentPassingMode argumentConstantIn] ;
      t := [@typeGalgas_entityInInstruction new !mElementTypeName] ;
      outModifierSignature += !t ![@formalArgumentPassingMode argumentConstantIn] ;
    elsif [inModifierName string] == "insertKeyAndGetIndex" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      @AC_galgasType t := [@typeGalgas_lstring new] ;
      outModifierSignature += !t ![@formalArgumentPassingMode argumentConstantIn] ;
      t := [@typeGalgas_entityInInstruction new !mElementTypeName] ;
      outModifierSignature += !t ![@formalArgumentPassingMode argumentConstantIn] ;
      t := [@typeGalgas_mapIndexInInstruction new ![inModifiedObjectName string]] ;
      outModifierSignature += !t ![@formalArgumentPassingMode argumentOut] ;
    else
      error inModifierName : "variables of this type only accept 'insertKey' and 'insertKey' modifier calls"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Handle reader instruction call
  override
  method handleReaderInstructionCall
    ??@lstring inReadObjectName
    ??@lstring inReaderName
    !@L_EXsignature outReaderSignature
  :
    if [inReaderName string] == "searchKey" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      @AC_galgasType t := [@typeGalgas_lstring new] ;
      outReaderSignature += !t ![@formalArgumentPassingMode argumentConstantIn] ;
      t := [@typeGalgas_entityInInstruction new !mElementTypeName] ;
      outReaderSignature += !t ![@formalArgumentPassingMode argumentOut] ;
    elsif [inReaderName string] == "searchKeyAndGetIndex" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      @AC_galgasType t := [@typeGalgas_lstring new] ;
      outReaderSignature += !t ![@formalArgumentPassingMode argumentConstantIn] ;
      t := [@typeGalgas_entityInInstruction new !mElementTypeName] ;
      outReaderSignature += !t ![@formalArgumentPassingMode argumentOut] ;
      t := [@typeGalgas_mapIndexInInstruction new ![inReadObjectName string]] ;
      outReaderSignature += !t ![@formalArgumentPassingMode argumentOut] ;
    else
      error inReadObjectName :
       "variables of this type  only accept 'searchKey'  'searchKeyAndGetIndex' reader calls"
       -> outReaderSignature ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a map entity" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    T Y P E                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumMessageMap {
  @L_lstringList mMessageStringList ;
  insert insertKey error message "the '%K' message name is already declared in %L" ;
  search searchKey error message "the '%K' message name is not declared" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_enum extends @AC_galgasType {
#--- Enumeration name
  @lstring mEnumTypeName ;

#--- Enumeration constants map
  @enumConstantMap mEnumConstantesMap ;

#--- Messages map
  @typeEnumMessageMap mMessagesMap ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mEnumTypeName string] ;
  end method ;

#--- Class accepts class method with constant names
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
  :
    [mEnumConstantesMap searchKey !inClassMethodName] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
  end method ;

  message messageGalgasType "an enum type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                 VERIFIER LA COMPATIBILITE DE DEUX TYPES                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkAssignmentTypesCompatibility
  ??@AC_galgasType inFormalType
  ??@AC_galgasType inEffectiveType
  ??@location inErrorLocation
  ??@bool inAcceptPolymorphism
:
  match inFormalType :: inEffectiveType :
  when @typeGalgas_stringset ():: @typeGalgas_stringset () :
  when @typeGalgas_uint ()     :: @typeGalgas_uint () :
  when @typeGalgas_sint ()     :: @typeGalgas_sint () :
  when @typeGalgas_uint64 ()   :: @typeGalgas_uint64 () :
  when @typeGalgas_sint64 ()   :: @typeGalgas_sint64 () :
  when @typeGalgas_char ()     :: @typeGalgas_char () :
  when @typeGalgas_string ()   :: @typeGalgas_string () :
  when @typeGalgas_bool ()     :: @typeGalgas_bool () :
  when @typeGalgas_double()    :: @typeGalgas_double () :
  when @typeGalgas_lbool ()    :: @typeGalgas_lbool () :
  when @typeGalgas_lchar ()    :: @typeGalgas_lchar () :
  when @typeGalgas_luint ()    :: @typeGalgas_luint () :
  when @typeGalgas_lsint ()    :: @typeGalgas_lsint () :
  when @typeGalgas_luint64 ()  :: @typeGalgas_luint64 () :
  when @typeGalgas_lsint64 ()  :: @typeGalgas_lsint64 () :
  when @typeGalgas_ldouble ()  :: @typeGalgas_ldouble () :
  when @typeGalgas_lstring ()  :: @typeGalgas_lstring () :
  when @typeGalgas_location () :: @typeGalgas_location () :

  when @typeGalgasUndefinedListType (@lstring attNomType1) :: @typeGalgasUndefinedListType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the list type '@" . [attNomType1 string] .
                                "', I have got the list type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedMapType (@lstring attNomType1) :: @typeGalgasUndefinedMapType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the map type '@" . [attNomType1 string] .
                              "', I have got the map type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring kNomType1)
    :: @typeGalgasClassType (@lstring kNomType2 * * @typeSuperClassesMap kAncestorClassesMap ...) :
    @bool accept := [kNomType1 string] == [kNomType2 string] ;
    if (not accept) & inAcceptPolymorphism then
      accept := [kAncestorClassesMap hasKey ![kNomType1 string]] ;
    end if ;
    if not accept then
      error inErrorLocation : "I was expecting the class type '@" . [kNomType1 string] .
                              "', I have got the class type '@" . [kNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring attNomType1) :: @typeGalgasUndefinedClassType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the class type '@" . [attNomType1 string] .
                              "', I have got the class type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedExternType (@lstring attNomType1 @lstring attCppClassName1)
    :: @typeGalgasUndefinedExternType (@lstring attNomType2 @lstring attCppClassName2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting an extern variable of extern '@" . [attNomType1 string] .
                               "' type variable, and I got an extern '@" . [attNomType2 string] . "' type variable" ;
    end if ;

  when @typeGalgas_enum (@lstring aTypeName1 * *)
    :: @typeGalgas_enum (@lstring aTypeName2 * *) :
    if [aTypeName1 string] != [aTypeName2 string] then
      error inErrorLocation : "I was expecting an enum variable of  '@" . [aTypeName1 string] .
                                "' type variable, and I got an enum '@" . [aTypeName2 string] . "' type variable" ;
    end if ;

  when @typeGalgas_entityInInstruction (@string kTypeName1)
    :: @typeGalgas_entityInInstruction (@string kTypeName2) :
    if kTypeName1 != kTypeName2 then
      error inErrorLocation : "I was expecting an entity instance of  '@" . kTypeName1 .
                              "' type variable, and I got an entity instance of type '@" . kTypeName2 . "'" ;
    end if ;

  when @typeGalgas_mapIndexInInstruction (@string kPropertyName1)
    :: @typeGalgas_mapIndexInInstruction (@string kPropertyName2) :
    if kPropertyName1 != kPropertyName2 then
      error inErrorLocation : "I was expecting a map index of  '" . kPropertyName1 .
                              "' map property, and I got a map index of '" . kPropertyName2 . "' map property" ;
    end if ;

  else
    error inErrorLocation : [inFormalType messageGalgasType] . " is not compatible with " . [inEffectiveType messageGalgasType]  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VERIFICATION DE COMPATIBILITE ENTRE DEUX SIGNATURES DE METHODE        *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteSignatures
  ??@L_EXsignature signatureReference
  ??@L_EXsignature signatureTestee
  ??@location ouSignalerErreur
:
  if [signatureReference length] < [signatureTestee length] then
    error ouSignalerErreur : "there are too much parameters" ;
  elsif [signatureReference length] > [signatureTestee length] then
    error ouSignalerErreur : "one or more parameters missing" ;
  else 
    foreach signatureReference (@AC_galgasType attTypeG @formalArgumentPassingMode passingMode1),
            signatureTestee (@AC_galgasType attTypeD @formalArgumentPassingMode passingMode2) :
      checkAssignmentTypesCompatibility
         !attTypeG
         !attTypeD
         !ouSignalerErreur
         !false
      ;
      if passingMode1 != passingMode2 then
        error ouSignalerErreur : [passingMode2 formalArgumentMessage] . " is not compatible with " .
                                [passingMode2 formalArgumentMessage] ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     COMMAND LINE INTERFACE OPTION MAP                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_cli_options {
  @lchar mOptionChar ;
  @lstring mOptionString ;
  @lstring mComment ;
  @uint mDefaultValue ;
  insert insertKey error message "the '%K' command line option has been already declared in %L" ;
  search searchKey error message "the '%K' command line option is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of option components                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_optionComponents {
  @M_cli_options mBoolOptionsMap ;
  @M_cli_options mUintOptionsMap ;
  @M_cli_options mStringOptionsMap ;
  insert insertKey error message "the '%K' option component named is already declared in %L" ;
  search searchKey error message "there is no '%K' option component" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          Grammar component map                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_grammarComponents {
  @M_nonterminalSymbolAltsForGrammar mNonterminalSymbolParametersMap ;
  @lstring mLexiqueName ;
  @M_optionComponents mOptionsMap ;
  insert insertKey error message "the '%K' grammar component has been already declared in %L" ;
  search searchKey error message "the '%K' grammar component is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of semantics components                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_semanticsComponents {
  @ModelMap mModelMap ; # The types and classes declared in this component
  @ActionMap mActionMap ; # The routines and the extern actions declared in this component 
  @stringset mImportedSemanticsComponents ; # The other semantics components imported in this component
  @stringset mImportedMetamodelComponents ; # The metamodel components imported in this component
  @stringset mImportedOptionsComponents ; # The option components imported in this component
  @M_optionComponents mOptionsComponents ; # The option components imported in this component (OLD STYLE)
  @M_semanticsEntitiesForUse mSemanticsEntitiesMap ; # OLD STYLE MAP
  insert insertKey error message "a semantics component named '%K' is already declared in %L" ;
  search searchKey error message "there is no semantics component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of metamodels components                                           *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_metamodelsComponents {
  @lstring mRootEntity ;
  @entityToImplementMap mEntityMap ;
  @stringset mMultiReferencedEntities ;
  insert insertKey error message "a metamodel component named '%K' is already declared in %L" ;
  search searchKey error message "there is no metamodel component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of constraints components                                          *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_constraintComponents {
  @lstring mMetamodel ;
  insert insertKey error message "a constraint component named '%K' is already declared in %L" ;
  search searchKey error message "there is no constraint component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              List of attributes for GUI description                       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_nibAndClassList {
  @lstring mValue ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   H A N D L E    @ S T R I N G    R E A D E R    C A L L                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleStringReaderCall
  ??@lstring inMethodName
  !@typeListeAttributsSemantiques outAccessorTypesList
  !@AC_galgasType outReturnedType
:
  if [inMethodName string] == "length" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inMethodName string] == "fileExists" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inMethodName string] == "characterAtIndex" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # First @string argument
    outReturnedType := [@typeGalgas_char new] ;
  elsif [inMethodName string] == "pathExtension" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inMethodName string] == "lastPathComponent" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inMethodName string] == "stringByDeletingPathExtension" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inMethodName string] == "stringByCapitalizingFirstCharacter" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inMethodName string] == "firstCharacterOrNul" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_char new] ;
  elsif [inMethodName string] == "stringByDeletingLastPathComponent" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inMethodName string] == "stringByReplacingStringByString" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # First @string argument
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # Second @string argument
  else
    error inMethodName : "this reader is not defined"
     -> outAccessorTypesList, outReturnedType ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   H A N D L E    R E A D E R    C A L L    I N    E X P R E S S I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleReaderCall
  ??@AC_galgasType inReceiverType
  ??@lstring inMethodName
  !@typeListeAttributsSemantiques outAccessorTypesList
  !@AC_galgasType outReturnedType
:
  if [inMethodName string] == "description" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
  else
    extract inReceiverType :
    when @typeGalgas_string () ->
      handleStringReaderCall !inMethodName ?outAccessorTypesList ?outReturnedType ;
    when @typeGalgas_lstring () ->
      if [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else # Inherited @ string reader ?
        handleStringReaderCall !inMethodName ?outAccessorTypesList ?outReturnedType ;
      end if ;
    when @typeGalgas_location () ->
      if [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_uint () ->
      if [inMethodName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inMethodName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inMethodName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_uint64 () ->
      if [inMethodName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inMethodName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inMethodName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_sint () ->
      if [inMethodName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inMethodName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inMethodName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_sint64 () ->
      if [inMethodName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inMethodName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inMethodName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_lchar () ->
      if [inMethodName string] == "char" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      elsif [inMethodName string] == "value" then
        warning inMethodName:"in GALGAS 1.4.1 and later, the 'value' reader of @lchar type  is deprecated; use 'char' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_lbool () ->
      if [inMethodName string] == "bool" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inMethodName string] == "value" then
        warning inMethodName:"in GALGAS 1.4.1 and later, the 'value' reader of @lbool type  is deprecated; use 'bool' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_luint ()->
      if [inMethodName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inMethodName string] == "value" then
        warning inMethodName:"in GALGAS 1.4.1 and later, the 'value' of @luint type  reader is deprecated; use 'uint' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_luint64 ()->
      if [inMethodName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_lsint () ->
      if [inMethodName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inMethodName string] == "value" then
        warning inMethodName:"in GALGAS 1.4.1 and later, the 'value' reader of @lsint type  is deprecated; use 'sint' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_lsint64 () ->
      if [inMethodName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_ldouble () ->
      if [inMethodName string] == "double" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_double new] ;
      elsif [inMethodName string] == "value" then
        warning inMethodName:"in GALGAS 1.4.1 and later, the 'value' reader of @ldouble type  is deprecated; use 'double' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_double new] ;
      elsif [inMethodName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inMethodName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inMethodName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgasListType (...) ->
      if [inMethodName string] == "length" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inMethodName :
           "list supports only 'length' reader call" -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgasMapType (...) ->
      if [inMethodName string] == "hasKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        @AC_galgasType keyType := [@typeGalgas_string new] ;
        outAccessorTypesList += !keyType ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inMethodName string] == "count" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inMethodName string] == "allKeys" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_stringset new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgas_stringset () ->
      if [inMethodName string] == "hasKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        @AC_galgasType keyType := [@typeGalgas_string new] ;
        outAccessorTypesList += !keyType ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inMethodName string] == "count" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inMethodName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when @typeGalgasClassType (* * @typeListeAttributsSemantiques kNonExternAttributesList * @typeClassInheritedMessagesMap kMessagesMap * *) ->
      outReturnedType := [@typeGalgas_string new] ;
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      if not [kMessagesMap hasKey ![inMethodName string]] then
      #--- Search for attribute
        @bool found := false ;
        foreach kNonExternAttributesList (@AC_galgasType kAttributType @lstring kNomAttribut) while not found :
          outReturnedType := kAttributType ;
          found := [inMethodName string] == [kNomAttribut string] ;
        end foreach ;
        if not found then
          error inMethodName: "this reader is not defined (you can name as class reader class attributes and class messages)" ;
        end if ;
      end if ;
    when @typeGalgas_enum (* * @typeEnumMessageMap kMessagesMap) ->
      [kMessagesMap searchKey !inMethodName ?*] ;
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ; #--- No argument
      outReturnedType := [@typeGalgas_string new] ;
    else
      error inMethodName :
         "variables of this type do not support reader call"
         -> outAccessorTypesList, outReturnedType ;
    end extract ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

action check_KL_escapeCharacters
 ?@lstring inString
;

#---------------------------------------------------------------------------*

action check_K_escapeCharacters
 ?@lstring inString
;

#---------------------------------------------------------------------------*

routine importSemanticsComponent
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioActionMap
  ?!@stringset ioAlreadyImportedSemanticsComponents
  ?!@stringset ioAlreadyImportedMetamodelComponents
  ?@lstring inSemanticsComponentName
:
  if not [ioAlreadyImportedSemanticsComponents hasKey ![inSemanticsComponentName string]] then
    @ModelMap modelMap ; # The types and classes declared in this component
    @ActionMap actionMap ; # The routines and the extern actions declared in this component 
    @stringset importedSemanticsComponents ; # The other semantics components imported in this component
    @stringset importedMetamodelComponents ; # The metamodel components imported in this component
    @stringset importedOptionsComponents ; # The option components imported in this component
    [ioSemanticsComponentsMap searchKey
      !inSemanticsComponentName
      ?modelMap
      ?actionMap
      ?importedSemanticsComponents
      ?importedMetamodelComponents
      ?importedOptionsComponents
      ?*
      ?*
    ] ;
  #--- Add Imported metamodels
    ioAlreadyImportedMetamodelComponents := ioAlreadyImportedMetamodelComponents | importedMetamodelComponents ;
  #--- Recursively import other semantics components
    foreach importedSemanticsComponents (@string kKey) :
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioMetamodelComponentMap
        !?ioModelMap
        !?ioActionMap
        !?ioAlreadyImportedSemanticsComponents
        !?ioAlreadyImportedMetamodelComponents
        ![@lstring new !kKey !here]
      ;
    end foreach ;
  #--- Add imported types
    foreach modelMap (@lstring kKey @TypeModel kType) :
      if not [ioModelMap hasKey ![kKey string]] then
        [!?ioModelMap insertKey !kKey !kType] ;
      end if ;
    end foreach ;
  #--- Add actions
    foreach actionMap (@lstring kKey @L_signature kSignature @bool kIsExtern) :
      if not [ioActionMap hasKey ![kKey string]] then
        [!?ioActionMap insertKey !kKey !kSignature !kIsExtern] ;
      end if ;
    end foreach ;
  #--- Flag component as imported
    ioAlreadyImportedSemanticsComponents += ![inSemanticsComponentName string] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine computeRepresentativeEntityName
  ??@entityToImplementMap inMetamodelEntityMap
  ??@entityToImplementMap inConstrainedEntityMap
  ??@lstring inEntityName
  !@lstring outRepresentativeEntityName
:
  outRepresentativeEntityName := [@lstring new !"" !here] ;
  @lstring searchedEntity := inEntityName ;
  loop [inMetamodelEntityMap count] + 1 :
  while ([outRepresentativeEntityName string] == "") & ([searchedEntity string] != "") do
    if [inConstrainedEntityMap hasKey ![searchedEntity string]] then
      outRepresentativeEntityName := searchedEntity ;
    else
      @lstring superEntity ;
      [inMetamodelEntityMap searchKey !searchedEntity ?* ?* ?* ?superEntity ?* ?* ?* ?*] ;
      searchedEntity := superEntity ;
    end if ;
  end loop ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   L O G G I N G    O B J E C T S    I N    P R O G R A M                  *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @loggableObject {
}

#---------------------------------------------------------------------------*

class @loggableMetamodel extends @loggableObject {
  @lstring mMetamodelName ;
}

#---------------------------------------------------------------------------*

class @loggableAttribute extends @loggableObject {
  @lstring mAttributeName ;
}

#---------------------------------------------------------------------------*

class @loggableConstraint extends @loggableObject {
  @lstring mMetamodelName ;
  @lstring mConstraintName ;
}

#---------------------------------------------------------------------------*

list @loggableObjectList {
  @loggableObject mLoggableObject ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Grammar descriptor (for program component)                   *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_grammarDescriptorForProgram {
  @string mGrammarPostfix ;
  @lstring mGrammarName ;
  @L_signature mStartSymbolSignature ;
  @L_lstringList mStartSymbolAttributesList ;
  @lstring mLexiqueClassName ;
  @lstring mReturnedMetamodelName ;
  @lstring mReturnedRootEntityName ;
  @L_lstringList mConstraintsForMetamodel ;
  @lstring mSourceExtension ;
  @string mHelpMessage ;
  @M_optionComponents mOptionsComponentsMap ;
  @loggableObjectList mLoggableObjectList ;
}

#---------------------------------------------------------------------------*

end semantics ;
