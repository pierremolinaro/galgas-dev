//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'grammarCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 20th, 2009, at 15h5'39"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "grammarCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_nonTerminalMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_nonTerminalMap::e_nonTerminalMap (void) :
mLabels (),
mHasParseLabel () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@nonTerminalMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nonTerminalMap::
elementOf_GGS_nonTerminalMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_nonTerminalMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonTerminalMap::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasParseLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonTerminalMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_nonTerminalMap * ptr = dynamic_cast <const elementOf_GGS_nonTerminalMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLabels.operator_isEqual (ptr->mInfo.mLabels)).boolValue ()
           && (mInfo.mHasParseLabel.operator_isEqual (ptr->mInfo.mHasParseLabel)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_nonTerminalMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_nonTerminalMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_nonTerminalMap * info = (e_nonTerminalMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_nonTerminalMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_nonTerminalMap * info = (e_nonTerminalMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalMap GGS_nonTerminalMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_nonTerminalMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonTerminalMap::
operator_isEqual (const GGS_nonTerminalMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonTerminalMap::
operator_isNotEqual (const GGS_nonTerminalMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_nonTerminalLabelList & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_nonTerminalMap info  ;
    info.mLabels = inParameter0 ;
    info.mHasParseLabel = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_nonTerminalLabelList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mLabels ;
    outParameter1 = node->mInfo.mHasParseLabel ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonTerminalMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_nonTerminalLabelList   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonTerminalMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_nonTerminalLabelList & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalMap GGS_nonTerminalMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_nonTerminalMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalMap GGS_nonTerminalMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_nonTerminalMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @nonTerminalMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_nonTerminalLabelList  & GGS_nonTerminalMap::cEnumerator::_mLabels (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLabels ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_nonTerminalMap::cEnumerator::_mHasParseLabel (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasParseLabel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "handleNonTerminalDeclarations"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleNonTerminalDeclarations (C_Compiler & inLexique,
                                GGS_nonTerminalMap  & var_cas_outNonTerminalMap,
                                const GGS_nonterminalDeclarationList   var_cas_inNonterminalDeclarationList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleNonTerminalDeclarations at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outNonTerminalMap = GGS_nonTerminalMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_nonterminalDeclarationList::cEnumerator enumerator_2978 (var_cas_inNonterminalDeclarationList, true) ;
    const GGS_nonterminalDeclarationList::cElement * operand_2978 = NULL ;
    while (((operand_2978 = enumerator_2978.nextObject ()))) {
      macroValidPointer (operand_2978) ;
      if ((var_cas_outNonTerminalMap.reader_hasKey (inLexique, operand_2978->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (54)) COMMA_SOURCE_FILE_AT_LINE (54))).isBuiltAndTrue ()) {
        GGS_nonTerminalLabelList  var_cas_labels ;
        GGS_bool var_cas_hasParseLabel ;
        const GGS_nonTerminalMap  temp_3147 = var_cas_outNonTerminalMap ;
        if (temp_3147.isBuilt ()) {
          temp_3147 (HERE)->method_searchKey (inLexique, operand_2978->mNonterminalName, var_cas_labels, var_cas_hasParseLabel COMMA_SOURCE_FILE_AT_LINE (57)) ;
        }
        if (((operand_2978->mHasParseLabel).operator_and ((var_cas_hasParseLabel).operator_not ())).isBuiltAndTrue ()) {
          operand_2978->mNonterminalName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this declaration has a 'parse' label, but declaration of the same non terminal in ")).operator_concat (var_cas_outNonTerminalMap.reader_locationForKey (inLexique, operand_2978->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (65)) COMMA_SOURCE_FILE_AT_LINE (65)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (65)))).operator_concat (GGS_string (" does not have a 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (67)) ;
        }else if ((((operand_2978->mHasParseLabel).operator_not ()).operator_and (var_cas_hasParseLabel)).isBuiltAndTrue ()) {
          operand_2978->mNonterminalName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this declaration has no 'parse' label, but declaration of the same non terminal in ")).operator_concat (var_cas_outNonTerminalMap.reader_locationForKey (inLexique, operand_2978->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (69)) COMMA_SOURCE_FILE_AT_LINE (69)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (69)))).operator_concat (GGS_string (" has a 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (71)) ;
        }
        if (((var_cas_labels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (73))).operator_isNotEqual (operand_2978->mLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (73)))).isBuiltAndTrue ()) {
          operand_2978->mNonterminalName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("this declaration names ")).operator_concat (operand_2978->mLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (75)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (75)))).operator_concat (GGS_string (" labels, but declaration of the same non terminal in "))).operator_concat (var_cas_outNonTerminalMap.reader_locationForKey (inLexique, operand_2978->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (77)) COMMA_SOURCE_FILE_AT_LINE (77)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (77)))).operator_concat (GGS_string (" names"))).operator_concat (var_cas_labels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (79)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (79)))).operator_concat (GGS_string (" labels.")) COMMA_SOURCE_FILE_AT_LINE (82)) ;
        }else{
          {
            GGS_nonTerminalLabelList::cEnumerator enumerator_4333 (operand_2978->mLabels, true) ;
            const GGS_nonTerminalLabelList::cElement * operand_4333 = NULL ;
            GGS_nonTerminalLabelList::cEnumerator enumerator_4341 (var_cas_labels, true) ;
            const GGS_nonTerminalLabelList::cElement * operand_4341 = NULL ;
            while (((operand_4333 = enumerator_4333.nextObject ()))
                && ((operand_4341 = enumerator_4341.nextObject ()))) {
              macroValidPointer (operand_4333) ;
              macroValidPointer (operand_4341) ;
              if (((operand_4333->mLabelName).operator_isNotEqual (operand_4341->mLabelName)).isBuiltAndTrue ()) {
                operand_4333->mLabelName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this label should be identical to the label '")).operator_concat (operand_4341->mLabelName)).operator_concat (GGS_string ("' declared in "))).operator_concat (operand_4341->mLabelName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (88)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (88))) COMMA_SOURCE_FILE_AT_LINE (90)) ;
              }
              {
                GGS_formalParameterList::cEnumerator enumerator_4700 (operand_4333->mFormalParameters, true) ;
                const GGS_formalParameterList::cElement * operand_4700 = NULL ;
                GGS_formalParameterList::cEnumerator enumerator_4718 (operand_4341->mFormalParameters, true) ;
                const GGS_formalParameterList::cElement * operand_4718 = NULL ;
                while (((operand_4700 = enumerator_4700.nextObject ()))
                    && ((operand_4718 = enumerator_4718.nextObject ()))) {
                  macroValidPointer (operand_4700) ;
                  macroValidPointer (operand_4718) ;
                  if (((operand_4700->mFormalParameterPassingMode).operator_isNotEqual (operand_4718->mFormalParameterPassingMode)).isBuiltAndTrue ()) {
                    operand_4700->mFormalParameterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((GGS_string ("the passing mode (")).operator_concat (operand_4700->mFormalParameterPassingMode.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (98)))).operator_concat (GGS_string (") for this parameter should be identical to the passing mode ("))).operator_concat (operand_4718->mFormalParameterPassingMode.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (100)))).operator_concat (GGS_string (") of the parameter declared in"))).operator_concat (operand_4341->mLabelName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (102)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (102))) COMMA_SOURCE_FILE_AT_LINE (104)) ;
                  }
                  if (((operand_4700->mFormalParameterName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (105))).operator_isNotEqual (operand_4718->mFormalParameterTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (105)))).isBuiltAndTrue ()) {
                    operand_4700->mFormalParameterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this type name should be identical to the '@")).operator_concat (operand_4341->mLabelName)).operator_concat (GGS_string ("' type name used in "))).operator_concat (operand_4341->mLabelName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (109)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (109))) COMMA_SOURCE_FILE_AT_LINE (111)) ;
                  }
                }
              }
            }
          }
        }
      }else{
        var_cas_outNonTerminalMap.modifier_insertKey (inLexique, operand_2978->mNonterminalName, operand_2978->mLabels, operand_2978->mHasParseLabel COMMA_SOURCE_FILE_AT_LINE (116)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleNonTerminalDeclarations\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@syntaxInstruction.buildSyntaxInstructionList'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList> gDispatchTableForMethod__syntaxInstruction__buildSyntaxInstructionList ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList (typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList inRoutine,
                     const sint32 inClassID) {
  gDispatchTableForMethod__syntaxInstruction__buildSyntaxInstructionList.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList
findCategoryMethod__syntaxInstruction__buildSyntaxInstructionList (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__syntaxInstruction__buildSyntaxInstructionList.count ()) {
    result = gDispatchTableForMethod__syntaxInstruction__buildSyntaxInstructionList (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__syntaxInstruction__buildSyntaxInstructionList (superClassPtr) ;
      gDispatchTableForMethod__syntaxInstruction__buildSyntaxInstructionList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticInstruction.buildSyntaxInstructionList'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_semanticInstruction * operand_6520,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6520 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@nonterminalCallInstruction.buildSyntaxInstructionList'  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__nonterminalCallInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_nonterminalCallInstruction * operand_6744,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6744 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@terminalCheckInstruction.buildSyntaxInstructionList'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__terminalCheckInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_terminalCheckInstruction * operand_7004,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7004 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@repeatInstruction.buildSyntaxInstructionList'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__repeatInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_repeatInstruction * operand_7257,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7257 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@selectInstruction.buildSyntaxInstructionList'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__selectInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_selectInstruction * operand_7472,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7472 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@parseDoInstruction.buildSyntaxInstructionList'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseDoInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_parseDoInstruction * operand_7688,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7688 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@blockInstruction.buildSyntaxInstructionList'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__blockInstruction__buildSyntaxInstructionList (C_Compiler &,
                                const cPtr_blockInstruction * operand_7902,
                                GGS_syntaxInstructionList  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7902 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildSyntaxInstructionList"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSyntaxInstructionList (C_Compiler & inLexique,
                                const GGS_syntaxInstructionList   var_cas_inInstructionList,
                                GGS_syntaxInstructionList  & var_cas_outSyntaxInstructionList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSyntaxInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outSyntaxInstructionList = GGS_syntaxInstructionList ::constructor_emptyList () ;
  {
    GGS_syntaxInstructionList::cEnumerator enumerator_8595 (var_cas_inInstructionList, true) ;
    const GGS_syntaxInstructionList::cElement * operand_8595 = NULL ;
    while (((operand_8595 = enumerator_8595.nextObject ()))) {
      macroValidPointer (operand_8595) ;
      const GGS_syntaxInstruction  temp_8643 = operand_8595->mInstruction ;
      if (temp_8643.isBuilt ()) {
        typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList method = findCategoryMethod__syntaxInstruction__buildSyntaxInstructionList (temp_8643.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_8643 (HERE), var_cas_outSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (196)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSyntaxInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "handleRules"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleRules (C_Compiler & inLexique,
                                const GGS_syntaxRuleList   var_cas_inRuleList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleRules at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_syntaxRuleList::cEnumerator enumerator_9172 (var_cas_inRuleList, true) ;
    const GGS_syntaxRuleList::cElement * operand_9172 = NULL ;
    while (((operand_9172 = enumerator_9172.nextObject ()))) {
      macroValidPointer (operand_9172) ;
      GGS_syntaxInstructionList  var_cas_instructionList ;
      GGS_lstring  automatic_var_0 ;
      GGS_formalParameterList  automatic_var_1 ;
      const GGS_syntaxRuleLabelList  temp_9314 = operand_9172->mLabelList ;
      if (temp_9314.isBuilt ()) {
        temp_9314 (HERE)->method_first (inLexique, automatic_var_0, automatic_var_1, var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (213)) ;
      }
      GGS_syntaxInstructionList  var_cas_syntaxInstructionList ;
      ::routine_buildSyntaxInstructionList (inLexique,  var_cas_instructionList,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (215)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleRules\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileGrammarComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_grammarComponentRoot  var_cas_grammarComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    grammarLL1grammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_grammarComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (228)) ;
  }
  GGS_lstring  var_cas_componentName ;
  var_cas_componentName = var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (230)) ;
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (231)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (231)) ;
  if (((var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (232))).operator_isNotEqual (var_cas_basename)).isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (234)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (236)) ;
  }
  GGS_string var_cas_lexiqueComponent ;
  var_cas_lexiqueComponent = GGS_string ("") ;
  {
    GGS_lstringlist::cEnumerator enumerator_10377 (var_cas_grammarComponentRoot.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (240)), true) ;
    const GGS_lstringlist::cElement * operand_10377 = NULL ;
    while (((operand_10377 = enumerator_10377.nextObject ()))) {
      macroValidPointer (operand_10377) ;
      if (((operand_10377->mValue.ggs_string ().reader_pathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (241))).operator_isNotEqual (GGS_string ("gSyntax"))).isBuiltAndTrue ()) {
        operand_10377->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a syntax component file should have '.gSyntax' as path extension") COMMA_SOURCE_FILE_AT_LINE (243)) ;
      }else{
        GGS_string var_cas_syntaxComponentName ;
        var_cas_syntaxComponentName = operand_10377->mValue.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (244)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (244)) ;
        GGS_syntaxComponentRoot  var_cas_syntaxComponentRoot ;
        if ((var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (246)).reader_hasKey (inLexique, var_cas_syntaxComponentName COMMA_SOURCE_FILE_AT_LINE (246))).isBuiltAndTrue ()) {
          const GGS_parsedSyntaxComponentMap  temp_10879 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (247)) ;
          if (temp_10879.isBuilt ()) {
            temp_10879 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, GGS_location (inLexique) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (247)) ;
          }
        }else{
          GGS_string var_cas_sourceFilePath ;
          var_cas_sourceFilePath = operand_10377->mValue.ggs_string ().reader_absolutePathFromPath (inLexique, var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (249)) COMMA_SOURCE_FILE_AT_LINE (249)) ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            syntaxSLRgrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_sourceFilePath, operand_10377->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (250)) COMMA_HERE),
                                          var_cas_syntaxComponentRoot
                                          COMMA_SOURCE_FILE_AT_LINE (250)) ;
          }
          var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, operand_10377->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (251)) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (251)) ;
        }
        GGS_string var_cas_currentLexiqueName ;
        var_cas_currentLexiqueName = var_cas_syntaxComponentRoot.reader_mImportedLexiqueReference (inLexique COMMA_SOURCE_FILE_AT_LINE (254)).ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (254)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (254)) ;
        if (((var_cas_lexiqueComponent).operator_isEqual (GGS_string (""))).isBuiltAndTrue ()) {
          var_cas_lexiqueComponent = var_cas_currentLexiqueName ;
        }else if (((var_cas_lexiqueComponent).operator_isNotEqual (var_cas_currentLexiqueName)).isBuiltAndTrue ()) {
          operand_10377->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this syntax component uses '")).operator_concat (var_cas_currentLexiqueName)).operator_concat (GGS_string ("' lexique component, but the first syntax component uses the '"))).operator_concat (var_cas_lexiqueComponent)).operator_concat (GGS_string ("' lexique component (they should be the same)")) COMMA_SOURCE_FILE_AT_LINE (261)) ;
        }
        GGS_nonTerminalMap  var_cas_nonTerminalMap ;
        ::routine_handleNonTerminalDeclarations (inLexique,  var_cas_nonTerminalMap,  var_cas_syntaxComponentRoot.reader_mNonterminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (266)) COMMA_SOURCE_FILE_AT_LINE (264)) ;
        ::routine_handleRules (inLexique,  var_cas_syntaxComponentRoot.reader_mRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (270)) COMMA_SOURCE_FILE_AT_LINE (269)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_grammarCompilation (void) {
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__semanticInstruction__buildSyntaxInstructionList, gClassInfoFor__semanticInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__nonterminalCallInstruction__buildSyntaxInstructionList, gClassInfoFor__nonterminalCallInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__terminalCheckInstruction__buildSyntaxInstructionList, gClassInfoFor__terminalCheckInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__repeatInstruction__buildSyntaxInstructionList, gClassInfoFor__repeatInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__selectInstruction__buildSyntaxInstructionList, gClassInfoFor__selectInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__parseDoInstruction__buildSyntaxInstructionList, gClassInfoFor__parseDoInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildSyntaxInstructionList ((typeCategoryMethod__syntaxInstruction__buildSyntaxInstructionList) category_method__blockInstruction__buildSyntaxInstructionList, gClassInfoFor__blockInstruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_grammarCompilation (prologueRoutineFor_grammarCompilation,
                                   NULL) ;

//---------------------------------------------------------------------------*

