//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'grammarCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 21th, 2010, at 17h23'43"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "grammarCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "transformLabelMap"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis  function_transformLabelMap (C_Compiler & inLexique,
                                const GGS_nonTerminalLabelListAST   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_transformLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis = GGS_nonterminalSymbolLabelMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (37)) ;
  {
    GGS_nonTerminalLabelListAST::cEnumerator enumerator_2194 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelListAST::cElement * operand_2194 = NULL ;
    while (((operand_2194 = enumerator_2194.nextObject ()))) {
      macroValidPointer (operand_2194) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList = GGS_signatureForGrammarAnalysis ::constructor_emptyList () ;
      {
        GGS_formalParameterListAST::cEnumerator enumerator_2297 (operand_2194->mFormalArgumentList, true) ;
        const GGS_formalParameterListAST::cElement * operand_2297 = NULL ;
        while (((operand_2297 = enumerator_2297.nextObject ()))) {
          macroValidPointer (operand_2297) ;
          var_cas_formalParametersList.addAssign_operation (operand_2297->mFormalArgumentPassingMode, operand_2297->mFormalArgumentTypeName) ;
        }
      }
      var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_2194->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (43)) ;
    }
  }
  const GGS_bool cond_2742 = var_cas_inHasParseLabel ;
  if (cond_2742.isBuiltAndTrue ()) {
    var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("parse"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (50)), GGS_signatureForGrammarAnalysis ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (49)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_transformLabelMap\n") ;
  #endif
  return var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_transformLabelMap (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_nonTerminalLabelListAST  arg_0 = GGS_nonTerminalLabelListAST ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_1 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_nonterminalSymbolLabelMapForGrammarAnalysis  result = function_transformLabelMap (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_transformLabelMap [2] = {& kTypeDescriptor_GGS_nonTerminalLabelListAST ,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_transformLabelMap ("transformLabelMap",
                              functionForGenericCall_transformLabelMap,
                              & kTypeDescriptor_GGS_nonterminalSymbolLabelMapForGrammarAnalysis ,
                              2,
                              kArgumentTypeList_transformLabelMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "checkLabelMap"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkLabelMap (C_Compiler & inLexique,
                                const GGS_location   var_cas_inNonTerminalLocation,
                                const GGS_nonTerminalLabelListAST   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel,
                                const GGS_location   var_cas_inOriginalNonTerminalLocation,
                                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis   var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_stringset  var_cas_labelStringSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_nonTerminalLabelListAST::cEnumerator enumerator_3166 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelListAST::cElement * operand_3166 = NULL ;
    while (((operand_3166 = enumerator_3166.nextObject ()))) {
      macroValidPointer (operand_3166) ;
      var_cas_labelStringSet.addAssign_operation (operand_3166->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (68))) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList ;
      if (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.isBuilt ()) {
        var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, operand_3166->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (70)) ;
      }
      const GGS_bool cond_3913 = (operand_3166->mFormalArgumentList.reader_length ()).operator_isNotEqual (var_cas_formalParametersList.reader_length ()) ;
      if (cond_3913.isBuiltAndTrue ()) {
        operand_3166->mLabelName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((((operand_3166->mFormalArgumentList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (72))).operator_concat (GGS_string (" formal parameter"))).operator_concat ((((operand_3166->mFormalArgumentList.reader_length ()).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string (""))))).operator_concat (GGS_string (" declared here, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3166->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (76)) COMMA_SOURCE_FILE_AT_LINE (76)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (76)))).operator_concat (GGS_string ("names "))).operator_concat (var_cas_formalParametersList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (77)))).operator_concat (GGS_string ("parameter"))).operator_concat ((((var_cas_formalParametersList.reader_length ()).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string ("")))) COMMA_SOURCE_FILE_AT_LINE (79)) ;
      }else if (cond_3913.isBuiltAndFalse ()) {
        {
          GGS_formalParameterListAST::cEnumerator enumerator_3947 (operand_3166->mFormalArgumentList, true) ;
          const GGS_formalParameterListAST::cElement * operand_3947 = NULL ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_3969 (var_cas_formalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_3969 = NULL ;
          while (((operand_3947 = enumerator_3947.nextObject ()))
              && ((operand_3969 = enumerator_3969.nextObject ()))) {
            macroValidPointer (operand_3947) ;
            macroValidPointer (operand_3969) ;
            const GGS_bool cond_4529 = (operand_3969->mFormalArgumentPassingModeForGrammarAnalysis).operator_isNotEqual (operand_3947->mFormalArgumentPassingMode) ;
            if (cond_4529.isBuiltAndTrue ()) {
              operand_3969->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared with ")).operator_concat (operand_3969->mFormalArgumentPassingModeForGrammarAnalysis.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (84)))).operator_concat (GGS_string (" passing mode, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3166->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (86)) COMMA_SOURCE_FILE_AT_LINE (86)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (86)))).operator_concat (GGS_string (" is declared with "))).operator_concat (operand_3947->mFormalArgumentPassingMode.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (87)))).operator_concat (GGS_string (" passing mode")) COMMA_SOURCE_FILE_AT_LINE (88)) ;
            }
            const GGS_bool cond_5023 = (operand_3969->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (89))).operator_isNotEqual (operand_3947->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (89))) ;
            if (cond_5023.isBuiltAndTrue ()) {
              operand_3969->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared of '@")).operator_concat (operand_3969->mGalgasTypeNameForGrammarAnalysis)).operator_concat (GGS_string ("' type, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3166->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (94)) COMMA_SOURCE_FILE_AT_LINE (94)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (94)))).operator_concat (GGS_string (" is declared with '@"))).operator_concat (operand_3947->mFormalArgumentTypeName)).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (96)) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_5458 = var_cas_inHasParseLabel ;
  if (cond_5458.isBuiltAndTrue ()) {
    var_cas_labelStringSet.addAssign_operation (GGS_string ("parse")) ;
    const GGS_bool cond_5447 = (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_hasKey (GGS_string ("parse"))).operator_not () ;
    if (cond_5447.isBuiltAndTrue ()) {
      var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this non terminal is declared with 'parse' label, but declaration at ")).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (105)))).operator_concat (GGS_string (" does not declare 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (107)) ;
    }
  }
  {
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_5524 (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis, true) ;
    const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_5524 = NULL ;
    while (((operand_5524 = enumerator_5524.nextObject ()))) {
      macroValidPointer (operand_5524) ;
      const GGS_bool cond_5798 = (var_cas_labelStringSet.reader_hasKey (operand_5524->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (111)))).operator_not () ;
      if (cond_5798.isBuiltAndTrue ()) {
        var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this non terminal does not declare the '")).operator_concat (operand_5524->mKey)).operator_concat (GGS_string ("' label, but declaration at "))).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (114)))).operator_concat (GGS_string (" does")) COMMA_SOURCE_FILE_AT_LINE (116)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkLabelMap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "handleNonTerminalDeclarations"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleNonTerminalDeclarations (C_Compiler & inLexique,
                                GGS_nonTerminalSymbolMapForGrammarAnalysis  & var_cas_ioNonTerminalMapForGrammarAnalysis,
                                const GGS_nonterminalDeclarationListAST   var_cas_inNonterminalDeclarationList
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleNonTerminalDeclarations at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_nonterminalDeclarationListAST::cEnumerator enumerator_6135 (var_cas_inNonterminalDeclarationList, true) ;
    const GGS_nonterminalDeclarationListAST::cElement * operand_6135 = NULL ;
    while (((operand_6135 = enumerator_6135.nextObject ()))) {
      macroValidPointer (operand_6135) ;
      elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis * operand_6184 = (elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis *) var_cas_ioNonTerminalMapForGrammarAnalysis.searchForReadWriteWithInstruction (operand_6135->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (127))) ;
      if (NULL != operand_6184) {
        ::routine_checkLabelMap (inLexique,  operand_6135->mNonterminalName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (129)),  operand_6135->mLabels,  operand_6135->mHasParseLabel,  var_cas_ioNonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_6135->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (132)) COMMA_SOURCE_FILE_AT_LINE (132)),  operand_6184->mInfo.mNonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (128)) ;
      }else{
        var_cas_ioNonTerminalMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_6135->mNonterminalName, var_cas_ioNonTerminalMapForGrammarAnalysis.reader_count (), function_transformLabelMap (inLexique, operand_6135->mLabels, operand_6135->mHasParseLabel COMMA_SOURCE_FILE_AT_LINE (139)) COMMA_SOURCE_FILE_AT_LINE (136)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleNonTerminalDeclarations\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@syntaxInstructionAST.transformInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__syntaxInstructionAST__transformInstruction> gDispatchTableForMethod__syntaxInstructionAST__transformInstruction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__syntaxInstructionAST__transformInstruction (typeCategoryMethod__syntaxInstructionAST__transformInstruction inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__syntaxInstructionAST__transformInstruction
findCategoryMethod__syntaxInstructionAST__transformInstruction (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__syntaxInstructionAST__transformInstruction result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.count ()) {
    result = gDispatchTableForMethod__syntaxInstructionAST__transformInstruction (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (NULL == result) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__syntaxInstructionAST__transformInstruction (superClassPtr) ;
      gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@semanticInstructionAST.transformInstruction'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticInstructionAST__transformInstruction (C_Compiler &,
                                const cPtr_semanticInstructionAST * operand_7390,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7390 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "transformInstructionList"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_transformInstructionList (C_Compiler & inLexique,
                                const GGS_syntaxInstructionList   var_cas_inInstructionList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_transformInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_syntaxInstructionList::cEnumerator enumerator_8109 (var_cas_inInstructionList, true) ;
    const GGS_syntaxInstructionList::cElement * operand_8109 = NULL ;
    while (((operand_8109 = enumerator_8109.nextObject ()))) {
      macroValidPointer (operand_8109) ;
      { typeCategoryMethod__syntaxInstructionAST__transformInstruction method = findCategoryMethod__syntaxInstructionAST__transformInstruction (operand_8109->mInstruction.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_8109->mInstruction (HERE), var_cas_ioActuallyUsedTerminalSymbolMap, var_cas_inNonTerminalSymbolMap, var_cas_ioAddedNonTerminalIndex, var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (176)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_transformInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@terminalCheckInstruction.transformInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__terminalCheckInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_terminalCheckInstruction * operand_8465,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8465 != NULL) {
    GGS_uint  var_cas_terminalSymbolIndex ;
    elementOf_GGS_terminalSymbolsMapForGrammarAnalysis * operand_8796 = (elementOf_GGS_terminalSymbolsMapForGrammarAnalysis *) var_cas_ioActuallyUsedTerminalSymbolMap.searchForReadWriteWithInstruction (operand_8465->mTerminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (194))) ;
    if (NULL != operand_8796) {
      var_cas_terminalSymbolIndex = operand_8796->mInfo.mTerminalIndex ;
    }else{
      var_cas_terminalSymbolIndex = var_cas_ioActuallyUsedTerminalSymbolMap.reader_count () ;
      var_cas_ioActuallyUsedTerminalSymbolMap.modifier_insertKey (inLexique, operand_8465->mTerminalName, var_cas_terminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (198)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_terminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_8465->mInstructionLocation, operand_8465->mTerminalName, var_cas_terminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (200))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@nonterminalCallInstruction.transformInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__nonterminalCallInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_nonterminalCallInstruction * operand_9359,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9359 != NULL) {
    GGS_uint  var_cas_nonTerminalSymbolIndex ;
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_9734_0 ;
    if (var_cas_inNonTerminalSymbolMap.isBuilt ()) {
      var_cas_inNonTerminalSymbolMap (HERE)->method_searchKey (inLexique, operand_9359->mNonterminalName, var_cas_nonTerminalSymbolIndex, automatic_var_9734_0 COMMA_SOURCE_FILE_AT_LINE (216)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_nonTerminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_9359->mInstructionLocation, operand_9359->mNonterminalName, var_cas_nonTerminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (217))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@repeatInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__repeatInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_repeatInstruction * operand_10044,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10044 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (233)) ;
    GGS_syntaxInstructionListForGrammarAnalysis  var_cas_repeatedInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
    ::routine_transformInstructionList (inLexique,  operand_10044->mRepeatedInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_repeatedInstructionList COMMA_SOURCE_FILE_AT_LINE (236)) ;
    GGS_branchListForGrammarAnalysis  var_cas_repeatBranchList = GGS_branchListForGrammarAnalysis ::constructor_listWithValue (var_cas_repeatedInstructionList) ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_10776 (operand_10044->mRepeatBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_10776 = NULL ;
      while (((operand_10776 = enumerator_10776.nextObject ()))) {
        macroValidPointer (operand_10776) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_10776->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (247)) ;
        var_cas_repeatBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_repeatInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_10044->mInstructionLocation, var_cas_repeatBranchList, var_cas_addedNonTerminalIndex COMMA_SOURCE_FILE_AT_LINE (257))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@selectInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__selectInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_selectInstruction * operand_11425,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11425 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (273)) ;
    GGS_branchListForGrammarAnalysis  var_cas_selectBranchList = GGS_branchListForGrammarAnalysis ::constructor_emptyList () ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_11859 (operand_11425->mSelectBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_11859 = NULL ;
      while (((operand_11859 = enumerator_11859.nextObject ()))) {
        macroValidPointer (operand_11859) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_11859->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (278)) ;
        var_cas_selectBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_selectInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_11425->mInstructionLocation, var_cas_selectBranchList, var_cas_addedNonTerminalIndex COMMA_SOURCE_FILE_AT_LINE (288))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@parseDoInstruction.transformInstruction'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseDoInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseDoInstruction * operand_12509,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12509 != NULL) {
    GGS_syntaxInstructionList  var_cas_syntaxInstructionList ;
    if (operand_12509->mParseDoBranchList.isBuilt ()) {
      operand_12509->mParseDoBranchList (HERE)->method_first (inLexique, var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (304)) ;
    }
    ::routine_transformInstructionList (inLexique,  var_cas_syntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (306)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@parseWhenInstruction.transformInstruction'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseWhenInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseWhenInstruction * operand_13195,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13195 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_13195->mElseInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (323)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@parseLoopInstruction.transformInstruction'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseLoopInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseLoopInstruction * operand_13776,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13776 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_13776->mDoInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (340)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@blockInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__blockInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_blockInstruction * operand_14351,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14351 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_14351->mInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (357)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "buildRuleList"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildRuleList (C_Compiler & inLexique,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalMapForGrammarAnalysis,
                                const GGS_lstring   var_cas_inSyntaxComponentName,
                                const GGS_syntaxRuleListAST   var_cas_inRuleList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                GGS_syntaxComponentListForGrammarAnalysis  & var_cas_ioSyntaxComponentListForGrammarAnalysis,
                                GGS_uint  & var_cas_ioAddedNonTerminalCount
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildRuleList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_productionRuleListForGrammarAnalysis  var_cas_productionRulesList = GGS_productionRuleListForGrammarAnalysis ::constructor_emptyList () ;
  {
    GGS_syntaxRuleListAST::cEnumerator enumerator_15327 (var_cas_inRuleList, true) ;
    const GGS_syntaxRuleListAST::cElement * operand_15327 = NULL ;
    while (((operand_15327 = enumerator_15327.nextObject ()))) {
      macroValidPointer (operand_15327) ;
      GGS_uint  var_cas_nonTerminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_nonterminalSymbolParametersMap ;
      if (var_cas_inNonTerminalMapForGrammarAnalysis.isBuilt ()) {
        var_cas_inNonTerminalMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, operand_15327->mNonterminalName, var_cas_nonTerminalIndex, var_cas_nonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (380)) ;
      }
      GGS_syntaxInstructionList  var_cas_parsedSyntaxInstructionList ;
      GGS_lstring  automatic_var_15726_0 ;
      GGS_formalParameterListAST  automatic_var_15726_1 ;
      GGS_location  automatic_var_15726_2 ;
      if (operand_15327->mLabelList.isBuilt ()) {
        operand_15327->mLabelList (HERE)->method_first (inLexique, automatic_var_15726_0, automatic_var_15726_1, automatic_var_15726_2, var_cas_parsedSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (382)) ;
      }
      GGS_syntaxInstructionListForGrammarAnalysis  var_cas_instructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
      ::routine_transformInstructionList (inLexique,  var_cas_parsedSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalMapForGrammarAnalysis,  var_cas_ioAddedNonTerminalCount,  var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (385)) ;
      var_cas_productionRulesList.addAssign_operation (operand_15327->mNonterminalName, var_cas_nonTerminalIndex, var_cas_instructionList, var_cas_productionRulesList.reader_length ()) ;
    }
  }
  var_cas_ioSyntaxComponentListForGrammarAnalysis.addAssign_operation (var_cas_productionRulesList, var_cas_inSyntaxComponentName) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildRuleList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@nonTerminalToAddList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nonTerminalToAddList::
elementOf_GGS_nonTerminalToAddList (const GGS_string& argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSyntaxComponentName (argument_0),
mNonTerminalToAddCount (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonTerminalToAddList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_nonTerminalToAddList * ptr = dynamic_cast <const elementOf_GGS_nonTerminalToAddList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue ()
         && mNonTerminalToAddCount.operator_isEqual (ptr->mNonTerminalToAddCount).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonTerminalToAddList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonTerminalToAddCount.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@nonTerminalToAddList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonTerminalToAddList ("nonTerminalToAddList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_uint & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
operator_concat (const GGS_nonTerminalToAddList & inOperand) const {
  GGS_nonTerminalToAddList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
dotAssign_operation (const GGS_nonTerminalToAddList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_nonTerminalToAddList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mSyntaxComponentName ;
          GGS_uint  p_1 = p->mNonTerminalToAddCount ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_uint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSyntaxComponentName,
                                ptr->mNonTerminalToAddCount
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList  GGS_nonTerminalToAddList::
constructor_emptyList (void) {
  GGS_nonTerminalToAddList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList  GGS_nonTerminalToAddList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_uint & argument_1) {
  GGS_nonTerminalToAddList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalSubListWithRange (GGS_nonTerminalToAddList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSyntaxComponentName, ptr->mNonTerminalToAddCount) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_nonTerminalToAddList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_nonTerminalToAddList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalToAddList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@nonTerminalToAddList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_uint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalToAddList::
reader_mSyntaxComponentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxComponentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_nonTerminalToAddList::
reader_mNonTerminalToAddCountAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNonTerminalToAddCount ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_setMSyntaxComponentNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxComponentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_setMNonTerminalToAddCountAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNonTerminalToAddCount = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nonTerminalToAddList::cEnumerator::_mSyntaxComponentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxComponentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_nonTerminalToAddList::cEnumerator::_mNonTerminalToAddCount (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNonTerminalToAddCount ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nonTerminalToAddList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonTerminalToAddList * p = NULL ;
    macroMyNew (p, GGS_nonTerminalToAddList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonTerminalToAddList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonTerminalToAddList * p = dynamic_cast <const GGS_nonTerminalToAddList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonTerminalToAddList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonTerminalToAddList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonTerminalToAddList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of wrapper 'grammarGenerationTemplate'            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_grammarGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_grammarGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_grammarGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_grammarGenerationTemplate_0,
  0,
  gWrapperAllDirectories_grammarGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'oldGrammarZone2Header' template of 'grammarGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_oldGrammarZone2Header (C_Compiler & inLexique,
                                const GGS_grammarComponentAST & var_cas_GRAMMAR_COMPONENT_ROOT) {
  C_String result ;
  const bool isBuilt = var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (1)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "#define GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (2)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_336 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (6)), true) ;
    const GGS_lstringlist::cElement * operand_336 = NULL ;
    while (((operand_336 = enumerator_336.nextObject ()))) {
      macroValidPointer (operand_336) ;
      result << "#include \"" ;
      result << operand_336->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (7)).reader_stringByDeletingPathExtension () ;
      result << ".h\"\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'oldGrammarZone3Header' template of 'grammarGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_oldGrammarZone3Header (C_Compiler & inLexique,
                                const GGS_string& var_cas_LEXIQUE_CLASS,
                                const GGS_grammarComponentAST & var_cas_GRAMMAR_COMPONENT_ROOT,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis & var_cas_NON_TERMINAL_MAP,
                                const GGS_nonTerminalToAddList & var_cas_ADDED_NON_TERMINAL_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_LEXIQUE_CLASS.isBuilt ()
    && var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt ()
    && var_cas_NON_TERMINAL_MAP.isBuilt ()
    && var_cas_ADDED_NON_TERMINAL_LIST.isBuilt () ;
  if (isBuilt) {
    result << "//---------------------------------------------------------------------------*\n"
      "\n"
      "class C_Grammar_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (3)).ggs_string ().reader_identifierRepresentation () ;
    result << " : " ;
    const GGS_string var_cas_COLUMN_CLASS_DECLARATION = GGS_string::stringWithColumnCount (result) ;
    GGS_lstringlist::cEnumerator enumerator_247 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (4)), true) ;
    const GGS_lstringlist::cElement * operand_247 = NULL ;
    while (((operand_247 = enumerator_247.nextObject ()))) {
      macroValidPointer (operand_247) ;
      result << "public " ;
      result << operand_247->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5)).reader_stringByDeletingPathExtension () ;
      if (enumerator_247.hasNextObject ()) {
        result << ",\n" ;
        result << var_cas_COLUMN_CLASS_DECLARATION ;
      }
    }
    result << " {\n" ;
    GGS_nonTerminalSymbolMapForGrammarAnalysis::cEnumerator enumerator_393 (var_cas_NON_TERMINAL_MAP, true) ;
    const GGS_nonTerminalSymbolMapForGrammarAnalysis::cElement * operand_393 = NULL ;
    while (((operand_393 = enumerator_393.nextObject ()))) {
      macroValidPointer (operand_393) ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_456 (operand_393->mInfo.mNonterminalSymbolParametersMap, true) ;
      const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_456 = NULL ;
      while (((operand_456 = enumerator_456.nextObject ()))) {
        macroValidPointer (operand_456) ;
        result << "  public : virtual void nt_" ;
        result << operand_393->mKey.ggs_string ().reader_identifierRepresentation () ;
        result << "_" ;
        result << operand_456->mKey.ggs_string ().reader_identifierRepresentation () ;
        result << " (" ;
        const GGS_string var_cas_COLUMN1 = GGS_string::stringWithColumnCount (result) ;
        result << "C_Lexique_" ;
        result << var_cas_LEXIQUE_CLASS ;
        result << " &" ;
        GGS_signatureForGrammarAnalysis::cEnumerator enumerator_649 (operand_456->mInfo.mFormalParametersList, true) ;
        const GGS_signatureForGrammarAnalysis::cElement * operand_649 = NULL ;
        while (((operand_649 = enumerator_649.nextObject ()))) {
          macroValidPointer (operand_649) ;
          result << ",\n" ;
          result << var_cas_COLUMN1 ;
          result << operand_649->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
          result << "GGS_" ;
          result << operand_649->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
          result << operand_649->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
        }
        result << ") ;\n"
          "\n" ;
        if ((var_cas_GRAMMAR_COMPONENT_ROOT.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (17)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17))).operator_isEqual (operand_393->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17))).boolValue ()) {
          result << "  public : static void _performSourceFileParsing_" ;
          result << operand_456->mKey.ggs_string ().reader_identifierRepresentation () ;
          result << " (" ;
          const GGS_string var_cas_COLUMN2 = GGS_string::stringWithColumnCount (result) ;
          result << "C_Compiler & inCompiler,\n" ;
          result << var_cas_COLUMN2 ;
          result << "const C_String & inDependancyExtension,\n" ;
          result << var_cas_COLUMN2 ;
          result << "const C_String & inDependancyPath,\n" ;
          result << var_cas_COLUMN2 ;
          result << "GGS_string * inSentStringPtr,\n" ;
          result << var_cas_COLUMN2 ;
          result << "const GGS_lstring inFileName" ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1371 (operand_456->mInfo.mFormalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_1371 = NULL ;
          while (((operand_1371 = enumerator_1371.nextObject ()))) {
            macroValidPointer (operand_1371) ;
            result << ",\n" ;
            result << var_cas_COLUMN2 ;
            result << operand_1371->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
            result << "GGS_" ;
            result << operand_1371->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
            result << operand_1371->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
          }
          result << "\n" ;
          result << var_cas_COLUMN2 ;
          result << "COMMA_LOCATION_ARGS) ;\n"
            "\n"
            "  public : static void _performSourceStringParsing_" ;
          result << operand_456->mKey.ggs_string ().reader_identifierRepresentation () ;
          result << " (" ;
          const GGS_string var_cas_COLUMN3 = GGS_string::stringWithColumnCount (result) ;
          result << "C_Compiler & inCompiler,\n" ;
          result << var_cas_COLUMN3 ;
          result << "GGS_string * inSentStringPtr,\n" ;
          result << var_cas_COLUMN3 ;
          result << "const GGS_string inSourceString" ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1942 (operand_456->mInfo.mFormalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_1942 = NULL ;
          while (((operand_1942 = enumerator_1942.nextObject ()))) {
            macroValidPointer (operand_1942) ;
            result << ",\n" ;
            result << var_cas_COLUMN3 ;
            result << operand_1942->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
            result << "GGS_" ;
            result << operand_1942->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
            result << operand_1942->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
          }
          result << "\n" ;
          result << var_cas_COLUMN3 ;
          result << "COMMA_LOCATION_ARGS) ;\n"
            "\n" ;
        }else {
        }
      }
    }
    GGS_nonTerminalToAddList::cEnumerator enumerator_2309 (var_cas_ADDED_NON_TERMINAL_LIST, true) ;
    const GGS_nonTerminalToAddList::cElement * operand_2309 = NULL ;
    while (((operand_2309 = enumerator_2309.nextObject ()))) {
      macroValidPointer (operand_2309) ;
      result << "  public : virtual PMSInt16 select_" ;
      result << operand_2309->mSyntaxComponentName.reader_identifierRepresentation () ;
      result << "_" ;
      result << operand_2309->mNonTerminalToAddCount.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (38)) ;
      result << " (C_Lexique_" ;
      result << var_cas_LEXIQUE_CLASS ;
      result << " &) ;\n" ;
      if (enumerator_2309.hasNextObject ()) {
        result << "\n" ;
      }
    }
    result << "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#endif\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "parseGrammarComponent"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_parseGrammarComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_grammarComponentAST  & var_cas_outGrammarComponentRoot
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_parseGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  elementOf_GGS_parsedGrammarComponentMap * operand_18066 = (elementOf_GGS_parsedGrammarComponentMap *) var_cas_ioParsedComponentStruct.mParsedGrammarComponentMap.searchForReadWithInstruction (var_cas_basename) ;
  if (NULL != operand_18066) {
    var_cas_outGrammarComponentRoot = operand_18066->mInfo.mGrammarComponentRoot ;
  }else{
    const GGS_string _depExtension = GGS_string ("") ;
    const GGS_string _depPath = GGS_string ("") ;
    if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
      C_Grammar_grammarLL_31_grammar::_performSourceFileParsing_ (inLexique,
                                    _depExtension.string (),
                                    _depPath.string (),
                                    NULL,
                                    var_cas_inSourceFile,
                                    var_cas_outGrammarComponentRoot
                                    COMMA_SOURCE_FILE_AT_LINE (447)) ;
    }
    var_cas_ioParsedComponentStruct.mParsedGrammarComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_basename, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (449)), var_cas_outGrammarComponentRoot COMMA_SOURCE_FILE_AT_LINE (448)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_parseGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileGrammarComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectoryForCppFiles,
                                const GGS_string  var_cas_inOutputDirectoryForHTMLFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_grammarComponentAST  var_cas_grammarComponentRoot ;
  ::routine_parseGrammarComponent (inLexique,  var_cas_inSourceFile,  var_cas_ioParsedComponentStruct,  var_cas_grammarComponentRoot COMMA_SOURCE_FILE_AT_LINE (468)) ;
  const GGS_lstring  var_cas_grammarComponentName = var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (470)) ;
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  const GGS_bool cond_19637 = (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (472))).operator_isNotEqual (var_cas_basename) ;
  if (cond_19637.isBuiltAndTrue ()) {
    var_cas_grammarComponentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (474)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (476)) ;
  }
  GGS_terminalSymbolsMapForGrammarAnalysis  var_cas_actuallyUsedTerminalSymbolMap = GGS_terminalSymbolsMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (479)) ;
  GGS_nonTerminalSymbolMapForGrammarAnalysis  var_cas_nonTerminalMapForGrammarAnalysis = GGS_nonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (480)) ;
  GGS_string var_cas_lexiqueComponentName = GGS_string ("") ;
  GGS_syntaxComponentListForGrammarAnalysis  var_cas_syntaxComponentListForGrammarAnalysis = GGS_syntaxComponentListForGrammarAnalysis ::constructor_emptyList () ;
  GGS_nonTerminalToAddList  var_cas_nonTerminalToAddList = GGS_nonTerminalToAddList ::constructor_emptyList () ;
  GGS_uint  var_cas_addedNonTerminalCount = GGS_uint (0U) ;
  {
    GGS_lstringlist::cEnumerator enumerator_20166 (var_cas_grammarComponentRoot.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (485)), true) ;
    const GGS_lstringlist::cElement * operand_20166 = NULL ;
    while (((operand_20166 = enumerator_20166.nextObject ()))) {
      macroValidPointer (operand_20166) ;
      const GGS_uint  var_cas_addedNonTerminalCountRef = var_cas_addedNonTerminalCount ;
      const GGS_bool cond_20470 = ((operand_20166->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("gSyntax"))).operator_and ((operand_20166->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("ggs"))) ;
      if (cond_20470.isBuiltAndTrue ()) {
        operand_20166->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a syntax component file should have '.ggs' or '.gSyntax' as path extension") COMMA_SOURCE_FILE_AT_LINE (489)) ;
      }else if (cond_20470.isBuiltAndFalse ()) {
        GGS_string var_cas_syntaxComponentName = operand_20166->mValue.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
        GGS_syntaxComponentAST var_cas_syntaxComponentRoot ;
        const GGS_bool cond_20861 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (492)).reader_hasKey (var_cas_syntaxComponentName) ;
        if (cond_20861.isBuiltAndTrue ()) {
          const GGS_parsedSyntaxComponentMap  temp_20783 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (493)) ;
          if (temp_20783.isBuilt ()) {
            temp_20783 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (493)), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (493)) ;
          }
        }else if (cond_20861.isBuiltAndFalse ()) {
          GGS_string var_cas_sourceFilePath = operand_20166->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent ()) ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            C_Grammar_syntaxSLRgrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_sourceFilePath, operand_20166->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (496)) COMMA_SOURCE_FILE_AT_LINE (496)),
                                          var_cas_syntaxComponentRoot
                                          COMMA_SOURCE_FILE_AT_LINE (496)) ;
          }
          var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, operand_20166->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (497)) COMMA_SOURCE_FILE_AT_LINE (497)), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (497)) ;
        }
        GGS_string var_cas_currentLexiqueName = var_cas_syntaxComponentRoot.reader_mImportedLexiqueFilePath (inLexique COMMA_SOURCE_FILE_AT_LINE (500)).ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
        const GGS_bool cond_21530 = (var_cas_lexiqueComponentName).operator_isEqual (GGS_string ("")) ;
        if (cond_21530.isBuiltAndTrue ()) {
          var_cas_lexiqueComponentName = var_cas_currentLexiqueName ;
        }else if (cond_21530.isBuiltAndFalse ()) {
          const GGS_bool cond_21825 = (var_cas_lexiqueComponentName).operator_isNotEqual (var_cas_currentLexiqueName) ;
          if (cond_21825.isBuiltAndTrue ()) {
            operand_20166->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this syntax component uses '")).operator_concat (var_cas_currentLexiqueName)).operator_concat (GGS_string ("' lexique component, but the first syntax component uses the '"))).operator_concat (var_cas_lexiqueComponentName)).operator_concat (GGS_string ("' lexique component (they should be the same)")) COMMA_SOURCE_FILE_AT_LINE (507)) ;
          }
        }
        ::routine_handleNonTerminalDeclarations (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mNonterminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (511)) COMMA_SOURCE_FILE_AT_LINE (509)) ;
        ::routine_buildRuleList (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mSyntaxComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (516)),  var_cas_syntaxComponentRoot.reader_mRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (517)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_addedNonTerminalCount COMMA_SOURCE_FILE_AT_LINE (514)) ;
        GGS_uint  var_cas_i = GGS_uint (0U) ;
        GGS_uint _variant_22532 = var_cas_addedNonTerminalCount ;
        GGS_bool _condition_22532 (_variant_22532.isBuilt (), true) ;
        while (_condition_22532.isBuiltAndTrue ()) {
          _condition_22532 = (var_cas_i).operator_strictInf (var_cas_addedNonTerminalCount.substract_operation (inLexique, var_cas_addedNonTerminalCountRef COMMA_SOURCE_FILE_AT_LINE (523))) ;
          if (_condition_22532.isBuiltAndTrue ()) {
            if (_variant_22532.uintValue () == 0) {
              inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (526)) ;
              _condition_22532 = GGS_bool (false) ;
            }else{
              _variant_22532.decrement_operation (inLexique COMMA_HERE) ;
              var_cas_nonTerminalToAddList.addAssign_operation (var_cas_syntaxComponentName, var_cas_i) ;
              var_cas_i.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (525)) ;
            }
          }
        }
      }
    }
  }
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_startSymbolAltMap ;
  GGS_uint  var_cas_startSymbolIndex ;
  if (var_cas_nonTerminalMapForGrammarAnalysis.isBuilt ()) {
    var_cas_nonTerminalMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (533)), var_cas_startSymbolIndex, var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (533)) ;
  }
  ::routine_checkLabelMap (inLexique,  var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (536)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (536)),  var_cas_grammarComponentRoot.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (537)),  var_cas_grammarComponentRoot.reader_mStartSymbolHasParseLabel (inLexique COMMA_SOURCE_FILE_AT_LINE (538)),  var_cas_nonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (539)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (539)) COMMA_SOURCE_FILE_AT_LINE (539)),  var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (535)) ;
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis  var_cas_unusedNonTerminalSymbolsForGrammar = GGS_unusedNonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (543)) ;
  {
    GGS_lstringlist::cEnumerator enumerator_23433 (var_cas_grammarComponentRoot.reader_mUnusedNonterminalList (inLexique COMMA_SOURCE_FILE_AT_LINE (544)), true) ;
    const GGS_lstringlist::cElement * operand_23433 = NULL ;
    while (((operand_23433 = enumerator_23433.nextObject ()))) {
      macroValidPointer (operand_23433) ;
      GGS_uint  var_cas_nonterminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_23587_0 ;
      if (var_cas_nonTerminalMapForGrammarAnalysis.isBuilt ()) {
        var_cas_nonTerminalMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, operand_23433->mValue, var_cas_nonterminalIndex, automatic_var_23587_0 COMMA_SOURCE_FILE_AT_LINE (546)) ;
      }
      var_cas_unusedNonTerminalSymbolsForGrammar.modifier_insertKey (inLexique, operand_23433->mValue, var_cas_nonterminalIndex COMMA_SOURCE_FILE_AT_LINE (547)) ;
    }
  }
  if (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (551)).isBuilt () &&
      var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (552)).isBuilt () &&
      var_cas_startSymbolIndex.isBuilt () &&
      var_cas_lexiqueComponentName.isBuilt () &&
      var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (555)).isBuilt () &&
      var_cas_actuallyUsedTerminalSymbolMap.isBuilt () &&
      var_cas_syntaxComponentListForGrammarAnalysis.isBuilt () &&
      var_cas_nonTerminalMapForGrammarAnalysis.isBuilt () &&
      var_cas_unusedNonTerminalSymbolsForGrammar.isBuilt () &&
      var_cas_inOutputDirectoryForCppFiles.isBuilt () &&
      var_cas_inOutputDirectoryForHTMLFile.isBuilt ()) {
    ::routine_analyzeGrammar (inLexique,  var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (551)),  var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (552)),  var_cas_startSymbolIndex,  var_cas_lexiqueComponentName,  var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (555)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_unusedNonTerminalSymbolsForGrammar,  var_cas_inOutputDirectoryForCppFiles,  var_cas_inOutputDirectoryForHTMLFile COMMA_SOURCE_FILE_AT_LINE (550)) ;
  }
  const GGS_bool cond_24905 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (564))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_24905.isBuiltAndTrue ()) {
    const GGS_string var_cas_zone2 = template_filewrapper_grammarGenerationTemplate_oldGrammarZone2Header (inLexique, var_cas_grammarComponentRoot) ;
    const GGS_string var_cas_zone3 = template_filewrapper_grammarGenerationTemplate_oldGrammarZone3Header (inLexique, var_cas_lexiqueComponentName.reader_identifierRepresentation (), var_cas_grammarComponentRoot, var_cas_nonTerminalMapForGrammarAnalysis, var_cas_nonTerminalToAddList) ;
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectoryForCppFiles, (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (576)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (576))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_zone2, GGS_string ("\n"
      "\n"), var_cas_zone3 COMMA_SOURCE_FILE_AT_LINE (574)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_grammarCompilation (void) {
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__semanticInstructionAST__transformInstruction, gClassInfoFor__semanticInstructionAST.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__terminalCheckInstruction__transformInstruction, gClassInfoFor__terminalCheckInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__nonterminalCallInstruction__transformInstruction, gClassInfoFor__nonterminalCallInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__repeatInstruction__transformInstruction, gClassInfoFor__repeatInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__selectInstruction__transformInstruction, gClassInfoFor__selectInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__parseDoInstruction__transformInstruction, gClassInfoFor__parseDoInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__parseWhenInstruction__transformInstruction, gClassInfoFor__parseWhenInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__parseLoopInstruction__transformInstruction, gClassInfoFor__parseLoopInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__blockInstruction__transformInstruction, gClassInfoFor__blockInstruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_grammarCompilation (void) {
  gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_grammarCompilation (prologueRoutineFor_grammarCompilation, epilogueRoutineFor_grammarCompilation) ;

//---------------------------------------------------------------------------*

