//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'grammarCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 8th, 2009, at 21h23'8"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "grammarCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "transformLabelMap"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis  function_transformLabelMap (C_Compiler & inLexique,
                                const GGS_nonTerminalLabelList   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_transformLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis = GGS_nonterminalSymbolLabelMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_nonTerminalLabelList::cEnumerator enumerator_2214 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelList::cElement * operand_2214 = NULL ;
    while (((operand_2214 = enumerator_2214.nextObject ()))) {
      macroValidPointer (operand_2214) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList = GGS_signatureForGrammarAnalysis ::constructor_emptyList () ;
      {
        GGS_formalParameterList::cEnumerator enumerator_2315 (operand_2214->mFormalParameters, true) ;
        const GGS_formalParameterList::cElement * operand_2315 = NULL ;
        while (((operand_2315 = enumerator_2315.nextObject ()))) {
          macroValidPointer (operand_2315) ;
          var_cas_formalParametersList.addAssign_operation (operand_2315->mFormalParameterPassingMode, operand_2315->mFormalParameterTypeName) ;
        }
      }
      var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_2214->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (44)) ;
    }
  }
  const GGS_bool cond_2762 = var_cas_inHasParseLabel ;
  if (cond_2762.isBuiltAndTrue ()) {
    var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("parse"), GGS_location (inLexique) COMMA_HERE), GGS_signatureForGrammarAnalysis ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (50)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_transformLabelMap\n") ;
  #endif
  return var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "checkLabelMap"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkLabelMap (C_Compiler & inLexique,
                                const GGS_location   var_cas_inNonTerminalLocation,
                                const GGS_nonTerminalLabelList   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel,
                                const GGS_location   var_cas_inOriginalNonTerminalLocation,
                                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis   var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_stringset  var_cas_labelStringSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_nonTerminalLabelList::cEnumerator enumerator_3183 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelList::cElement * operand_3183 = NULL ;
    while (((operand_3183 = enumerator_3183.nextObject ()))) {
      macroValidPointer (operand_3183) ;
      var_cas_labelStringSet.addAssign_operation (operand_3183->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (69))) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList ;
      const GGS_nonterminalSymbolLabelMapForGrammarAnalysis  temp_3348 = var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis ;
      if (temp_3348.isBuilt ()) {
        temp_3348 (HERE)->method_searchKey (inLexique, operand_3183->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (71)) ;
      }
      const GGS_bool cond_3924 = (operand_3183->mFormalParameters.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (72))).operator_isNotEqual (var_cas_formalParametersList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (72))) ;
      if (cond_3924.isBuiltAndTrue ()) {
        operand_3183->mLabelName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((((operand_3183->mFormalParameters.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (73)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (73))).operator_concat (GGS_string (" formal parameter"))).operator_concat ((((operand_3183->mFormalParameters.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (75))).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string (""))))).operator_concat (GGS_string (" declared here, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3183->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (77)) COMMA_SOURCE_FILE_AT_LINE (77)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (77)))).operator_concat (GGS_string ("names "))).operator_concat (var_cas_formalParametersList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (78)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (78)))).operator_concat (GGS_string ("parameter"))).operator_concat ((((var_cas_formalParametersList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (79))).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string ("")))) COMMA_SOURCE_FILE_AT_LINE (80)) ;
      }else if (cond_3924.isBuiltAndFalse ()) {
        {
          GGS_formalParameterList::cEnumerator enumerator_3956 (operand_3183->mFormalParameters, true) ;
          const GGS_formalParameterList::cElement * operand_3956 = NULL ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_3978 (var_cas_formalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_3978 = NULL ;
          while (((operand_3956 = enumerator_3956.nextObject ()))
              && ((operand_3978 = enumerator_3978.nextObject ()))) {
            macroValidPointer (operand_3956) ;
            macroValidPointer (operand_3978) ;
            const GGS_bool cond_4540 = (operand_3978->mFormalArgumentPassingModeForGrammarAnalysis).operator_isNotEqual (operand_3956->mFormalParameterPassingMode) ;
            if (cond_4540.isBuiltAndTrue ()) {
              operand_3978->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared with ")).operator_concat (operand_3978->mFormalArgumentPassingModeForGrammarAnalysis.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (85)))).operator_concat (GGS_string (" passing mode, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3183->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (87)) COMMA_SOURCE_FILE_AT_LINE (87)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (87)))).operator_concat (GGS_string (" is declared with "))).operator_concat (operand_3956->mFormalParameterPassingMode.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (88)))).operator_concat (GGS_string (" passing mode")) COMMA_SOURCE_FILE_AT_LINE (89)) ;
            }
            const GGS_bool cond_5036 = (operand_3978->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (90))).operator_isNotEqual (operand_3956->mFormalParameterTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (90))) ;
            if (cond_5036.isBuiltAndTrue ()) {
              operand_3978->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared of '@")).operator_concat (operand_3978->mGalgasTypeNameForGrammarAnalysis)).operator_concat (GGS_string ("' type, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3183->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95)) COMMA_SOURCE_FILE_AT_LINE (95)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (95)))).operator_concat (GGS_string (" is declared with '@"))).operator_concat (operand_3956->mFormalParameterTypeName)).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (97)) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_5471 = var_cas_inHasParseLabel ;
  if (cond_5471.isBuiltAndTrue ()) {
    var_cas_labelStringSet.addAssign_operation (GGS_string ("parse")) ;
    const GGS_bool cond_5460 = (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_hasKey (inLexique, GGS_string ("parse") COMMA_SOURCE_FILE_AT_LINE (103))).operator_not () ;
    if (cond_5460.isBuiltAndTrue ()) {
      var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this non terminal is declared with 'parse' label, but declaration at ")).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (106)))).operator_concat (GGS_string (" does not declare 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (108)) ;
    }
  }
  {
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_5537 (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis, true) ;
    const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_5537 = NULL ;
    while (((operand_5537 = enumerator_5537.nextObject ()))) {
      macroValidPointer (operand_5537) ;
      const GGS_bool cond_5809 = (var_cas_labelStringSet.reader_hasKey (inLexique, operand_5537->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (112)) COMMA_SOURCE_FILE_AT_LINE (112))).operator_not () ;
      if (cond_5809.isBuiltAndTrue ()) {
        var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this non terminal does not declare the '")).operator_concat (operand_5537->mKey)).operator_concat (GGS_string ("' label, but declaration at "))).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (115)))).operator_concat (GGS_string (" does")) COMMA_SOURCE_FILE_AT_LINE (117)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkLabelMap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "handleNonTerminalDeclarations"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleNonTerminalDeclarations (C_Compiler & inLexique,
                                GGS_nonTerminalSymbolMapForGrammarAnalysis  & var_cas_ioNonTerminalMapForGrammarAnalysis,
                                const GGS_nonterminalDeclarationList   var_cas_inNonterminalDeclarationList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleNonTerminalDeclarations at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_nonterminalDeclarationList::cEnumerator enumerator_6143 (var_cas_inNonterminalDeclarationList, true) ;
    const GGS_nonterminalDeclarationList::cElement * operand_6143 = NULL ;
    while (((operand_6143 = enumerator_6143.nextObject ()))) {
      macroValidPointer (operand_6143) ;
      elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis * operand_6192 = (elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis *) var_cas_ioNonTerminalMapForGrammarAnalysis.searchForTolerantWithInstruction (operand_6143->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (128))) ;
      if (NULL != operand_6192) {
        ::routine_checkLabelMap (inLexique,  operand_6143->mNonterminalName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (130)),  operand_6143->mLabels,  operand_6143->mHasParseLabel,  var_cas_ioNonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_6143->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (133)) COMMA_SOURCE_FILE_AT_LINE (133)),  operand_6192->mInfo.mNonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (129)) ;
      }else{
        var_cas_ioNonTerminalMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_6143->mNonterminalName, var_cas_ioNonTerminalMapForGrammarAnalysis.reader_count (inLexique COMMA_SOURCE_FILE_AT_LINE (139)), function_transformLabelMap (inLexique, operand_6143->mLabels, operand_6143->mHasParseLabel COMMA_SOURCE_FILE_AT_LINE (140)) COMMA_SOURCE_FILE_AT_LINE (137)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleNonTerminalDeclarations\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@syntaxInstruction.transformInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__syntaxInstruction__transformInstruction> gDispatchTableForMethod__syntaxInstruction__transformInstruction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__syntaxInstruction__transformInstruction (typeCategoryMethod__syntaxInstruction__transformInstruction inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__syntaxInstruction__transformInstruction.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__syntaxInstruction__transformInstruction
findCategoryMethod__syntaxInstruction__transformInstruction (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__syntaxInstruction__transformInstruction result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__syntaxInstruction__transformInstruction.count ()) {
    result = gDispatchTableForMethod__syntaxInstruction__transformInstruction (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__syntaxInstruction__transformInstruction (superClassPtr) ;
      gDispatchTableForMethod__syntaxInstruction__transformInstruction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "transformInstructionList"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_transformInstructionList (C_Compiler & inLexique,
                                const GGS_syntaxInstructionList   var_cas_inInstructionList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_transformInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_syntaxInstructionList::cEnumerator enumerator_7686 (var_cas_inInstructionList, true) ;
    const GGS_syntaxInstructionList::cElement * operand_7686 = NULL ;
    while (((operand_7686 = enumerator_7686.nextObject ()))) {
      macroValidPointer (operand_7686) ;
      const GGS_syntaxInstruction  temp_7728 = operand_7686->mInstruction ;
      if (temp_7728.isBuilt ()) {
        typeCategoryMethod__syntaxInstruction__transformInstruction method = findCategoryMethod__syntaxInstruction__transformInstruction (temp_7728.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_7728 (HERE), var_cas_ioActuallyUsedTerminalSymbolMap, var_cas_inNonTerminalSymbolMap, var_cas_ioAddedNonTerminalIndex, var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (167)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_transformInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@terminalCheckInstruction.transformInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__terminalCheckInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_terminalCheckInstruction * operand_8042,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8042 != NULL) {
    GGS_uint  var_cas_terminalSymbolIndex ;
    elementOf_GGS_terminalSymbolsMapForGrammarAnalysis * operand_8373 = (elementOf_GGS_terminalSymbolsMapForGrammarAnalysis *) var_cas_ioActuallyUsedTerminalSymbolMap.searchForTolerantWithInstruction (operand_8042->mTerminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (185))) ;
    if (NULL != operand_8373) {
      var_cas_terminalSymbolIndex = operand_8373->mInfo.mTerminalIndex ;
    }else{
      var_cas_terminalSymbolIndex = var_cas_ioActuallyUsedTerminalSymbolMap.reader_count (inLexique COMMA_SOURCE_FILE_AT_LINE (188)) ;
      var_cas_ioActuallyUsedTerminalSymbolMap.modifier_insertKey (inLexique, operand_8042->mTerminalName, var_cas_terminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (189)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_terminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_8042->mStartLocation, operand_8042->mTerminalName, var_cas_terminalSymbolIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@nonterminalCallInstruction.transformInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__nonterminalCallInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_nonterminalCallInstruction * operand_8930,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8930 != NULL) {
    GGS_uint  var_cas_nonTerminalSymbolIndex ;
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_0 ;
    const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_9259 = var_cas_inNonTerminalSymbolMap ;
    if (temp_9259.isBuilt ()) {
      temp_9259 (HERE)->method_searchKey (inLexique, operand_8930->mNonterminalName, var_cas_nonTerminalSymbolIndex, automatic_var_0 COMMA_SOURCE_FILE_AT_LINE (207)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_nonTerminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_8930->mStartLocation, operand_8930->mNonterminalName, var_cas_nonTerminalSymbolIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@repeatInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__repeatInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_repeatInstruction * operand_9609,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9609 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (224)) ;
    GGS_syntaxInstructionListForGrammarAnalysis  var_cas_repeatedInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
    ::routine_transformInstructionList (inLexique,  operand_9609->mRepeatedInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_repeatedInstructionList COMMA_SOURCE_FILE_AT_LINE (227)) ;
    GGS_branchListForGrammarAnalysis  var_cas_repeatBranchList = GGS_branchListForGrammarAnalysis ::constructor_listWithValue (var_cas_repeatedInstructionList) ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_10341 (operand_9609->mRepeatBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_10341 = NULL ;
      while (((operand_10341 = enumerator_10341.nextObject ()))) {
        macroValidPointer (operand_10341) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_10341->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (238)) ;
        var_cas_repeatBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_repeatInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_9609->mStartLocation, var_cas_repeatBranchList, var_cas_addedNonTerminalIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@selectInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__selectInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_selectInstruction * operand_10984,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10984 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (264)) ;
    GGS_branchListForGrammarAnalysis  var_cas_selectBranchList = GGS_branchListForGrammarAnalysis ::constructor_emptyList () ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_11418 (operand_10984->mSelectBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_11418 = NULL ;
      while (((operand_11418 = enumerator_11418.nextObject ()))) {
        macroValidPointer (operand_11418) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_11418->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (269)) ;
        var_cas_selectBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_selectInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_10984->mStartLocation, var_cas_selectBranchList, var_cas_addedNonTerminalIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@parseDoInstruction.transformInstruction'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseDoInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseDoInstruction * operand_12062,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12062 != NULL) {
    GGS_syntaxInstructionList  var_cas_syntaxInstructionList ;
    const GGS_listOfSyntaxInstructionList  temp_12385 = operand_12062->mParseDoBranchList ;
    if (temp_12385.isBuilt ()) {
      temp_12385 (HERE)->method_first (inLexique, var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (295)) ;
    }
    ::routine_transformInstructionList (inLexique,  var_cas_syntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (297)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@blockInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__blockInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_blockInstruction * operand_12744,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12744 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_12744->mInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (314)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "buildRuleList"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildRuleList (C_Compiler & inLexique,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalMapForGrammarAnalysis,
                                const GGS_lstring   var_cas_inSyntaxComponentName,
                                const GGS_syntaxRuleList   var_cas_inRuleList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                GGS_syntaxComponentListForGrammarAnalysis  & var_cas_ioSyntaxComponentListForGrammarAnalysis,
                                GGS_uint  & var_cas_ioAddedNonTerminalCount COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildRuleList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  inLexique.printMessage (C_String ("LOGGING inSyntaxComponentName: ") + var_cas_inSyntaxComponentName.reader_description (inLexique COMMA_HERE).string () + "\n" COMMA_SOURCE_FILE_AT_LINE (333)) ;
  GGS_productionRuleListForGrammarAnalysis  var_cas_productionRulesList = GGS_productionRuleListForGrammarAnalysis ::constructor_emptyList () ;
  {
    GGS_syntaxRuleList::cEnumerator enumerator_13745 (var_cas_inRuleList, true) ;
    const GGS_syntaxRuleList::cElement * operand_13745 = NULL ;
    while (((operand_13745 = enumerator_13745.nextObject ()))) {
      macroValidPointer (operand_13745) ;
      GGS_uint  var_cas_nonTerminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_nonterminalSymbolParametersMap ;
      const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_13909 = var_cas_inNonTerminalMapForGrammarAnalysis ;
      if (temp_13909.isBuilt ()) {
        temp_13909 (HERE)->method_searchKey (inLexique, operand_13745->mNonterminalName, var_cas_nonTerminalIndex, var_cas_nonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (338)) ;
      }
      GGS_syntaxInstructionList  var_cas_parsedSyntaxInstructionList ;
      GGS_lstring  automatic_var_1 ;
      GGS_formalParameterList  automatic_var_2 ;
      const GGS_syntaxRuleLabelList  temp_14105 = operand_13745->mLabelList ;
      if (temp_14105.isBuilt ()) {
        temp_14105 (HERE)->method_first (inLexique, automatic_var_1, automatic_var_2, var_cas_parsedSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (340)) ;
      }
      GGS_syntaxInstructionListForGrammarAnalysis  var_cas_instructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
      ::routine_transformInstructionList (inLexique,  var_cas_parsedSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalMapForGrammarAnalysis,  var_cas_ioAddedNonTerminalCount,  var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (343)) ;
      var_cas_productionRulesList.addAssign_operation (operand_13745->mNonterminalName, var_cas_nonTerminalIndex, var_cas_instructionList) ;
    }
  }
  var_cas_ioSyntaxComponentListForGrammarAnalysis.addAssign_operation (var_cas_productionRulesList, var_cas_inSyntaxComponentName) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildRuleList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileGrammarComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_grammarComponentRoot  var_cas_grammarComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    grammarLL1grammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_grammarComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (371)) ;
  }
  const GGS_lstring  var_cas_grammarComponentName = var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (373)) ;
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (374)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (374)) ;
  const GGS_bool cond_15563 = (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (375))).operator_isNotEqual (var_cas_basename) ;
  if (cond_15563.isBuiltAndTrue ()) {
    var_cas_grammarComponentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (377)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (379)) ;
  }
  GGS_terminalSymbolsMapForGrammarAnalysis  var_cas_actuallyUsedTerminalSymbolMap = GGS_terminalSymbolsMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  GGS_nonTerminalSymbolMapForGrammarAnalysis  var_cas_nonTerminalMapForGrammarAnalysis = GGS_nonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  GGS_string var_cas_lexiqueComponentName = GGS_string ("") ;
  GGS_syntaxComponentListForGrammarAnalysis  var_cas_syntaxComponentListForGrammarAnalysis = GGS_syntaxComponentListForGrammarAnalysis ::constructor_emptyList () ;
  GGS_uint  var_cas_addedNonTerminalCount = GGS_uint (0U) ;
  {
    GGS_lstringlist::cEnumerator enumerator_16033 (var_cas_grammarComponentRoot.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (387)), true) ;
    const GGS_lstringlist::cElement * operand_16033 = NULL ;
    while (((operand_16033 = enumerator_16033.nextObject ()))) {
      macroValidPointer (operand_16033) ;
      const GGS_bool cond_16221 = (operand_16033->mValue.ggs_string ().reader_pathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (388))).operator_isNotEqual (GGS_string ("gSyntax")) ;
      if (cond_16221.isBuiltAndTrue ()) {
        operand_16033->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a syntax component file should have '.gSyntax' as path extension") COMMA_SOURCE_FILE_AT_LINE (390)) ;
      }else if (cond_16221.isBuiltAndFalse ()) {
        GGS_string var_cas_syntaxComponentName = operand_16033->mValue.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (391)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (391)) ;
        GGS_syntaxComponentRoot  var_cas_syntaxComponentRoot ;
        const GGS_bool cond_16613 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (393)).reader_hasKey (inLexique, var_cas_syntaxComponentName COMMA_SOURCE_FILE_AT_LINE (393)) ;
        if (cond_16613.isBuiltAndTrue ()) {
          const GGS_parsedSyntaxComponentMap  temp_16535 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (394)) ;
          if (temp_16535.isBuilt ()) {
            temp_16535 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, GGS_location (inLexique) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (394)) ;
          }
        }else if (cond_16613.isBuiltAndFalse ()) {
          GGS_string var_cas_sourceFilePath = operand_16033->mValue.ggs_string ().reader_absolutePathFromPath (inLexique, var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (396)) COMMA_SOURCE_FILE_AT_LINE (396)) ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            syntaxSLRgrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_sourceFilePath, operand_16033->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (397)) COMMA_HERE),
                                          var_cas_syntaxComponentRoot
                                          COMMA_SOURCE_FILE_AT_LINE (397)) ;
          }
          var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, operand_16033->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (398)) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (398)) ;
        }
        GGS_string var_cas_currentLexiqueName = var_cas_syntaxComponentRoot.reader_mImportedLexiqueReference (inLexique COMMA_SOURCE_FILE_AT_LINE (401)).ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (401)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (401)) ;
        const GGS_bool cond_17282 = (var_cas_lexiqueComponentName).operator_isEqual (GGS_string ("")) ;
        if (cond_17282.isBuiltAndTrue ()) {
          var_cas_lexiqueComponentName = var_cas_currentLexiqueName ;
        }else if (cond_17282.isBuiltAndFalse ()) {
          const GGS_bool cond_17577 = (var_cas_lexiqueComponentName).operator_isNotEqual (var_cas_currentLexiqueName) ;
          if (cond_17577.isBuiltAndTrue ()) {
            operand_16033->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this syntax component uses '")).operator_concat (var_cas_currentLexiqueName)).operator_concat (GGS_string ("' lexique component, but the first syntax component uses the '"))).operator_concat (var_cas_lexiqueComponentName)).operator_concat (GGS_string ("' lexique component (they should be the same)")) COMMA_SOURCE_FILE_AT_LINE (408)) ;
          }
        }
        ::routine_handleNonTerminalDeclarations (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mNonterminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (412)) COMMA_SOURCE_FILE_AT_LINE (410)) ;
        ::routine_buildRuleList (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mSyntaxComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (417)),  var_cas_syntaxComponentRoot.reader_mRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (418)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_addedNonTerminalCount COMMA_SOURCE_FILE_AT_LINE (415)) ;
      }
    }
  }
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_startSymbolAltMap ;
  GGS_uint  var_cas_startSymbolIndex ;
  const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_18369 = var_cas_nonTerminalMapForGrammarAnalysis ;
  if (temp_18369.isBuilt ()) {
    temp_18369 (HERE)->method_searchKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (429)), var_cas_startSymbolIndex, var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (429)) ;
  }
  ::routine_checkLabelMap (inLexique,  var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (432)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (432)),  var_cas_grammarComponentRoot.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (433)),  GGS_bool (false),  var_cas_nonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (435)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (435)) COMMA_SOURCE_FILE_AT_LINE (435)),  var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (431)) ;
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis  var_cas_unusedNonTerminalSymbolsForGrammar = GGS_unusedNonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_lstringlist::cEnumerator enumerator_18950 (var_cas_grammarComponentRoot.reader_mUnusedNonterminalList (inLexique COMMA_SOURCE_FILE_AT_LINE (440)), true) ;
    const GGS_lstringlist::cElement * operand_18950 = NULL ;
    while (((operand_18950 = enumerator_18950.nextObject ()))) {
      macroValidPointer (operand_18950) ;
      GGS_uint  var_cas_nonterminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_3 ;
      const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_19074 = var_cas_nonTerminalMapForGrammarAnalysis ;
      if (temp_19074.isBuilt ()) {
        temp_19074 (HERE)->method_searchKey (inLexique, operand_18950->mValue, var_cas_nonterminalIndex, automatic_var_3 COMMA_SOURCE_FILE_AT_LINE (442)) ;
      }
      var_cas_unusedNonTerminalSymbolsForGrammar.modifier_insertKey (inLexique, operand_18950->mValue, var_cas_nonterminalIndex COMMA_SOURCE_FILE_AT_LINE (443)) ;
    }
  }
  if (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (447)).isBuilt () &&
      var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (448)).isBuilt () &&
      var_cas_startSymbolIndex.isBuilt () &&
      var_cas_lexiqueComponentName.isBuilt () &&
      var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (451)).isBuilt () &&
      var_cas_actuallyUsedTerminalSymbolMap.isBuilt () &&
      var_cas_syntaxComponentListForGrammarAnalysis.isBuilt () &&
      var_cas_nonTerminalMapForGrammarAnalysis.isBuilt () &&
      var_cas_unusedNonTerminalSymbolsForGrammar.isBuilt () &&
      var_cas_inOutputDirectory.isBuilt ()) {
    ::routine_analyzeGrammar (inLexique,  var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (447)),  var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (448)),  var_cas_startSymbolIndex,  var_cas_lexiqueComponentName,  var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (451)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_unusedNonTerminalSymbolsForGrammar,  var_cas_inOutputDirectory COMMA_SOURCE_FILE_AT_LINE (446)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_grammarCompilation (void) {
 enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__terminalCheckInstruction__transformInstruction, gClassInfoFor__terminalCheckInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__nonterminalCallInstruction__transformInstruction, gClassInfoFor__nonterminalCallInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__repeatInstruction__transformInstruction, gClassInfoFor__repeatInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__selectInstruction__transformInstruction, gClassInfoFor__selectInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__parseDoInstruction__transformInstruction, gClassInfoFor__parseDoInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__blockInstruction__transformInstruction, gClassInfoFor__blockInstruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_grammarCompilation (prologueRoutineFor_grammarCompilation,
                                   NULL) ;

//---------------------------------------------------------------------------*

