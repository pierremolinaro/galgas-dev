//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'grammarCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     february 7th, 2010, at 19h52'43"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "grammarCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "transformLabelMap"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis  function_transformLabelMap (C_Compiler & inLexique,
                                const GGS_nonTerminalLabelList   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_transformLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis = GGS_nonterminalSymbolLabelMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_nonTerminalLabelList::cEnumerator enumerator_2206 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelList::cElement * operand_2206 = NULL ;
    while (((operand_2206 = enumerator_2206.nextObject ()))) {
      macroValidPointer (operand_2206) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList = GGS_signatureForGrammarAnalysis ::constructor_emptyList () ;
      {
        GGS_formalParameterList::cEnumerator enumerator_2307 (operand_2206->mFormalParameters, true) ;
        const GGS_formalParameterList::cElement * operand_2307 = NULL ;
        while (((operand_2307 = enumerator_2307.nextObject ()))) {
          macroValidPointer (operand_2307) ;
          var_cas_formalParametersList.addAssign_operation (operand_2307->mFormalParameterPassingMode, operand_2307->mFormalParameterTypeName) ;
        }
      }
      var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_2206->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (43)) ;
    }
  }
  const GGS_bool cond_2754 = var_cas_inHasParseLabel ;
  if (cond_2754.isBuiltAndTrue ()) {
    var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("parse"), GGS_location (inLexique) COMMA_HERE), GGS_signatureForGrammarAnalysis ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (49)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_transformLabelMap\n") ;
  #endif
  return var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_transformLabelMap (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_nonTerminalLabelList  arg_0 = GGS_nonTerminalLabelList ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_1 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_nonterminalSymbolLabelMapForGrammarAnalysis  result = function_transformLabelMap (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_transformLabelMap [2] = {& kTypeDescriptor_GGS_nonTerminalLabelList ,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_transformLabelMap ("transformLabelMap",
                              functionForGenericCall_transformLabelMap,
                              & kTypeDescriptor_GGS_nonterminalSymbolLabelMapForGrammarAnalysis ,
                              2,
                              kArgumentTypeList_transformLabelMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "checkLabelMap"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkLabelMap (C_Compiler & inLexique,
                                const GGS_location   var_cas_inNonTerminalLocation,
                                const GGS_nonTerminalLabelList   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel,
                                const GGS_location   var_cas_inOriginalNonTerminalLocation,
                                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis   var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_stringset  var_cas_labelStringSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_nonTerminalLabelList::cEnumerator enumerator_3175 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelList::cElement * operand_3175 = NULL ;
    while (((operand_3175 = enumerator_3175.nextObject ()))) {
      macroValidPointer (operand_3175) ;
      var_cas_labelStringSet.addAssign_operation (operand_3175->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (68))) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList ;
      const GGS_nonterminalSymbolLabelMapForGrammarAnalysis  temp_3340 = var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis ;
      if (temp_3340.isBuilt ()) {
        temp_3340 (HERE)->method_searchKey (inLexique, operand_3175->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (70)) ;
      }
      const GGS_bool cond_3916 = (operand_3175->mFormalParameters.reader_length ()).operator_isNotEqual (var_cas_formalParametersList.reader_length ()) ;
      if (cond_3916.isBuiltAndTrue ()) {
        operand_3175->mLabelName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((((operand_3175->mFormalParameters.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (72))).operator_concat (GGS_string (" formal parameter"))).operator_concat ((((operand_3175->mFormalParameters.reader_length ()).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string (""))))).operator_concat (GGS_string (" declared here, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3175->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (76)) COMMA_SOURCE_FILE_AT_LINE (76)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (76)))).operator_concat (GGS_string ("names "))).operator_concat (var_cas_formalParametersList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (77)))).operator_concat (GGS_string ("parameter"))).operator_concat ((((var_cas_formalParametersList.reader_length ()).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string ("")))) COMMA_SOURCE_FILE_AT_LINE (79)) ;
      }else if (cond_3916.isBuiltAndFalse ()) {
        {
          GGS_formalParameterList::cEnumerator enumerator_3948 (operand_3175->mFormalParameters, true) ;
          const GGS_formalParameterList::cElement * operand_3948 = NULL ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_3970 (var_cas_formalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_3970 = NULL ;
          while (((operand_3948 = enumerator_3948.nextObject ()))
              && ((operand_3970 = enumerator_3970.nextObject ()))) {
            macroValidPointer (operand_3948) ;
            macroValidPointer (operand_3970) ;
            const GGS_bool cond_4532 = (operand_3970->mFormalArgumentPassingModeForGrammarAnalysis).operator_isNotEqual (operand_3948->mFormalParameterPassingMode) ;
            if (cond_4532.isBuiltAndTrue ()) {
              operand_3970->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared with ")).operator_concat (operand_3970->mFormalArgumentPassingModeForGrammarAnalysis.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (84)))).operator_concat (GGS_string (" passing mode, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3175->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (86)) COMMA_SOURCE_FILE_AT_LINE (86)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (86)))).operator_concat (GGS_string (" is declared with "))).operator_concat (operand_3948->mFormalParameterPassingMode.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (87)))).operator_concat (GGS_string (" passing mode")) COMMA_SOURCE_FILE_AT_LINE (88)) ;
            }
            const GGS_bool cond_5028 = (operand_3970->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (89))).operator_isNotEqual (operand_3948->mFormalParameterTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (89))) ;
            if (cond_5028.isBuiltAndTrue ()) {
              operand_3970->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared of '@")).operator_concat (operand_3970->mGalgasTypeNameForGrammarAnalysis)).operator_concat (GGS_string ("' type, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3175->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (94)) COMMA_SOURCE_FILE_AT_LINE (94)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (94)))).operator_concat (GGS_string (" is declared with '@"))).operator_concat (operand_3948->mFormalParameterTypeName)).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (96)) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_5463 = var_cas_inHasParseLabel ;
  if (cond_5463.isBuiltAndTrue ()) {
    var_cas_labelStringSet.addAssign_operation (GGS_string ("parse")) ;
    const GGS_bool cond_5452 = (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_hasKey (GGS_string ("parse"))).operator_not () ;
    if (cond_5452.isBuiltAndTrue ()) {
      var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this non terminal is declared with 'parse' label, but declaration at ")).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (105)))).operator_concat (GGS_string (" does not declare 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (107)) ;
    }
  }
  {
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_5529 (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis, true) ;
    const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_5529 = NULL ;
    while (((operand_5529 = enumerator_5529.nextObject ()))) {
      macroValidPointer (operand_5529) ;
      const GGS_bool cond_5801 = (var_cas_labelStringSet.reader_hasKey (operand_5529->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (111)))).operator_not () ;
      if (cond_5801.isBuiltAndTrue ()) {
        var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this non terminal does not declare the '")).operator_concat (operand_5529->mKey)).operator_concat (GGS_string ("' label, but declaration at "))).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (114)))).operator_concat (GGS_string (" does")) COMMA_SOURCE_FILE_AT_LINE (116)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkLabelMap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "handleNonTerminalDeclarations"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleNonTerminalDeclarations (C_Compiler & inLexique,
                                GGS_nonTerminalSymbolMapForGrammarAnalysis  & var_cas_ioNonTerminalMapForGrammarAnalysis,
                                const GGS_nonterminalDeclarationList   var_cas_inNonterminalDeclarationList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleNonTerminalDeclarations at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_nonterminalDeclarationList::cEnumerator enumerator_6135 (var_cas_inNonterminalDeclarationList, true) ;
    const GGS_nonterminalDeclarationList::cElement * operand_6135 = NULL ;
    while (((operand_6135 = enumerator_6135.nextObject ()))) {
      macroValidPointer (operand_6135) ;
      elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis * operand_6184 = (elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis *) var_cas_ioNonTerminalMapForGrammarAnalysis.searchForTolerantWithInstruction (operand_6135->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (127))) ;
      if (NULL != operand_6184) {
        ::routine_checkLabelMap (inLexique,  operand_6135->mNonterminalName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (129)),  operand_6135->mLabels,  operand_6135->mHasParseLabel,  var_cas_ioNonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_6135->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (132)) COMMA_SOURCE_FILE_AT_LINE (132)),  operand_6184->mInfo.mNonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (128)) ;
      }else{
        var_cas_ioNonTerminalMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_6135->mNonterminalName, var_cas_ioNonTerminalMapForGrammarAnalysis.reader_count (), function_transformLabelMap (inLexique, operand_6135->mLabels, operand_6135->mHasParseLabel COMMA_SOURCE_FILE_AT_LINE (139)) COMMA_SOURCE_FILE_AT_LINE (136)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleNonTerminalDeclarations\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@syntaxInstruction.transformInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__syntaxInstruction__transformInstruction> gDispatchTableForMethod__syntaxInstruction__transformInstruction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__syntaxInstruction__transformInstruction (typeCategoryMethod__syntaxInstruction__transformInstruction inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__syntaxInstruction__transformInstruction.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__syntaxInstruction__transformInstruction
findCategoryMethod__syntaxInstruction__transformInstruction (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__syntaxInstruction__transformInstruction result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__syntaxInstruction__transformInstruction.count ()) {
    result = gDispatchTableForMethod__syntaxInstruction__transformInstruction (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__syntaxInstruction__transformInstruction (superClassPtr) ;
      gDispatchTableForMethod__syntaxInstruction__transformInstruction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@semanticInstruction.transformInstruction'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticInstruction__transformInstruction (C_Compiler &,
                                const cPtr_semanticInstruction * operand_7384,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7384 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "transformInstructionList"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_transformInstructionList (C_Compiler & inLexique,
                                const GGS_syntaxInstructionList   var_cas_inInstructionList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_transformInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_syntaxInstructionList::cEnumerator enumerator_8103 (var_cas_inInstructionList, true) ;
    const GGS_syntaxInstructionList::cElement * operand_8103 = NULL ;
    while (((operand_8103 = enumerator_8103.nextObject ()))) {
      macroValidPointer (operand_8103) ;
      const GGS_syntaxInstruction  temp_8145 = operand_8103->mInstruction ;
      if (temp_8145.isBuilt ()) {
        typeCategoryMethod__syntaxInstruction__transformInstruction method = findCategoryMethod__syntaxInstruction__transformInstruction (temp_8145.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_8145 (HERE), var_cas_ioActuallyUsedTerminalSymbolMap, var_cas_inNonTerminalSymbolMap, var_cas_ioAddedNonTerminalIndex, var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (176)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_transformInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@terminalCheckInstruction.transformInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__terminalCheckInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_terminalCheckInstruction * operand_8459,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8459 != NULL) {
    GGS_uint  var_cas_terminalSymbolIndex ;
    elementOf_GGS_terminalSymbolsMapForGrammarAnalysis * operand_8790 = (elementOf_GGS_terminalSymbolsMapForGrammarAnalysis *) var_cas_ioActuallyUsedTerminalSymbolMap.searchForTolerantWithInstruction (operand_8459->mTerminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (194))) ;
    if (NULL != operand_8790) {
      var_cas_terminalSymbolIndex = operand_8790->mInfo.mTerminalIndex ;
    }else{
      var_cas_terminalSymbolIndex = var_cas_ioActuallyUsedTerminalSymbolMap.reader_count () ;
      var_cas_ioActuallyUsedTerminalSymbolMap.modifier_insertKey (inLexique, operand_8459->mTerminalName, var_cas_terminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (198)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_terminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_8459->mStartLocation, operand_8459->mTerminalName, var_cas_terminalSymbolIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@nonterminalCallInstruction.transformInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__nonterminalCallInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_nonterminalCallInstruction * operand_9347,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9347 != NULL) {
    GGS_uint  var_cas_nonTerminalSymbolIndex ;
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_9722_0 ;
    const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_9676 = var_cas_inNonTerminalSymbolMap ;
    if (temp_9676.isBuilt ()) {
      temp_9676 (HERE)->method_searchKey (inLexique, operand_9347->mNonterminalName, var_cas_nonTerminalSymbolIndex, automatic_var_9722_0 COMMA_SOURCE_FILE_AT_LINE (216)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_nonTerminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_9347->mStartLocation, operand_9347->mNonterminalName, var_cas_nonTerminalSymbolIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@repeatInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__repeatInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_repeatInstruction * operand_10026,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10026 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (233)) ;
    GGS_syntaxInstructionListForGrammarAnalysis  var_cas_repeatedInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
    ::routine_transformInstructionList (inLexique,  operand_10026->mRepeatedInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_repeatedInstructionList COMMA_SOURCE_FILE_AT_LINE (236)) ;
    GGS_branchListForGrammarAnalysis  var_cas_repeatBranchList = GGS_branchListForGrammarAnalysis ::constructor_listWithValue (var_cas_repeatedInstructionList) ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_10758 (operand_10026->mRepeatBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_10758 = NULL ;
      while (((operand_10758 = enumerator_10758.nextObject ()))) {
        macroValidPointer (operand_10758) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_10758->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (247)) ;
        var_cas_repeatBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_repeatInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_10026->mStartLocation, var_cas_repeatBranchList, var_cas_addedNonTerminalIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@selectInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__selectInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_selectInstruction * operand_11401,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11401 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (273)) ;
    GGS_branchListForGrammarAnalysis  var_cas_selectBranchList = GGS_branchListForGrammarAnalysis ::constructor_emptyList () ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_11835 (operand_11401->mSelectBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_11835 = NULL ;
      while (((operand_11835 = enumerator_11835.nextObject ()))) {
        macroValidPointer (operand_11835) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_11835->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (278)) ;
        var_cas_selectBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_selectInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_11401->mStartLocation, var_cas_selectBranchList, var_cas_addedNonTerminalIndex COMMA_HERE)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@parseDoInstruction.transformInstruction'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseDoInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseDoInstruction * operand_12479,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12479 != NULL) {
    GGS_syntaxInstructionList  var_cas_syntaxInstructionList ;
    const GGS_listOfSyntaxInstructionList  temp_12802 = operand_12479->mParseDoBranchList ;
    if (temp_12802.isBuilt ()) {
      temp_12802 (HERE)->method_first (inLexique, var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (304)) ;
    }
    ::routine_transformInstructionList (inLexique,  var_cas_syntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (306)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@parseWhenInstruction.transformInstruction'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseWhenInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseWhenInstruction * operand_13165,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13165 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_13165->mElseInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (323)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@parseLoopInstruction.transformInstruction'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseLoopInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_parseLoopInstruction * operand_13746,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13746 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_13746->mDoInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (340)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@blockInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__blockInstruction__transformInstruction (C_Compiler & inLexique,
                                const cPtr_blockInstruction * operand_14321,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14321 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_14321->mInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (357)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "buildRuleList"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildRuleList (C_Compiler & inLexique,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalMapForGrammarAnalysis,
                                const GGS_lstring   var_cas_inSyntaxComponentName,
                                const GGS_syntaxRuleList   var_cas_inRuleList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                GGS_syntaxComponentListForGrammarAnalysis  & var_cas_ioSyntaxComponentListForGrammarAnalysis,
                                GGS_uint  & var_cas_ioAddedNonTerminalCount COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildRuleList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_productionRuleListForGrammarAnalysis  var_cas_productionRulesList = GGS_productionRuleListForGrammarAnalysis ::constructor_emptyList () ;
  {
    GGS_syntaxRuleList::cEnumerator enumerator_15294 (var_cas_inRuleList, true) ;
    const GGS_syntaxRuleList::cElement * operand_15294 = NULL ;
    while (((operand_15294 = enumerator_15294.nextObject ()))) {
      macroValidPointer (operand_15294) ;
      GGS_uint  var_cas_nonTerminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_nonterminalSymbolParametersMap ;
      const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_15458 = var_cas_inNonTerminalMapForGrammarAnalysis ;
      if (temp_15458.isBuilt ()) {
        temp_15458 (HERE)->method_searchKey (inLexique, operand_15294->mNonterminalName, var_cas_nonTerminalIndex, var_cas_nonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (380)) ;
      }
      GGS_syntaxInstructionList  var_cas_parsedSyntaxInstructionList ;
      GGS_lstring  automatic_var_15690_0 ;
      GGS_formalParameterList  automatic_var_15690_1 ;
      const GGS_syntaxRuleLabelList  temp_15654 = operand_15294->mLabelList ;
      if (temp_15654.isBuilt ()) {
        temp_15654 (HERE)->method_first (inLexique, automatic_var_15690_0, automatic_var_15690_1, var_cas_parsedSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (382)) ;
      }
      GGS_syntaxInstructionListForGrammarAnalysis  var_cas_instructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
      ::routine_transformInstructionList (inLexique,  var_cas_parsedSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalMapForGrammarAnalysis,  var_cas_ioAddedNonTerminalCount,  var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (385)) ;
      var_cas_productionRulesList.addAssign_operation (operand_15294->mNonterminalName, var_cas_nonTerminalIndex, var_cas_instructionList) ;
    }
  }
  var_cas_ioSyntaxComponentListForGrammarAnalysis.addAssign_operation (var_cas_productionRulesList, var_cas_inSyntaxComponentName) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildRuleList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@nonTerminalToAddList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nonTerminalToAddList::
elementOf_GGS_nonTerminalToAddList (const GGS_string& argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSyntaxComponentName (argument_0),
mNonTerminalToAddCount (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonTerminalToAddList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_nonTerminalToAddList * ptr = dynamic_cast <const elementOf_GGS_nonTerminalToAddList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue ()
         && mNonTerminalToAddCount.operator_isEqual (ptr->mNonTerminalToAddCount).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonTerminalToAddList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonTerminalToAddCount.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@nonTerminalToAddList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonTerminalToAddList ("nonTerminalToAddList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_uint & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
operator_concat (const GGS_nonTerminalToAddList & inOperand) const {
  GGS_nonTerminalToAddList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
dotAssign_operation (const GGS_nonTerminalToAddList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_nonTerminalToAddList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mSyntaxComponentName ;
          GGS_uint  p_1 = p->mNonTerminalToAddCount ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_uint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSyntaxComponentName,
                                ptr->mNonTerminalToAddCount
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList  GGS_nonTerminalToAddList::
constructor_emptyList (void) {
  GGS_nonTerminalToAddList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList  GGS_nonTerminalToAddList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_uint & argument_1) {
  GGS_nonTerminalToAddList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalSubListWithRange (GGS_nonTerminalToAddList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSyntaxComponentName, ptr->mNonTerminalToAddCount) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_nonTerminalToAddList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_nonTerminalToAddList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalToAddList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@nonTerminalToAddList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_uint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalToAddList::
reader_mSyntaxComponentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxComponentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_nonTerminalToAddList::
reader_mNonTerminalToAddCountAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNonTerminalToAddCount ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_setMSyntaxComponentNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxComponentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_setMNonTerminalToAddCountAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNonTerminalToAddCount = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nonTerminalToAddList::cEnumerator::_mSyntaxComponentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxComponentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_nonTerminalToAddList::cEnumerator::_mNonTerminalToAddCount (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNonTerminalToAddCount ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nonTerminalToAddList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonTerminalToAddList * p = NULL ;
    macroMyNew (p, GGS_nonTerminalToAddList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonTerminalToAddList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonTerminalToAddList * p = dynamic_cast <const GGS_nonTerminalToAddList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonTerminalToAddList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonTerminalToAddList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonTerminalToAddList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of wrapper 'grammarGenerationTemplate'            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_grammarGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_grammarGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_grammarGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_grammarGenerationTemplate_0,
  0,
  gWrapperAllDirectories_grammarGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'oldGrammarZone2Header' template of 'grammarGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_oldGrammarZone2Header (C_Compiler & inLexique,
                                const GGS_grammarComponentRoot & var_cas_GRAMMAR_COMPONENT_ROOT) {
  C_String result ;
  const bool isBuilt = var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (1)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "#define GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (2)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_336 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (6)), true) ;
    const GGS_lstringlist::cElement * operand_336 = NULL ;
    while (((operand_336 = enumerator_336.nextObject ()))) {
      macroValidPointer (operand_336) ;
      result << "#include \"" ;
      result << operand_336->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (7)).reader_stringByDeletingPathExtension () ;
      result << ".h\"\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'oldGrammarZone3Header' template of 'grammarGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_oldGrammarZone3Header (C_Compiler & inLexique,
                                const GGS_string& var_cas_LEXIQUE_CLASS,
                                const GGS_grammarComponentRoot & var_cas_GRAMMAR_COMPONENT_ROOT,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis & var_cas_NON_TERMINAL_MAP,
                                const GGS_nonTerminalToAddList & var_cas_ADDED_NON_TERMINAL_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_LEXIQUE_CLASS.isBuilt ()
    && var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt ()
    && var_cas_NON_TERMINAL_MAP.isBuilt ()
    && var_cas_ADDED_NON_TERMINAL_LIST.isBuilt () ;
  if (isBuilt) {
    result << "//---------------------------------------------------------------------------*\n"
      "\n"
      "class C_Grammar_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (3)).ggs_string ().reader_identifierRepresentation () ;
    result << " : " ;
    const GGS_string var_cas_COLUMN_CLASS_DECLARATION = GGS_string::stringWithColumnCount (result) ;
    GGS_lstringlist::cEnumerator enumerator_247 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (4)), true) ;
    const GGS_lstringlist::cElement * operand_247 = NULL ;
    while (((operand_247 = enumerator_247.nextObject ()))) {
      macroValidPointer (operand_247) ;
      result << "public " ;
      result << operand_247->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5)).reader_stringByDeletingPathExtension () ;
      if (enumerator_247.hasNextObject ()) {
        result << ",\n" ;
        result << var_cas_COLUMN_CLASS_DECLARATION ;
      }
    }
    result << " {\n" ;
    GGS_nonTerminalSymbolMapForGrammarAnalysis::cEnumerator enumerator_393 (var_cas_NON_TERMINAL_MAP, true) ;
    const GGS_nonTerminalSymbolMapForGrammarAnalysis::cElement * operand_393 = NULL ;
    while (((operand_393 = enumerator_393.nextObject ()))) {
      macroValidPointer (operand_393) ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_456 (operand_393->mInfo.mNonterminalSymbolParametersMap, true) ;
      const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_456 = NULL ;
      while (((operand_456 = enumerator_456.nextObject ()))) {
        macroValidPointer (operand_456) ;
        result << "  public : virtual void nt_" ;
        result << operand_393->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (12)) ;
        result << "_" ;
        result << operand_456->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (12)) ;
        result << " (" ;
        const GGS_string var_cas_COLUMN1 = GGS_string::stringWithColumnCount (result) ;
        result << "C_Lexique_" ;
        result << var_cas_LEXIQUE_CLASS ;
        result << " &" ;
        GGS_signatureForGrammarAnalysis::cEnumerator enumerator_611 (operand_456->mInfo.mFormalParametersList, true) ;
        const GGS_signatureForGrammarAnalysis::cElement * operand_611 = NULL ;
        while (((operand_611 = enumerator_611.nextObject ()))) {
          macroValidPointer (operand_611) ;
          result << ",\n" ;
          result << var_cas_COLUMN1 ;
          result << operand_611->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
          result << "GGS_" ;
          result << operand_611->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
          result << operand_611->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
        }
        result << ") ;\n"
          "\n" ;
        if ((var_cas_GRAMMAR_COMPONENT_ROOT.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (17)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17))).operator_isEqual (operand_393->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17))).boolValue ()) {
          result << "  public : static void _performSourceFileParsing_" ;
          result << operand_456->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (18)) ;
          result << " (" ;
          const GGS_string var_cas_COLUMN2 = GGS_string::stringWithColumnCount (result) ;
          result << "C_Compiler & inCompiler,\n" ;
          result << var_cas_COLUMN2 ;
          result << "const C_String & inDependancyExtension,\n" ;
          result << var_cas_COLUMN2 ;
          result << "const C_String & inDependancyPath,\n" ;
          result << var_cas_COLUMN2 ;
          result << "GGS_string * inSentStringPtr,\n" ;
          result << var_cas_COLUMN2 ;
          result << "const GGS_lstring inFileName" ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1313 (operand_456->mInfo.mFormalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_1313 = NULL ;
          while (((operand_1313 = enumerator_1313.nextObject ()))) {
            macroValidPointer (operand_1313) ;
            result << ",\n" ;
            result << var_cas_COLUMN2 ;
            result << operand_1313->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
            result << "GGS_" ;
            result << operand_1313->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
            result << operand_1313->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
          }
          result << "\n" ;
          result << var_cas_COLUMN2 ;
          result << "COMMA_LOCATION_ARGS) ;\n"
            "\n"
            "  public : static void _performSourceStringParsing_" ;
          result << operand_456->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (27)) ;
          result << " (" ;
          const GGS_string var_cas_COLUMN3 = GGS_string::stringWithColumnCount (result) ;
          result << "C_Compiler & inCompiler,\n" ;
          result << var_cas_COLUMN3 ;
          result << "GGS_string * inSentStringPtr,\n" ;
          result << var_cas_COLUMN3 ;
          result << "const GGS_string inSourceString" ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1865 (operand_456->mInfo.mFormalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_1865 = NULL ;
          while (((operand_1865 = enumerator_1865.nextObject ()))) {
            macroValidPointer (operand_1865) ;
            result << ",\n" ;
            result << var_cas_COLUMN3 ;
            result << operand_1865->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
            result << "GGS_" ;
            result << operand_1865->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
            result << operand_1865->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
          }
          result << "\n" ;
          result << var_cas_COLUMN3 ;
          result << "COMMA_LOCATION_ARGS) ;\n"
            "\n" ;
        }else {
        }
      }
    }
    GGS_nonTerminalToAddList::cEnumerator enumerator_2232 (var_cas_ADDED_NON_TERMINAL_LIST, true) ;
    const GGS_nonTerminalToAddList::cElement * operand_2232 = NULL ;
    while (((operand_2232 = enumerator_2232.nextObject ()))) {
      macroValidPointer (operand_2232) ;
      result << "  public : virtual PMSInt16 select_" ;
      result << operand_2232->mSyntaxComponentName.reader_identifierRepresentation () ;
      result << "_" ;
      result << operand_2232->mNonTerminalToAddCount.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (38)) ;
      result << " (C_Lexique_" ;
      result << var_cas_LEXIQUE_CLASS ;
      result << " &) ;\n" ;
      if (enumerator_2232.hasNextObject ()) {
        result << "\n" ;
      }
    }
    result << "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#endif\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileGrammarComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectoryForCppFiles,
                                const GGS_string  var_cas_inOutputDirectoryForHTMLFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_grammarComponentRoot  var_cas_grammarComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    C_Grammar_grammarLL_31_grammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_grammarComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (444)) ;
  }
  const GGS_lstring  var_cas_grammarComponentName = var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (446)) ;
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  const GGS_bool cond_18517 = (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (448))).operator_isNotEqual (var_cas_basename) ;
  if (cond_18517.isBuiltAndTrue ()) {
    var_cas_grammarComponentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (450)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (452)) ;
  }
  GGS_terminalSymbolsMapForGrammarAnalysis  var_cas_actuallyUsedTerminalSymbolMap = GGS_terminalSymbolsMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  GGS_nonTerminalSymbolMapForGrammarAnalysis  var_cas_nonTerminalMapForGrammarAnalysis = GGS_nonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  GGS_string var_cas_lexiqueComponentName = GGS_string ("") ;
  GGS_syntaxComponentListForGrammarAnalysis  var_cas_syntaxComponentListForGrammarAnalysis = GGS_syntaxComponentListForGrammarAnalysis ::constructor_emptyList () ;
  GGS_nonTerminalToAddList  var_cas_nonTerminalToAddList = GGS_nonTerminalToAddList ::constructor_emptyList () ;
  GGS_uint  var_cas_addedNonTerminalCount = GGS_uint (0U) ;
  {
    GGS_lstringlist::cEnumerator enumerator_19046 (var_cas_grammarComponentRoot.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (461)), true) ;
    const GGS_lstringlist::cElement * operand_19046 = NULL ;
    while (((operand_19046 = enumerator_19046.nextObject ()))) {
      macroValidPointer (operand_19046) ;
      const GGS_uint  var_cas_addedNonTerminalCountRef = var_cas_addedNonTerminalCount ;
      const GGS_bool cond_19350 = ((operand_19046->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("gSyntax"))).operator_and ((operand_19046->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("ggs"))) ;
      if (cond_19350.isBuiltAndTrue ()) {
        operand_19046->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a syntax component file should have '.ggs' or '.gSyntax' as path extension") COMMA_SOURCE_FILE_AT_LINE (465)) ;
      }else if (cond_19350.isBuiltAndFalse ()) {
        GGS_string var_cas_syntaxComponentName = operand_19046->mValue.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
        GGS_syntaxComponentRoot  var_cas_syntaxComponentRoot ;
        const GGS_bool cond_19742 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (468)).reader_hasKey (var_cas_syntaxComponentName) ;
        if (cond_19742.isBuiltAndTrue ()) {
          const GGS_parsedSyntaxComponentMap  temp_19664 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (469)) ;
          if (temp_19664.isBuilt ()) {
            temp_19664 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, GGS_location (inLexique) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (469)) ;
          }
        }else if (cond_19742.isBuiltAndFalse ()) {
          GGS_string var_cas_sourceFilePath = operand_19046->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent ()) ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            C_Grammar_syntaxSLRgrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_sourceFilePath, operand_19046->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (472)) COMMA_HERE),
                                          var_cas_syntaxComponentRoot
                                          COMMA_SOURCE_FILE_AT_LINE (472)) ;
          }
          var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, operand_19046->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (473)) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (473)) ;
        }
        GGS_string var_cas_currentLexiqueName = var_cas_syntaxComponentRoot.reader_mImportedLexiqueReference (inLexique COMMA_SOURCE_FILE_AT_LINE (476)).ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
        const GGS_bool cond_20411 = (var_cas_lexiqueComponentName).operator_isEqual (GGS_string ("")) ;
        if (cond_20411.isBuiltAndTrue ()) {
          var_cas_lexiqueComponentName = var_cas_currentLexiqueName ;
        }else if (cond_20411.isBuiltAndFalse ()) {
          const GGS_bool cond_20706 = (var_cas_lexiqueComponentName).operator_isNotEqual (var_cas_currentLexiqueName) ;
          if (cond_20706.isBuiltAndTrue ()) {
            operand_19046->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this syntax component uses '")).operator_concat (var_cas_currentLexiqueName)).operator_concat (GGS_string ("' lexique component, but the first syntax component uses the '"))).operator_concat (var_cas_lexiqueComponentName)).operator_concat (GGS_string ("' lexique component (they should be the same)")) COMMA_SOURCE_FILE_AT_LINE (483)) ;
          }
        }
        ::routine_handleNonTerminalDeclarations (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mNonterminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (487)) COMMA_SOURCE_FILE_AT_LINE (485)) ;
        ::routine_buildRuleList (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mSyntaxComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (492)),  var_cas_syntaxComponentRoot.reader_mRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (493)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_addedNonTerminalCount COMMA_SOURCE_FILE_AT_LINE (490)) ;
        GGS_uint  var_cas_i = GGS_uint (0U) ;
        GGS_uint _variant_21413 = var_cas_addedNonTerminalCount ;
        GGS_bool _condition_21413 (_variant_21413.isBuilt (), true) ;
        while (_condition_21413.isBuiltAndTrue ()) {
          _condition_21413 = (var_cas_i).operator_strictInf (var_cas_addedNonTerminalCount.substract_operation (inLexique, var_cas_addedNonTerminalCountRef COMMA_SOURCE_FILE_AT_LINE (499))) ;
          if (_condition_21413.isBuiltAndTrue ()) {
            if (_variant_21413.uintValue () == 0) {
              inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (502)) ;
              _condition_21413 = GGS_bool (false) ;
            }else{
              _variant_21413.decrement_operation (inLexique COMMA_HERE) ;
              var_cas_nonTerminalToAddList.addAssign_operation (var_cas_syntaxComponentName, var_cas_i) ;
              var_cas_i.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (501)) ;
            }
          }
        }
      }
    }
  }
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_startSymbolAltMap ;
  GGS_uint  var_cas_startSymbolIndex ;
  const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_21707 = var_cas_nonTerminalMapForGrammarAnalysis ;
  if (temp_21707.isBuilt ()) {
    temp_21707 (HERE)->method_searchKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (509)), var_cas_startSymbolIndex, var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (509)) ;
  }
  ::routine_checkLabelMap (inLexique,  var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (512)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (512)),  var_cas_grammarComponentRoot.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (513)),  var_cas_grammarComponentRoot.reader_mStartSymbolHasParseLabel (inLexique COMMA_SOURCE_FILE_AT_LINE (514)),  var_cas_nonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (515)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (515)) COMMA_SOURCE_FILE_AT_LINE (515)),  var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (511)) ;
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis  var_cas_unusedNonTerminalSymbolsForGrammar = GGS_unusedNonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_lstringlist::cEnumerator enumerator_22314 (var_cas_grammarComponentRoot.reader_mUnusedNonterminalList (inLexique COMMA_SOURCE_FILE_AT_LINE (520)), true) ;
    const GGS_lstringlist::cElement * operand_22314 = NULL ;
    while (((operand_22314 = enumerator_22314.nextObject ()))) {
      macroValidPointer (operand_22314) ;
      GGS_uint  var_cas_nonterminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_22468_0 ;
      const GGS_nonTerminalSymbolMapForGrammarAnalysis  temp_22438 = var_cas_nonTerminalMapForGrammarAnalysis ;
      if (temp_22438.isBuilt ()) {
        temp_22438 (HERE)->method_searchKey (inLexique, operand_22314->mValue, var_cas_nonterminalIndex, automatic_var_22468_0 COMMA_SOURCE_FILE_AT_LINE (522)) ;
      }
      var_cas_unusedNonTerminalSymbolsForGrammar.modifier_insertKey (inLexique, operand_22314->mValue, var_cas_nonterminalIndex COMMA_SOURCE_FILE_AT_LINE (523)) ;
    }
  }
  if (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (527)).isBuilt () &&
      var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (528)).isBuilt () &&
      var_cas_startSymbolIndex.isBuilt () &&
      var_cas_lexiqueComponentName.isBuilt () &&
      var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (531)).isBuilt () &&
      var_cas_actuallyUsedTerminalSymbolMap.isBuilt () &&
      var_cas_syntaxComponentListForGrammarAnalysis.isBuilt () &&
      var_cas_nonTerminalMapForGrammarAnalysis.isBuilt () &&
      var_cas_unusedNonTerminalSymbolsForGrammar.isBuilt () &&
      var_cas_inOutputDirectoryForCppFiles.isBuilt () &&
      var_cas_inOutputDirectoryForHTMLFile.isBuilt ()) {
    ::routine_analyzeGrammar (inLexique,  var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (527)),  var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (528)),  var_cas_startSymbolIndex,  var_cas_lexiqueComponentName,  var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (531)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_unusedNonTerminalSymbolsForGrammar,  var_cas_inOutputDirectoryForCppFiles,  var_cas_inOutputDirectoryForHTMLFile COMMA_SOURCE_FILE_AT_LINE (526)) ;
  }
  const GGS_bool cond_23786 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_23786.isBuiltAndTrue ()) {
    const GGS_string var_cas_zone2 = template_filewrapper_grammarGenerationTemplate_oldGrammarZone2Header (inLexique, var_cas_grammarComponentRoot) ;
    const GGS_string var_cas_zone3 = template_filewrapper_grammarGenerationTemplate_oldGrammarZone3Header (inLexique, var_cas_lexiqueComponentName.reader_identifierRepresentation (), var_cas_grammarComponentRoot, var_cas_nonTerminalMapForGrammarAnalysis, var_cas_nonTerminalToAddList) ;
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectoryForCppFiles, (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (552)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (552))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_zone2, GGS_string ("\n"
      "\n"), var_cas_zone3 COMMA_SOURCE_FILE_AT_LINE (550)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_grammarCompilation (void) {
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__semanticInstruction__transformInstruction, gClassInfoFor__semanticInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__terminalCheckInstruction__transformInstruction, gClassInfoFor__terminalCheckInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__nonterminalCallInstruction__transformInstruction, gClassInfoFor__nonterminalCallInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__repeatInstruction__transformInstruction, gClassInfoFor__repeatInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__selectInstruction__transformInstruction, gClassInfoFor__selectInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__parseDoInstruction__transformInstruction, gClassInfoFor__parseDoInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__parseWhenInstruction__transformInstruction, gClassInfoFor__parseWhenInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__parseLoopInstruction__transformInstruction, gClassInfoFor__parseLoopInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstruction__transformInstruction ((typeCategoryMethod__syntaxInstruction__transformInstruction) category_method__blockInstruction__transformInstruction, gClassInfoFor__blockInstruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_grammarCompilation (void) {
  gDispatchTableForMethod__syntaxInstruction__transformInstruction.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_grammarCompilation (prologueRoutineFor_grammarCompilation, epilogueRoutineFor_grammarCompilation) ;

//---------------------------------------------------------------------------*

