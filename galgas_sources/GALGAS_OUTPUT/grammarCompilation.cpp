//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'grammarCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 19th, 2009, at 21h52'43"                     *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "grammarCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_nonTerminalMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_nonTerminalMap::e_nonTerminalMap (void) :
mLabels (),
mHasParseLabel () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@nonTerminalMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nonTerminalMap::
elementOf_GGS_nonTerminalMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_nonTerminalMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonTerminalMap::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLabels.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasParseLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonTerminalMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_nonTerminalMap * ptr = dynamic_cast <const elementOf_GGS_nonTerminalMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLabels.operator_isEqual (ptr->mInfo.mLabels)).boolValue ()
           && (mInfo.mHasParseLabel.operator_isEqual (ptr->mInfo.mHasParseLabel)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_nonTerminalMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_nonTerminalMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_nonTerminalMap * info = (e_nonTerminalMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_nonTerminalMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_nonTerminalMap * info = (e_nonTerminalMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalMap GGS_nonTerminalMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_nonTerminalMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonTerminalMap::
operator_isEqual (const GGS_nonTerminalMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonTerminalMap::
operator_isNotEqual (const GGS_nonTerminalMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_nonTerminalLabelList & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_nonTerminalMap info  ;
    info.mLabels = inParameter0 ;
    info.mHasParseLabel = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_nonTerminalLabelList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mLabels ;
    outParameter1 = node->mInfo.mHasParseLabel ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonTerminalMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_nonTerminalLabelList   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonTerminalMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_nonTerminalLabelList & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalMap GGS_nonTerminalMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_nonTerminalMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalMap GGS_nonTerminalMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_nonTerminalMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @nonTerminalMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_nonTerminalLabelList  & GGS_nonTerminalMap::cEnumerator::_mLabels (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLabels ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_nonTerminalMap::cEnumerator::_mHasParseLabel (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasParseLabel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileGrammarComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_grammarComponentRoot  var_cas_grammarComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    grammarLL1grammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_grammarComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (48)) ;
  }
  GGS_lstring  var_cas_componentName ;
  var_cas_componentName = var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (50)) ;
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (51)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (51)) ;
  if (((var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (52))).operator_isNotEqual (var_cas_basename)).isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (54)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (56)) ;
  }
  GGS_string var_cas_lexiqueComponent ;
  var_cas_lexiqueComponent = GGS_string ("") ;
  {
    GGS_lstringlist::cEnumerator enumerator_3237 (var_cas_grammarComponentRoot.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (60)), true) ;
    const GGS_lstringlist::cElement * operand_3237 = NULL ;
    while (((operand_3237 = enumerator_3237.nextObject ()))) {
      macroValidPointer (operand_3237) ;
      if (((operand_3237->mValue.ggs_string ().reader_pathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (61))).operator_isNotEqual (GGS_string ("gSyntax"))).isBuiltAndTrue ()) {
        operand_3237->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a syntax component file should have '.gSyntax' as path extension") COMMA_SOURCE_FILE_AT_LINE (63)) ;
      }else{
        GGS_string var_cas_syntaxComponentName ;
        var_cas_syntaxComponentName = operand_3237->mValue.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (64)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (64)) ;
        GGS_syntaxComponentRoot  var_cas_syntaxComponentRoot ;
        if ((var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (66)).reader_hasKey (inLexique, var_cas_syntaxComponentName COMMA_SOURCE_FILE_AT_LINE (66))).isBuiltAndTrue ()) {
          const GGS_parsedSyntaxComponentMap  temp_3739 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (67)) ;
          if (temp_3739.isBuilt ()) {
            temp_3739 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, GGS_location (inLexique) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (67)) ;
          }
        }else{
          GGS_string var_cas_sourceFilePath ;
          var_cas_sourceFilePath = operand_3237->mValue.ggs_string ().reader_absolutePathFromPath (inLexique, var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (69)) COMMA_SOURCE_FILE_AT_LINE (69)) ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            syntaxSLRgrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_sourceFilePath, operand_3237->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (70)) COMMA_HERE),
                                          var_cas_syntaxComponentRoot
                                          COMMA_SOURCE_FILE_AT_LINE (70)) ;
          }
          var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, operand_3237->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (71)) COMMA_HERE), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (71)) ;
        }
        GGS_string var_cas_currentLexiqueName ;
        var_cas_currentLexiqueName = var_cas_syntaxComponentRoot.reader_mImportedLexiqueReference (inLexique COMMA_SOURCE_FILE_AT_LINE (74)).ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (74)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (74)) ;
        if (((var_cas_lexiqueComponent).operator_isEqual (GGS_string (""))).isBuiltAndTrue ()) {
          var_cas_lexiqueComponent = var_cas_currentLexiqueName ;
        }else if (((var_cas_lexiqueComponent).operator_isNotEqual (var_cas_currentLexiqueName)).isBuiltAndTrue ()) {
          operand_3237->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this syntax component uses '")).operator_concat (var_cas_currentLexiqueName)).operator_concat (GGS_string ("' lexique component, but the first syntax component uses the '"))).operator_concat (var_cas_lexiqueComponent)).operator_concat (GGS_string ("' lexique component (they should be the same)")) COMMA_SOURCE_FILE_AT_LINE (81)) ;
        }
        GGS_nonTerminalMap  var_cas_nonTerminalMap ;
        var_cas_nonTerminalMap = GGS_nonTerminalMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
        {
          GGS_nonterminalDeclarationList::cEnumerator enumerator_4878 (var_cas_syntaxComponentRoot.reader_mNonterminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (84)), true) ;
          const GGS_nonterminalDeclarationList::cElement * operand_4878 = NULL ;
          while (((operand_4878 = enumerator_4878.nextObject ()))) {
            macroValidPointer (operand_4878) ;
            if ((var_cas_nonTerminalMap.reader_hasKey (inLexique, operand_4878->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (85)) COMMA_SOURCE_FILE_AT_LINE (85))).isBuiltAndTrue ()) {
              GGS_nonTerminalLabelList  var_cas_labels ;
              GGS_bool var_cas_hasParseLabel ;
              const GGS_nonTerminalMap  temp_5105 = var_cas_nonTerminalMap ;
              if (temp_5105.isBuilt ()) {
                temp_5105 (HERE)->method_searchKey (inLexique, operand_4878->mNonterminalName, var_cas_labels, var_cas_hasParseLabel COMMA_SOURCE_FILE_AT_LINE (88)) ;
              }
              if (((operand_4878->mHasParseLabel).operator_and ((var_cas_hasParseLabel).operator_not ())).isBuiltAndTrue ()) {
                operand_4878->mNonterminalName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this declaration has a 'parse' label, but declaration of the same non terminal in ")).operator_concat (var_cas_nonTerminalMap.reader_locationForKey (inLexique, operand_4878->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (96)) COMMA_SOURCE_FILE_AT_LINE (96)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (96)))).operator_concat (GGS_string (" does not have a 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (98)) ;
              }else if ((((operand_4878->mHasParseLabel).operator_not ()).operator_and (var_cas_hasParseLabel)).isBuiltAndTrue ()) {
                operand_4878->mNonterminalName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this declaration has no 'parse' label, but declaration of the same non terminal in ")).operator_concat (var_cas_nonTerminalMap.reader_locationForKey (inLexique, operand_4878->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (100)) COMMA_SOURCE_FILE_AT_LINE (100)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (100)))).operator_concat (GGS_string (" has a 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (102)) ;
              }
              if (((var_cas_labels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (104))).operator_isNotEqual (operand_4878->mLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (104)))).isBuiltAndTrue ()) {
                operand_4878->mNonterminalName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("this declaration names ")).operator_concat (operand_4878->mLabels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (106)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (106)))).operator_concat (GGS_string (" labels, but declaration of the same non terminal in "))).operator_concat (var_cas_nonTerminalMap.reader_locationForKey (inLexique, operand_4878->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (108)) COMMA_SOURCE_FILE_AT_LINE (108)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (108)))).operator_concat (GGS_string (" names"))).operator_concat (var_cas_labels.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (110)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (110)))).operator_concat (GGS_string (" labels.")) COMMA_SOURCE_FILE_AT_LINE (113)) ;
              }else{
                {
                  GGS_nonTerminalLabelList::cEnumerator enumerator_6386 (operand_4878->mLabels, true) ;
                  const GGS_nonTerminalLabelList::cElement * operand_6386 = NULL ;
                  GGS_nonTerminalLabelList::cEnumerator enumerator_6394 (var_cas_labels, true) ;
                  const GGS_nonTerminalLabelList::cElement * operand_6394 = NULL ;
                  while (((operand_6386 = enumerator_6386.nextObject ()))
                      && ((operand_6394 = enumerator_6394.nextObject ()))) {
                    macroValidPointer (operand_6386) ;
                    macroValidPointer (operand_6394) ;
                    if (((operand_6386->mLabelName).operator_isNotEqual (operand_6394->mLabelName)).isBuiltAndTrue ()) {
                      operand_6386->mLabelName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this label should be identical to the label '")).operator_concat (operand_6394->mLabelName)).operator_concat (GGS_string ("' declared in "))).operator_concat (operand_6394->mLabelName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (119)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (119))) COMMA_SOURCE_FILE_AT_LINE (121)) ;
                    }
                    {
                      GGS_formalParameterList::cEnumerator enumerator_6785 (operand_6386->mFormalParameters, true) ;
                      const GGS_formalParameterList::cElement * operand_6785 = NULL ;
                      GGS_formalParameterList::cEnumerator enumerator_6803 (operand_6394->mFormalParameters, true) ;
                      const GGS_formalParameterList::cElement * operand_6803 = NULL ;
                      while (((operand_6785 = enumerator_6785.nextObject ()))
                          && ((operand_6803 = enumerator_6803.nextObject ()))) {
                        macroValidPointer (operand_6785) ;
                        macroValidPointer (operand_6803) ;
                        if (((operand_6785->mFormalParameterPassingMode).operator_isNotEqual (operand_6803->mFormalParameterPassingMode)).isBuiltAndTrue ()) {
                          operand_6785->mFormalParameterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((GGS_string ("the passing mode (")).operator_concat (operand_6785->mFormalParameterPassingMode.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (129)))).operator_concat (GGS_string (") for this parameter should be identical to the passing mode ("))).operator_concat (operand_6803->mFormalParameterPassingMode.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (131)))).operator_concat (GGS_string (") of the parameter declared in"))).operator_concat (operand_6394->mLabelName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (133)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (133))) COMMA_SOURCE_FILE_AT_LINE (135)) ;
                        }
                        if (((operand_6785->mFormalParameterName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (136))).operator_isNotEqual (operand_6803->mFormalParameterTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (136)))).isBuiltAndTrue ()) {
                          operand_6785->mFormalParameterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this type name should be identical to the '@")).operator_concat (operand_6394->mLabelName)).operator_concat (GGS_string ("' type name used in "))).operator_concat (operand_6394->mLabelName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (140)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (140))) COMMA_SOURCE_FILE_AT_LINE (142)) ;
                        }
                      }
                    }
                  }
                }
              }
            }else{
              var_cas_nonTerminalMap.modifier_insertKey (inLexique, operand_4878->mNonterminalName, operand_4878->mLabels, operand_4878->mHasParseLabel COMMA_SOURCE_FILE_AT_LINE (147)) ;
            }
          }
        }
        {
          GGS_syntaxRuleList::cEnumerator enumerator_8255 (var_cas_syntaxComponentRoot.reader_mRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (155)), true) ;
          const GGS_syntaxRuleList::cElement * operand_8255 = NULL ;
          while (((operand_8255 = enumerator_8255.nextObject ()))) {
            macroValidPointer (operand_8255) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

