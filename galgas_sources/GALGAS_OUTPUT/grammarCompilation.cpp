//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'grammarCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 1st, 2010, at 21h23'38"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "grammarCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "transformLabelMap"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis  function_transformLabelMap (C_CompilerEx & inLexique,
                                const GGS_nonTerminalLabelListAST   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_transformLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
  var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis = GGS_nonterminalSymbolLabelMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (39)) ;
  {
    GGS_nonTerminalLabelListAST::cEnumerator enumerator_2269 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelListAST::cElement * operand_2269 = NULL ;
    while (((operand_2269 = enumerator_2269.nextObject ()))) {
      macroValidPointer (operand_2269) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList = GGS_signatureForGrammarAnalysis ::constructor_emptyList () ;
      {
        GGS_formalParameterListAST::cEnumerator enumerator_2372 (operand_2269->mFormalArgumentList, true) ;
        const GGS_formalParameterListAST::cElement * operand_2372 = NULL ;
        while (((operand_2372 = enumerator_2372.nextObject ()))) {
          macroValidPointer (operand_2372) ;
          var_cas_formalParametersList.addAssign_operation (operand_2372->mFormalArgumentPassingMode, operand_2372->mFormalArgumentTypeName) ;
        }
      }
      var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_2269->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (45)) ;
    }
  }
  const GGS_bool cond_2817 = var_cas_inHasParseLabel ;
  if (cond_2817.isBuiltAndTrue ()) {
    var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("parse"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (52)), GGS_signatureForGrammarAnalysis ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (51)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_transformLabelMap\n") ;
  #endif
  return var_cas_outNonterminalSymbolLabelMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_transformLabelMap (C_CompilerEx & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_nonTerminalLabelListAST  arg_0 = GGS_nonTerminalLabelListAST ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_1 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_nonterminalSymbolLabelMapForGrammarAnalysis  result = function_transformLabelMap (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_transformLabelMap [2] = {& kTypeDescriptor_GGS_nonTerminalLabelListAST ,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_transformLabelMap ("transformLabelMap",
                              functionForGenericCall_transformLabelMap,
                              & kTypeDescriptor_GGS_nonterminalSymbolLabelMapForGrammarAnalysis ,
                              2,
                              kArgumentTypeList_transformLabelMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "checkLabelMap"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkLabelMap (C_CompilerEx & inLexique,
                                const GGS_location   var_cas_inNonTerminalLocation,
                                const GGS_nonTerminalLabelListAST   var_cas_inLabels,
                                const GGS_bool  var_cas_inHasParseLabel,
                                const GGS_location   var_cas_inOriginalNonTerminalLocation,
                                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis   var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkLabelMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_stringset  var_cas_labelStringSet = GGS_stringset ::constructor_emptySet () ;
  {
    GGS_nonTerminalLabelListAST::cEnumerator enumerator_3241 (var_cas_inLabels, true) ;
    const GGS_nonTerminalLabelListAST::cElement * operand_3241 = NULL ;
    while (((operand_3241 = enumerator_3241.nextObject ()))) {
      macroValidPointer (operand_3241) ;
      var_cas_labelStringSet.addAssign_operation (operand_3241->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (70))) ;
      GGS_signatureForGrammarAnalysis  var_cas_formalParametersList ;
      if (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.isBuilt ()) {
        var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, operand_3241->mLabelName, var_cas_formalParametersList COMMA_SOURCE_FILE_AT_LINE (72)) ;
      }
      const GGS_bool cond_3988 = (operand_3241->mFormalArgumentList.reader_length ()).operator_isNotEqual (var_cas_formalParametersList.reader_length ()) ;
      if (cond_3988.isBuiltAndTrue ()) {
        operand_3241->mLabelName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((((operand_3241->mFormalArgumentList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (74))).operator_concat (GGS_string (" formal parameter"))).operator_concat ((((operand_3241->mFormalArgumentList.reader_length ()).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string (""))))).operator_concat (GGS_string (" declared here, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3241->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (78)) COMMA_SOURCE_FILE_AT_LINE (78)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (78)))).operator_concat (GGS_string ("names "))).operator_concat (var_cas_formalParametersList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (79)))).operator_concat (GGS_string ("parameter"))).operator_concat ((((var_cas_formalParametersList.reader_length ()).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string ("")))) COMMA_SOURCE_FILE_AT_LINE (81)) ;
      }else if (cond_3988.isBuiltAndFalse ()) {
        {
          GGS_formalParameterListAST::cEnumerator enumerator_4022 (operand_3241->mFormalArgumentList, true) ;
          const GGS_formalParameterListAST::cElement * operand_4022 = NULL ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_4044 (var_cas_formalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_4044 = NULL ;
          while (((operand_4022 = enumerator_4022.nextObject ()))
              && ((operand_4044 = enumerator_4044.nextObject ()))) {
            macroValidPointer (operand_4022) ;
            macroValidPointer (operand_4044) ;
            const GGS_bool cond_4604 = (operand_4044->mFormalArgumentPassingModeForGrammarAnalysis).operator_isNotEqual (operand_4022->mFormalArgumentPassingMode) ;
            if (cond_4604.isBuiltAndTrue ()) {
              operand_4044->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared with ")).operator_concat (operand_4044->mFormalArgumentPassingModeForGrammarAnalysis.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (86)))).operator_concat (GGS_string (" passing mode, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3241->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (88)) COMMA_SOURCE_FILE_AT_LINE (88)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (88)))).operator_concat (GGS_string (" is declared with "))).operator_concat (operand_4022->mFormalArgumentPassingMode.reader_formalArgumentString (inLexique COMMA_SOURCE_FILE_AT_LINE (89)))).operator_concat (GGS_string (" passing mode")) COMMA_SOURCE_FILE_AT_LINE (90)) ;
            }
            const GGS_bool cond_5098 = (operand_4044->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (91))).operator_isNotEqual (operand_4022->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (91))) ;
            if (cond_5098.isBuiltAndTrue ()) {
              operand_4044->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string (" this formal parameter is declared of '@")).operator_concat (operand_4044->mGalgasTypeNameForGrammarAnalysis)).operator_concat (GGS_string ("' type, but declaration at "))).operator_concat (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_3241->mLabelName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (96)) COMMA_SOURCE_FILE_AT_LINE (96)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (96)))).operator_concat (GGS_string (" is declared with '@"))).operator_concat (operand_4022->mFormalArgumentTypeName)).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (98)) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_5533 = var_cas_inHasParseLabel ;
  if (cond_5533.isBuiltAndTrue ()) {
    var_cas_labelStringSet.addAssign_operation (GGS_string ("parse")) ;
    const GGS_bool cond_5522 = (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis.reader_hasKey (GGS_string ("parse"))).operator_not () ;
    if (cond_5522.isBuiltAndTrue ()) {
      var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("this non terminal is declared with 'parse' label, but declaration at ")).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (107)))).operator_concat (GGS_string (" does not declare 'parse' label")) COMMA_SOURCE_FILE_AT_LINE (109)) ;
    }
  }
  {
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_5599 (var_cas_inNonterminalSymbolLabelMapForGrammarAnalysis, true) ;
    const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_5599 = NULL ;
    while (((operand_5599 = enumerator_5599.nextObject ()))) {
      macroValidPointer (operand_5599) ;
      const GGS_bool cond_5873 = (var_cas_labelStringSet.reader_hasKey (operand_5599->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (113)))).operator_not () ;
      if (cond_5873.isBuiltAndTrue ()) {
        var_cas_inNonTerminalLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this non terminal does not declare the '")).operator_concat (operand_5599->mKey)).operator_concat (GGS_string ("' label, but declaration at "))).operator_concat (var_cas_inOriginalNonTerminalLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (116)))).operator_concat (GGS_string (" does")) COMMA_SOURCE_FILE_AT_LINE (118)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkLabelMap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "handleNonTerminalDeclarations"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleNonTerminalDeclarations (C_CompilerEx & inLexique,
                                GGS_nonTerminalSymbolMapForGrammarAnalysis  & var_cas_ioNonTerminalMapForGrammarAnalysis,
                                const GGS_nonterminalDeclarationListAST   var_cas_inNonterminalDeclarationList
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleNonTerminalDeclarations at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_nonterminalDeclarationListAST::cEnumerator enumerator_6210 (var_cas_inNonterminalDeclarationList, true) ;
    const GGS_nonterminalDeclarationListAST::cElement * operand_6210 = NULL ;
    while (((operand_6210 = enumerator_6210.nextObject ()))) {
      macroValidPointer (operand_6210) ;
      elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis * operand_6259 = (elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis *) var_cas_ioNonTerminalMapForGrammarAnalysis.searchForReadWriteWithInstruction (operand_6210->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (129))) ;
      if (NULL != operand_6259) {
        ::routine_checkLabelMap (inLexique,  operand_6210->mNonterminalName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (131)),  operand_6210->mLabels,  operand_6210->mHasParseLabel,  var_cas_ioNonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, operand_6210->mNonterminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (134)) COMMA_SOURCE_FILE_AT_LINE (134)),  operand_6259->mInfo.mNonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (130)) ;
      }else{
        var_cas_ioNonTerminalMapForGrammarAnalysis.modifier_insertKey (inLexique, operand_6210->mNonterminalName, var_cas_ioNonTerminalMapForGrammarAnalysis.reader_count (), function_transformLabelMap (inLexique, operand_6210->mLabels, operand_6210->mHasParseLabel COMMA_SOURCE_FILE_AT_LINE (141)) COMMA_SOURCE_FILE_AT_LINE (138)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleNonTerminalDeclarations\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@syntaxInstructionAST.transformInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__syntaxInstructionAST__transformInstruction> gDispatchTableForMethod__syntaxInstructionAST__transformInstruction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__syntaxInstructionAST__transformInstruction (typeCategoryMethod__syntaxInstructionAST__transformInstruction inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__syntaxInstructionAST__transformInstruction
findCategoryMethod__syntaxInstructionAST__transformInstruction (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__syntaxInstructionAST__transformInstruction result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.count ()) {
      result = gDispatchTableForMethod__syntaxInstructionAST__transformInstruction (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__syntaxInstructionAST__transformInstruction (superClassPtr) ;
        gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@semanticInstructionAST.transformInstruction'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticInstructionAST__transformInstruction (C_CompilerEx &,
                                const cPtr_semanticInstructionAST * operand_7465,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & /* var_cas_ioSyntaxInstructionList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7465 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "transformInstructionList"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_transformInstructionList (C_CompilerEx & inLexique,
                                const GGS_syntaxInstructionList   var_cas_inInstructionList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_transformInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_syntaxInstructionList::cEnumerator enumerator_8184 (var_cas_inInstructionList, true) ;
    const GGS_syntaxInstructionList::cElement * operand_8184 = NULL ;
    while (((operand_8184 = enumerator_8184.nextObject ()))) {
      macroValidPointer (operand_8184) ;
      { typeCategoryMethod__syntaxInstructionAST__transformInstruction method = findCategoryMethod__syntaxInstructionAST__transformInstruction (operand_8184->mInstruction.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_8184->mInstruction (HERE), var_cas_ioActuallyUsedTerminalSymbolMap, var_cas_inNonTerminalSymbolMap, var_cas_ioAddedNonTerminalIndex, var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (178)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_transformInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@terminalCheckInstruction.transformInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__terminalCheckInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_terminalCheckInstruction * operand_8540,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   /* var_cas_inNonTerminalSymbolMap */,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8540 != NULL) {
    GGS_uint  var_cas_terminalSymbolIndex ;
    elementOf_GGS_terminalSymbolsMapForGrammarAnalysis * operand_8871 = (elementOf_GGS_terminalSymbolsMapForGrammarAnalysis *) var_cas_ioActuallyUsedTerminalSymbolMap.searchForReadWriteWithInstruction (operand_8540->mTerminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (196))) ;
    if (NULL != operand_8871) {
      var_cas_terminalSymbolIndex = operand_8871->mInfo.mTerminalIndex ;
    }else{
      var_cas_terminalSymbolIndex = var_cas_ioActuallyUsedTerminalSymbolMap.reader_count () ;
      var_cas_ioActuallyUsedTerminalSymbolMap.modifier_insertKey (inLexique, operand_8540->mTerminalName, var_cas_terminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (200)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_terminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_8540->mInstructionLocation, operand_8540->mTerminalName, var_cas_terminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (202))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@nonterminalCallInstruction.transformInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__nonterminalCallInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_nonterminalCallInstruction * operand_9434,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & /* var_cas_ioActuallyUsedTerminalSymbolMap */,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & /* var_cas_ioAddedNonTerminalIndex */,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9434 != NULL) {
    GGS_uint  var_cas_nonTerminalSymbolIndex ;
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_9809_0 ;
    if (var_cas_inNonTerminalSymbolMap.isBuilt ()) {
      var_cas_inNonTerminalSymbolMap (HERE)->method_searchKey (inLexique, operand_9434->mNonterminalName, var_cas_nonTerminalSymbolIndex, automatic_var_9809_0 COMMA_SOURCE_FILE_AT_LINE (218)) ;
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_nonTerminalInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_9434->mInstructionLocation, operand_9434->mNonterminalName, var_cas_nonTerminalSymbolIndex COMMA_SOURCE_FILE_AT_LINE (219))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@repeatInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__repeatInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_repeatInstruction * operand_10119,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10119 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (235)) ;
    GGS_syntaxInstructionListForGrammarAnalysis  var_cas_repeatedInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
    ::routine_transformInstructionList (inLexique,  operand_10119->mRepeatedInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_repeatedInstructionList COMMA_SOURCE_FILE_AT_LINE (238)) ;
    GGS_branchListForGrammarAnalysis  var_cas_repeatBranchList = GGS_branchListForGrammarAnalysis ::constructor_listWithValue (var_cas_repeatedInstructionList) ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_10851 (operand_10119->mRepeatBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_10851 = NULL ;
      while (((operand_10851 = enumerator_10851.nextObject ()))) {
        macroValidPointer (operand_10851) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_10851->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (249)) ;
        var_cas_repeatBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_repeatInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_10119->mInstructionLocation, var_cas_repeatBranchList, var_cas_addedNonTerminalIndex COMMA_SOURCE_FILE_AT_LINE (259))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@selectInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__selectInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_selectInstruction * operand_11500,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11500 != NULL) {
    const GGS_uint  var_cas_addedNonTerminalIndex = var_cas_ioAddedNonTerminalIndex ;
    var_cas_ioAddedNonTerminalIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (275)) ;
    GGS_branchListForGrammarAnalysis  var_cas_selectBranchList = GGS_branchListForGrammarAnalysis ::constructor_emptyList () ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_11934 (operand_11500->mSelectBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_11934 = NULL ;
      while (((operand_11934 = enumerator_11934.nextObject ()))) {
        macroValidPointer (operand_11934) ;
        GGS_syntaxInstructionListForGrammarAnalysis  var_cas_syntaxInstructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
        ::routine_transformInstructionList (inLexique,  operand_11934->mSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_syntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (280)) ;
        var_cas_selectBranchList.addAssign_operation (var_cas_syntaxInstructionList) ;
      }
    }
    var_cas_ioSyntaxInstructionList.addAssign_operation (GGS_selectInstructionForGrammarAnalysis ::constructor_new (inLexique, operand_11500->mInstructionLocation, var_cas_selectBranchList, var_cas_addedNonTerminalIndex COMMA_SOURCE_FILE_AT_LINE (290))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@parseRewindInstruction.transformInstruction'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseRewindInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_parseRewindInstruction * operand_12588,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12588 != NULL) {
    GGS_syntaxInstructionList  var_cas_syntaxInstructionList ;
    GGS_location  automatic_var_12942_0 ;
    if (operand_12588->mParseRewindBranchList.isBuilt ()) {
      operand_12588->mParseRewindBranchList (HERE)->method_first (inLexique, var_cas_syntaxInstructionList, automatic_var_12942_0 COMMA_SOURCE_FILE_AT_LINE (306)) ;
    }
    ::routine_transformInstructionList (inLexique,  var_cas_syntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (308)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@parseWhenInstruction.transformInstruction'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseWhenInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_parseWhenInstruction * operand_13281,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13281 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_13281->mElseInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (325)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@parseLoopInstruction.transformInstruction'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseLoopInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_parseLoopInstruction * operand_13862,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13862 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_13862->mDoInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (342)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@blockInstruction.transformInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__blockInstruction__transformInstruction (C_CompilerEx & inLexique,
                                const cPtr_blockInstruction * operand_14437,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalSymbolMap,
                                GGS_uint  & var_cas_ioAddedNonTerminalIndex,
                                GGS_syntaxInstructionListForGrammarAnalysis  & var_cas_ioSyntaxInstructionList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14437 != NULL) {
    ::routine_transformInstructionList (inLexique,  operand_14437->mInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalSymbolMap,  var_cas_ioAddedNonTerminalIndex,  var_cas_ioSyntaxInstructionList COMMA_SOURCE_FILE_AT_LINE (359)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "buildRuleList"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildRuleList (C_CompilerEx & inLexique,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis   var_cas_inNonTerminalMapForGrammarAnalysis,
                                const GGS_lstring   var_cas_inSyntaxComponentName,
                                const GGS_syntaxRuleListAST   var_cas_inRuleList,
                                GGS_terminalSymbolsMapForGrammarAnalysis  & var_cas_ioActuallyUsedTerminalSymbolMap,
                                GGS_syntaxComponentListForGrammarAnalysis  & var_cas_ioSyntaxComponentListForGrammarAnalysis,
                                GGS_uint  & var_cas_ioAddedNonTerminalCount
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildRuleList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_productionRuleListForGrammarAnalysis  var_cas_productionRulesList = GGS_productionRuleListForGrammarAnalysis ::constructor_emptyList () ;
  {
    GGS_syntaxRuleListAST::cEnumerator enumerator_15413 (var_cas_inRuleList, true) ;
    const GGS_syntaxRuleListAST::cElement * operand_15413 = NULL ;
    while (((operand_15413 = enumerator_15413.nextObject ()))) {
      macroValidPointer (operand_15413) ;
      GGS_uint  var_cas_nonTerminalIndex ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_nonterminalSymbolParametersMap ;
      if (var_cas_inNonTerminalMapForGrammarAnalysis.isBuilt ()) {
        var_cas_inNonTerminalMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, operand_15413->mNonterminalName, var_cas_nonTerminalIndex, var_cas_nonterminalSymbolParametersMap COMMA_SOURCE_FILE_AT_LINE (382)) ;
      }
      GGS_syntaxInstructionList  var_cas_parsedSyntaxInstructionList ;
      GGS_lstring  automatic_var_15815_0 ;
      GGS_formalParameterListAST  automatic_var_15815_1 ;
      GGS_location  automatic_var_15815_2 ;
      GGS_location  automatic_var_15815_3 ;
      if (operand_15413->mLabelList.isBuilt ()) {
        operand_15413->mLabelList (HERE)->method_first (inLexique, automatic_var_15815_0, automatic_var_15815_1, automatic_var_15815_2, var_cas_parsedSyntaxInstructionList, automatic_var_15815_3 COMMA_SOURCE_FILE_AT_LINE (384)) ;
      }
      GGS_syntaxInstructionListForGrammarAnalysis  var_cas_instructionList = GGS_syntaxInstructionListForGrammarAnalysis ::constructor_emptyList () ;
      ::routine_transformInstructionList (inLexique,  var_cas_parsedSyntaxInstructionList,  var_cas_ioActuallyUsedTerminalSymbolMap,  var_cas_inNonTerminalMapForGrammarAnalysis,  var_cas_ioAddedNonTerminalCount,  var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (387)) ;
      var_cas_productionRulesList.addAssign_operation (operand_15413->mNonterminalName, var_cas_nonTerminalIndex, var_cas_instructionList, var_cas_productionRulesList.reader_length ()) ;
    }
  }
  var_cas_ioSyntaxComponentListForGrammarAnalysis.addAssign_operation (var_cas_productionRulesList, var_cas_inSyntaxComponentName) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildRuleList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@nonTerminalToAddList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nonTerminalToAddList::
elementOf_GGS_nonTerminalToAddList (const GGS_string& argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSyntaxComponentName (argument_0),
mNonTerminalToAddCount (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonTerminalToAddList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_nonTerminalToAddList * ptr = dynamic_cast <const elementOf_GGS_nonTerminalToAddList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue ()
         && mNonTerminalToAddCount.operator_isEqual (ptr->mNonTerminalToAddCount).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonTerminalToAddList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonTerminalToAddCount.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@nonTerminalToAddList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonTerminalToAddList ("nonTerminalToAddList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_uint & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
operator_concat (const GGS_nonTerminalToAddList & inOperand) const {
  GGS_nonTerminalToAddList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
dotAssign_operation (const GGS_nonTerminalToAddList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_nonTerminalToAddList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mSyntaxComponentName ;
          GGS_uint  p_1 = p->mNonTerminalToAddCount ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_uint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSyntaxComponentName,
                                ptr->mNonTerminalToAddCount
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList  GGS_nonTerminalToAddList::
constructor_emptyList (void) {
  GGS_nonTerminalToAddList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList  GGS_nonTerminalToAddList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_uint & argument_1) {
  GGS_nonTerminalToAddList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
internalSubListWithRange (GGS_nonTerminalToAddList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSyntaxComponentName, ptr->mNonTerminalToAddCount) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_nonTerminalToAddList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_nonTerminalToAddList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalToAddList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@nonTerminalToAddList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
method_first (C_CompilerEx & inLexique,
              GGS_string& _out_0,
              GGS_uint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
method_last (C_CompilerEx & inLexique,
             GGS_string& _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_string& _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mNonTerminalToAddCount ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalToAddList::
reader_mSyntaxComponentNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxComponentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_nonTerminalToAddList::
reader_mNonTerminalToAddCountAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNonTerminalToAddCount ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_setMSyntaxComponentNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxComponentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalToAddList::
modifier_setMNonTerminalToAddCountAtIndex (C_CompilerEx & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNonTerminalToAddCount = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nonTerminalToAddList::cEnumerator::_mSyntaxComponentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxComponentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_nonTerminalToAddList::cEnumerator::_mNonTerminalToAddCount (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNonTerminalToAddCount ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nonTerminalToAddList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonTerminalToAddList * p = NULL ;
    macroMyNew (p, GGS_nonTerminalToAddList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalToAddList GGS_nonTerminalToAddList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonTerminalToAddList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonTerminalToAddList * p = dynamic_cast <const GGS_nonTerminalToAddList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonTerminalToAddList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonTerminalToAddList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonTerminalToAddList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of wrapper 'grammarGenerationTemplate'            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapperEx * gWrapperAllFiles_grammarGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapperEx * gWrapperAllDirectories_grammarGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapperEx gWrapperDirectory_0_grammarGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_grammarGenerationTemplate_0,
  0,
  gWrapperAllDirectories_grammarGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'oldGrammarZone2Header' template of 'grammarGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_oldGrammarZone2Header (C_CompilerEx & inLexique,
                                const GGS_grammarComponentAST & var_cas_GRAMMAR_COMPONENT_ROOT) {
  C_String result ;
  const bool isBuilt = var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (1)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "#define GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (2)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_336 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (6)), true) ;
    const GGS_lstringlist::cElement * operand_336 = NULL ;
    while (((operand_336 = enumerator_336.nextObject ()))) {
      macroValidPointer (operand_336) ;
      result << "#include \"" ;
      result << operand_336->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (7)).reader_stringByDeletingPathExtension () ;
      result << ".h\"\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'oldGrammarZone3Header' template of 'grammarGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_oldGrammarZone3Header (C_CompilerEx & inLexique,
                                const GGS_string& var_cas_LEXIQUE_CLASS,
                                const GGS_grammarComponentAST & var_cas_GRAMMAR_COMPONENT_ROOT,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis & var_cas_NON_TERMINAL_MAP,
                                const GGS_nonTerminalToAddList & var_cas_ADDED_NON_TERMINAL_LIST) {
  C_String result ;
  PMUInt32 columnMarker = 0 ;
  const bool isBuilt = var_cas_LEXIQUE_CLASS.isBuilt ()
    && var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt ()
    && var_cas_NON_TERMINAL_MAP.isBuilt ()
    && var_cas_ADDED_NON_TERMINAL_LIST.isBuilt () ;
  if (isBuilt) {
    result << "//---------------------------------------------------------------------------*\n"
      "\n"
      "class C_Grammar_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (3)).ggs_string ().reader_identifierRepresentation () ;
    result << " : " ;
    columnMarker = result.currentColumn () ;
    GGS_lstringlist::cEnumerator enumerator_224 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (4)), true) ;
    const GGS_lstringlist::cElement * operand_224 = NULL ;
    while (((operand_224 = enumerator_224.nextObject ()))) {
      macroValidPointer (operand_224) ;
      result << "public " ;
      result << operand_224->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5)).reader_stringByDeletingPathExtension () ;
      if (enumerator_224.hasNextObject ()) {
        result << ",\n" ;
        result.appendSpacesUntilColumn (columnMarker) ;
      }
    }
    result << " {\n" ;
    GGS_nonTerminalSymbolMapForGrammarAnalysis::cEnumerator enumerator_347 (var_cas_NON_TERMINAL_MAP, true) ;
    const GGS_nonTerminalSymbolMapForGrammarAnalysis::cElement * operand_347 = NULL ;
    while (((operand_347 = enumerator_347.nextObject ()))) {
      macroValidPointer (operand_347) ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_410 (operand_347->mInfo.mNonterminalSymbolParametersMap, true) ;
      const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_410 = NULL ;
      while (((operand_410 = enumerator_410.nextObject ()))) {
        macroValidPointer (operand_410) ;
        result << "  public : virtual void nt_" ;
        result << operand_347->mKey.ggs_string ().reader_identifierRepresentation () ;
        result << "_" ;
        result << operand_410->mKey.ggs_string ().reader_identifierRepresentation () ;
        result << " (" ;
        columnMarker = result.currentColumn () ;
        result << "C_Lexique_" ;
        result << var_cas_LEXIQUE_CLASS ;
        result << " &" ;
        GGS_signatureForGrammarAnalysis::cEnumerator enumerator_597 (operand_410->mInfo.mFormalParametersList, true) ;
        const GGS_signatureForGrammarAnalysis::cElement * operand_597 = NULL ;
        while (((operand_597 = enumerator_597.nextObject ()))) {
          macroValidPointer (operand_597) ;
          result << ",\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << operand_597->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
          result << "GGS_" ;
          result << operand_597->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
          result << operand_597->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (14)) ;
        }
        result << ") ;\n"
          "\n" ;
        if ((var_cas_GRAMMAR_COMPONENT_ROOT.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (17)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17))).operator_isEqual (operand_347->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17))).boolValue ()) {
          result << "  public : static void _performSourceFileParsing_" ;
          result << operand_410->mKey.ggs_string ().reader_identifierRepresentation () ;
          result << " (" ;
          columnMarker = result.currentColumn () ;
          result << "C_CompilerEx & inCompiler,\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "const C_String & inDependancyExtension,\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "const C_String & inDependancyPath,\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "GGS_string * inSentStringPtr,\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "const GGS_lstring inFileName" ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1285 (operand_410->mInfo.mFormalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_1285 = NULL ;
          while (((operand_1285 = enumerator_1285.nextObject ()))) {
            macroValidPointer (operand_1285) ;
            result << ",\n" ;
            result.appendSpacesUntilColumn (columnMarker) ;
            result << operand_1285->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
            result << "GGS_" ;
            result << operand_1285->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
            result << operand_1285->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (24)) ;
          }
          result << "\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "COMMA_LOCATION_ARGS) ;\n"
            "\n"
            "  public : static void _performSourceStringParsing_" ;
          result << operand_410->mKey.ggs_string ().reader_identifierRepresentation () ;
          result << " (" ;
          columnMarker = result.currentColumn () ;
          result << "C_CompilerEx & inCompiler,\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "GGS_string * inSentStringPtr,\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "const GGS_string inSourceString" ;
          GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1828 (operand_410->mInfo.mFormalParametersList, true) ;
          const GGS_signatureForGrammarAnalysis::cElement * operand_1828 = NULL ;
          while (((operand_1828 = enumerator_1828.nextObject ()))) {
            macroValidPointer (operand_1828) ;
            result << ",\n" ;
            result.appendSpacesUntilColumn (columnMarker) ;
            result << operand_1828->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation1ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
            result << "GGS_" ;
            result << operand_1828->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
            result << operand_1828->mFormalArgumentPassingModeForGrammarAnalysis.reader_generation2ForFormalParameter (inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ;
          }
          result << "\n" ;
          result.appendSpacesUntilColumn (columnMarker) ;
          result << "COMMA_LOCATION_ARGS) ;\n"
            "\n" ;
        }else {
        }
      }
    }
    GGS_nonTerminalToAddList::cEnumerator enumerator_2183 (var_cas_ADDED_NON_TERMINAL_LIST, true) ;
    const GGS_nonTerminalToAddList::cElement * operand_2183 = NULL ;
    while (((operand_2183 = enumerator_2183.nextObject ()))) {
      macroValidPointer (operand_2183) ;
      result << "  public : virtual PMSInt16 select_" ;
      result << operand_2183->mSyntaxComponentName.reader_identifierRepresentation () ;
      result << "_" ;
      result << operand_2183->mNonTerminalToAddCount.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (38)) ;
      result << " (C_Lexique_" ;
      result << var_cas_LEXIQUE_CLASS ;
      result << " &) ;\n" ;
      if (enumerator_2183.hasNextObject ()) {
        result << "\n" ;
      }
    }
    result << "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#endif\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
// 'grammarZone2Header' template of 'grammarGenerationTemplate' filewrapper  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_grammarZone2Header (C_CompilerEx & inLexique,
                                const GGS_grammarComponentAST & var_cas_GRAMMAR_COMPONENT_ROOT) {
  C_String result ;
  const bool isBuilt = var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (1)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "#define GRAMMAR_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (2)).ggs_string ().reader_identifierRepresentation () ;
    result << "_HAS_BEEN_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_336 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (6)), true) ;
    const GGS_lstringlist::cElement * operand_336 = NULL ;
    while (((operand_336 = enumerator_336.nextObject ()))) {
      macroValidPointer (operand_336) ;
      result << "#include \"" ;
      result << operand_336->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (7)).reader_stringByDeletingPathExtension () ;
      result << ".h\"\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
// 'grammarZone3Header' template of 'grammarGenerationTemplate' filewrapper  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_grammarGenerationTemplate_grammarZone3Header (C_CompilerEx & inLexique,
                                const GGS_string& var_cas_LEXIQUE_IDENTIFIER,
                                const GGS_grammarComponentAST & var_cas_GRAMMAR_COMPONENT_ROOT,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis & var_cas_NON_TERMINAL_MAP,
                                const GGS_nonTerminalToAddList & var_cas_ADDED_NON_TERMINAL_LIST) {
  C_String result ;
  PMUInt32 columnMarker = 0 ;
  const bool isBuilt = var_cas_LEXIQUE_IDENTIFIER.isBuilt ()
    && var_cas_GRAMMAR_COMPONENT_ROOT.isBuilt ()
    && var_cas_NON_TERMINAL_MAP.isBuilt ()
    && var_cas_ADDED_NON_TERMINAL_LIST.isBuilt () ;
  if (isBuilt) {
    result << "//---------------------------------------------------------------------------*\n"
      "\n"
      "class cGrammar_" ;
    result << var_cas_GRAMMAR_COMPONENT_ROOT.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (3)).ggs_string ().reader_identifierRepresentation () ;
    result << " : " ;
    columnMarker = result.currentColumn () ;
    GGS_lstringlist::cEnumerator enumerator_223 (var_cas_GRAMMAR_COMPONENT_ROOT.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (4)), true) ;
    const GGS_lstringlist::cElement * operand_223 = NULL ;
    while (((operand_223 = enumerator_223.nextObject ()))) {
      macroValidPointer (operand_223) ;
      result << "public cParser_" ;
      result << operand_223->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5)).reader_stringByDeletingPathExtension ().reader_identifierRepresentation () ;
      if (enumerator_223.hasNextObject ()) {
        result << ",\n" ;
        result.appendSpacesUntilColumn (columnMarker) ;
      }
    }
    result << " {\n" ;
    GGS_nonTerminalSymbolMapForGrammarAnalysis::cEnumerator enumerator_381 (var_cas_NON_TERMINAL_MAP, true) ;
    const GGS_nonTerminalSymbolMapForGrammarAnalysis::cElement * operand_381 = NULL ;
    while (((operand_381 = enumerator_381.nextObject ()))) {
      macroValidPointer (operand_381) ;
      GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator enumerator_444 (operand_381->mInfo.mNonterminalSymbolParametersMap, true) ;
      const GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cElement * operand_444 = NULL ;
      while (((operand_444 = enumerator_444.nextObject ()))) {
        macroValidPointer (operand_444) ;
        result << "  public : virtual void nt_" ;
        result << operand_381->mKey.ggs_string ().reader_identifierRepresentation () ;
        result << "_" ;
        result << operand_444->mKey.ggs_string ().reader_identifierRepresentation () ;
        result << " (" ;
        columnMarker = result.currentColumn () ;
        GGS_signatureForGrammarAnalysis::cEnumerator enumerator_600 (operand_444->mInfo.mFormalParametersList, true) ;
        const GGS_signatureForGrammarAnalysis::cElement * operand_600 = NULL ;
        { GGS_uint var_cas_IDX (true, 0) ;
      while (((operand_600 = enumerator_600.nextObject ()))) {
        macroValidPointer (operand_600) ;
        if ((operand_600->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (14))).boolValue ()) {
          result << "const GALGAS_" ;
          result << operand_600->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
          result << " inArgument" ;
          result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (15)) ;
        }else if ((operand_600->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_SOURCE_FILE_AT_LINE (16))).boolValue ()) {
          result << "GALGAS_" ;
          result << operand_600->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
          result << " & ioArgument" ;
          result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (17)) ;
        }else if ((operand_600->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (18))).boolValue ()) {
          result << "GALGAS_" ;
          result << operand_600->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
          result << " & outArgument" ;
          result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (19)) ;
        }else {
          result << "GALGAS_" ;
          result << operand_600->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
          result << " inArgument" ;
          result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (21)) ;
        }
        result << ",\n" ;
        result.appendSpacesUntilColumn (columnMarker) ;
        var_cas_IDX.increment_operation (inLexique COMMA_HERE) ;
      }
    }
    result << "C_Lexique_" ;
    result << var_cas_LEXIQUE_IDENTIFIER ;
    result << " * inCompiler) ;\n"
      "\n" ;
    if ((var_cas_GRAMMAR_COMPONENT_ROOT.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (26)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (26))).operator_isEqual (operand_381->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (26))).boolValue ()) {
      result << "  public : static void _performSourceFileParsing_" ;
      result << operand_444->mKey.ggs_string ().reader_identifierRepresentation () ;
      result << " (" ;
      columnMarker = result.currentColumn () ;
      result << "C_Compiler * inCompiler,\n" ;
      result.appendSpacesUntilColumn (columnMarker) ;
      result << "GALGAS_lstring inFileName" ;
      GGS_signatureForGrammarAnalysis::cEnumerator enumerator_1802 (operand_444->mInfo.mFormalParametersList, true) ;
      const GGS_signatureForGrammarAnalysis::cElement * operand_1802 = NULL ;
      { GGS_uint var_cas_IDX (true, 0) ;
    while (((operand_1802 = enumerator_1802.nextObject ()))) {
      macroValidPointer (operand_1802) ;
      result << ",\n" ;
      result.appendSpacesUntilColumn (columnMarker) ;
      if ((operand_1802->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (31))).boolValue ()) {
        result << "const GALGAS_" ;
        result << operand_1802->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
        result << " inArgument" ;
        result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (32)) ;
      }else if ((operand_1802->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_SOURCE_FILE_AT_LINE (33))).boolValue ()) {
        result << "GALGAS_" ;
        result << operand_1802->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
        result << " & ioArgument" ;
        result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (34)) ;
      }else if ((operand_1802->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (35))).boolValue ()) {
        result << "GALGAS_" ;
        result << operand_1802->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
        result << " & outArgument" ;
        result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (36)) ;
      }else {
        result << "GALGAS_" ;
        result << operand_1802->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
        result << " inArgument" ;
        result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (38)) ;
      }
      var_cas_IDX.increment_operation (inLexique COMMA_HERE) ;
    }
  }
  result << "\n" ;
  result.appendSpacesUntilColumn (columnMarker) ;
  result << "COMMA_LOCATION_ARGS) ;\n"
    "\n"
    "  public : static void _performSourceStringParsing_" ;
  result << operand_444->mKey.ggs_string ().reader_identifierRepresentation () ;
  result << " (" ;
  columnMarker = result.currentColumn () ;
  result << "C_Compiler * inCompiler,\n" ;
  result.appendSpacesUntilColumn (columnMarker) ;
  result << "GALGAS_string inSourceString" ;
  GGS_signatureForGrammarAnalysis::cEnumerator enumerator_2934 (operand_444->mInfo.mFormalParametersList, true) ;
  const GGS_signatureForGrammarAnalysis::cElement * operand_2934 = NULL ;
  { GGS_uint var_cas_IDX (true, 0) ;
while (((operand_2934 = enumerator_2934.nextObject ()))) {
  macroValidPointer (operand_2934) ;
  result << ",\n" ;
  result.appendSpacesUntilColumn (columnMarker) ;
  if ((operand_2934->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (46))).boolValue ()) {
    result << "const GALGAS_" ;
    result << operand_2934->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
    result << " inArgument" ;
    result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (47)) ;
  }else if ((operand_2934->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_SOURCE_FILE_AT_LINE (48))).boolValue ()) {
    result << "GALGAS_" ;
    result << operand_2934->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
    result << " & ioArgument" ;
    result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (49)) ;
  }else if ((operand_2934->mFormalArgumentPassingModeForGrammarAnalysis).operator_isEqual (GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (50))).boolValue ()) {
    result << "GALGAS_" ;
    result << operand_2934->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
    result << " & outArgument" ;
    result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (51)) ;
  }else {
    result << "GALGAS_" ;
    result << operand_2934->mGalgasTypeNameForGrammarAnalysis.ggs_string ().reader_identifierRepresentation () ;
    result << " inArgument" ;
    result << var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (53)) ;
  }
  var_cas_IDX.increment_operation (inLexique COMMA_HERE) ;
}
}
result << "\n" ;
result.appendSpacesUntilColumn (columnMarker) ;
result << "COMMA_LOCATION_ARGS) ;\n"
  "\n" ;
}else {
}
}
}
result << "\n" ;
GGS_nonTerminalToAddList::cEnumerator enumerator_3927 (var_cas_ADDED_NON_TERMINAL_LIST, true) ;
const GGS_nonTerminalToAddList::cElement * operand_3927 = NULL ;
while (((operand_3927 = enumerator_3927.nextObject ()))) {
macroValidPointer (operand_3927) ;
result << "  public : virtual PMSInt32 select_" ;
result << operand_3927->mSyntaxComponentName.reader_identifierRepresentation () ;
result << "_" ;
result << operand_3927->mNonTerminalToAddCount.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (61)) ;
result << " (C_Lexique_" ;
result << var_cas_LEXIQUE_IDENTIFIER ;
result << " *) ;\n" ;
if (enumerator_3927.hasNextObject ()) {
result << "\n" ;
}
}
result << "} ;\n"
  "\n"
  "//---------------------------------------------------------------------------*\n"
  "\n"
  "#endif\n" ;
}
return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "parseGrammarComponent"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_parseGrammarComponent (C_CompilerEx & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_grammarComponentAST  & var_cas_outGrammarComponentRoot
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_parseGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
elementOf_GGS_parsedGrammarComponentMap * operand_18522 = (elementOf_GGS_parsedGrammarComponentMap *) var_cas_ioParsedComponentStruct.mParsedGrammarComponentMap.searchForReadWithInstruction (var_cas_basename) ;
if (NULL != operand_18522) {
var_cas_outGrammarComponentRoot = operand_18522->mInfo.mGrammarComponentRoot ;
}else{
const GGS_string _depExtension = GGS_string ("") ;
const GGS_string _depPath = GGS_string ("") ;
if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
  C_Grammar_grammarLL_31_grammar::_performSourceFileParsing_ (inLexique,
                                _depExtension.string (),
                                _depPath.string (),
                                NULL,
                                var_cas_inSourceFile,
                                var_cas_outGrammarComponentRoot
                                COMMA_SOURCE_FILE_AT_LINE (458)) ;
}
var_cas_ioParsedComponentStruct.mParsedGrammarComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_basename, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (460)), var_cas_outGrammarComponentRoot COMMA_SOURCE_FILE_AT_LINE (459)) ;
}
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_parseGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileGrammarComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponent (C_CompilerEx & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectoryForCppFiles,
                                const GGS_string  var_cas_inOutputDirectoryForHTMLFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
GGS_grammarComponentAST  var_cas_grammarComponentRoot ;
::routine_parseGrammarComponent (inLexique,  var_cas_inSourceFile,  var_cas_ioParsedComponentStruct,  var_cas_grammarComponentRoot COMMA_SOURCE_FILE_AT_LINE (479)) ;
const GGS_lstring  var_cas_grammarComponentName = var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (481)) ;
const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
const GGS_bool cond_20093 = (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (483))).operator_isNotEqual (var_cas_basename) ;
if (cond_20093.isBuiltAndTrue ()) {
var_cas_grammarComponentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
  "the component name ('")).operator_concat (var_cas_grammarComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (485)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (487)) ;
}
GGS_terminalSymbolsMapForGrammarAnalysis  var_cas_actuallyUsedTerminalSymbolMap = GGS_terminalSymbolsMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (490)) ;
GGS_nonTerminalSymbolMapForGrammarAnalysis  var_cas_nonTerminalMapForGrammarAnalysis = GGS_nonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (491)) ;
GGS_string var_cas_lexiqueComponentName = GGS_string ("") ;
GGS_syntaxComponentListForGrammarAnalysis  var_cas_syntaxComponentListForGrammarAnalysis = GGS_syntaxComponentListForGrammarAnalysis ::constructor_emptyList () ;
GGS_nonTerminalToAddList  var_cas_nonTerminalToAddList = GGS_nonTerminalToAddList ::constructor_emptyList () ;
GGS_uint  var_cas_addedNonTerminalCount = GGS_uint (0U) ;
{
GGS_lstringlist::cEnumerator enumerator_20622 (var_cas_grammarComponentRoot.reader_mSyntaxComponents (inLexique COMMA_SOURCE_FILE_AT_LINE (496)), true) ;
const GGS_lstringlist::cElement * operand_20622 = NULL ;
while (((operand_20622 = enumerator_20622.nextObject ()))) {
  macroValidPointer (operand_20622) ;
const GGS_uint  var_cas_addedNonTerminalCountRef = var_cas_addedNonTerminalCount ;
const GGS_bool cond_20926 = ((operand_20622->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("gSyntax"))).operator_and ((operand_20622->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("ggs"))) ;
if (cond_20926.isBuiltAndTrue ()) {
operand_20622->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a syntax component file should have '.ggs' or '.gSyntax' as path extension") COMMA_SOURCE_FILE_AT_LINE (500)) ;
}else if (cond_20926.isBuiltAndFalse ()) {
GGS_string var_cas_syntaxComponentName = operand_20622->mValue.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
GGS_syntaxComponentAST var_cas_syntaxComponentRoot ;
const GGS_bool cond_21317 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (503)).reader_hasKey (var_cas_syntaxComponentName) ;
if (cond_21317.isBuiltAndTrue ()) {
const GGS_parsedSyntaxComponentMap  temp_21239 = var_cas_ioParsedComponentStruct.reader_mParsedSyntaxComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (504)) ;
if (temp_21239.isBuilt ()) {
  temp_21239 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (504)), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (504)) ;
}
}else if (cond_21317.isBuiltAndFalse ()) {
GGS_string var_cas_sourceFilePath = operand_20622->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent ()) ;
const GGS_string _depExtension = GGS_string ("") ;
const GGS_string _depPath = GGS_string ("") ;
if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
  C_Grammar_syntaxSLRgrammar::_performSourceFileParsing_ (inLexique,
                                _depExtension.string (),
                                _depPath.string (),
                                NULL,
                                GGS_lstring ::constructor_new (inLexique, var_cas_sourceFilePath, operand_20622->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (507)) COMMA_SOURCE_FILE_AT_LINE (507)),
                                var_cas_syntaxComponentRoot
                                COMMA_SOURCE_FILE_AT_LINE (507)) ;
}
var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_syntaxComponentName, operand_20622->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (508)) COMMA_SOURCE_FILE_AT_LINE (508)), var_cas_syntaxComponentRoot COMMA_SOURCE_FILE_AT_LINE (508)) ;
}
GGS_string var_cas_currentLexiqueName = var_cas_syntaxComponentRoot.reader_mImportedLexiqueFilePath (inLexique COMMA_SOURCE_FILE_AT_LINE (511)).ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
const GGS_bool cond_21986 = (var_cas_lexiqueComponentName).operator_isEqual (GGS_string ("")) ;
if (cond_21986.isBuiltAndTrue ()) {
var_cas_lexiqueComponentName = var_cas_currentLexiqueName ;
}else if (cond_21986.isBuiltAndFalse ()) {
const GGS_bool cond_22281 = (var_cas_lexiqueComponentName).operator_isNotEqual (var_cas_currentLexiqueName) ;
if (cond_22281.isBuiltAndTrue ()) {
operand_20622->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this syntax component uses '")).operator_concat (var_cas_currentLexiqueName)).operator_concat (GGS_string ("' lexique component, but the first syntax component uses the '"))).operator_concat (var_cas_lexiqueComponentName)).operator_concat (GGS_string ("' lexique component (they should be the same)")) COMMA_SOURCE_FILE_AT_LINE (518)) ;
}
}
::routine_handleNonTerminalDeclarations (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mNonterminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (522)) COMMA_SOURCE_FILE_AT_LINE (520)) ;
::routine_buildRuleList (inLexique,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_syntaxComponentRoot.reader_mSyntaxComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (527)),  var_cas_syntaxComponentRoot.reader_mRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (528)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_addedNonTerminalCount COMMA_SOURCE_FILE_AT_LINE (525)) ;
GGS_uint  var_cas_i = GGS_uint (0U) ;
GGS_uint _variant_22988 = var_cas_addedNonTerminalCount ;
GGS_bool _condition_22988 (_variant_22988.isBuilt (), true) ;
while (_condition_22988.isBuiltAndTrue ()) {
  _condition_22988 = (var_cas_i).operator_strictInf (var_cas_addedNonTerminalCount.substract_operation (inLexique, var_cas_addedNonTerminalCountRef COMMA_SOURCE_FILE_AT_LINE (534))) ;
  if (_condition_22988.isBuiltAndTrue ()) {
    if (_variant_22988.uintValue () == 0) {
      inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (537)) ;
      _condition_22988 = GGS_bool (false) ;
    }else{
      _variant_22988.decrement_operation (inLexique COMMA_HERE) ;
  var_cas_nonTerminalToAddList.addAssign_operation (var_cas_syntaxComponentName, var_cas_i) ;
  var_cas_i.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (536)) ;
    }
  }
}
}
}
}
GGS_nonterminalSymbolLabelMapForGrammarAnalysis  var_cas_startSymbolAltMap ;
GGS_uint  var_cas_startSymbolIndex ;
if (var_cas_nonTerminalMapForGrammarAnalysis.isBuilt ()) {
  var_cas_nonTerminalMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (544)), var_cas_startSymbolIndex, var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (544)) ;
}
::routine_checkLabelMap (inLexique,  var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (547)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (547)),  var_cas_grammarComponentRoot.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (548)),  var_cas_grammarComponentRoot.reader_mStartSymbolHasParseLabel (inLexique COMMA_SOURCE_FILE_AT_LINE (549)),  var_cas_nonTerminalMapForGrammarAnalysis.reader_locationForKey (inLexique, var_cas_grammarComponentRoot.reader_mStartSymbolName (inLexique COMMA_SOURCE_FILE_AT_LINE (550)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (550)) COMMA_SOURCE_FILE_AT_LINE (550)),  var_cas_startSymbolAltMap COMMA_SOURCE_FILE_AT_LINE (546)) ;
GGS_unusedNonTerminalSymbolMapForGrammarAnalysis  var_cas_unusedNonTerminalSymbolsForGrammar = GGS_unusedNonTerminalSymbolMapForGrammarAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (554)) ;
{
GGS_lstringlist::cEnumerator enumerator_23889 (var_cas_grammarComponentRoot.reader_mUnusedNonterminalList (inLexique COMMA_SOURCE_FILE_AT_LINE (555)), true) ;
const GGS_lstringlist::cElement * operand_23889 = NULL ;
while (((operand_23889 = enumerator_23889.nextObject ()))) {
  macroValidPointer (operand_23889) ;
GGS_uint  var_cas_nonterminalIndex ;
GGS_nonterminalSymbolLabelMapForGrammarAnalysis  automatic_var_24043_0 ;
if (var_cas_nonTerminalMapForGrammarAnalysis.isBuilt ()) {
  var_cas_nonTerminalMapForGrammarAnalysis (HERE)->method_searchKey (inLexique, operand_23889->mValue, var_cas_nonterminalIndex, automatic_var_24043_0 COMMA_SOURCE_FILE_AT_LINE (557)) ;
}
var_cas_unusedNonTerminalSymbolsForGrammar.modifier_insertKey (inLexique, operand_23889->mValue, var_cas_nonterminalIndex COMMA_SOURCE_FILE_AT_LINE (558)) ;
}
}
if (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (562)).isBuilt () &&
    var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (563)).isBuilt () &&
    var_cas_startSymbolIndex.isBuilt () &&
    var_cas_lexiqueComponentName.isBuilt () &&
    var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (566)).isBuilt () &&
    var_cas_actuallyUsedTerminalSymbolMap.isBuilt () &&
    var_cas_syntaxComponentListForGrammarAnalysis.isBuilt () &&
    var_cas_nonTerminalMapForGrammarAnalysis.isBuilt () &&
    var_cas_unusedNonTerminalSymbolsForGrammar.isBuilt () &&
    var_cas_inOutputDirectoryForCppFiles.isBuilt () &&
    var_cas_inOutputDirectoryForHTMLFile.isBuilt ()) {
  ::routine_grammarAnalysisAndGeneration (inLexique,  var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (562)),  var_cas_grammarComponentRoot.reader_mGrammarClass (inLexique COMMA_SOURCE_FILE_AT_LINE (563)),  var_cas_startSymbolIndex,  var_cas_lexiqueComponentName,  var_cas_grammarComponentRoot.reader_mEndOfSourceText (inLexique COMMA_SOURCE_FILE_AT_LINE (566)),  var_cas_actuallyUsedTerminalSymbolMap,  var_cas_syntaxComponentListForGrammarAnalysis,  var_cas_nonTerminalMapForGrammarAnalysis,  var_cas_unusedNonTerminalSymbolsForGrammar,  var_cas_inOutputDirectoryForCppFiles,  var_cas_inOutputDirectoryForHTMLFile COMMA_SOURCE_FILE_AT_LINE (561)) ;
}
const GGS_bool cond_26140 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (575))).operator_isEqual (GGS_uint (0U)) ;
if (cond_26140.isBuiltAndTrue ()) {
const GGS_bool cond_25479 = (GGS_bool (gOption_galgas_5F_cli_5F_options_legacyCodeGeneration.reader_value ())).operator_not () ;
if (cond_25479.isBuiltAndTrue ()) {
const GGS_string var_cas_zone2 = template_filewrapper_grammarGenerationTemplate_grammarZone2Header (inLexique, var_cas_grammarComponentRoot) ;
const GGS_string var_cas_zone3 = template_filewrapper_grammarGenerationTemplate_grammarZone3Header (inLexique, var_cas_lexiqueComponentName.reader_identifierRepresentation (), var_cas_grammarComponentRoot, var_cas_nonTerminalMapForGrammarAnalysis, var_cas_nonTerminalToAddList) ;
GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectoryForCppFiles, (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (588)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (588))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
  "\n"), var_cas_zone2, GGS_string ("\n"
  "\n"), var_cas_zone3 COMMA_SOURCE_FILE_AT_LINE (586)) ;
}else if (cond_25479.isBuiltAndFalse ()) {
const GGS_string var_cas_zone2 = template_filewrapper_grammarGenerationTemplate_oldGrammarZone2Header (inLexique, var_cas_grammarComponentRoot) ;
const GGS_string var_cas_zone3 = template_filewrapper_grammarGenerationTemplate_oldGrammarZone3Header (inLexique, var_cas_lexiqueComponentName.reader_identifierRepresentation (), var_cas_grammarComponentRoot, var_cas_nonTerminalMapForGrammarAnalysis, var_cas_nonTerminalToAddList) ;
GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectoryForCppFiles, (var_cas_grammarComponentRoot.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (607)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (607))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
  "\n"), var_cas_zone2, GGS_string ("\n"
  "\n"), var_cas_zone3 COMMA_SOURCE_FILE_AT_LINE (605)) ;
}
}
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_grammarCompilation (void) {
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__semanticInstructionAST__transformInstruction, gClassInfoFor__semanticInstructionAST.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__terminalCheckInstruction__transformInstruction, gClassInfoFor__terminalCheckInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__nonterminalCallInstruction__transformInstruction, gClassInfoFor__nonterminalCallInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__repeatInstruction__transformInstruction, gClassInfoFor__repeatInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__selectInstruction__transformInstruction, gClassInfoFor__selectInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__parseRewindInstruction__transformInstruction, gClassInfoFor__parseRewindInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__parseWhenInstruction__transformInstruction, gClassInfoFor__parseWhenInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__parseLoopInstruction__transformInstruction, gClassInfoFor__parseLoopInstruction.slotID ()) ;
  enterCategoryMethod__syntaxInstructionAST__transformInstruction ((typeCategoryMethod__syntaxInstructionAST__transformInstruction) category_method__blockInstruction__transformInstruction, gClassInfoFor__blockInstruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_grammarCompilation (void) {
  gDispatchTableForMethod__syntaxInstructionAST__transformInstruction.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_grammarCompilation (prologueRoutineFor_grammarCompilation, epilogueRoutineFor_grammarCompilation) ;

//---------------------------------------------------------------------------*

