//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'common_semantics.h'                          *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                       april 12th, 2005, at 12h9'3"                        *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef common_semantics_DEFINED
#define common_semantics_DEFINED

#include <string.h>

// Include predefined semantics types definition *
#include "galgas/C_GGS_Object.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldfloat.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/AC_galgas_map.h"
// Include scanner definition *
#include "galgas/C_Lexique.h"
//---------------------------------------------------------------------------*
//                                                                           *
//   Include directives generated by extern types, methods or attributes     *
//                                                                           *
//---------------------------------------------------------------------------*

#include "galgas/C_galgas_stringset.h"
#include "cClassMethodsMap.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         Classes predeclarations                           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_signature ;
class GGS_typeListeAttributsSemantiques ;
class GGS_AC_galgasType ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Extern type 'string_set'                          *
//                                                                           *
//---------------------------------------------------------------------------*

typedef C_galgas_stringset GGS_string_set ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class for enumeration 'actualParametersPassingMode'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_actualParametersPassingMode {
//--- Enumeration
  public : enum enumeration {kNotBuilt, enum_parameterOut, enum_parameterOutIn, enum_parameterIn} ;

//--- Private attribute
  private : enumeration mValue ;

//--- Get value
  public : inline enumeration getValue (void) const {return mValue ; }

//--- Default constructor
  public : inline GGS_actualParametersPassingMode (void) : mValue (kNotBuilt) {}

//--- Internal constructor
  private : inline GGS_actualParametersPassingMode (const enumeration inValue) : mValue (inValue) {}

//--- Bit count for bdd
  public : static inline uint16 bitCount (void) { return 2 ; }

//--- Is built ?
  public : inline bool isBuilt (void) const { return mValue > kNotBuilt ; }

//--- Construction from GALGAS constructor
  public : static inline GGS_actualParametersPassingMode constructor_parameterOut (void) {
    return GGS_actualParametersPassingMode (enum_parameterOut) ;
  }
  public : static inline GGS_actualParametersPassingMode constructor_parameterOutIn (void) {
    return GGS_actualParametersPassingMode (enum_parameterOutIn) ;
  }
  public : static inline GGS_actualParametersPassingMode constructor_parameterIn (void) {
    return GGS_actualParametersPassingMode (enum_parameterIn) ;
  }

//--- Messages
  public : GGS_string reader_actualArgumentMessage (void) const ;

//--- Drop operation
  public : inline void drop_operation (void) { mValue = kNotBuilt ; }

//--- Comparison operators
  public : GGS_bool operator == (const GGS_actualParametersPassingMode inOperand) const ;
  public : GGS_bool operator != (const GGS_actualParametersPassingMode inOperand) const ;
  public : GGS_bool operator <= (const GGS_actualParametersPassingMode inOperand) const ;
  public : GGS_bool operator >= (const GGS_actualParametersPassingMode inOperand) const ;
  public : GGS_bool operator <  (const GGS_actualParametersPassingMode inOperand) const ;
  public : GGS_bool operator >  (const GGS_actualParametersPassingMode inOperand) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            class for enumeration 'formalArgumentPassingMode'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_formalArgumentPassingMode {
//--- Enumeration
  public : enum enumeration {kNotBuilt, enum_argumentIn, enum_argumentOut, enum_argumentInOut, enum_argumentConstantIn} ;

//--- Private attribute
  private : enumeration mValue ;

//--- Get value
  public : inline enumeration getValue (void) const {return mValue ; }

//--- Default constructor
  public : inline GGS_formalArgumentPassingMode (void) : mValue (kNotBuilt) {}

//--- Internal constructor
  private : inline GGS_formalArgumentPassingMode (const enumeration inValue) : mValue (inValue) {}

//--- Bit count for bdd
  public : static inline uint16 bitCount (void) { return 3 ; }

//--- Is built ?
  public : inline bool isBuilt (void) const { return mValue > kNotBuilt ; }

//--- Construction from GALGAS constructor
  public : static inline GGS_formalArgumentPassingMode constructor_argumentIn (void) {
    return GGS_formalArgumentPassingMode (enum_argumentIn) ;
  }
  public : static inline GGS_formalArgumentPassingMode constructor_argumentOut (void) {
    return GGS_formalArgumentPassingMode (enum_argumentOut) ;
  }
  public : static inline GGS_formalArgumentPassingMode constructor_argumentInOut (void) {
    return GGS_formalArgumentPassingMode (enum_argumentInOut) ;
  }
  public : static inline GGS_formalArgumentPassingMode constructor_argumentConstantIn (void) {
    return GGS_formalArgumentPassingMode (enum_argumentConstantIn) ;
  }

//--- Messages
  public : GGS_string reader_formalArgumentMessage (void) const ;

//--- Drop operation
  public : inline void drop_operation (void) { mValue = kNotBuilt ; }

//--- Comparison operators
  public : GGS_bool operator == (const GGS_formalArgumentPassingMode inOperand) const ;
  public : GGS_bool operator != (const GGS_formalArgumentPassingMode inOperand) const ;
  public : GGS_bool operator <= (const GGS_formalArgumentPassingMode inOperand) const ;
  public : GGS_bool operator >= (const GGS_formalArgumentPassingMode inOperand) const ;
  public : GGS_bool operator <  (const GGS_formalArgumentPassingMode inOperand) const ;
  public : GGS_bool operator >  (const GGS_formalArgumentPassingMode inOperand) const ;
} ;

class cPtr_AC_galgasType ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_galgasType {
  protected : cPtr_AC_galgasType * mPointer ;
  public : GGS_AC_galgasType (void) ;
  public : GGS_AC_galgasType (const GGS_AC_galgasType &) ;
  public : virtual ~GGS_AC_galgasType (void) ;
  public : void operator = (const GGS_AC_galgasType &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_galgasType & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_galgasType * inSource) ;
  public : GGS_AC_galgasType (cPtr_AC_galgasType * inSource) ;
  public : inline cPtr_AC_galgasType * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_galgasType * operator () (void) const ;
  public : GGS_string reader_messageGalgasType (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'typeListeAttributsSemantiques'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeListeAttributsSemantiques {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_galgasType  mAttributType ;
    public : GGS_lstring  aNomAttribut ;
    public : element_type (const GGS_AC_galgasType & ,
                                const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeListeAttributsSemantiques ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeAttributsSemantiques (void) ; // Default Constructor
  public : GGS_typeListeAttributsSemantiques (const GGS_typeListeAttributsSemantiques &) ; // Copy constructor
  public : void operator = (const GGS_typeListeAttributsSemantiques &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeAttributsSemantiques (void) ;

//--- Constructor 'new'
  public : static GGS_typeListeAttributsSemantiques constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'typeTypesList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTypesList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_location  mEndOfExpressionLocation ;
    public : element_type (const GGS_AC_galgasType & ,
                                const GGS_location & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeTypesList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeTypesList (void) ; // Default Constructor
  public : GGS_typeTypesList (const GGS_typeTypesList &) ; // Copy constructor
  public : void operator = (const GGS_typeTypesList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeTypesList (void) ;

//--- Constructor 'new'
  public : static GGS_typeTypesList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) ;
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class list 'L_signature'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_signature {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_formalArgumentPassingMode mFormalArgumentPassingMode ;
    public : element_type (const GGS_AC_galgasType & ,
                                const GGS_formalArgumentPassingMode& ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_signature ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_signature (void) ; // Default Constructor
  public : GGS_L_signature (const GGS_L_signature &) ; // Copy constructor
  public : void operator = (const GGS_L_signature &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_signature (void) ;

//--- Constructor 'new'
  public : static GGS_L_signature constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) ;
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'L_actualParametersSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_actualParametersSignature {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_actualParametersPassingMode mFormalArgumentPassingMode ;
    public : element_type (const GGS_AC_galgasType & ,
                                const GGS_actualParametersPassingMode& ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_actualParametersSignature ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_actualParametersSignature (void) ; // Default Constructor
  public : GGS_L_actualParametersSignature (const GGS_L_actualParametersSignature &) ; // Copy constructor
  public : void operator = (const GGS_L_actualParametersSignature &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_actualParametersSignature (void) ;

//--- Constructor 'new'
  public : static GGS_L_actualParametersSignature constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) ;
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  DECLARATIONS FOR MAP 'M_accessors_map'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_accessors_map {
  public : GGS_L_signature  mAccessorSignature ;
  public : GGS_AC_galgasType  mReturnedType ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_accessors_map : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_accessors_map & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_accessors_map mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_accessors_map constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_L_signature & inParameter0,
                               const GGS_AC_galgasType & inParameter1,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_L_signature * outParameter0,
                               GGS_AC_galgasType * outParameter1,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_accessors_map (C_Lexique & inLexique,
                                GGS_M_accessors_map & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_AC_galgasType   * outParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_accessors_map (C_Lexique & inLexique,
                                GGS_M_accessors_map & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_AC_galgasType &  inParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'L_stringList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_stringList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_string mErrorMessageElement ;
    public : element_type (const GGS_string& ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_stringList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_stringList (void) ; // Default Constructor
  public : GGS_L_stringList (const GGS_L_stringList &) ; // Copy constructor
  public : void operator = (const GGS_L_stringList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_stringList (void) ;

//--- Constructor 'new'
  public : static GGS_L_stringList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_string& argument_0) ;
  protected : void internalAppendItem (const GGS_string& argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'L_lstringList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_lstringList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  mString ;
    public : element_type (const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_lstringList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_lstringList (void) ; // Default Constructor
  public : GGS_L_lstringList (const GGS_L_lstringList &) ; // Copy constructor
  public : void operator = (const GGS_L_lstringList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_lstringList (void) ;

//--- Constructor 'new'
  public : static GGS_L_lstringList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_C_galgasPrimitiveType ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_galgasPrimitiveType {
  protected : cPtr_C_galgasPrimitiveType * mPointer ;
  public : GGS_C_galgasPrimitiveType (void) ;
  public : GGS_C_galgasPrimitiveType (const GGS_C_galgasPrimitiveType &) ;
  public : virtual ~GGS_C_galgasPrimitiveType (void) ;
  public : void operator = (const GGS_C_galgasPrimitiveType &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_C_galgasPrimitiveType & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_C_galgasPrimitiveType * inSource) ;
  public : GGS_C_galgasPrimitiveType (cPtr_C_galgasPrimitiveType * inSource) ;
  public : inline cPtr_C_galgasPrimitiveType * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_C_galgasPrimitiveType * operator () (void) const ;
  public : GGS_string reader_messageGalgasType (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map element 'e_typeTableMethodes'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMethodes {
  public : GGS_L_signature  aListeTypesParametres ;
  public : bool isBuilt (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         map 'typeTableMethodes'                           *
//                                                                           *
//---------------------------------------------------------------------------*

typedef cClassMethodsMap <e_typeTableMethodes, GGS_lstring> GGS_typeTableMethodes ;

void searchKey_typeTableMethodes (C_Lexique & inLexique,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_luint * outIndex) ;

void searchForOverride_typeTableMethodes (C_Lexique & inLexique,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_luint * outIndex) ;

void insertAbstract_typeTableMethodes (C_Lexique & inLexique,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                GGS_luint * outIndex) ;

void insertNotAbstract_typeTableMethodes (C_Lexique & inLexique,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            DECLARATIONS FOR MAP 'M_externTypeConstructorMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_externTypeConstructorMap {
  public : GGS_typeListeAttributsSemantiques  aListeDesAttributs ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_externTypeConstructorMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_externTypeConstructorMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_externTypeConstructorMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_externTypeConstructorMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_typeListeAttributsSemantiques & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_typeListeAttributsSemantiques * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_externTypeConstructorMap (C_Lexique & inLexique,
                                GGS_M_externTypeConstructorMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_externTypeConstructorMap (C_Lexique & inLexique,
                                GGS_M_externTypeConstructorMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            DECLARATIONS FOR MAP 'M_terminalSymbolsMapForUse'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_terminalSymbolsMapForUse {
  public : GGS_typeListeAttributsSemantiques  aListeDesAttributs ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_terminalSymbolsMapForUse : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_terminalSymbolsMapForUse & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_terminalSymbolsMapForUse mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_terminalSymbolsMapForUse constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_typeListeAttributsSemantiques & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_typeListeAttributsSemantiques * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_terminalSymbolsMapForUse (C_Lexique & inLexique,
                                GGS_M_terminalSymbolsMapForUse & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_terminalSymbolsMapForUse (C_Lexique & inLexique,
                                GGS_M_terminalSymbolsMapForUse & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                DECLARATIONS FOR MAP 'M_lexiqueComponents'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_lexiqueComponents {
  public : GGS_M_terminalSymbolsMapForUse  mTerminalSymbolMap ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_lexiqueComponents : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_lexiqueComponents & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_lexiqueComponents mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_lexiqueComponents constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_terminalSymbolsMapForUse & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_terminalSymbolsMapForUse * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_lexiqueComponents (C_Lexique & inLexique,
                                GGS_M_lexiqueComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_lexiqueComponents (C_Lexique & inLexique,
                                GGS_M_lexiqueComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 DECLARATIONS FOR MAP 'typeTableEnAvant'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableEnAvant {
  public : GGS_AC_galgasType  mType ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableEnAvant : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableEnAvant & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeTableEnAvant mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeTableEnAvant constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_AC_galgasType & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_AC_galgasType * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeTableEnAvant (C_Lexique & inLexique,
                                GGS_typeTableEnAvant & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeTableEnAvant (C_Lexique & inLexique,
                                GGS_typeTableEnAvant & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              DECLARATIONS FOR MAP 'M_nonterminalSymbolAlts'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_nonterminalSymbolAlts {
  public : GGS_L_signature  mFormalParametersList ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_nonterminalSymbolAlts : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_nonterminalSymbolAlts & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_nonterminalSymbolAlts mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_nonterminalSymbolAlts constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_L_signature & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_L_signature * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_nonterminalSymbolAlts (C_Lexique & inLexique,
                                GGS_M_nonterminalSymbolAlts & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_nonterminalSymbolAlts (C_Lexique & inLexique,
                                GGS_M_nonterminalSymbolAlts & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            DECLARATIONS FOR MAP 'M_externClassesDirectories'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_externClassesDirectories {
  public : GGS_lstring  mDirectory ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_externClassesDirectories : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_externClassesDirectories & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_externClassesDirectories mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_externClassesDirectories constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_lstring & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_lstring * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_externClassesDirectories (C_Lexique & inLexique,
                                GGS_M_externClassesDirectories & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_externClassesDirectories (C_Lexique & inLexique,
                                GGS_M_externClassesDirectories & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0,
                                GGS_luint * outIndex) ;

class cPtr_AC_semanticsEntity ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_semanticsEntity {
  protected : cPtr_AC_semanticsEntity * mPointer ;
  public : GGS_AC_semanticsEntity (void) ;
  public : GGS_AC_semanticsEntity (const GGS_AC_semanticsEntity &) ;
  public : virtual ~GGS_AC_semanticsEntity (void) ;
  public : void operator = (const GGS_AC_semanticsEntity &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_semanticsEntity & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_semanticsEntity * inSource) ;
  public : GGS_AC_semanticsEntity (cPtr_AC_semanticsEntity * inSource) ;
  public : inline cPtr_AC_semanticsEntity * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_semanticsEntity * operator () (void) const ;
  public : GGS_string reader_messageTypeEntite (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             DECLARATIONS FOR MAP 'M_semanticsEntitiesForUse'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_semanticsEntitiesForUse {
  public : GGS_AC_semanticsEntity  aDefEntite ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_semanticsEntitiesForUse : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_semanticsEntitiesForUse & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_semanticsEntitiesForUse mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_semanticsEntitiesForUse constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_AC_semanticsEntity & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_AC_semanticsEntity * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_semanticsEntitiesForUse (C_Lexique & inLexique,
                                GGS_M_semanticsEntitiesForUse & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_semanticsEntitiesForUse (C_Lexique & inLexique,
                                GGS_M_semanticsEntitiesForUse & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity &  inParameter0,
                                GGS_luint * outIndex) ;

class cPtr_AC_typeForGrammarComponent ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_typeForGrammarComponent {
  protected : cPtr_AC_typeForGrammarComponent * mPointer ;
  public : GGS_AC_typeForGrammarComponent (void) ;
  public : GGS_AC_typeForGrammarComponent (const GGS_AC_typeForGrammarComponent &) ;
  public : virtual ~GGS_AC_typeForGrammarComponent (void) ;
  public : void operator = (const GGS_AC_typeForGrammarComponent &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_typeForGrammarComponent & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_typeForGrammarComponent * inSource) ;
  public : GGS_AC_typeForGrammarComponent (cPtr_AC_typeForGrammarComponent * inSource) ;
  public : inline cPtr_AC_typeForGrammarComponent * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_typeForGrammarComponent * operator () (void) const ;
  public : GGS_string reader_typeForGrammarComponentMessage (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            DECLARATIONS FOR MAP 'M_typesForGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_typesForGrammarComponent {
  public : GGS_AC_typeForGrammarComponent  mType ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_typesForGrammarComponent : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_typesForGrammarComponent & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_typesForGrammarComponent mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_typesForGrammarComponent constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_AC_typeForGrammarComponent & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_AC_typeForGrammarComponent * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_typesForGrammarComponent (C_Lexique & inLexique,
                                GGS_M_typesForGrammarComponent & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_typesForGrammarComponent (C_Lexique & inLexique,
                                GGS_M_typesForGrammarComponent & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class list 'L_signature_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_signature_ForGrammarComponent {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_formalArgumentPassingMode mFormalArgumentPassingMode ;
    public : GGS_lstring  mGalgasTypeName ;
    public : element_type (const GGS_formalArgumentPassingMode& ,
                                const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_signature_ForGrammarComponent ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_signature_ForGrammarComponent (void) ; // Default Constructor
  public : GGS_L_signature_ForGrammarComponent (const GGS_L_signature_ForGrammarComponent &) ; // Copy constructor
  public : void operator = (const GGS_L_signature_ForGrammarComponent &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_signature_ForGrammarComponent (void) ;

//--- Constructor 'new'
  public : static GGS_L_signature_ForGrammarComponent constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void internalAppendItem (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

void routine_checkSignature_ForGrammarComponent (C_Lexique &,
                                const GGS_L_signature_ForGrammarComponent  &,
                                const GGS_L_signature_ForGrammarComponent  &,
                                const GGS_location  &) ;

class cPtr_AC_instruction_ForGrammar ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_instruction_ForGrammar {
  protected : cPtr_AC_instruction_ForGrammar * mPointer ;
  public : GGS_AC_instruction_ForGrammar (void) ;
  public : GGS_AC_instruction_ForGrammar (const GGS_AC_instruction_ForGrammar &) ;
  public : virtual ~GGS_AC_instruction_ForGrammar (void) ;
  public : void operator = (const GGS_AC_instruction_ForGrammar &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_instruction_ForGrammar & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_instruction_ForGrammar * inSource) ;
  public : GGS_AC_instruction_ForGrammar (cPtr_AC_instruction_ForGrammar * inSource) ;
  public : inline cPtr_AC_instruction_ForGrammar * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_instruction_ForGrammar * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class list 'L_ruleSyntaxSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_ruleSyntaxSignature {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_instruction_ForGrammar  mInstruction ;
    public : element_type (const GGS_AC_instruction_ForGrammar & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_ruleSyntaxSignature ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_ruleSyntaxSignature (void) ; // Default Constructor
  public : GGS_L_ruleSyntaxSignature (const GGS_L_ruleSyntaxSignature &) ; // Copy constructor
  public : void operator = (const GGS_L_ruleSyntaxSignature &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_ruleSyntaxSignature (void) ;

//--- Constructor 'new'
  public : static GGS_L_ruleSyntaxSignature constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) ;
  protected : void internalAppendItem (const GGS_AC_instruction_ForGrammar & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   DECLARATIONS FOR MAP 'L_grammarsMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class e_L_grammarsMap {
  public : GGS_M_nonterminalSymbolAlts  mStartSymbolParametersMap ;
} ;

//---------------------------------------------------------------------------*

class GGS_L_grammarsMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_L_grammarsMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_L_grammarsMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_L_grammarsMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_nonterminalSymbolAlts & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_nonterminalSymbolAlts * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_L_grammarsMap (C_Lexique & inLexique,
                                GGS_L_grammarsMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_L_grammarsMap (C_Lexique & inLexique,
                                GGS_L_grammarsMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Extern type 'SS_terminal_symbols'                      *
//                                                                           *
//---------------------------------------------------------------------------*

typedef C_galgas_stringset GGS_SS_terminal_symbols ;

//---------------------------------------------------------------------------*
//                                                                           *
//         DECLARATIONS FOR MAP 'M_nonterminalSymbolAltsForGrammar'          *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_nonterminalSymbolAltsForGrammar {
  public : GGS_L_signature_ForGrammarComponent  mFormalParametersList ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_nonterminalSymbolAltsForGrammar : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_nonterminalSymbolAltsForGrammar & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_nonterminalSymbolAltsForGrammar mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_nonterminalSymbolAltsForGrammar constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_L_signature_ForGrammarComponent & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_L_signature_ForGrammarComponent * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_nonterminalSymbolAltsForGrammar (C_Lexique & inLexique,
                                GGS_M_nonterminalSymbolAltsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature_ForGrammarComponent   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_nonterminalSymbolAltsForGrammar (C_Lexique & inLexique,
                                GGS_M_nonterminalSymbolAltsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature_ForGrammarComponent &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            class list 'L_productionRules_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_productionRules_ForGrammarComponent {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  mLeftNonterminalSymbol ;
    public : GGS_uint  mLeftNonterminalSymbolIndex ;
    public : GGS_L_ruleSyntaxSignature  mInstructionsList ;
    public : element_type (const GGS_lstring & ,
                                const GGS_uint & ,
                                const GGS_L_ruleSyntaxSignature & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_productionRules_ForGrammarComponent ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_productionRules_ForGrammarComponent (void) ; // Default Constructor
  public : GGS_L_productionRules_ForGrammarComponent (const GGS_L_productionRules_ForGrammarComponent &) ; // Copy constructor
  public : void operator = (const GGS_L_productionRules_ForGrammarComponent &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_productionRules_ForGrammarComponent (void) ;

//--- Constructor 'new'
  public : static GGS_L_productionRules_ForGrammarComponent constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          DECLARATIONS FOR MAP 'M_nonTerminalSymbolsForGrammar'            *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_nonTerminalSymbolsForGrammar {
  public : GGS_M_nonterminalSymbolAltsForGrammar  mNonterminalSymbolParametersMap ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_nonTerminalSymbolsForGrammar : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_nonTerminalSymbolsForGrammar & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_nonTerminalSymbolsForGrammar mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_nonTerminalSymbolsForGrammar constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_nonterminalSymbolAltsForGrammar * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_nonTerminalSymbolsForGrammar (C_Lexique & inLexique,
                                GGS_M_nonTerminalSymbolsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_nonTerminalSymbolsForGrammar (C_Lexique & inLexique,
                                GGS_M_nonTerminalSymbolsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                DECLARATIONS FOR MAP 'M_syntaxComponents'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_syntaxComponents {
  public : GGS_M_nonTerminalSymbolsForGrammar  mNonterminalSymbolsMap ;
  public : GGS_L_productionRules_ForGrammarComponent  mProductionRulesList ;
  public : GGS_lstring  mLexiqueComponentName ;
  public : GGS_string_set mClassesNamesSet ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_syntaxComponents : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_syntaxComponents & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_syntaxComponents mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_syntaxComponents constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                               const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                               const GGS_lstring & inParameter2,
                               const GGS_string_set& inParameter3,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_nonTerminalSymbolsForGrammar * outParameter0,
                               GGS_L_productionRules_ForGrammarComponent * outParameter1,
                               GGS_lstring * outParameter2,
                               GGS_string_set* outParameter3,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_syntaxComponents (C_Lexique & inLexique,
                                GGS_M_syntaxComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   * outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   * outParameter1,
                                GGS_lstring   * outParameter2,
                                GGS_string_set  * outParameter3,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_syntaxComponents (C_Lexique & inLexique,
                                GGS_M_syntaxComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar &  inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent &  inParameter1,
                                const GGS_lstring &  inParameter2,
                                const GGS_string_set&  inParameter3,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class list 'L_branchList_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_branchList_ForGrammarComponent {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_L_ruleSyntaxSignature  mInstructionsList ;
    public : element_type (const GGS_L_ruleSyntaxSignature & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_branchList_ForGrammarComponent ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_branchList_ForGrammarComponent (void) ; // Default Constructor
  public : GGS_L_branchList_ForGrammarComponent (const GGS_L_branchList_ForGrammarComponent &) ; // Copy constructor
  public : void operator = (const GGS_L_branchList_ForGrammarComponent &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_branchList_ForGrammarComponent (void) ;

//--- Constructor 'new'
  public : static GGS_L_branchList_ForGrammarComponent constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) ;
  protected : void internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'L_syntaxComponents_ForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_syntaxComponents_ForGrammar {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_M_nonTerminalSymbolsForGrammar  mNonterminalSymbolsMap ;
    public : GGS_L_productionRules_ForGrammarComponent  mProductionRulesList ;
    public : GGS_string_set mClassesNamesSet ;
    public : GGS_lstring  mSyntaxComponentName ;
    public : element_type (const GGS_M_nonTerminalSymbolsForGrammar & ,
                                const GGS_L_productionRules_ForGrammarComponent & ,
                                const GGS_string_set& ,
                                const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_syntaxComponents_ForGrammar ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_syntaxComponents_ForGrammar (void) ; // Default Constructor
  public : GGS_L_syntaxComponents_ForGrammar (const GGS_L_syntaxComponents_ForGrammar &) ; // Copy constructor
  public : void operator = (const GGS_L_syntaxComponents_ForGrammar &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_syntaxComponents_ForGrammar (void) ;

//--- Constructor 'new'
  public : static GGS_L_syntaxComponents_ForGrammar constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_string_set& argument_2,
                                const GGS_lstring & argument_3) ;
  protected : void internalAppendItem (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_string_set& argument_2,
                                const GGS_lstring & argument_3) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'L_identifiers'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_identifiers {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  aIdentificateur ;
    public : element_type (const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_identifiers ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_identifiers (void) ; // Default Constructor
  public : GGS_L_identifiers (const GGS_L_identifiers &) ; // Copy constructor
  public : void operator = (const GGS_L_identifiers &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_identifiers (void) ;

//--- Constructor 'new'
  public : static GGS_L_identifiers constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                DECLARATIONS FOR MAP 'typeSuperClassesMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeSuperClassesMap {
} ;

//---------------------------------------------------------------------------*

class GGS_typeSuperClassesMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeSuperClassesMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeSuperClassesMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeSuperClassesMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void insertKey_typeSuperClassesMap (C_Lexique & inLexique,
                                GGS_typeSuperClassesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           DECLARATIONS FOR MAP 'typeClassInheritedMessagesMap'            *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeClassInheritedMessagesMap {
} ;

//---------------------------------------------------------------------------*

class GGS_typeClassInheritedMessagesMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeClassInheritedMessagesMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeClassInheritedMessagesMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeClassInheritedMessagesMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeClassInheritedMessagesMap (C_Lexique & inLexique,
                                GGS_typeClassInheritedMessagesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeClassInheritedMessagesMap (C_Lexique & inLexique,
                                GGS_typeClassInheritedMessagesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             DECLARATIONS FOR MAP 'typeSemanticAttributesMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeSemanticAttributesMap {
  public : GGS_AC_galgasType  mAttributType ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeSemanticAttributesMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeSemanticAttributesMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeSemanticAttributesMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeSemanticAttributesMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_AC_galgasType & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_AC_galgasType * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeSemanticAttributesMap (C_Lexique & inLexique,
                                GGS_typeSemanticAttributesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeSemanticAttributesMap (C_Lexique & inLexique,
                                GGS_typeSemanticAttributesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         DECLARATIONS FOR MAP 'typeTableMethodesInsererChercher'           *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMethodesInsererChercher {
  public : GGS_L_stringList  mErrorMessageList ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableMethodesInsererChercher : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableMethodesInsererChercher & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeTableMethodesInsererChercher mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeTableMethodesInsererChercher constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_L_stringList & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_L_stringList * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeTableMethodesInsererChercher (C_Lexique & inLexique,
                                GGS_typeTableMethodesInsererChercher & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_stringList   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeTableMethodesInsererChercher (C_Lexique & inLexique,
                                GGS_typeTableMethodesInsererChercher & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_stringList &  inParameter0,
                                GGS_luint * outIndex) ;

class cPtr_typeDefEntiteUtilisable ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefEntiteUtilisable {
  protected : cPtr_typeDefEntiteUtilisable * mPointer ;
  public : GGS_typeDefEntiteUtilisable (void) ;
  public : GGS_typeDefEntiteUtilisable (const GGS_typeDefEntiteUtilisable &) ;
  public : virtual ~GGS_typeDefEntiteUtilisable (void) ;
  public : void operator = (const GGS_typeDefEntiteUtilisable &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_typeDefEntiteUtilisable & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeDefEntiteUtilisable * inSource) ;
  public : GGS_typeDefEntiteUtilisable (cPtr_typeDefEntiteUtilisable * inSource) ;
  public : inline cPtr_typeDefEntiteUtilisable * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_typeDefEntiteUtilisable * operator () (void) const ;
  public : GGS_string reader_messageTypeEntite (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               DECLARATIONS FOR MAP 'typeTableBlocsDeTable'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableBlocsDeTable {
  public : GGS_L_signature  aSignatureDebut ;
  public : GGS_L_signature  aSignatureFin ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableBlocsDeTable : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableBlocsDeTable & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeTableBlocsDeTable mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeTableBlocsDeTable constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_L_signature & inParameter0,
                               const GGS_L_signature & inParameter1,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_L_signature * outParameter0,
                               GGS_L_signature * outParameter1,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeTableBlocsDeTable (C_Lexique & inLexique,
                                GGS_typeTableBlocsDeTable & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_L_signature   * outParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeTableBlocsDeTable (C_Lexique & inLexique,
                                GGS_typeTableBlocsDeTable & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_L_signature &  inParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         DECLARATIONS FOR MAP 'typeTableUtilisationsSemantiques'           *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableUtilisationsSemantiques {
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableUtilisationsSemantiques : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableUtilisationsSemantiques & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeTableUtilisationsSemantiques mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeTableUtilisationsSemantiques constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void insertKey_typeTableUtilisationsSemantiques (C_Lexique & inLexique,
                                GGS_typeTableUtilisationsSemantiques & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               DECLARATIONS FOR MAP 'typeEnumConstantesMap'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeEnumConstantesMap {
} ;

//---------------------------------------------------------------------------*

class GGS_typeEnumConstantesMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeEnumConstantesMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeEnumConstantesMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeEnumConstantesMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeEnumConstantesMap (C_Lexique & inLexique,
                                GGS_typeEnumConstantesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeEnumConstantesMap (C_Lexique & inLexique,
                                GGS_typeEnumConstantesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                DECLARATIONS FOR MAP 'typeEnumMessageMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeEnumMessageMap {
  public : GGS_L_lstringList  mMessageStringList ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeEnumMessageMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeEnumMessageMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_typeEnumMessageMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_typeEnumMessageMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_L_lstringList & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_L_lstringList * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_typeEnumMessageMap (C_Lexique & inLexique,
                                GGS_typeEnumMessageMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   * outParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_typeEnumMessageMap (C_Lexique & inLexique,
                                GGS_typeEnumMessageMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList &  inParameter0,
                                GGS_luint * outIndex) ;

void routine_verifierCompatibiliteTypesSemantiques (C_Lexique &,
                                const GGS_AC_galgasType  &,
                                const GGS_AC_galgasType  &,
                                const GGS_location  &) ;

void routine_verifierCompatibiliteSignatures (C_Lexique &,
                                GGS_L_signature  ,
                                GGS_L_signature  ,
                                GGS_location  ) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   DECLARATIONS FOR MAP 'M_cli_options'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_cli_options {
  public : GGS_lchar  mOptionChar ;
  public : GGS_lstring  mOptionString ;
  public : GGS_lstring  mComment ;
  public : GGS_uint  mDefaultValue ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_cli_options : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_cli_options & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_cli_options mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_cli_options constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_lchar & inParameter0,
                               const GGS_lstring & inParameter1,
                               const GGS_lstring & inParameter2,
                               const GGS_uint & inParameter3,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_lchar * outParameter0,
                               GGS_lstring * outParameter1,
                               GGS_lstring * outParameter2,
                               GGS_uint * outParameter3,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_cli_options (C_Lexique & inLexique,
                                GGS_M_cli_options & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lchar   * outParameter0,
                                GGS_lstring   * outParameter1,
                                GGS_lstring   * outParameter2,
                                GGS_uint   * outParameter3,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_cli_options (C_Lexique & inLexique,
                                GGS_M_cli_options & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lchar &  inParameter0,
                                const GGS_lstring &  inParameter1,
                                const GGS_lstring &  inParameter2,
                                const GGS_uint &  inParameter3,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                DECLARATIONS FOR MAP 'M_optionComponents'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_optionComponents {
  public : GGS_M_cli_options  mBoolOptionsMap ;
  public : GGS_M_cli_options  mUintOptionsMap ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_optionComponents : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_optionComponents & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_optionComponents mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_optionComponents constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_cli_options & inParameter0,
                               const GGS_M_cli_options & inParameter1,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_cli_options * outParameter0,
                               GGS_M_cli_options * outParameter1,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_optionComponents (C_Lexique & inLexique,
                                GGS_M_optionComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   * outParameter0,
                                GGS_M_cli_options   * outParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_optionComponents (C_Lexique & inLexique,
                                GGS_M_optionComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options &  inParameter0,
                                const GGS_M_cli_options &  inParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               DECLARATIONS FOR MAP 'M_semanticsComponents'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_semanticsComponents {
  public : GGS_M_semanticsEntitiesForUse  mSemanticsEntitiesMap ;
  public : GGS_M_optionComponents  mOptionsComponents ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_semanticsComponents : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_semanticsComponents & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_semanticsComponents mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_semanticsComponents constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_semanticsEntitiesForUse & inParameter0,
                               const GGS_M_optionComponents & inParameter1,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_semanticsEntitiesForUse * outParameter0,
                               GGS_M_optionComponents * outParameter1,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_semanticsComponents (C_Lexique & inLexique,
                                GGS_M_semanticsComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_semanticsEntitiesForUse   * outParameter0,
                                GGS_M_optionComponents   * outParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_semanticsComponents (C_Lexique & inLexique,
                                GGS_M_semanticsComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_semanticsEntitiesForUse &  inParameter0,
                                const GGS_M_optionComponents &  inParameter1,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                DECLARATIONS FOR MAP 'M_grammarComponents'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_grammarComponents {
  public : GGS_M_nonterminalSymbolAltsForGrammar  mNonterminalSymbolParametersMap ;
  public : GGS_lstring  mLexiqueName ;
  public : GGS_M_optionComponents  mOptionsMap ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_grammarComponents : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_grammarComponents & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_String
    public : virtual C_String getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_grammarComponents mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_grammarComponents constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                               const GGS_lstring & inParameter1,
                               const GGS_M_optionComponents & inParameter2,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_Lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_M_nonterminalSymbolAltsForGrammar * outParameter0,
                               GGS_lstring * outParameter1,
                               GGS_M_optionComponents * outParameter2,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_grammarComponents (C_Lexique & inLexique,
                                GGS_M_grammarComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   * outParameter0,
                                GGS_lstring   * outParameter1,
                                GGS_M_optionComponents   * outParameter2,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_grammarComponents (C_Lexique & inLexique,
                                GGS_M_grammarComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
                                const GGS_lstring &  inParameter1,
                                const GGS_M_optionComponents &  inParameter2,
                                GGS_luint * outIndex) ;

void routine_handleReaderCall (C_Lexique &,
                                const GGS_AC_galgasType  &,
                                const GGS_lstring  &,
                                GGS_typeListeAttributsSemantiques  &,
                                GGS_AC_galgasType  &) ;

#include "include_AC_galgasType.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeGalgas_jokerInParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_jokerInParameterList

#define macroInheritFrom_typeGalgas_jokerInParameterList

class cPtr_typeGalgas_jokerInParameterList : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_jokerInParameterList
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_jokerInParameterList {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_jokerInParameterList * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_jokerInParameterList * constructor_new () {
      return new cPtr_typeGalgas_jokerInParameterList() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_bool'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_bool

#define macroInheritFrom_typeGalgas_bool

class cPtr_typeGalgas_bool : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_bool
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_bool {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_bool * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_bool * constructor_new () {
      return new cPtr_typeGalgas_bool() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_string'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_string

#define macroInheritFrom_typeGalgas_string

class cPtr_typeGalgas_string : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_string
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_string {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_string * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_string * constructor_new () {
      return new cPtr_typeGalgas_string() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_sint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_sint

#define macroInheritFrom_typeGalgas_sint

class cPtr_typeGalgas_sint : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_sint
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_sint {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_sint * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_sint * constructor_new () {
      return new cPtr_typeGalgas_sint() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_uint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_uint

#define macroInheritFrom_typeGalgas_uint

class cPtr_typeGalgas_uint : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_uint
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleIncrementOperatorCall (C_Lexique &,
                                GGS_location  ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_uint {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_uint * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_uint * constructor_new () {
      return new cPtr_typeGalgas_uint() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_char'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_char

#define macroInheritFrom_typeGalgas_char

class cPtr_typeGalgas_char : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_char
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_char {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_char * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_char * constructor_new () {
      return new cPtr_typeGalgas_char() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_dfloat'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_dfloat

#define macroInheritFrom_typeGalgas_dfloat

class cPtr_typeGalgas_dfloat : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_dfloat
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_dfloat'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_dfloat {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_dfloat * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_dfloat * constructor_new () {
      return new cPtr_typeGalgas_dfloat() ;
    }
  #endif
} ;

#include "include_C_galgasPrimitiveType.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_location'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_location

#define macroInheritFrom_typeGalgas_location

class cPtr_typeGalgas_location : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_location
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_acceptAssignmentFromHere (C_Lexique &,
                                GGS_lstring  ) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_location {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_location * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_location * constructor_new () {
      return new cPtr_typeGalgas_location() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_lstring'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_lstring

#define macroInheritFrom_typeGalgas_lstring

class cPtr_typeGalgas_lstring : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_lstring
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_acceptToBeKeyForMap (C_Lexique &) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_lstring {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_lstring * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_lstring * constructor_new () {
      return new cPtr_typeGalgas_lstring() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lchar'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_lchar

#define macroInheritFrom_typeGalgas_lchar

class cPtr_typeGalgas_lchar : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_lchar
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_lchar {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_lchar * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_lchar * constructor_new () {
      return new cPtr_typeGalgas_lchar() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lbool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_lbool

#define macroInheritFrom_typeGalgas_lbool

class cPtr_typeGalgas_lbool : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_lbool
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_lbool {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_lbool * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_lbool * constructor_new () {
      return new cPtr_typeGalgas_lbool() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_luint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_luint

#define macroInheritFrom_typeGalgas_luint

class cPtr_typeGalgas_luint : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_luint
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_acceptToBeKeyForMap (C_Lexique &) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_luint {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_luint * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_luint * constructor_new () {
      return new cPtr_typeGalgas_luint() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lsint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_lsint

#define macroInheritFrom_typeGalgas_lsint

class cPtr_typeGalgas_lsint : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_lsint
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_acceptToBeKeyForMap (C_Lexique &) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_lsint {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_lsint * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_lsint * constructor_new () {
      return new cPtr_typeGalgas_lsint() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_ldfloat'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_ldfloat

#define macroInheritFrom_typeGalgas_ldfloat

class cPtr_typeGalgas_ldfloat : public cPtr_C_galgasPrimitiveType {
  private : typedef cPtr_C_galgasPrimitiveType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_C_galgasPrimitiveType
  macro_typeGalgas_ldfloat
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique &) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldfloat'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_ldfloat {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_ldfloat * constructor_new () ;
  #else
    public : inline static cPtr_typeGalgas_ldfloat * constructor_new () {
      return new cPtr_typeGalgas_ldfloat() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeGalgasUndefinedExternType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasUndefinedExternType

#define macroInheritFrom_typeGalgasUndefinedExternType

class cPtr_typeGalgasUndefinedExternType : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgasUndefinedExternType
  public : cPtr_typeGalgasUndefinedExternType (const GGS_lstring & ,
                                const GGS_lstring & ) ;
  public : GGS_lstring  mGalgasClassName ;
  public : GGS_lstring  mCppClassName ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasUndefinedExternType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasUndefinedExternType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  #else
    public : inline static cPtr_typeGalgasUndefinedExternType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
      return new cPtr_typeGalgasUndefinedExternType(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasExternType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasExternType

#define macroInheritFrom_typeGalgasExternType

class cPtr_typeGalgasExternType : public cPtr_typeGalgasUndefinedExternType {
  private : typedef cPtr_typeGalgasUndefinedExternType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_typeGalgasUndefinedExternType
  macro_typeGalgasExternType
  public : cPtr_typeGalgasExternType (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_M_externTypeConstructorMap & ,
                                const GGS_typeTableMethodes & ,
                                const GGS_typeTableMethodes & ,
                                const GGS_bool& ,
                                const GGS_typeListeAttributsSemantiques & ) ;
  public : GGS_M_externTypeConstructorMap  mConstructorMap ;
  public : GGS_typeTableMethodes  mModifiersMap ;
  public : GGS_typeTableMethodes  mReadersInInstructionMap ;
  public : GGS_bool mAcceptAddAssignOperatorCall ;
  public : GGS_typeListeAttributsSemantiques  mAddAssignOperatorCallTypeList ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_handleModifierCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_L_signature & ) ;
  public : virtual void methode_handleReaderInstructionCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_L_signature & ) ;
  public : virtual void methode_handleAddAssignOperatorCall (C_Lexique &,
                                GGS_location  ,
                                GGS_typeListeAttributsSemantiques & ,
                                GGS_bool& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasExternType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasExternType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6) ;
  #else
    public : inline static cPtr_typeGalgasExternType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6) {
      return new cPtr_typeGalgasExternType(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
    }
  #endif
} ;

#include "include_AC_semanticsEntity.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_grammarForSemantics'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_grammarForSemantics

#define macroInheritFrom_C_grammarForSemantics

class cPtr_C_grammarForSemantics : public cPtr_AC_semanticsEntity {
  private : typedef cPtr_AC_semanticsEntity inherited ;
  macroInheritFrom_AC_semanticsEntity
  macro_C_grammarForSemantics
  public : cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & ) ;
  public : GGS_M_nonterminalSymbolAlts  mGrammarAltMap ;
  public : virtual bool isBuilt (void) const ;

  public : virtual const char * message_messageTypeEntite (void) const ;
  public : static const char * static_string_message_messageTypeEntite (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_grammarForSemantics {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_grammarForSemantics * constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) ;
  #else
    public : inline static cPtr_C_grammarForSemantics * constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) {
      return new cPtr_C_grammarForSemantics(argument_0) ;
    }
  #endif
} ;

#include "include_AC_typeForGrammarComponent.h"

#include "include_AC_instruction_ForGrammar.h"

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'T_terminalInstruction_forGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_T_terminalInstruction_forGrammarComponent

#define macroInheritFrom_T_terminalInstruction_forGrammarComponent

class cPtr_T_terminalInstruction_forGrammarComponent : public cPtr_AC_instruction_ForGrammar {
  private : typedef cPtr_AC_instruction_ForGrammar inherited ;
  macroInheritFrom_AC_instruction_ForGrammar
  macro_T_terminalInstruction_forGrammarComponent
  public : cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & ,
                                const GGS_lstring & ,
                                const GGS_uint & ) ;
  public : GGS_lstring  mTerminalSymbolName ;
  public : GGS_uint  mTerminalSymbolIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_T_terminalInstruction_forGrammarComponent {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_T_terminalInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) ;
  #else
    public : inline static cPtr_T_terminalInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) {
      return new cPtr_T_terminalInstruction_forGrammarComponent(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'T_nonterminalInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_T_nonterminalInstruction_forGrammarComponent

#define macroInheritFrom_T_nonterminalInstruction_forGrammarComponent

class cPtr_T_nonterminalInstruction_forGrammarComponent : public cPtr_AC_instruction_ForGrammar {
  private : typedef cPtr_AC_instruction_ForGrammar inherited ;
  macroInheritFrom_AC_instruction_ForGrammar
  macro_T_nonterminalInstruction_forGrammarComponent
  public : cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & ,
                                const GGS_lstring & ,
                                const GGS_uint & ) ;
  public : GGS_lstring  mNonterminalSymbolName ;
  public : GGS_uint  mNonterminalSymbolIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_T_nonterminalInstruction_forGrammarComponent {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_T_nonterminalInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) ;
  #else
    public : inline static cPtr_T_nonterminalInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) {
      return new cPtr_T_nonterminalInstruction_forGrammarComponent(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_selectInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_T_selectInstruction_forGrammarComponent

#define macroInheritFrom_T_selectInstruction_forGrammarComponent

class cPtr_T_selectInstruction_forGrammarComponent : public cPtr_AC_instruction_ForGrammar {
  private : typedef cPtr_AC_instruction_ForGrammar inherited ;
  macroInheritFrom_AC_instruction_ForGrammar
  macro_T_selectInstruction_forGrammarComponent
  public : cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & ,
                                const GGS_L_branchList_ForGrammarComponent & ,
                                const GGS_uint & ) ;
  public : GGS_L_branchList_ForGrammarComponent  mSelectList ;
  public : GGS_uint  mAddedNonterminalmSymbolIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_T_selectInstruction_forGrammarComponent {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_T_selectInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) ;
  #else
    public : inline static cPtr_T_selectInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) {
      return new cPtr_T_selectInstruction_forGrammarComponent(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_repeatInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_T_repeatInstruction_forGrammarComponent

#define macroInheritFrom_T_repeatInstruction_forGrammarComponent

class cPtr_T_repeatInstruction_forGrammarComponent : public cPtr_AC_instruction_ForGrammar {
  private : typedef cPtr_AC_instruction_ForGrammar inherited ;
  macroInheritFrom_AC_instruction_ForGrammar
  macro_T_repeatInstruction_forGrammarComponent
  public : cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & ,
                                const GGS_L_branchList_ForGrammarComponent & ,
                                const GGS_uint & ) ;
  public : GGS_L_branchList_ForGrammarComponent  mRepeatList ;
  public : GGS_uint  mAddedNonterminalmSymbolIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_T_repeatInstruction_forGrammarComponent {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_T_repeatInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) ;
  #else
    public : inline static cPtr_T_repeatInstruction_forGrammarComponent * constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) {
      return new cPtr_T_repeatInstruction_forGrammarComponent(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

#include "include_typeDefEntiteUtilisable.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasSetType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasSetType

#define macroInheritFrom_typeGalgasSetType

class cPtr_typeGalgasSetType : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgasSetType
  public : cPtr_typeGalgasSetType (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_AC_galgasType & ) ;
  public : GGS_lstring  mSetTypeName ;
  public : GGS_lstring  mEnumElementTypeName ;
  public : GGS_AC_galgasType  mEnumType ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual void methode_handleModifierCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_L_signature & ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasSetType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasSetType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasSetType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_AC_galgasType & argument_2) ;
  #else
    public : inline static cPtr_typeGalgasSetType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_AC_galgasType & argument_2) {
      return new cPtr_typeGalgasSetType(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedListType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasUndefinedListType

#define macroInheritFrom_typeGalgasUndefinedListType

class cPtr_typeGalgasUndefinedListType : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgasUndefinedListType
  public : cPtr_typeGalgasUndefinedListType (const GGS_lstring & ) ;
  public : GGS_lstring  mListTypeName ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasUndefinedListType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasUndefinedListType * constructor_new (const GGS_lstring & argument_0) ;
  #else
    public : inline static cPtr_typeGalgasUndefinedListType * constructor_new (const GGS_lstring & argument_0) {
      return new cPtr_typeGalgasUndefinedListType(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasListType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasListType

#define macroInheritFrom_typeGalgasListType

class cPtr_typeGalgasListType : public cPtr_typeGalgasUndefinedListType {
  private : typedef cPtr_typeGalgasUndefinedListType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_typeGalgasUndefinedListType
  macro_typeGalgasListType
  public : cPtr_typeGalgasListType (const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ) ;
  public : GGS_typeListeAttributsSemantiques  mNonExternAttributesList ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_handleAddAssignOperatorCall (C_Lexique &,
                                GGS_location  ,
                                GGS_typeListeAttributsSemantiques & ,
                                GGS_bool& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasListType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasListType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1) ;
  #else
    public : inline static cPtr_typeGalgasListType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1) {
      return new cPtr_typeGalgasListType(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgasUndefinedMapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasUndefinedMapType

#define macroInheritFrom_typeGalgasUndefinedMapType

class cPtr_typeGalgasUndefinedMapType : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgasUndefinedMapType
  public : cPtr_typeGalgasUndefinedMapType (const GGS_lstring & ) ;
  public : GGS_lstring  mMapTypeName ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasUndefinedMapType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasUndefinedMapType * constructor_new (const GGS_lstring & argument_0) ;
  #else
    public : inline static cPtr_typeGalgasUndefinedMapType * constructor_new (const GGS_lstring & argument_0) {
      return new cPtr_typeGalgasUndefinedMapType(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasMapType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasMapType

#define macroInheritFrom_typeGalgasMapType

class cPtr_typeGalgasMapType : public cPtr_typeGalgasUndefinedMapType {
  private : typedef cPtr_typeGalgasUndefinedMapType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_typeGalgasUndefinedMapType
  macro_typeGalgasMapType
  public : cPtr_typeGalgasMapType (const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_typeTableMethodesInsererChercher & ,
                                const GGS_typeTableMethodesInsererChercher & ,
                                const GGS_typeTableBlocsDeTable & ,
                                const GGS_lstring & ,
                                const GGS_AC_galgasType & ) ;
  public : GGS_typeListeAttributsSemantiques  mNonExternAttributesList ;
  public : GGS_typeTableMethodesInsererChercher  aTableMethodesInserer ;
  public : GGS_typeTableMethodesInsererChercher  aTableMethodesChercher ;
  public : GGS_typeTableBlocsDeTable  aTableMethodesSurcharger ;
  public : GGS_lstring  mKeyTypeName ;
  public : GGS_AC_galgasType  mKeyType ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasMapType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasMapType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodesInsererChercher & argument_2,
                                const GGS_typeTableMethodesInsererChercher & argument_3,
                                const GGS_typeTableBlocsDeTable & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_AC_galgasType & argument_6) ;
  #else
    public : inline static cPtr_typeGalgasMapType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodesInsererChercher & argument_2,
                                const GGS_typeTableMethodesInsererChercher & argument_3,
                                const GGS_typeTableBlocsDeTable & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_AC_galgasType & argument_6) {
      return new cPtr_typeGalgasMapType(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedClassType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasUndefinedClassType

#define macroInheritFrom_typeGalgasUndefinedClassType

class cPtr_typeGalgasUndefinedClassType : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgasUndefinedClassType
  public : cPtr_typeGalgasUndefinedClassType (const GGS_lstring & ) ;
  public : GGS_lstring  mClassTypeName ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasUndefinedClassType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasUndefinedClassType * constructor_new (const GGS_lstring & argument_0) ;
  #else
    public : inline static cPtr_typeGalgasUndefinedClassType * constructor_new (const GGS_lstring & argument_0) {
      return new cPtr_typeGalgasUndefinedClassType(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasClassType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgasClassType

#define macroInheritFrom_typeGalgasClassType

class cPtr_typeGalgasClassType : public cPtr_typeGalgasUndefinedClassType {
  private : typedef cPtr_typeGalgasUndefinedClassType inherited ;
  macroInheritFrom_AC_galgasType
  macroInheritFrom_typeGalgasUndefinedClassType
  macro_typeGalgasClassType
  public : cPtr_typeGalgasClassType (const GGS_lstring & ,
                                const GGS_typeTableMethodes & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_typeSuperClassesMap & ,
                                const GGS_typeClassInheritedMessagesMap & ,
                                const GGS_typeSemanticAttributesMap & ,
                                const GGS_bool& ) ;
  public : GGS_typeTableMethodes  mMethodsMap ;
  public : GGS_typeListeAttributsSemantiques  mNonExternAttributesList ;
  public : GGS_typeSuperClassesMap  mAncestorClassesMap ;
  public : GGS_typeClassInheritedMessagesMap  mMessagesMap ;
  public : GGS_typeSemanticAttributesMap  mNonExternAttributesMap ;
  public : GGS_bool mClassIsAbstract ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_typeCanBeUsedInObjectDeclaration (C_Lexique &) ;
  public : virtual void methode_handleReaderInstructionCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_L_signature & ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgasClassType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgasClassType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6) ;
  #else
    public : inline static cPtr_typeGalgasClassType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6) {
      return new cPtr_typeGalgasClassType(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeEntiteType

#define macroInheritFrom_typeEntiteType

class cPtr_typeEntiteType : public cPtr_AC_semanticsEntity {
  private : typedef cPtr_AC_semanticsEntity inherited ;
  macroInheritFrom_AC_semanticsEntity
  macro_typeEntiteType
  public : cPtr_typeEntiteType (const GGS_AC_galgasType & ) ;
  public : GGS_AC_galgasType  aDefType ;
  public : virtual bool isBuilt (void) const ;

  public : virtual const char * message_messageTypeEntite (void) const ;
  public : static const char * static_string_message_messageTypeEntite (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeEntiteType * constructor_new (const GGS_AC_galgasType & argument_0) ;
  #else
    public : inline static cPtr_typeEntiteType * constructor_new (const GGS_AC_galgasType & argument_0) {
      return new cPtr_typeEntiteType(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeEntiteRoutine'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeEntiteRoutine

#define macroInheritFrom_typeEntiteRoutine

class cPtr_typeEntiteRoutine : public cPtr_AC_semanticsEntity {
  private : typedef cPtr_AC_semanticsEntity inherited ;
  macroInheritFrom_AC_semanticsEntity
  macro_typeEntiteRoutine
  public : cPtr_typeEntiteRoutine (const GGS_L_signature & ) ;
  public : GGS_L_signature  aListeArgumentsFormels ;
  public : virtual bool isBuilt (void) const ;

  public : virtual const char * message_messageTypeEntite (void) const ;
  public : static const char * static_string_message_messageTypeEntite (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteRoutine {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeEntiteRoutine * constructor_new (const GGS_L_signature & argument_0) ;
  #else
    public : inline static cPtr_typeEntiteRoutine * constructor_new (const GGS_L_signature & argument_0) {
      return new cPtr_typeEntiteRoutine(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_enum'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeGalgas_enum

#define macroInheritFrom_typeGalgas_enum

class cPtr_typeGalgas_enum : public cPtr_AC_galgasType {
  private : typedef cPtr_AC_galgasType inherited ;
  macroInheritFrom_AC_galgasType
  macro_typeGalgas_enum
  public : cPtr_typeGalgas_enum (const GGS_lstring & ,
                                const GGS_typeEnumConstantesMap & ,
                                const GGS_typeEnumMessageMap & ) ;
  public : GGS_lstring  mEnumTypeName ;
  public : GGS_typeEnumConstantesMap  mEnumConstantesMap ;
  public : GGS_typeEnumMessageMap  mMessagesMap ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_getTypeName (C_Lexique &,
                                GGS_string& ) ;
  public : virtual void methode_handleConstructorCall (C_Lexique &,
                                GGS_lstring  ,
                                GGS_typeListeAttributsSemantiques & ) ;
  public : virtual const char * message_messageGalgasType (void) const ;
  public : static const char * static_string_message_messageGalgasType (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeGalgas_enum {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeGalgas_enum * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) ;
  #else
    public : inline static cPtr_typeGalgas_enum * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) {
      return new cPtr_typeGalgas_enum(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*

#endif
