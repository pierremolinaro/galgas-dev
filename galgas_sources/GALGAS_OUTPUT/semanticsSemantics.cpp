//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsSemantics.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 18th, 2010, at 18h39'35"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'variableStateAutomaton' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_variableStateAutomaton ("variableStateAutomaton", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_variableStateAutomaton::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_isEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_isNotEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_infOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_supOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_strictInf (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_strictSup (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_writeAccess (C_CompilerEx & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_writeAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local constant cannot be written, it is is already defined") COMMA_SOURCE_FILE_AT_LINE (52)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local constant cannot be written, it is is already defined") COMMA_SOURCE_FILE_AT_LINE (54)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterDefined ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be written, it is a constant") COMMA_SOURCE_FILE_AT_LINE (59)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be written, it is a constant") COMMA_SOURCE_FILE_AT_LINE (60)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readAccess (C_CompilerEx & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (66)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (69)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local constant cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (70)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (77)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readWriteAccess (C_CompilerEx & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readWriteAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (85)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (88)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (89)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (90)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (92)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (93)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (96)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (97)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (98)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_dropAccess (C_CompilerEx & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_dropAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (104)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableDropped ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable is already dropped") COMMA_SOURCE_FILE_AT_LINE (107)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (108)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (109)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (111)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (112)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterDropped ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDropped ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter is already dropped") COMMA_SOURCE_FILE_AT_LINE (115)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a constant input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (116)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a constant input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (117)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

static const GGS_variableStateAutomaton::enumeration kResultForvariableStateAutomaton_endOfRepeatedBranch [121] = {
  GGS_variableStateAutomaton::enum_localVariableDeclared, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::enum_localVariableUsed, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt /* enum_localVariableUsed, enum_localVariableUsed */
} ;

//---------------------------------------------------------------------------*

static const PMSInt32 kErrorForvariableStateAutomaton_endOfRepeatedBranch [121] = {
  1, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDropped */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_localConstantDeclared */
  -1, /* enum_constantInputFormalParameterDefined, enum_localConstantDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_localContantUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableDeclared */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableDropped */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  2, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDropped */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_localConstantDeclared */
  -1, /* enum_constantInputFormalParameterUsed, enum_localConstantDefined */
  -1, /* enum_constantInputFormalParameterUsed, enum_localContantUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableDeclared */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableDropped */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDefined, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterDefined, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterDefined, enum_localContantUsed */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDropped, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterDropped, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterDropped, enum_localContantUsed */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterUsed, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterUsed, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterUsed, enum_localContantUsed */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableUsed */
  -1, /* enum_localConstantDeclared, enum_constantInputFormalParameterDefined */
  -1, /* enum_localConstantDeclared, enum_constantInputFormalParameterUsed */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterDefined */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterDropped */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterUsed */
  -1, /* enum_localConstantDeclared, enum_localConstantDeclared */
  -1, /* enum_localConstantDeclared, enum_localConstantDefined */
  -1, /* enum_localConstantDeclared, enum_localContantUsed */
  -1, /* enum_localConstantDeclared, enum_localVariableDeclared */
  -1, /* enum_localConstantDeclared, enum_localVariableDropped */
  -1, /* enum_localConstantDeclared, enum_localVariableUsed */
  -1, /* enum_localConstantDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_localConstantDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterDefined */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterDropped */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterUsed */
  -1, /* enum_localConstantDefined, enum_localConstantDeclared */
  -1, /* enum_localConstantDefined, enum_localConstantDefined */
  -1, /* enum_localConstantDefined, enum_localContantUsed */
  -1, /* enum_localConstantDefined, enum_localVariableDeclared */
  -1, /* enum_localConstantDefined, enum_localVariableDropped */
  -1, /* enum_localConstantDefined, enum_localVariableUsed */
  -1, /* enum_localContantUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_localContantUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_localContantUsed, enum_inputFormalParameterDefined */
  -1, /* enum_localContantUsed, enum_inputFormalParameterDropped */
  -1, /* enum_localContantUsed, enum_inputFormalParameterUsed */
  -1, /* enum_localContantUsed, enum_localConstantDeclared */
  -1, /* enum_localContantUsed, enum_localConstantDefined */
  -1, /* enum_localContantUsed, enum_localContantUsed */
  -1, /* enum_localContantUsed, enum_localVariableDeclared */
  -1, /* enum_localContantUsed, enum_localVariableDropped */
  -1, /* enum_localContantUsed, enum_localVariableUsed */
  -1, /* enum_localVariableDeclared, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableDeclared, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableDeclared, enum_localConstantDeclared */
  -1, /* enum_localVariableDeclared, enum_localConstantDefined */
  -1, /* enum_localVariableDeclared, enum_localContantUsed */
  -1, /* enum_localVariableDeclared, enum_localVariableDeclared */
  -1, /* enum_localVariableDeclared, enum_localVariableDropped */
  -1, /* enum_localVariableDeclared, enum_localVariableUsed */
  -1, /* enum_localVariableDropped, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableDropped, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableDropped, enum_localConstantDeclared */
  -1, /* enum_localVariableDropped, enum_localConstantDefined */
  -1, /* enum_localVariableDropped, enum_localContantUsed */
  -1, /* enum_localVariableDropped, enum_localVariableDeclared */
  -1, /* enum_localVariableDropped, enum_localVariableDropped */
  -1, /* enum_localVariableDropped, enum_localVariableUsed */
  -1, /* enum_localVariableUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableUsed, enum_localConstantDeclared */
  -1, /* enum_localVariableUsed, enum_localConstantDefined */
  -1, /* enum_localVariableUsed, enum_localContantUsed */
  -1, /* enum_localVariableUsed, enum_localVariableDeclared */
  -1, /* enum_localVariableUsed, enum_localVariableDropped */
  -1 /* enum_localVariableUsed, enum_localVariableUsed */
} ;

//---------------------------------------------------------------------------*

GGS_variableStateAutomaton GGS_variableStateAutomaton::
operator_endOfRepeatedBranch (C_CompilerEx & inLexique,
                                const GGS_variableStateAutomaton & inOperand,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) const {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::operator_endOfRepeatedBranch at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  enumeration result = kNotBuilt ;
  if ((mValue > 0) && (inOperand.mValue > 0)) {
    const PMSInt32 kIndex = (mValue - 1) * 11 + inOperand.mValue - 1 ;
    result = kResultForvariableStateAutomaton_endOfRepeatedBranch [kIndex] ;
    const PMSInt32 error = kErrorForvariableStateAutomaton_endOfRepeatedBranch [kIndex] ;
    if (error != 0) {
      switch (error) {
      case 1:
        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("error 1") COMMA_SOURCE_FILE_AT_LINE (122)) ;
      break ;
      case 2:
        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("warning 1") COMMA_SOURCE_FILE_AT_LINE (122)) ;
      break ;
      default: // error == -1
        { C_String errorMessage ;
          errorMessage << "Unhandled configuration in enum operator" ;
          inLexique.onTheFlySemanticError (errorMessage COMMA_HERE) ;
        }
      break ;
      }
    }
  }
  return GGS_variableStateAutomaton (result) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableStateAutomaton::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @variableStateAutomaton" ;
  switch (mValue) {
  case enum_constantInputFormalParameterDefined:
    s << " constantInputFormalParameterDefined>" ;
    break ;
  case enum_constantInputFormalParameterUsed:
    s << " constantInputFormalParameterUsed>" ;
    break ;
  case enum_inputFormalParameterDefined:
    s << " inputFormalParameterDefined>" ;
    break ;
  case enum_inputFormalParameterDropped:
    s << " inputFormalParameterDropped>" ;
    break ;
  case enum_inputFormalParameterUsed:
    s << " inputFormalParameterUsed>" ;
    break ;
  case enum_localConstantDeclared:
    s << " localConstantDeclared>" ;
    break ;
  case enum_localConstantDefined:
    s << " localConstantDefined>" ;
    break ;
  case enum_localContantUsed:
    s << " localContantUsed>" ;
    break ;
  case enum_localVariableDeclared:
    s << " localVariableDeclared>" ;
    break ;
  case enum_localVariableDropped:
    s << " localVariableDropped>" ;
    break ;
  case enum_localVariableUsed:
    s << " localVariableUsed>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_variableStateAutomaton::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_variableStateAutomaton * p = NULL ;
    macroMyNew (p, GGS_variableStateAutomaton (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_variableStateAutomaton GGS_variableStateAutomaton::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_variableStateAutomaton result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_variableStateAutomaton * p = dynamic_cast <const GGS_variableStateAutomaton *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_variableStateAutomaton, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_variableStateAutomaton::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_variableStateAutomaton ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@variableMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_variableMap ("variableMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_variableMap::
elementOf_GGS_variableMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_variableMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_variableMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_variableMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_variableMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_variableMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_variableMap * info = (e_variableMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_variableMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_variableMap * info = (e_variableMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_variableMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableMap::
operator_isEqual (const GGS_variableMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableMap::
operator_isNotEqual (const GGS_variableMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_variableMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForReadOnlyAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('l'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForDestructiveReadAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForReadWriteAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('/'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForWriteAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForReadOnlyAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForReadOnlyAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForDestructiveReadAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForDestructiveReadAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForReadWriteAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForReadWriteAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForWriteAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForWriteAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertListOfEntitiesLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertSingleEntityLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertEntityAttributeLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUnusedInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertConstInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUsedConstInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUsedConstInArgumentNoShadow [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUnusedConstInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertOutProperty [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertInOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUsedInOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUnusedInOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertListOfEntitiesLocalVariable (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertListOfEntitiesLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertSingleEntityLocalVariable (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertSingleEntityLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertEntityAttributeLocalVariable (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertEntityAttributeLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUnusedInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertConstInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertConstInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedConstInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUsedConstInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedConstInArgumentNoShadow (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUsedConstInArgumentNoShadow,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedConstInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUnusedConstInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertLocalVariable (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertOutProperty (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertOutProperty,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertInOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertInOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedInOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUsedInOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedInOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUnusedInOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_variableMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_variableMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @variableMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_variableMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_variableMap * p = NULL ;
    macroMyNew (p, GGS_variableMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_variableMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_variableMap * p = dynamic_cast <const GGS_variableMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_variableMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_variableMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_variableMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineMap ("routineMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_routineMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineMap * p = NULL ;
    macroMyNew (p, GGS_routineMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineMap * p = dynamic_cast <const GGS_routineMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionMap ("functionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultTypeIndex.operator_isEqual (ptr->mInfo.mResultTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signature & inParameter0,
                const GGS_typeMapIndex & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultTypeIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signature   & outParameter0,
               GGS_typeMapIndex   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signature   & outParameter0,
                                GGS_typeMapIndex   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signature & inParameter0,
                                const GGS_typeMapIndex & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signature  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_functionMap::cEnumerator::_mResultTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultTypeIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_functionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionMap * p = NULL ;
    macroMyNew (p, GGS_functionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionMap * p = dynamic_cast <const GGS_functionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@classIndexList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classIndexList::
elementOf_GGS_classIndexList (const GGS_typeMapIndex & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mClassMapindex (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classIndexList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classIndexList * ptr = dynamic_cast <const elementOf_GGS_classIndexList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassMapindex.operator_isEqual (ptr->mClassMapindex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classIndexList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassMapindex.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@classIndexList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classIndexList ("classIndexList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_classIndexList::
internalAppendValues (const GGS_typeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
internalPrependValues (const GGS_typeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
addAssign_operation (const GGS_typeMapIndex & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::
operator_concat (const GGS_classIndexList & inOperand) const {
  GGS_classIndexList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
dotAssign_operation (const GGS_classIndexList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_classIndexList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mClassMapindex ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeMapIndex & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mClassMapindex
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList  GGS_classIndexList::
constructor_emptyList (void) {
  GGS_classIndexList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classIndexList  GGS_classIndexList::
constructor_listWithValue (const GGS_typeMapIndex & argument_0) {
  GGS_classIndexList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
internalSubListWithRange (GGS_classIndexList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mClassMapindex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classIndexList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classIndexList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classIndexList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@classIndexList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
method_first (C_CompilerEx & inLexique,
              GGS_typeMapIndex & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
method_last (C_CompilerEx & inLexique,
             GGS_typeMapIndex & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeMapIndex & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeMapIndex & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_classIndexList::
reader_mClassMapindexAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassMapindex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_setMClassMapindexAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassMapindex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_classIndexList::cEnumerator::_mClassMapindex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mClassMapindex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classIndexList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classIndexList * p = NULL ;
    macroMyNew (p, GGS_classIndexList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classIndexList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classIndexList * p = dynamic_cast <const GGS_classIndexList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classIndexList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classIndexList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classIndexList ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_descendantClassListMap ("descendantClassListMap", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_classIndexList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_descendantClassListMap::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_descendantClassListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_descendantClassListMap::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
constructor_emptyMap (void) {
  GGS_descendantClassListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_descendantClassListMap::
_typeNameForDescriptionReader (void) const {
  return "@descendantClassListMap" ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
operator_concat (const GGS_descendantClassListMap & inOperand) const {
  GGS_descendantClassListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
dotAssign_operation (const GGS_descendantClassListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_classIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_typeMapIndex & inAttribute0) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_classIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_descendantClassListMap::
reader_listForKey (C_CompilerEx & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classIndexList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_classIndexList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_descendantClassListMap::
reader_allKeys (C_CompilerEx & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_descendantClassListMap::
reader_keyList (C_CompilerEx & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cEnumerator::
cEnumerator (const GGS_descendantClassListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_classIndexList & GGS_descendantClassListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_descendantClassListMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_descendantClassListMap * p = NULL ;
    macroMyNew (p, GGS_descendantClassListMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_descendantClassListMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_descendantClassListMap * p = dynamic_cast <const GGS_descendantClassListMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_descendantClassListMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_descendantClassListMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_descendantClassListMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mDescendantClassListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mDescendantClassListMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mDescendantClassListMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isEqual (inOperand.mTypeMap)
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mDescendantClassListMap.operator_isEqual (inOperand.mDescendantClassListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isNotEqual (inOperand.mTypeMap)
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mDescendantClassListMap.operator_isNotEqual (inOperand.mDescendantClassListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_typeMap & argument_0,
                 const GGS_routineMap & argument_1,
                 const GGS_functionMap & argument_2,
                 const GGS_descendantClassListMap& argument_3) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  result.mRoutineMap = argument_1 ;
  result.mFunctionMap = argument_2 ;
  result.mDescendantClassListMap = argument_3 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDescendantClassListMap " ;
    _s << mDescendantClassListMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*

