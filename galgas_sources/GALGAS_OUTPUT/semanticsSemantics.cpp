//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsSemantics.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 10th, 2008, at 20h42'38"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semanticsSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'variableStateAutomaton' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_variableStateAutomaton::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_isEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_isNotEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_infOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_supOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_strictInf (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_strictSup (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_writeAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_writeAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local constant cannot be written, it is is already defined") COMMA_SOURCE_FILE_AT_LINE (50)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local constant cannot be written, it is is already defined") COMMA_SOURCE_FILE_AT_LINE (51)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterDefined ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be written, it is a constant") COMMA_SOURCE_FILE_AT_LINE (57)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be written, it is a constant") COMMA_SOURCE_FILE_AT_LINE (58)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (64)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (66)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local constant cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (68)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (74)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readWriteAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readWriteAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (83)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (85)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (87)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (88)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (89)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (91)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (93)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (95)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (96)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_dropAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_dropAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (102)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableDropped ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable is already dropped") COMMA_SOURCE_FILE_AT_LINE (104)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (106)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (107)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (108)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (110)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterDropped ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter is already dropped") COMMA_SOURCE_FILE_AT_LINE (112)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a constant input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (114)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a constant input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (115)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

static const GGS_variableStateAutomaton::enumeration kResultForvariableStateAutomaton_endOfRepeatedBranch [121] = {
  GGS_variableStateAutomaton::enum_localVariableDeclared, /* enum_localVariableDeclared, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::enum_localVariableUsed, /* enum_localVariableUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterUsed */
} ;

//---------------------------------------------------------------------------*

static const sint32 kErrorForvariableStateAutomaton_endOfRepeatedBranch [121] = {
  1, /* enum_localVariableDeclared, enum_localVariableDeclared */
  -1, /* enum_localVariableDeclared, enum_localVariableUsed */
  -1, /* enum_localVariableDeclared, enum_localVariableDropped */
  -1, /* enum_localVariableDeclared, enum_localConstantDeclared */
  -1, /* enum_localVariableDeclared, enum_localConstantDefined */
  -1, /* enum_localVariableDeclared, enum_localContantUsed */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableDeclared, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableDeclared, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableUsed, enum_localVariableDeclared */
  2, /* enum_localVariableUsed, enum_localVariableUsed */
  -1, /* enum_localVariableUsed, enum_localVariableDropped */
  -1, /* enum_localVariableUsed, enum_localConstantDeclared */
  -1, /* enum_localVariableUsed, enum_localConstantDefined */
  -1, /* enum_localVariableUsed, enum_localContantUsed */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableDropped, enum_localVariableDeclared */
  -1, /* enum_localVariableDropped, enum_localVariableUsed */
  -1, /* enum_localVariableDropped, enum_localVariableDropped */
  -1, /* enum_localVariableDropped, enum_localConstantDeclared */
  -1, /* enum_localVariableDropped, enum_localConstantDefined */
  -1, /* enum_localVariableDropped, enum_localContantUsed */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableDropped, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableDropped, enum_constantInputFormalParameterUsed */
  -1, /* enum_localConstantDeclared, enum_localVariableDeclared */
  -1, /* enum_localConstantDeclared, enum_localVariableUsed */
  -1, /* enum_localConstantDeclared, enum_localVariableDropped */
  -1, /* enum_localConstantDeclared, enum_localConstantDeclared */
  -1, /* enum_localConstantDeclared, enum_localConstantDefined */
  -1, /* enum_localConstantDeclared, enum_localContantUsed */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterDefined */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterUsed */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterDropped */
  -1, /* enum_localConstantDeclared, enum_constantInputFormalParameterDefined */
  -1, /* enum_localConstantDeclared, enum_constantInputFormalParameterUsed */
  -1, /* enum_localConstantDefined, enum_localVariableDeclared */
  -1, /* enum_localConstantDefined, enum_localVariableUsed */
  -1, /* enum_localConstantDefined, enum_localVariableDropped */
  -1, /* enum_localConstantDefined, enum_localConstantDeclared */
  -1, /* enum_localConstantDefined, enum_localConstantDefined */
  -1, /* enum_localConstantDefined, enum_localContantUsed */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterDefined */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterUsed */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterDropped */
  -1, /* enum_localConstantDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_localConstantDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_localContantUsed, enum_localVariableDeclared */
  -1, /* enum_localContantUsed, enum_localVariableUsed */
  -1, /* enum_localContantUsed, enum_localVariableDropped */
  -1, /* enum_localContantUsed, enum_localConstantDeclared */
  -1, /* enum_localContantUsed, enum_localConstantDefined */
  -1, /* enum_localContantUsed, enum_localContantUsed */
  -1, /* enum_localContantUsed, enum_inputFormalParameterDefined */
  -1, /* enum_localContantUsed, enum_inputFormalParameterUsed */
  -1, /* enum_localContantUsed, enum_inputFormalParameterDropped */
  -1, /* enum_localContantUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_localContantUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterDefined, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterDefined, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterDefined, enum_localContantUsed */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterUsed, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterUsed, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterUsed, enum_localContantUsed */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterDropped, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterDropped, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterDropped, enum_localContantUsed */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableDeclared */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableDropped */
  -1, /* enum_constantInputFormalParameterDefined, enum_localConstantDeclared */
  -1, /* enum_constantInputFormalParameterDefined, enum_localConstantDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_localContantUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDropped */
  -1, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableDeclared */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableDropped */
  -1, /* enum_constantInputFormalParameterUsed, enum_localConstantDeclared */
  -1, /* enum_constantInputFormalParameterUsed, enum_localConstantDefined */
  -1, /* enum_constantInputFormalParameterUsed, enum_localContantUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDropped */
  -1, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  -1 /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterUsed */
} ;

//---------------------------------------------------------------------------*

GGS_variableStateAutomaton GGS_variableStateAutomaton::
operator_endOfRepeatedBranch (C_Compiler & _inLexique,
                                const GGS_variableStateAutomaton & inOperand,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) const {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::operator_endOfRepeatedBranch at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  enumeration result = kNotBuilt ;
  if ((mValue > 0) && (inOperand.mValue > 0)) {
    const sint32 kIndex = (mValue - 1) * 11 + inOperand.mValue - 1 ;
    result = kResultForvariableStateAutomaton_endOfRepeatedBranch [kIndex] ;
    const sint32 error = kErrorForvariableStateAutomaton_endOfRepeatedBranch [kIndex] ;
    if (error != 0) {
      switch (error) {
      case 1:
        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "error 1") COMMA_SOURCE_FILE_AT_LINE (120)) ;
      break ;
      case 2:
        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "warning 1") COMMA_SOURCE_FILE_AT_LINE (121)) ;
      break ;
      default: // error == -1
        { C_String errorMessage ;
          errorMessage << "Unhandled configuration in enum operator" ;
          _inLexique.onTheFlySemanticError (errorMessage COMMA_HERE) ;
        }
      break ;
      }
    }
  }
  return GGS_variableStateAutomaton (result) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableStateAutomaton::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @variableStateAutomaton" ;
  switch (mValue) {
  case enum_localVariableDeclared:
    s << " localVariableDeclared>" ;
    break ;
  case enum_localVariableUsed:
    s << " localVariableUsed>" ;
    break ;
  case enum_localVariableDropped:
    s << " localVariableDropped>" ;
    break ;
  case enum_localConstantDeclared:
    s << " localConstantDeclared>" ;
    break ;
  case enum_localConstantDefined:
    s << " localConstantDefined>" ;
    break ;
  case enum_localContantUsed:
    s << " localContantUsed>" ;
    break ;
  case enum_inputFormalParameterDefined:
    s << " inputFormalParameterDefined>" ;
    break ;
  case enum_inputFormalParameterUsed:
    s << " inputFormalParameterUsed>" ;
    break ;
  case enum_inputFormalParameterDropped:
    s << " inputFormalParameterDropped>" ;
    break ;
  case enum_constantInputFormalParameterDefined:
    s << " constantInputFormalParameterDefined>" ;
    break ;
  case enum_constantInputFormalParameterUsed:
    s << " constantInputFormalParameterUsed>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@variableMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_variableMap::
elementOf_GGS_variableMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_variableMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_variableMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_variableMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_variableMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_variableMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_variableMap * info = (e_variableMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_variableMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_variableMap * info = (e_variableMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_variableMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableMap::
_operator_isEqual (const GGS_variableMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableMap::
_operator_isNotEqual (const GGS_variableMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_variableMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForReadOnlyAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the variable '%K' cannot be accessed in read only mode",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForDestructiveReadAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the variable '%K' cannot be accessed in destructive read mode",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForReadWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the variable '%K' cannot be accessed in read/write mode",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the variable '%K' cannot be accessed in write mode",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertListOfEntitiesLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertSingleEntityLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertEntityAttributeLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertConstInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedConstInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedConstInArgumentNoShadow (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedConstInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertOutProperty (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertInOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedInOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedInOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the variable '%K' is already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_variableMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_variableMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @variableMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_ACGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ACGalgasType::
cPtr_ACGalgasType (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ACGalgasType * GGS_ACGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ACGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ACGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_checkNoCircularity (C_Compiler & /* _inLexique */,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_enterInSortedList (C_Compiler & /* _inLexique */,
                                GGS_sortedTypeList & /* var_cas_ioSortedTypeList */,
                                GGS_typeMap  /* var_cas_inTypeMap */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generatePredeclarationInHeader (C_Compiler & /* _inLexique */,
                                GGS_string& /* var_cas_ioGeneratedUserZone3 */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generateDeclaration_1_inHeader (C_Compiler & /* _inLexique */,
                                GGS_string& /* var_cas_ioGeneratedUserZone3 */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generateDeclaration_2_inHeader (C_Compiler & /* _inLexique */,
                                GGS_string& /* var_cas_ioGeneratedUserZone3 */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generateImplementation (C_Compiler & /* _inLexique */,
                                GGS_string& /* var_cas_ioGeneratedCode */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ACGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ACGalgasType (& typeid (cPtr_ACGalgasType), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ACGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ACGalgasType GGS_ACGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ACGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ACGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ACGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ACGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ACGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ACGalgasType::actualTypeName (void) const {
  return "ACGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_typeMap'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeMap::e_typeMap (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@typeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeMap::
elementOf_GGS_typeMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeMap * _p = dynamic_cast <const elementOf_GGS_typeMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType._operator_isEqual (_p->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
_operator_isEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
_operator_isNotEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ACGalgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeMap info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ACGalgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ACGalgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' type is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ACGalgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' type has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        map index '@typeMapIndex'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapIndex GGS_typeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
_operator_isEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
_operator_isNotEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapIndex::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @typeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_typeMap & ioMap,
                               GGS_typeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
method_searchKey (C_Compiler & inLexique,
                   GGS_lstring & outKey,
                   GGS_ACGalgasType & outAttribute1
                   COMMA_LOCATION_ARGS) const {
  bool shouldDropArguments = true ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      AC_galgas_map::emitMapSemanticErrorMessage (inLexique, mKey, "the '@%K' type is not declared" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_typeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_typeMap * p = (const elementOf_GGS_typeMap *) mIndex.retrieve () ;
      outKey = mKey ;
      outAttribute1 = p->mInfo.mType ;
      shouldDropArguments = false ;
    }
    break ;
  case kNull:
    inLexique.onTheFlyRunTimeError ("key access on a null index" COMMA_THERE) ;
    break ;
  }
  if (shouldDropArguments) {
    outKey._drop_operation () ;
    outAttribute1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@sortedTypeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedTypeList::
elementOf_GGS_sortedTypeList (const GGS_ACGalgasType & argument_0,
                                const GGS_string& argument_1):
mType (argument_0),
mSortString (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedTypeList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedTypeList * _p = dynamic_cast <const elementOf_GGS_sortedTypeList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mSortString._operator_isEqual (_p->mSortString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

sint32 elementOf_GGS_sortedTypeList::
compareForSorting (const cSortedListElement * inOperand) const {
  elementOf_GGS_sortedTypeList * operand = (elementOf_GGS_sortedTypeList *) inOperand ;
  sint32 result = mSortString.compare (operand->mSortString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedTypeList::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@sortedTypeList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedTypeList::GGS_sortedTypeList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList::
GGS_sortedTypeList (const GGS_sortedTypeList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedTypeList::
_operator_isEqual (const GGS_sortedTypeList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedTypeList::
_operator_isNotEqual (const GGS_sortedTypeList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
_internalAppendValues (const GGS_ACGalgasType & argument_0,
                    const GGS_string& argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
_addAssign_operation (const GGS_ACGalgasType & argument_0,
                                const GGS_string& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList GGS_sortedTypeList::
_operator_concat (const GGS_sortedTypeList & inOperand) const {
  GGS_sortedTypeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_sortedTypeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ACGalgasType  p_0 = p->mType ;
          GGS_string p_1 = p->mSortString ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mSortString) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList  GGS_sortedTypeList::
constructor_emptySortedList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortedTypeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList  GGS_sortedTypeList::
constructor_sortedListWithValue (C_Compiler & /* _inLexique */,
                           const GGS_ACGalgasType & argument_0,
                           const GGS_string& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortedTypeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedTypeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@sortedTypeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
method_smallest (C_Compiler & _inLexique,
                 GGS_ACGalgasType & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mSortString ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
method_greatest (C_Compiler & _inLexique,
             GGS_ACGalgasType & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mSortString ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
modifier_popSmallest (C_Compiler & _inLexique,
                 GGS_ACGalgasType & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mSortString ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
modifier_popGreatest (C_Compiler & _inLexique,
                GGS_ACGalgasType & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mSortString ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@typeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeList::
elementOf_GGS_typeList (const GGS_ACGalgasType & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeList * _p = dynamic_cast <const elementOf_GGS_typeList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             List '@typeList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeList::
_internalAppendValues (const GGS_ACGalgasType & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
_internalPrependValues (const GGS_ACGalgasType & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
_addAssign_operation (const GGS_ACGalgasType & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
_operator_concat (const GGS_typeList & inOperand) const {
  GGS_typeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ACGalgasType  p_0 = p->mType ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_ACGalgasType & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeList  GGS_typeList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList  GGS_typeList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_ACGalgasType & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
internalSubListWithRange (GGS_typeList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
method_first (C_Compiler & _inLexique,
              GGS_ACGalgasType & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
method_last (C_Compiler & _inLexique,
             GGS_ACGalgasType & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_ACGalgasType & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_ACGalgasType & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@signature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_signature::
elementOf_GGS_signature (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mFormalArgumentName (argument_1),
mFormalArgumentPassingMode (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_signature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_signature * _p = dynamic_cast <const elementOf_GGS_signature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeIndex._operator_isEqual (_p->mAttributeTypeIndex).boolValue ()
         && mFormalArgumentName._operator_isEqual (_p->mFormalArgumentName).boolValue ()
         && mFormalArgumentPassingMode._operator_isEqual (_p->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_signature::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@signature'                              *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_signature::
_internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalArgumentPassingMode& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
_internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalArgumentPassingMode& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
_addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
_operator_concat (const GGS_signature & inOperand) const {
  GGS_signature result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_signature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mFormalArgumentName ;
          GGS_formalArgumentPassingMode p_2 = p->mFormalArgumentPassingMode ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalArgumentPassingMode& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeIndex,
                                _p->mFormalArgumentName,
                                _p->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_signature::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_signature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_signature::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeMapIndex & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_formalArgumentPassingMode& argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_signature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
internalSubListWithRange (GGS_signature & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributeTypeIndex, _p->mFormalArgumentName, _p->mFormalArgumentPassingMode) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_signature result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_signature result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_signature::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@signature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
method_first (C_Compiler & _inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1,
              GGS_formalArgumentPassingMode& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mFormalArgumentName ;
    _out_2 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
method_last (C_Compiler & _inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1,
             GGS_formalArgumentPassingMode& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mFormalArgumentName ;
    _out_2 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalArgumentPassingMode& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mFormalArgumentName ;
    _out_2 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1,
                GGS_formalArgumentPassingMode& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mFormalArgumentName ;
    _out_2 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_routineMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRoutineSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * _p = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRoutineSignature._operator_isEqual (_p->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
_operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
_operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' routine is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' routine has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@attributeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeList::
elementOf_GGS_attributeList (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeList * _p = dynamic_cast <const elementOf_GGS_attributeList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeIndex._operator_isEqual (_p->mAttributeTypeIndex).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@attributeList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_attributeList::
_internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
_operator_concat (const GGS_attributeList & inOperand) const {
  GGS_attributeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_attributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeIndex,
                                _p->mAttributeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeMapIndex & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
internalSubListWithRange (GGS_attributeList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributeTypeIndex, _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@attributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_first (C_Compiler & _inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_last (C_Compiler & _inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_locationGalgasType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_locationGalgasType::
cPtr_locationGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_locationGalgasType * GGS_locationGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_locationGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_locationGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_locationGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_locationGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@locationGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_locationGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_locationGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_locationGalgasType (& typeid (cPtr_locationGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_locationGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_locationGalgasType::
GGS_locationGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType::
GGS_locationGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_locationGalgasType GGS_locationGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_locationGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_locationGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_locationGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_locationGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_locationGalgasType * gSingleton_locationGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_locationGalgasType (void) {
  macroDetachPointer (gSingleton_locationGalgasType, cPtr_locationGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType GGS_locationGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType result ;
  if (NULL == gSingleton_locationGalgasType) {
    macroMyNew (gSingleton_locationGalgasType, cPtr_locationGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_locationGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_locationGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_locationGalgasType::actualTypeName (void) const {
  return "locationGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_stringGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringGalgasType::
cPtr_stringGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringGalgasType * GGS_stringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@stringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringGalgasType (& typeid (cPtr_stringGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_stringGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_stringGalgasType GGS_stringGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_stringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_stringGalgasType * gSingleton_stringGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_stringGalgasType (void) {
  macroDetachPointer (gSingleton_stringGalgasType, cPtr_stringGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType GGS_stringGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  if (NULL == gSingleton_stringGalgasType) {
    macroMyNew (gSingleton_stringGalgasType, cPtr_stringGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_stringGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_stringGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringGalgasType::actualTypeName (void) const {
  return "stringGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_charGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charGalgasType::
cPtr_charGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charGalgasType * GGS_charGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_charGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_charGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_charGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@charGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charGalgasType (& typeid (cPtr_charGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_charGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_charGalgasType GGS_charGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_charGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_charGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_charGalgasType * gSingleton_charGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_charGalgasType (void) {
  macroDetachPointer (gSingleton_charGalgasType, cPtr_charGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType GGS_charGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  if (NULL == gSingleton_charGalgasType) {
    macroMyNew (gSingleton_charGalgasType, cPtr_charGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_charGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_charGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charGalgasType::actualTypeName (void) const {
  return "charGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_boolGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolGalgasType::
cPtr_boolGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolGalgasType * GGS_boolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_boolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_boolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_boolGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@boolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolGalgasType (& typeid (cPtr_boolGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_boolGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_boolGalgasType GGS_boolGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_boolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_boolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_boolGalgasType * gSingleton_boolGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_boolGalgasType (void) {
  macroDetachPointer (gSingleton_boolGalgasType, cPtr_boolGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType GGS_boolGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  if (NULL == gSingleton_boolGalgasType) {
    macroMyNew (gSingleton_boolGalgasType, cPtr_boolGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_boolGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_boolGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolGalgasType::actualTypeName (void) const {
  return "boolGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_uintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintGalgasType::
cPtr_uintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintGalgasType * GGS_uintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@uintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintGalgasType (& typeid (cPtr_uintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_uintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_uintGalgasType GGS_uintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_uintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_uintGalgasType * gSingleton_uintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_uintGalgasType (void) {
  macroDetachPointer (gSingleton_uintGalgasType, cPtr_uintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType GGS_uintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  if (NULL == gSingleton_uintGalgasType) {
    macroMyNew (gSingleton_uintGalgasType, cPtr_uintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_uintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_uintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintGalgasType::actualTypeName (void) const {
  return "uintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_sintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintGalgasType::
cPtr_sintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintGalgasType * GGS_sintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@sintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintGalgasType (& typeid (cPtr_sintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_sintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sintGalgasType GGS_sintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_sintGalgasType * gSingleton_sintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_sintGalgasType (void) {
  macroDetachPointer (gSingleton_sintGalgasType, cPtr_sintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType GGS_sintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  if (NULL == gSingleton_sintGalgasType) {
    macroMyNew (gSingleton_sintGalgasType, cPtr_sintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_sintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_sintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintGalgasType::actualTypeName (void) const {
  return "sintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_uint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64GalgasType::
cPtr_uint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64GalgasType * GGS_uint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@uint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64GalgasType (& typeid (cPtr_uint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_uint64GalgasType GGS_uint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_uint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_uint64GalgasType * gSingleton_uint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_uint64GalgasType (void) {
  macroDetachPointer (gSingleton_uint64GalgasType, cPtr_uint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType GGS_uint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  if (NULL == gSingleton_uint64GalgasType) {
    macroMyNew (gSingleton_uint64GalgasType, cPtr_uint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_uint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_uint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64GalgasType::actualTypeName (void) const {
  return "uint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_sint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64GalgasType::
cPtr_sint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64GalgasType * GGS_sint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@sint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64GalgasType (& typeid (cPtr_sint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sint64GalgasType GGS_sint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_sint64GalgasType * gSingleton_sint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_sint64GalgasType (void) {
  macroDetachPointer (gSingleton_sint64GalgasType, cPtr_sint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType GGS_sint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  if (NULL == gSingleton_sint64GalgasType) {
    macroMyNew (gSingleton_sint64GalgasType, cPtr_sint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_sint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_sint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64GalgasType::actualTypeName (void) const {
  return "sint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_doubleGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doubleGalgasType::
cPtr_doubleGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doubleGalgasType * GGS_doubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_doubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_doubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_doubleGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@doubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doubleGalgasType (& typeid (cPtr_doubleGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_doubleGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_doubleGalgasType GGS_doubleGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_doubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_doubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_doubleGalgasType * gSingleton_doubleGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_doubleGalgasType (void) {
  macroDetachPointer (gSingleton_doubleGalgasType, cPtr_doubleGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType GGS_doubleGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  if (NULL == gSingleton_doubleGalgasType) {
    macroMyNew (gSingleton_doubleGalgasType, cPtr_doubleGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_doubleGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_doubleGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doubleGalgasType::actualTypeName (void) const {
  return "doubleGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lstringGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lstringGalgasType::
cPtr_lstringGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lstringGalgasType * GGS_lstringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lstringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lstringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lstringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lstringGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lstringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lstringGalgasType (& typeid (cPtr_lstringGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lstringGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lstringGalgasType GGS_lstringGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lstringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lstringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lstringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lstringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lstringGalgasType * gSingleton_lstringGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lstringGalgasType (void) {
  macroDetachPointer (gSingleton_lstringGalgasType, cPtr_lstringGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType GGS_lstringGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  if (NULL == gSingleton_lstringGalgasType) {
    macroMyNew (gSingleton_lstringGalgasType, cPtr_lstringGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lstringGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lstringGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lstringGalgasType::actualTypeName (void) const {
  return "lstringGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_lcharGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lcharGalgasType::
cPtr_lcharGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lcharGalgasType * GGS_lcharGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lcharGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lcharGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lcharGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lcharGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lcharGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lcharGalgasType (& typeid (cPtr_lcharGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lcharGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lcharGalgasType GGS_lcharGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lcharGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lcharGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lcharGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lcharGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lcharGalgasType * gSingleton_lcharGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lcharGalgasType (void) {
  macroDetachPointer (gSingleton_lcharGalgasType, cPtr_lcharGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType GGS_lcharGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  if (NULL == gSingleton_lcharGalgasType) {
    macroMyNew (gSingleton_lcharGalgasType, cPtr_lcharGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lcharGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lcharGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lcharGalgasType::actualTypeName (void) const {
  return "lcharGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_lboolGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lboolGalgasType::
cPtr_lboolGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lboolGalgasType * GGS_lboolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lboolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lboolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lboolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lboolGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lboolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lboolGalgasType (& typeid (cPtr_lboolGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lboolGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lboolGalgasType GGS_lboolGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lboolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lboolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lboolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lboolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lboolGalgasType * gSingleton_lboolGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lboolGalgasType (void) {
  macroDetachPointer (gSingleton_lboolGalgasType, cPtr_lboolGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType GGS_lboolGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  if (NULL == gSingleton_lboolGalgasType) {
    macroMyNew (gSingleton_lboolGalgasType, cPtr_lboolGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lboolGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lboolGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lboolGalgasType::actualTypeName (void) const {
  return "lboolGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_luintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luintGalgasType::
cPtr_luintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luintGalgasType * GGS_luintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@luintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luintGalgasType (& typeid (cPtr_luintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_luintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_luintGalgasType GGS_luintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_luintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_luintGalgasType * gSingleton_luintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_luintGalgasType (void) {
  macroDetachPointer (gSingleton_luintGalgasType, cPtr_luintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType GGS_luintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  if (NULL == gSingleton_luintGalgasType) {
    macroMyNew (gSingleton_luintGalgasType, cPtr_luintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_luintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_luintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luintGalgasType::actualTypeName (void) const {
  return "luintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_lsintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsintGalgasType::
cPtr_lsintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsintGalgasType * GGS_lsintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lsintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsintGalgasType (& typeid (cPtr_lsintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lsintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lsintGalgasType GGS_lsintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lsintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lsintGalgasType * gSingleton_lsintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lsintGalgasType (void) {
  macroDetachPointer (gSingleton_lsintGalgasType, cPtr_lsintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType GGS_lsintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  if (NULL == gSingleton_lsintGalgasType) {
    macroMyNew (gSingleton_lsintGalgasType, cPtr_lsintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lsintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lsintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsintGalgasType::actualTypeName (void) const {
  return "lsintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_luint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luint64GalgasType::
cPtr_luint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luint64GalgasType * GGS_luint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@luint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luint64GalgasType (& typeid (cPtr_luint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_luint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_luint64GalgasType GGS_luint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_luint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_luint64GalgasType * gSingleton_luint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_luint64GalgasType (void) {
  macroDetachPointer (gSingleton_luint64GalgasType, cPtr_luint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType GGS_luint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  if (NULL == gSingleton_luint64GalgasType) {
    macroMyNew (gSingleton_luint64GalgasType, cPtr_luint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_luint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_luint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luint64GalgasType::actualTypeName (void) const {
  return "luint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lsint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsint64GalgasType::
cPtr_lsint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsint64GalgasType * GGS_lsint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lsint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsint64GalgasType (& typeid (cPtr_lsint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lsint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lsint64GalgasType GGS_lsint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lsint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lsint64GalgasType * gSingleton_lsint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lsint64GalgasType (void) {
  macroDetachPointer (gSingleton_lsint64GalgasType, cPtr_lsint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType GGS_lsint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  if (NULL == gSingleton_lsint64GalgasType) {
    macroMyNew (gSingleton_lsint64GalgasType, cPtr_lsint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lsint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lsint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsint64GalgasType::actualTypeName (void) const {
  return "lsint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_ldoubleGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ldoubleGalgasType::
cPtr_ldoubleGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ldoubleGalgasType * GGS_ldoubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ldoubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ldoubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ldoubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_ldoubleGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ldoubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ldoubleGalgasType (& typeid (cPtr_ldoubleGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ldoubleGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ldoubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ldoubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ldoubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ldoubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_ldoubleGalgasType * gSingleton_ldoubleGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_ldoubleGalgasType (void) {
  macroDetachPointer (gSingleton_ldoubleGalgasType, cPtr_ldoubleGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  if (NULL == gSingleton_ldoubleGalgasType) {
    macroMyNew (gSingleton_ldoubleGalgasType, cPtr_ldoubleGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_ldoubleGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_ldoubleGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ldoubleGalgasType::actualTypeName (void) const {
  return "ldoubleGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_stringsetGalgasType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetGalgasType::
cPtr_stringsetGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetGalgasType * GGS_stringsetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringsetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringsetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@stringsetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetGalgasType (& typeid (cPtr_stringsetGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_stringsetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_stringsetGalgasType GGS_stringsetGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_stringsetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_stringsetGalgasType * gSingleton_stringsetGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_stringsetGalgasType (void) {
  macroDetachPointer (gSingleton_stringsetGalgasType, cPtr_stringsetGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType GGS_stringsetGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  if (NULL == gSingleton_stringsetGalgasType) {
    macroMyNew (gSingleton_stringsetGalgasType, cPtr_stringsetGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_stringsetGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_stringsetGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetGalgasType::actualTypeName (void) const {
  return "stringsetGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_binarysetGalgasType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetGalgasType::
cPtr_binarysetGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetGalgasType * GGS_binarysetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_binarysetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_binarysetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@binarysetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetGalgasType (& typeid (cPtr_binarysetGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_binarysetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_binarysetGalgasType GGS_binarysetGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_binarysetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_binarysetGalgasType * gSingleton_binarysetGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_binarysetGalgasType (void) {
  macroDetachPointer (gSingleton_binarysetGalgasType, cPtr_binarysetGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType GGS_binarysetGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  if (NULL == gSingleton_binarysetGalgasType) {
    macroMyNew (gSingleton_binarysetGalgasType, cPtr_binarysetGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_binarysetGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_binarysetGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetGalgasType::actualTypeName (void) const {
  return "binarysetGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@classMethodList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMethodList::
elementOf_GGS_classMethodList (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mMethodSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classMethodList * _p = dynamic_cast <const elementOf_GGS_classMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mMethodSignature._operator_isEqual (_p->mMethodSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@classMethodList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_classMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_signature & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_signature & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
_operator_concat (const GGS_classMethodList & inOperand) const {
  GGS_classMethodList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_classMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_signature  p_1 = p->mMethodSignature ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_signature & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mMethodSignature
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classMethodList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classMethodList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_signature & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
internalSubListWithRange (GGS_classMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mMethodSignature) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@classMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_signature & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mMethodSignature ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_signature & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mMethodSignature ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_signature & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mMethodSignature ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_signature & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mMethodSignature ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_classGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classGalgasType::
cPtr_classGalgasType (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeMapIndex & argument_2,
                                const GGS_attributeList & argument_3,
                                const GGS_classMethodList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mIsAbstract (argument_0),
mClassName (argument_1),
mSuperClassIndex (argument_2),
mAttributeList (argument_3),
mMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classGalgasType * GGS_classGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classGalgasType * _p = dynamic_cast <const cPtr_classGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mSuperClassIndex._operator_isEqual (_p->mSuperClassIndex).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mMethodList._operator_isEqual (_p->mMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
method_checkNoCircularity (C_Compiler & _inLexique,
                                GGS_uint  var_cas_inTypeCount COMMA_UNUSED_LOCATION_ARGS) {
  GGS_string var_cas_classPath ;
  var_cas_classPath = mClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (519)) ;
  GGS_stringset  var_cas_superClassSet ;
  var_cas_superClassSet = GGS_stringset ::constructor_setWithString (_inLexique, mClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (520)) COMMA_HERE) ;
  GGS_typeMapIndex  var_cas_superClassIndex ;
  var_cas_superClassIndex = mSuperClassIndex ;
  GGS_bool var_cas_circularityError ;
  var_cas_circularityError = GGS_bool (true, false) ;
  GGS_bool var_cas_ok ;
  var_cas_ok = GGS_bool (true, true) ;
  GGS_uint _variant_27642 = var_cas_inTypeCount ;
  GGS_bool _condition_27642 (_variant_27642._isBuilt (), true) ;
  while (_condition_27642.isBuiltAndTrue ()) {
    _condition_27642 = ((var_cas_superClassIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (525)))._operator_and (var_cas_ok))._operator_and ((var_cas_circularityError)._operator_not ()) ;
    if (_condition_27642.isBuiltAndTrue ()) {
      if (_variant_27642.uintValue () == 0) {
        _inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (553)) ;
        _condition_27642 = GGS_bool (true, false) ;
      }else{
        _variant_27642._decrement_operation (_inLexique COMMA_HERE) ;
        if ((var_cas_superClassIndex.reader_isSolved (_inLexique COMMA_SOURCE_FILE_AT_LINE (526))).isBuiltAndTrue ()) {
          GGS_lstring  var_cas_superClassName ;
          GGS_ACGalgasType  var_cas_t ;
          const GGS_typeMapIndex  _temp_26607 = var_cas_superClassIndex ;
          if (_temp_26607._isBuilt ()) {
            _temp_26607 (HERE)->method_searchKey (_inLexique, var_cas_superClassName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (530)) ;
          }
          var_cas_circularityError = var_cas_superClassSet.reader_hasKey (_inLexique, var_cas_superClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (532)) COMMA_SOURCE_FILE_AT_LINE (532)) ;
          var_cas_superClassSet._addAssign_operation (var_cas_superClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (533))) ;
          var_cas_classPath.writeString (".") ;
          var_cas_classPath._dotAssign_operation (var_cas_superClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (534))) ;
          GGS_typeMapIndex  var_cas_superSuperClassIndex ;
          { const GGS_ACGalgasType _var_27317 = var_cas_t ; // CAST instruction
            if (_var_27317.getPtr () != NULL) {
              macroValidPointer (_var_27317.getPtr ()) ;
              if (dynamic_cast <cPtr_classGalgasType *> (_var_27317.getPtr ()) != NULL) {
                const GGS_classGalgasType var_cas_kClassType (_var_27317.getPtr ()) ;
                var_cas_superSuperClassIndex = var_cas_kClassType.reader_mSuperClassIndex (_inLexique COMMA_SOURCE_FILE_AT_LINE (539)) ;
              }else{
                mClassName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this class inherits from @"))._operator_concat (var_cas_superClassName))._operator_concat (GGS_string (true, ", but @")))._operator_concat (var_cas_superClassName))._operator_concat (GGS_string (true, " is not a class")) COMMA_SOURCE_FILE_AT_LINE (544)) ;
                var_cas_superSuperClassIndex._drop_operation () ;
              }
            }
          }
          var_cas_superClassIndex = var_cas_superSuperClassIndex ;
        }else{
          var_cas_ok = GGS_bool (true, false) ;
          GGS_string var_cas_superClassName ;
          var_cas_superClassName = var_cas_superClassIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (549)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (549)) ;
          mClassName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this class inherits from @"))._operator_concat (var_cas_superClassName))._operator_concat (GGS_string (true, ", but @")))._operator_concat (var_cas_superClassName))._operator_concat (GGS_string (true, " does not exist")) COMMA_SOURCE_FILE_AT_LINE (552)) ;
        }
      }
    }
  }
  if ((var_cas_circularityError).isBuiltAndTrue ()) {
    mClassName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "inheritance circularity for class '"))._operator_concat (mClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (559))))._operator_concat (GGS_string (true, "': ")))._operator_concat (var_cas_classPath.reader_stringByReplacingStringByString (_inLexique, GGS_string (true, "."), GGS_string (true, " extends ") COMMA_SOURCE_FILE_AT_LINE (560))) COMMA_SOURCE_FILE_AT_LINE (560)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classGalgasType:"
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classGalgasType (& typeid (cPtr_classGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_classGalgasType GGS_classGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_classGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_classGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType GGS_classGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeMapIndex & argument_2,
                 const GGS_attributeList & argument_3,
                 const GGS_classMethodList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  macroMyNew (result.mPointer, cPtr_classGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classGalgasType::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classGalgasType::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_classGalgasType::
reader_mSuperClassIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mSuperClassIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_classGalgasType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classGalgasType::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classGalgasType::actualTypeName (void) const {
  return "classGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_entityGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_entityGalgasType::
cPtr_entityGalgasType (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeMapIndex & argument_2,
                                const GGS_attributeList & argument_3,
                                const GGS_uint & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mIsAbstract (argument_0),
mEntityName (argument_1),
mSuperEntityIndex (argument_2),
mPropertyList (argument_3),
mEntityIndexInMetamodel (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_entityGalgasType * GGS_entityGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_entityGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_entityGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_entityGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_entityGalgasType * _p = dynamic_cast <const cPtr_entityGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mEntityName._operator_isEqual (_p->mEntityName).boolValue ()
         && mSuperEntityIndex._operator_isEqual (_p->mSuperEntityIndex).boolValue ()
         && mPropertyList._operator_isEqual (_p->mPropertyList).boolValue ()
         && mEntityIndexInMetamodel._operator_isEqual (_p->mEntityIndexInMetamodel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_checkNoCircularity (C_Compiler & _inLexique,
                                GGS_uint  var_cas_inTypeCount COMMA_UNUSED_LOCATION_ARGS) {
  GGS_string var_cas_entityPath ;
  var_cas_entityPath = mEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (582)) ;
  GGS_stringset  var_cas_superEntitySet ;
  var_cas_superEntitySet = GGS_stringset ::constructor_setWithString (_inLexique, mEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (583)) COMMA_HERE) ;
  GGS_typeMapIndex  var_cas_superEntityIndex ;
  var_cas_superEntityIndex = mSuperEntityIndex ;
  GGS_bool var_cas_circularityError ;
  var_cas_circularityError = GGS_bool (true, false) ;
  GGS_bool var_cas_ok ;
  var_cas_ok = GGS_bool (true, true) ;
  GGS_uint _variant_30157 = var_cas_inTypeCount ;
  GGS_bool _condition_30157 (_variant_30157._isBuilt (), true) ;
  while (_condition_30157.isBuiltAndTrue ()) {
    _condition_30157 = ((var_cas_superEntityIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (588)))._operator_and (var_cas_ok))._operator_and ((var_cas_circularityError)._operator_not ()) ;
    if (_condition_30157.isBuiltAndTrue ()) {
      if (_variant_30157.uintValue () == 0) {
        _inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (616)) ;
        _condition_30157 = GGS_bool (true, false) ;
      }else{
        _variant_30157._decrement_operation (_inLexique COMMA_HERE) ;
        if ((var_cas_superEntityIndex.reader_isSolved (_inLexique COMMA_SOURCE_FILE_AT_LINE (589))).isBuiltAndTrue ()) {
          GGS_lstring  var_cas_superEntityName ;
          GGS_ACGalgasType  var_cas_t ;
          const GGS_typeMapIndex  _temp_29098 = var_cas_superEntityIndex ;
          if (_temp_29098._isBuilt ()) {
            _temp_29098 (HERE)->method_searchKey (_inLexique, var_cas_superEntityName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (593)) ;
          }
          var_cas_circularityError = var_cas_superEntitySet.reader_hasKey (_inLexique, var_cas_superEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (595)) COMMA_SOURCE_FILE_AT_LINE (595)) ;
          var_cas_superEntitySet._addAssign_operation (var_cas_superEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (596))) ;
          var_cas_entityPath.writeString (".") ;
          var_cas_entityPath._dotAssign_operation (var_cas_superEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (597))) ;
          GGS_typeMapIndex  var_cas_superSuperEntityIndex ;
          { const GGS_ACGalgasType _var_29824 = var_cas_t ; // CAST instruction
            if (_var_29824.getPtr () != NULL) {
              macroValidPointer (_var_29824.getPtr ()) ;
              if (dynamic_cast <cPtr_entityGalgasType *> (_var_29824.getPtr ()) != NULL) {
                const GGS_entityGalgasType var_cas_kClassType (_var_29824.getPtr ()) ;
                var_cas_superSuperEntityIndex = var_cas_kClassType.reader_mSuperEntityIndex (_inLexique COMMA_SOURCE_FILE_AT_LINE (602)) ;
              }else{
                mEntityName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this entity inherits from @"))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, ", but @")))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, " is not a class")) COMMA_SOURCE_FILE_AT_LINE (607)) ;
                var_cas_superSuperEntityIndex._drop_operation () ;
              }
            }
          }
          var_cas_superEntityIndex = var_cas_superSuperEntityIndex ;
        }else{
          var_cas_ok = GGS_bool (true, false) ;
          GGS_string var_cas_superEntityName ;
          var_cas_superEntityName = var_cas_superEntityIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (612)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (612)) ;
          mEntityName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this entity inherits from @"))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, ", but @")))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, " does not exist")) COMMA_SOURCE_FILE_AT_LINE (615)) ;
        }
      }
    }
  }
  if ((var_cas_circularityError).isBuiltAndTrue ()) {
    mEntityName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "inheritance circularity for entity '"))._operator_concat (mEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (622))))._operator_concat (GGS_string (true, "': ")))._operator_concat (var_cas_entityPath.reader_stringByReplacingStringByString (_inLexique, GGS_string (true, "."), GGS_string (true, " extends ") COMMA_SOURCE_FILE_AT_LINE (623))) COMMA_SOURCE_FILE_AT_LINE (623)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_getInheritedAttributeList (C_Compiler & _inLexique,
                                GGS_attributeList & var_cas_outInheritedPropertyList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outInheritedPropertyList = GGS_attributeList ::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_typeMapIndex  var_cas_entityIndex ;
  var_cas_entityIndex = mSuperEntityIndex ;
  GGS_bool var_cas_ok ;
  var_cas_ok = GGS_bool (true, true) ;
  GGS_uint _variant_31286 = GGS_uint ::constructor_max (_inLexique COMMA_HERE) ;
  GGS_bool _condition_31286 (_variant_31286._isBuilt (), true) ;
  while (_condition_31286.isBuiltAndTrue ()) {
    _condition_31286 = (var_cas_entityIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (636)))._operator_and (var_cas_ok) ;
    if (_condition_31286.isBuiltAndTrue ()) {
      if (_variant_31286.uintValue () == 0) {
        _inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (649)) ;
        _condition_31286 = GGS_bool (true, false) ;
      }else{
        _variant_31286._decrement_operation (_inLexique COMMA_HERE) ;
        GGS_lstring  var_cas_superEntityName ;
        GGS_ACGalgasType  var_cas_superType ;
        const GGS_typeMapIndex  _temp_30833 = var_cas_entityIndex ;
        if (_temp_30833._isBuilt ()) {
          _temp_30833 (HERE)->method_searchKey (_inLexique, var_cas_superEntityName, var_cas_superType COMMA_SOURCE_FILE_AT_LINE (639)) ;
        }
        { const GGS_ACGalgasType _var_31269 = var_cas_superType ; // CAST instruction
          if (_var_31269.getPtr () != NULL) {
            macroValidPointer (_var_31269.getPtr ()) ;
            if (dynamic_cast <cPtr_entityGalgasType *> (_var_31269.getPtr ()) != NULL) {
              const GGS_entityGalgasType var_cas_kClassType (_var_31269.getPtr ()) ;
              var_cas_outInheritedPropertyList = (var_cas_kClassType.reader_mPropertyList (_inLexique COMMA_SOURCE_FILE_AT_LINE (642)))._operator_concat (var_cas_outInheritedPropertyList) ;
              var_cas_entityIndex = var_cas_kClassType.reader_mSuperEntityIndex (_inLexique COMMA_SOURCE_FILE_AT_LINE (643)) ;
            }else{
              mEntityName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this entity inherits from @"))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, ", but @")))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, " is not a class")) COMMA_SOURCE_FILE_AT_LINE (647)) ;
              var_cas_ok = GGS_bool (true, false) ;
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_getAllAttributeList (C_Compiler & _inLexique,
                                GGS_attributeList & var_cas_outAllPropertyList COMMA_UNUSED_LOCATION_ARGS) {
  const GGS_entityGalgasType  _temp_31425 = (*this) ;
  if (_temp_31425._isBuilt ()) {
    _temp_31425 (HERE)->method_getInheritedAttributeList (_inLexique, var_cas_outAllPropertyList COMMA_SOURCE_FILE_AT_LINE (658)) ;
  }
  var_cas_outAllPropertyList = (var_cas_outAllPropertyList)._operator_concat (mPropertyList) ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_enterInSortedList (C_Compiler & _inLexique,
                                GGS_sortedTypeList & var_cas_ioSortedTypeList,
                                GGS_typeMap  var_cas_inTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  GGS_string var_cas_sortDescriptor ;
  var_cas_sortDescriptor = mEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (669)) ;
  GGS_typeMapIndex  var_cas_entityIndex ;
  var_cas_entityIndex = mSuperEntityIndex ;
  GGS_bool var_cas_ok ;
  var_cas_ok = GGS_bool (true, true) ;
  GGS_uint _variant_32405 = var_cas_inTypeMap.reader_count (_inLexique COMMA_SOURCE_FILE_AT_LINE (672)) ;
  GGS_bool _condition_32405 (_variant_32405._isBuilt (), true) ;
  while (_condition_32405.isBuiltAndTrue ()) {
    _condition_32405 = (var_cas_entityIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (673)))._operator_and (var_cas_ok) ;
    if (_condition_32405.isBuiltAndTrue ()) {
      if (_variant_32405.uintValue () == 0) {
        _inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (686)) ;
        _condition_32405 = GGS_bool (true, false) ;
      }else{
        _variant_32405._decrement_operation (_inLexique COMMA_HERE) ;
        GGS_lstring  var_cas_superEntityName ;
        GGS_ACGalgasType  var_cas_superType ;
        const GGS_typeMapIndex  _temp_31970 = var_cas_entityIndex ;
        if (_temp_31970._isBuilt ()) {
          _temp_31970 (HERE)->method_searchKey (_inLexique, var_cas_superEntityName, var_cas_superType COMMA_SOURCE_FILE_AT_LINE (676)) ;
        }
        var_cas_sortDescriptor = ((var_cas_superEntityName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (677)))._operator_concat (GGS_string (true, ".")))._operator_concat (var_cas_sortDescriptor) ;
        { const GGS_ACGalgasType _var_32388 = var_cas_superType ; // CAST instruction
          if (_var_32388.getPtr () != NULL) {
            macroValidPointer (_var_32388.getPtr ()) ;
            if (dynamic_cast <cPtr_entityGalgasType *> (_var_32388.getPtr ()) != NULL) {
              const GGS_entityGalgasType var_cas_kClassType (_var_32388.getPtr ()) ;
              var_cas_entityIndex = var_cas_kClassType.reader_mSuperEntityIndex (_inLexique COMMA_SOURCE_FILE_AT_LINE (680)) ;
            }else{
              mEntityName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this entity inherits from @"))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, ", but @")))._operator_concat (var_cas_superEntityName))._operator_concat (GGS_string (true, " is not a class")) COMMA_SOURCE_FILE_AT_LINE (684)) ;
              var_cas_ok = GGS_bool (true, false) ;
            }
          }
        }
      }
    }
  }
  var_cas_ioSortedTypeList._addAssign_operation ((*this), var_cas_sortDescriptor) ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_generatePredeclarationInHeader (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_ioGeneratedUserZone3 COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_ioGeneratedUserZone3.writeString ("class GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" ;\n"
  "class GGS_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" ;\n"
  "class cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" ;\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_generateDeclaration_1_inHeader (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioGeneratedUserZone3 COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList  var_cas_allAttributeList ;
  const GGS_entityGalgasType  _temp_32946 = (*this) ;
  if (_temp_32946._isBuilt ()) {
    _temp_32946 (HERE)->method_getAllAttributeList (_inLexique, var_cas_allAttributeList COMMA_SOURCE_FILE_AT_LINE (710)) ;
  }
  var_cas_ioGeneratedUserZone3._dotAssign_operation (GGS_string::constructor_CppTitleComment (_inLexique, ((GGS_string (true, "GALGAS entity '@"))._operator_concat (mEntityName))._operator_concat (GGS_string (true, "'")) COMMA_HERE)) ;
  var_cas_ioGeneratedUserZone3.writeString ("class GGS_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" : public ") ;
  if ((mSuperEntityIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (713))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedUserZone3.writeString ("GGS_") ;
    var_cas_ioGeneratedUserZone3._dotAssign_operation (mSuperEntityIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (714))) ;
  }else{
    var_cas_ioGeneratedUserZone3.writeString (" AC_galgas_entity") ;
  }
  var_cas_ioGeneratedUserZone3.writeString (" {\n") ;
  if (((mIsAbstract)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_ioGeneratedUserZone3.writeString ("//--- 'new' constructor\n"
    "  public : static GGS_") ;
    var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedUserZone3.writeString (" constructor_new (C_Compiler & inLexique") ;
    GGS_uint  var_cas_n ;
    var_cas_n = GGS_uint (true, 0U) ;
    {
      GGS_attributeList::cEnumerator enumerator_33565 (var_cas_allAttributeList, true) ;
      const GGS_attributeList::cElement * operand_33565 = NULL ;
      while (((operand_33565 = (GGS_attributeList::cElement *) enumerator_33565.nextObject ()))) {
        macroValidPointer (operand_33565) ;
        var_cas_ioGeneratedUserZone3.writeString (",\n"
        "                                const GGS_") ;
        var_cas_ioGeneratedUserZone3._dotAssign_operation (operand_33565->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (725))) ;
        var_cas_ioGeneratedUserZone3.writeString (" & argument_") ;
        var_cas_ioGeneratedUserZone3._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (726))) ;
        var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (727)) ;
      }
    }
    var_cas_ioGeneratedUserZone3.writeString ("\n"
    "                                COMMA_LOCATION_ARGS) ;\n"
      "\n") ;
  }
  var_cas_ioGeneratedUserZone3.writeString ("//--- getPtr\n"
  "  public : inline cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" * getPtr (void) const {\n"
  "    return (cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" *) mPointer ;\n"
  "  }\n"
    "\n"
  "//--- 'description' reader\n"
  "  public : virtual const char * actualTypeName (void) const ;\n"
    "\n"
  "//--- Readers\n") ;
  {
    GGS_attributeList::cEnumerator enumerator_34305 (var_cas_allAttributeList, true) ;
    const GGS_attributeList::cElement * operand_34305 = NULL ;
    while (((operand_34305 = (GGS_attributeList::cElement *) enumerator_34305.nextObject ()))) {
      macroValidPointer (operand_34305) ;
      var_cas_ioGeneratedUserZone3.writeString ("  public : GGS_") ;
      var_cas_ioGeneratedUserZone3._dotAssign_operation (operand_34305->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (740))) ;
      var_cas_ioGeneratedUserZone3.writeString (" reader_") ;
      var_cas_ioGeneratedUserZone3._dotAssign_operation (operand_34305->mAttributeName) ;
      var_cas_ioGeneratedUserZone3.writeString (" (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;\n") ;
    }
  }
  var_cas_ioGeneratedUserZone3.writeString ("\n"
  "//--- operator ()\n"
  "  #ifndef DO_NOT_GENERATE_CHECKINGS\n"
  "    public : cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" * operator () (LOCATION_ARGS) const ;\n"
  "  #else\n"
  "    public : inline cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" * operator () (void) const {\n"
  "      return (cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" *) mPointer ;\n"
  "    }\n"
  "  #endif\n"
  "} ;\n"
    "\n") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (GGS_string::constructor_CppTitleComment (_inLexique, ((GGS_string (true, "GALGAS list of entity '@"))._operator_concat (mEntityName))._operator_concat (GGS_string (true, "'")) COMMA_HERE)) ;
  var_cas_ioGeneratedUserZone3.writeString ("class GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" : public AC_galgas_entity_list {\n"
  "//--- Constructor 'emptyList'\n"
  "  public : static GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;\n"
  "  public : static GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString ("\n"
  "  constructor_listWithValue (C_Compiler & _inLexique,\n"
  "                             const GGS_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" & inObject\n"
  "                             COMMA_LOCATION_ARGS) ;\n"
    "\n"
  "//--- Operator () used for method call\n"
  "  public : inline const GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" * operator () (UNUSED_LOCATION_ARGS) const {\n"
  "    return this ;\n"
  "  }\n"
    "\n"
  "//--- Handling '+=' GALGAS operator\n"
  "  public : void _addAssign_operation (const GGS_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" & inElement) ;\n"
    "\n"
  "//--- Handling '.' GALGAS operator\n"
  "  public : GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" _operator_concat (const GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" & inOperand) const ;\n"
    "\n"
  "//--- Handling 'prependValue' GALGAS modifier\n"
  "  public : void modifier_prependValue (C_Compiler & _inLexique,\n"
  "                                       const GGS_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" & inObject\n"
  "                                       COMMA_LOCATION_ARGS) ;\n"
    "\n"
  "//--- 'description' reader\n"
  "  public : GGS_string\n"
  "  reader_description (C_Compiler & _inLexique\n"
  "                      COMMA_LOCATION_ARGS,\n"
  "                      const sint32 inIndentation = 0) const ;\n"
    "\n"
  "} ;\n"
    "\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_generateDeclaration_2_inHeader (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioGeneratedUserZone3 COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList  var_cas_allAttributeList ;
  const GGS_entityGalgasType  _temp_36858 = (*this) ;
  if (_temp_36858._isBuilt ()) {
    _temp_36858 (HERE)->method_getAllAttributeList (_inLexique, var_cas_allAttributeList COMMA_SOURCE_FILE_AT_LINE (787)) ;
  }
  var_cas_ioGeneratedUserZone3._dotAssign_operation (GGS_string::constructor_CppTitleComment (_inLexique, ((GGS_string (true, "Element of list '@"))._operator_concat (mEntityName))._operator_concat (GGS_string (true, "'")) COMMA_HERE)) ;
  var_cas_ioGeneratedUserZone3.writeString ("class cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" : public ") ;
  if ((mSuperEntityIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (790))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedUserZone3.writeString ("cPtr_") ;
    var_cas_ioGeneratedUserZone3._dotAssign_operation (mSuperEntityIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (791))) ;
  }else{
    var_cas_ioGeneratedUserZone3.writeString ("cPtr_entity") ;
  }
  var_cas_ioGeneratedUserZone3.writeString (" {\n"
  "//--- Attributes\n") ;
  {
    GGS_attributeList::cEnumerator enumerator_37299 (mPropertyList, true) ;
    const GGS_attributeList::cElement * operand_37299 = NULL ;
    while (((operand_37299 = (GGS_attributeList::cElement *) enumerator_37299.nextObject ()))) {
      macroValidPointer (operand_37299) ;
      var_cas_ioGeneratedUserZone3.writeString ("  public : GGS_") ;
      var_cas_ioGeneratedUserZone3._dotAssign_operation (operand_37299->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (798))) ;
      var_cas_ioGeneratedUserZone3.writeString (" ") ;
      var_cas_ioGeneratedUserZone3._dotAssign_operation (operand_37299->mAttributeName) ;
      var_cas_ioGeneratedUserZone3.writeString (" ;\n") ;
    }
  }
  var_cas_ioGeneratedUserZone3.writeString ("\n"
  "//--- Constructor\n"
  "  public : cPtr_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" (") ;
  if (((var_cas_allAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (804)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedUserZone3.writeString ("LOCATION_ARGS") ;
  }else{
    GGS_uint  var_cas_n ;
    var_cas_n = GGS_uint (true, 0U) ;
    {
      GGS_attributeList::cEnumerator enumerator_37750 (var_cas_allAttributeList, true) ;
      const GGS_attributeList::cElement * operand_37750 = NULL ;
      while (((operand_37750 = (GGS_attributeList::cElement *) enumerator_37750.nextObject ()))) {
        macroValidPointer (operand_37750) ;
        if (((var_cas_n)._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
          var_cas_ioGeneratedUserZone3.writeString (",\n"
          "                                ") ;
        }
        var_cas_ioGeneratedUserZone3.writeString ("const GGS_") ;
        var_cas_ioGeneratedUserZone3._dotAssign_operation (operand_37750->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (813))) ;
        var_cas_ioGeneratedUserZone3.writeString (" & argument_") ;
        var_cas_ioGeneratedUserZone3._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (814))) ;
        var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (815)) ;
      }
    }
    var_cas_ioGeneratedUserZone3.writeString ("\n"
    "                                COMMA_LOCATION_ARGS") ;
  }
  var_cas_ioGeneratedUserZone3.writeString (") ;\n"
    "\n"
  "//--- Element comparison\n"
  "  public : virtual bool isEqualToObject (const cPtr_entity * inOperand) const ;\n"
    "\n"
  "//--- Method used for description\n"
  "  public : virtual void\n"
  "  appendForDescription (C_Compiler & _inLexique,\n"
  "                        C_String & ioString,\n"
  "                        const sint32 inIndentation\n"
  "                        COMMA_LOCATION_ARGS) const ;\n"
    "\n"
  "//--- Metamodel Component Index\n"
  "  public : virtual sint32 _metamodelComponentIndex (const sint32 inLevel) const ;\n"
    "\n"
  "//--- Metamodel Component Name\n"
  "  public : virtual const char * _metamodelComponentName (const sint32 inLevel) const ;\n"
  "//--- Metamodel Class ID\n"
  "  public : virtual sint32 _metamodelClassID (const sint32 inLevel) const ;\n"
    "\n"
  "//--- Metamodel Class Name\n"
  "  public : virtual const char * _metamodelClassName (const sint32 inLevel) const ;\n"
    "\n"
  "//--- Friend class declarations\n"
  "  friend class GGS__list_") ;
  var_cas_ioGeneratedUserZone3._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedUserZone3.writeString (" ;\n"
  "} ;\n"
    "\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
method_generateImplementation (C_Compiler & _inLexique,
                                GGS_string& var_cas_ioGeneratedCode COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList  var_cas_allAttributeList ;
  const GGS_entityGalgasType  _temp_39514 = (*this) ;
  if (_temp_39514._isBuilt ()) {
    _temp_39514 (HERE)->method_getAllAttributeList (_inLexique, var_cas_allAttributeList COMMA_SOURCE_FILE_AT_LINE (850)) ;
  }
  GGS_attributeList  var_cas_inheritedAttributeList ;
  const GGS_entityGalgasType  _temp_39610 = (*this) ;
  if (_temp_39610._isBuilt ()) {
    _temp_39610 (HERE)->method_getInheritedAttributeList (_inLexique, var_cas_inheritedAttributeList COMMA_SOURCE_FILE_AT_LINE (852)) ;
  }
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppTitleComment (_inLexique, ((GGS_string (true, "Element of list '@"))._operator_concat (mEntityName))._operator_concat (GGS_string (true, "'")) COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" (") ;
  if (((var_cas_allAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (856)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedCode.writeString ("LOCATION_ARGS) :\n") ;
  }else{
    GGS_uint  var_cas_n ;
    var_cas_n = GGS_uint (true, 0U) ;
    {
      GGS_attributeList::cEnumerator enumerator_39964 (var_cas_allAttributeList, true) ;
      const GGS_attributeList::cElement * operand_39964 = NULL ;
      while (((operand_39964 = (GGS_attributeList::cElement *) enumerator_39964.nextObject ()))) {
        macroValidPointer (operand_39964) ;
        if (((var_cas_n)._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
          var_cas_ioGeneratedCode.writeString (",\n"
          "                                ") ;
        }
        var_cas_ioGeneratedCode.writeString ("const GGS_") ;
        var_cas_ioGeneratedCode._dotAssign_operation (operand_39964->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (865))) ;
        var_cas_ioGeneratedCode.writeString (" & argument_") ;
        var_cas_ioGeneratedCode._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (866))) ;
        var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (867)) ;
      }
    }
    var_cas_ioGeneratedCode.writeString ("\n"
    "                                COMMA_LOCATION_ARGS) :\n") ;
  }
  if ((mSuperEntityIndex.reader_isRegular (_inLexique COMMA_SOURCE_FILE_AT_LINE (872))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedCode.writeString ("cPtr_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mSuperEntityIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (873))) ;
    var_cas_ioGeneratedCode.writeString (" (") ;
    if (((var_cas_inheritedAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (874)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      var_cas_ioGeneratedCode.writeString ("THERE)") ;
    }else{
      GGS_uint  var_cas_n ;
      var_cas_n = GGS_uint (true, 0U) ;
      {
        GGS_attributeList::cEnumerator enumerator_40668 (var_cas_inheritedAttributeList, true) ;
        const GGS_attributeList::cElement * operand_40668 = NULL ;
        while (((operand_40668 = (GGS_attributeList::cElement *) enumerator_40668.nextObject ()))) {
          macroValidPointer (operand_40668) ;
          if (((var_cas_n)._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
            var_cas_ioGeneratedCode.writeString (",\n"
            "                                ") ;
          }
          var_cas_ioGeneratedCode.writeString ("argument_") ;
          var_cas_ioGeneratedCode._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (883))) ;
          var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (884)) ;
        }
      }
      var_cas_ioGeneratedCode.writeString ("\n"
      "                                COMMA_THERE)") ;
    }
  }else{
    var_cas_ioGeneratedCode.writeString ("cPtr_entity (THERE)") ;
  }
  GGS_uint  var_cas_n ;
  var_cas_n = var_cas_inheritedAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (892)) ;
  {
    GGS_attributeList::cEnumerator enumerator_41164 (mPropertyList, true) ;
    const GGS_attributeList::cElement * operand_41164 = NULL ;
    while (((operand_41164 = (GGS_attributeList::cElement *) enumerator_41164.nextObject ()))) {
      macroValidPointer (operand_41164) ;
      var_cas_ioGeneratedCode.writeString (",\n") ;
      var_cas_ioGeneratedCode._dotAssign_operation (operand_41164->mAttributeName) ;
      var_cas_ioGeneratedCode.writeString (" (argument_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (894))) ;
      var_cas_ioGeneratedCode.writeString (")") ;
      var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (895)) ;
    }
  }
  var_cas_ioGeneratedCode.writeString (" {\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("bool cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "isEqualToObject (const cPtr_entity * inOperand) const {\n"
  "  bool equal = inOperand == this ;\n") ;
  if (((var_cas_allAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (903)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedCode.writeString ("  if (! equal) {\n"
    "    const cPtr_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedCode.writeString (" * _p = dynamic_cast <const cPtr_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedCode.writeString (" *> (inOperand) ;\n"
    "    macroValidPointer (_p) ;\n") ;
    GGS_bool var_cas_firstLoop ;
    var_cas_firstLoop = GGS_bool (true, true) ;
    {
      GGS_attributeList::cEnumerator enumerator_41846 (var_cas_allAttributeList, true) ;
      const GGS_attributeList::cElement * operand_41846 = NULL ;
      while (((operand_41846 = (GGS_attributeList::cElement *) enumerator_41846.nextObject ()))) {
        macroValidPointer (operand_41846) ;
        if ((var_cas_firstLoop).isBuiltAndTrue ()) {
          var_cas_ioGeneratedCode.writeString ("    equal = ") ;
          var_cas_firstLoop = GGS_bool (true, false) ;
        }else{
          var_cas_ioGeneratedCode.writeString ("\n"
            "         && ") ;
        }
        var_cas_ioGeneratedCode._dotAssign_operation (operand_41846->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (915))) ;
        var_cas_ioGeneratedCode.writeString ("._operator_isEqual (_p->") ;
        var_cas_ioGeneratedCode._dotAssign_operation (operand_41846->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (915))) ;
        var_cas_ioGeneratedCode.writeString (").boolValue ()") ;
      }
    }
    var_cas_ioGeneratedCode.writeString (" ;\n"
    "  }\n") ;
  }
  var_cas_ioGeneratedCode.writeString ("  return equal ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("void cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n") ;
  if (((var_cas_allAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (925)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_ioGeneratedCode.writeString ("appendForDescription (C_Compiler & /* _inLexique */,\n"
    "                      C_String & ioString,\n"
    "                      const sint32 /* inIndentation */\n"
    "                      COMMA_UNUSED_LOCATION_ARGS) const {\n") ;
  }else{
    var_cas_ioGeneratedCode.writeString ("appendForDescription (C_Compiler & _inLexique,\n"
    "                      C_String & ioString,\n"
    "                      const sint32 inIndentation\n"
    "                      COMMA_LOCATION_ARGS) const {\n") ;
  }
  var_cas_ioGeneratedCode.writeString ("  ioString << \"-> instance of @") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("\" ;\n"
  "  ioString << \"\\n\" ;\n") ;
  GGS_bool var_cas_firstLoop ;
  var_cas_firstLoop = GGS_bool (true, true) ;
  {
    GGS_attributeList::cEnumerator enumerator_43202 (var_cas_allAttributeList, true) ;
    const GGS_attributeList::cElement * operand_43202 = NULL ;
    while (((operand_43202 = (GGS_attributeList::cElement *) enumerator_43202.nextObject ()))) {
      macroValidPointer (operand_43202) ;
      if ((var_cas_firstLoop).isBuiltAndTrue ()) {
        var_cas_firstLoop = GGS_bool (true, false) ;
      }else{
        var_cas_ioGeneratedCode.writeString ("  ioString << \"\\n\" ;\n") ;
      }
      var_cas_ioGeneratedCode.writeString ("  ioString.writeStringMultiple (\"| \", inIndentation) ;\n"
      "  ioString << \"|-\" ;\n"
      "  ioString << ") ;
      var_cas_ioGeneratedCode._dotAssign_operation (operand_43202->mAttributeName) ;
      var_cas_ioGeneratedCode.writeString (".reader_description  (_inLexique COMMA_THERE, inIndentation) ;\n") ;
    }
  }
  var_cas_ioGeneratedCode.writeString ("}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("sint32 cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::_metamodelComponentIndex (const sint32 inLevel) const {\n"
  "  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;\n"
  "  if (inLevel > 0) {\n"
  "    result = -1 ;\n"
  "  }\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("const char * cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::_metamodelComponentName (const sint32 inLevel) const {\n"
  "  const char * result = gMetamodelManager.mMetamodelComponentName ;\n"
  "  if (inLevel > 0) {\n"
  "    result = NULL ;\n"
  "  }\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("sint32 cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::_metamodelClassID (const sint32 inLevel) const {\n"
  "  sint32 result = ") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityIndexInMetamodel.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (971))) ;
  var_cas_ioGeneratedCode.writeString (" ;\n"
  "  if (inLevel > 0) {\n"
  "    result = -1 ;\n"
  "  }\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("const char * cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::_metamodelClassName (const sint32 inLevel) const {\n"
  "  const char * result = \"") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("\" ;\n"
  "  if (inLevel > 0) {\n"
  "    result = NULL ;\n"
  "  }\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppTitleComment (_inLexique, ((GGS_string (true, "List '@"))._operator_concat (mEntityName))._operator_concat (GGS_string (true, "'")) COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("void GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "_addAssign_operation (const GGS_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" & inObject) {\n"
  "   _insulateList () ;\n"
  "   _internalAppendItem (inObject._ptr ()) ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "_operator_concat (const GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" & inOperand) const {\n"
  "  GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" result ;\n"
  "  if (_isBuilt () && inOperand._isBuilt ()) {\n"
  "    if (count () == 0) {\n"
  "      result = inOperand ;\n"
  "    }else{\n"
  "      result = * this ;\n"
  "      if (inOperand.count () > 0) {\n"
  "        result._insulateList () ;\n"
  "        cEntityListElement * p = inOperand.firstObject () ;\n"
  "        while (p != NULL) {\n"
  "          macroValidPointer (p) ;\n"
  "          macroValidPointer (p->ptr ()) ;\n"
  "          result._internalAppendItem (p->ptr ()) ;\n"
  "          p = p->internalNextItem () ;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("void GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "modifier_prependValue (C_Compiler & /* inLexique */,\n"
  "                       const GGS_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" & inObject\n"
  "                       COMMA_UNUSED_LOCATION_ARGS) {\n"
  "  if (_isBuilt () && inObject._isBuilt ()) {\n"
  "    _insulateList () ;\n"
  "    _internalPrependItem (inObject._ptr ()) ;\n"
  "  }\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("  GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {\n"
  "  GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" result ;\n"
  "  result._alloc () ;\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("  GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "constructor_listWithValue (C_Compiler & /* _inLexique */,\n"
  "                           const GGS_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" & inObject\n"
  "                           COMMA_UNUSED_LOCATION_ARGS) {\n"
  "  GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" result ;\n"
  "  result._alloc () ;\n"
  "  result._internalAppendItem (inObject._ptr ()) ;\n"
  "  return result ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("GGS_string GGS__list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::\n"
  "reader_description (C_Compiler & _inLexique\n"
  "                    COMMA_LOCATION_ARGS,\n"
  "                    const sint32 inIndentation) const {\n"
  "  return _description (_inLexique, \"@_list_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("\", inIndentation COMMA_THERE) ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppTitleComment (_inLexique, ((GGS_string (true, "Entity '@"))._operator_concat (mEntityName))._operator_concat (GGS_string (true, "'")) COMMA_HERE)) ;
  if (((mIsAbstract)._operator_not ()).isBuiltAndTrue ()) {
    var_cas_ioGeneratedCode.writeString ("GGS_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedCode.writeString (" GGS_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedCode.writeString ("::\n"
    "constructor_new (C_Compiler & /* inLexique */") ;
    GGS_uint  var_cas_n ;
    var_cas_n = GGS_uint (true, 0U) ;
    {
      GGS_attributeList::cEnumerator enumerator_48076 (var_cas_allAttributeList, true) ;
      const GGS_attributeList::cElement * operand_48076 = NULL ;
      while (((operand_48076 = (GGS_attributeList::cElement *) enumerator_48076.nextObject ()))) {
        macroValidPointer (operand_48076) ;
        var_cas_ioGeneratedCode.writeString (",\n"
          "                                "
        "const GGS_") ;
        var_cas_ioGeneratedCode._dotAssign_operation (operand_48076->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (1056))) ;
        var_cas_ioGeneratedCode.writeString (" & argument_") ;
        var_cas_ioGeneratedCode._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1057))) ;
        var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (1058)) ;
      }
    }
    var_cas_ioGeneratedCode.writeString ("\n"
      "                                "
    "COMMA_LOCATION_ARGS) {\n"
    "  GGS_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedCode.writeString (" result ;\n"
    "  macroMyNew (result.mPointer, cPtr_") ;
    var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
    var_cas_ioGeneratedCode.writeString (" (") ;
    if (((var_cas_allAttributeList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (1064)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
      var_cas_ioGeneratedCode.writeString ("THERE)) ;") ;
    }else{
      var_cas_n = GGS_uint (true, 0U) ;
      {
        GGS_attributeList::cEnumerator enumerator_48667 (var_cas_allAttributeList, true) ;
        const GGS_attributeList::cElement * operand_48667 = NULL ;
        while (((operand_48667 = (GGS_attributeList::cElement *) enumerator_48667.nextObject ()))) {
          macroValidPointer (operand_48667) ;
          if (((var_cas_n)._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
            var_cas_ioGeneratedCode.writeString (",\n"
              "                                ") ;
          }
          var_cas_ioGeneratedCode.writeString ("argument_") ;
          var_cas_ioGeneratedCode._dotAssign_operation (var_cas_n.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1072))) ;
          var_cas_n._increment_operation (_inLexique COMMA_SOURCE_FILE_AT_LINE (1073)) ;
        }
      }
      var_cas_ioGeneratedCode.writeString ("\n"
        "                                "
      "COMMA_THERE)) ;\n") ;
    }
    var_cas_ioGeneratedCode.writeString ("  return result ;\n"
    "}\n"
      "\n") ;
  }
  {
    GGS_attributeList::cEnumerator enumerator_49101 (mPropertyList, true) ;
    const GGS_attributeList::cElement * operand_49101 = NULL ;
    while (((operand_49101 = (GGS_attributeList::cElement *) enumerator_49101.nextObject ()))) {
      macroValidPointer (operand_49101) ;
      var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
      var_cas_ioGeneratedCode.writeString ("GGS_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (operand_49101->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (1084))) ;
      var_cas_ioGeneratedCode.writeString (" GGS_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
      var_cas_ioGeneratedCode.writeString ("::\n"
      "reader_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (operand_49101->mAttributeName) ;
      var_cas_ioGeneratedCode.writeString (" (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {\n"
      "  GGS_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (operand_49101->mAttributeTypeIndex.reader_key (_inLexique COMMA_SOURCE_FILE_AT_LINE (1086))) ;
      var_cas_ioGeneratedCode.writeString (" result ;\n"
      "  if (mPointer != NULL) {\n"
      "    macroValidPointer (mPointer) ;\n"
      "    MF_Assert (dynamic_cast <cPtr_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
      var_cas_ioGeneratedCode.writeString (" *> (mPointer) != NULL,\n"
      "               \"dynamic cast error\", 0, 0) ;\n"
      "    result = ((cPtr_") ;
      var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
      var_cas_ioGeneratedCode.writeString (" *) mPointer)->") ;
      var_cas_ioGeneratedCode._dotAssign_operation (operand_49101->mAttributeName) ;
      var_cas_ioGeneratedCode.writeString (" ;\n"
      "  }\n"
      "  return result ;\n"
      "}\n"
        "\n") ;
    }
  }
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("const char * GGS_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::actualTypeName (void) const {\n"
  " return \"") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("\" ;\n"
  "}\n"
    "\n") ;
  var_cas_ioGeneratedCode._dotAssign_operation (GGS_string::constructor_CppLineComment (_inLexique COMMA_HERE)) ;
  var_cas_ioGeneratedCode.writeString ("#ifndef DO_NOT_GENERATE_CHECKINGS\n"
  "  cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" * GGS_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString ("::operator () (LOCATION_ARGS) const {\n"
  "    macroValidPointerThere (mPointer) ;\n"
  "    return (cPtr_") ;
  var_cas_ioGeneratedCode._dotAssign_operation (mEntityName) ;
  var_cas_ioGeneratedCode.writeString (" *) mPointer ;\n"
  "  }\n"
  "#endif\n"
    "\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_entityGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@entityGalgasType:"
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperEntityIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPropertyList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEntityIndexInMetamodel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_entityGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_entityGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_entityGalgasType (& typeid (cPtr_entityGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_entityGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_entityGalgasType::
GGS_entityGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_entityGalgasType::
GGS_entityGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_entityGalgasType GGS_entityGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_entityGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_entityGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_entityGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_entityGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_entityGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_entityGalgasType GGS_entityGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeMapIndex & argument_2,
                 const GGS_attributeList & argument_3,
                 const GGS_uint & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_entityGalgasType result ;
  macroMyNew (result.mPointer, cPtr_entityGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_entityGalgasType::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_entityGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_entityGalgasType *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_entityGalgasType::
reader_mEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_entityGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_entityGalgasType *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_entityGalgasType::
reader_mSuperEntityIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_entityGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_entityGalgasType *) mPointer)->mSuperEntityIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_entityGalgasType::
reader_mPropertyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_entityGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_entityGalgasType *) mPointer)->mPropertyList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_entityGalgasType::
reader_mEntityIndexInMetamodel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_entityGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_entityGalgasType *) mPointer)->mEntityIndexInMetamodel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_entityGalgasType::actualTypeName (void) const {
  return "entityGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_multipleReferenceGalgasType'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multipleReferenceGalgasType::
cPtr_multipleReferenceGalgasType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multipleReferenceGalgasType * GGS_multipleReferenceGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multipleReferenceGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_multipleReferenceGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_multipleReferenceGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_multipleReferenceGalgasType * _p = dynamic_cast <const cPtr_multipleReferenceGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntityName._operator_isEqual (_p->mEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multipleReferenceGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@multipleReferenceGalgasType:"
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_multipleReferenceGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multipleReferenceGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_multipleReferenceGalgasType (& typeid (cPtr_multipleReferenceGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_multipleReferenceGalgasType'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_multipleReferenceGalgasType::
GGS_multipleReferenceGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_multipleReferenceGalgasType::
GGS_multipleReferenceGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_multipleReferenceGalgasType GGS_multipleReferenceGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_multipleReferenceGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_multipleReferenceGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_multipleReferenceGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_multipleReferenceGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_multipleReferenceGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_multipleReferenceGalgasType GGS_multipleReferenceGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_multipleReferenceGalgasType result ;
  macroMyNew (result.mPointer, cPtr_multipleReferenceGalgasType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multipleReferenceGalgasType::
reader_mEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multipleReferenceGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multipleReferenceGalgasType *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multipleReferenceGalgasType::actualTypeName (void) const {
  return "multipleReferenceGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_listGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listGalgasType::
cPtr_listGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listGalgasType * GGS_listGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listGalgasType * _p = dynamic_cast <const cPtr_listGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@listGalgasType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listGalgasType (& typeid (cPtr_listGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_listGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_listGalgasType GGS_listGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_listGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_listGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType GGS_listGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  macroMyNew (result.mPointer, cPtr_listGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listGalgasType::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listGalgasType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_listGalgasType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listGalgasType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listGalgasType::actualTypeName (void) const {
  return "listGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sortDescriptorList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortDescriptorList::
elementOf_GGS_sortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortDescriptorList * _p = dynamic_cast <const elementOf_GGS_sortDescriptorList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue ()
         && mAscending._operator_isEqual (_p->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortDescriptorList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@sortDescriptorList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
_operator_concat (const GGS_sortDescriptorList & inOperand) const {
  GGS_sortDescriptorList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_sortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeName,
                                _p->mAscending
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortDescriptorList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_bool& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortDescriptorList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
internalSubListWithRange (GGS_sortDescriptorList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributeName, _p->mAscending) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@sortDescriptorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mAscending ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mAscending ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mAscending ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mAscending ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_sortedlistGalgasType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedlistGalgasType::
cPtr_sortedlistGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1,
                                const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedlistGalgasType * GGS_sortedlistGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sortedlistGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedlistGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedlistGalgasType * _p = dynamic_cast <const cPtr_sortedlistGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mSortDescriptorList._operator_isEqual (_p->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedlistGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sortedlistGalgasType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSortDescriptorList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedlistGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedlistGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedlistGalgasType (& typeid (cPtr_sortedlistGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sortedlistGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType::
GGS_sortedlistGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType::
GGS_sortedlistGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sortedlistGalgasType GGS_sortedlistGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedlistGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sortedlistGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sortedlistGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedlistGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType GGS_sortedlistGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1,
                 const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType result ;
  macroMyNew (result.mPointer, cPtr_sortedlistGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedlistGalgasType::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedlistGalgasType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_sortedlistGalgasType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedlistGalgasType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortedlistGalgasType::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortDescriptorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedlistGalgasType *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedlistGalgasType::actualTypeName (void) const {
  return "sortedlistGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_mapindexType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexType::
cPtr_mapindexType (const GGS_lstring & argument_0,
                                const GGS_typeMapIndex & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapIndexName (argument_0),
mMapTypeIndex (argument_1),
mSearchMethodName (argument_2),
mSearchMethodErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexType * GGS_mapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexType * _p = dynamic_cast <const cPtr_mapindexType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapIndexName._operator_isEqual (_p->mMapIndexName).boolValue ()
         && mMapTypeIndex._operator_isEqual (_p->mMapTypeIndex).boolValue ()
         && mSearchMethodName._operator_isEqual (_p->mSearchMethodName).boolValue ()
         && mSearchMethodErrorMessage._operator_isEqual (_p->mSearchMethodErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapindexType:"
           << mMapIndexName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexType (& typeid (cPtr_mapindexType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mapindexType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_mapindexType GGS_mapindexType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_mapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType GGS_mapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeMapIndex & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  macroMyNew (result.mPointer, cPtr_mapindexType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexType::
reader_mMapIndexName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mMapIndexName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_mapindexType::
reader_mMapTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mMapTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexType::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexType::
reader_mSearchMethodErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mSearchMethodErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexType::actualTypeName (void) const {
  return "mapindexType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_mapType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapType::
cPtr_mapType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapType * GGS_mapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapType * _p = dynamic_cast <const cPtr_mapType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapType:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapType (& typeid (cPtr_mapType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_mapType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapType::
GGS_mapType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapType::
GGS_mapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_mapType GGS_mapType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapType *> (inPointer) != NULL)
      : (typeid (cPtr_mapType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_mapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_mapType GGS_mapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_mapType result ;
  macroMyNew (result.mPointer, cPtr_mapType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapType::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapType *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_mapType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapType::actualTypeName (void) const {
  return "mapType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_enumType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumType::
cPtr_enumType (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumType * GGS_enumType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumType * _p = dynamic_cast <const cPtr_enumType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mConstantList._operator_isEqual (_p->mConstantList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumType:"
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumType (& typeid (cPtr_enumType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_enumType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumType::
GGS_enumType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumType::
GGS_enumType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_enumType GGS_enumType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumType *> (inPointer) != NULL)
      : (typeid (cPtr_enumType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_enumType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_enumType GGS_enumType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumType result ;
  macroMyNew (result.mPointer, cPtr_enumType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumType::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumType *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumType::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumType *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumType::actualTypeName (void) const {
  return "enumType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::_drop_operation (void) {
  mTypeMap._drop_operation () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::_isBuilt (void) const {
  return mTypeMap._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
_operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap._operator_isEqual (inOperand.mTypeMap) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
_operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap._operator_isNotEqual (inOperand.mTypeMap) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeMap & argument_0
                 COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  return result ;
}

//---------------------------------------------------------------------------*

