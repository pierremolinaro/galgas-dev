//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsSemantics.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 8th, 2009, at 12h50'32"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'variableStateAutomaton' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_variableStateAutomaton::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_isEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_isNotEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_infOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_supOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_strictInf (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
operator_strictSup (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_writeAccess (C_Compiler & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_writeAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local constant cannot be written, it is is already defined") COMMA_SOURCE_FILE_AT_LINE (52)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local constant cannot be written, it is is already defined") COMMA_SOURCE_FILE_AT_LINE (54)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterDefined ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be written, it is a constant") COMMA_SOURCE_FILE_AT_LINE (59)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be written, it is a constant") COMMA_SOURCE_FILE_AT_LINE (60)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readAccess (C_Compiler & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (66)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (69)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local constant cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (70)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (77)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readWriteAccess (C_Compiler & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readWriteAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (85)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (88)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (89)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (90)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (92)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (93)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (96)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (97)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (98)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_dropAccess (C_Compiler & inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_dropAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (104)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableDropped ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the local variable is already dropped") COMMA_SOURCE_FILE_AT_LINE (107)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (108)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (109)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (111)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (112)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterDropped ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDropped ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the input parameter is already dropped") COMMA_SOURCE_FILE_AT_LINE (115)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a constant input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (116)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a constant input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (117)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

static const GGS_variableStateAutomaton::enumeration kResultForvariableStateAutomaton_endOfRepeatedBranch [121] = {
  GGS_variableStateAutomaton::enum_localVariableDeclared, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::enum_localVariableUsed, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_constantInputFormalParameterUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterDropped, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_inputFormalParameterUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDeclared, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localConstantDefined, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localContantUsed, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDeclared, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableDropped, enum_localVariableUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_constantInputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_constantInputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterDropped */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_inputFormalParameterUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localConstantDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localConstantDefined */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localContantUsed */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localVariableDeclared */
  GGS_variableStateAutomaton::kNotBuilt, /* enum_localVariableUsed, enum_localVariableDropped */
  GGS_variableStateAutomaton::kNotBuilt /* enum_localVariableUsed, enum_localVariableUsed */
} ;

//---------------------------------------------------------------------------*

static const PMSInt32 kErrorForvariableStateAutomaton_endOfRepeatedBranch [121] = {
  1, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterDropped */
  -1, /* enum_constantInputFormalParameterDefined, enum_inputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_localConstantDeclared */
  -1, /* enum_constantInputFormalParameterDefined, enum_localConstantDefined */
  -1, /* enum_constantInputFormalParameterDefined, enum_localContantUsed */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableDeclared */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableDropped */
  -1, /* enum_constantInputFormalParameterDefined, enum_localVariableUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  2, /* enum_constantInputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDefined */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterDropped */
  -1, /* enum_constantInputFormalParameterUsed, enum_inputFormalParameterUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_localConstantDeclared */
  -1, /* enum_constantInputFormalParameterUsed, enum_localConstantDefined */
  -1, /* enum_constantInputFormalParameterUsed, enum_localContantUsed */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableDeclared */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableDropped */
  -1, /* enum_constantInputFormalParameterUsed, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterDefined, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDefined, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterDefined, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterDefined, enum_localContantUsed */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterDefined, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDropped, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterDropped, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterDropped, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterDropped, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterDropped, enum_localContantUsed */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterDropped, enum_localVariableUsed */
  -1, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_inputFormalParameterUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDefined */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterDropped */
  -1, /* enum_inputFormalParameterUsed, enum_inputFormalParameterUsed */
  -1, /* enum_inputFormalParameterUsed, enum_localConstantDeclared */
  -1, /* enum_inputFormalParameterUsed, enum_localConstantDefined */
  -1, /* enum_inputFormalParameterUsed, enum_localContantUsed */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableDeclared */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableDropped */
  -1, /* enum_inputFormalParameterUsed, enum_localVariableUsed */
  -1, /* enum_localConstantDeclared, enum_constantInputFormalParameterDefined */
  -1, /* enum_localConstantDeclared, enum_constantInputFormalParameterUsed */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterDefined */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterDropped */
  -1, /* enum_localConstantDeclared, enum_inputFormalParameterUsed */
  -1, /* enum_localConstantDeclared, enum_localConstantDeclared */
  -1, /* enum_localConstantDeclared, enum_localConstantDefined */
  -1, /* enum_localConstantDeclared, enum_localContantUsed */
  -1, /* enum_localConstantDeclared, enum_localVariableDeclared */
  -1, /* enum_localConstantDeclared, enum_localVariableDropped */
  -1, /* enum_localConstantDeclared, enum_localVariableUsed */
  -1, /* enum_localConstantDefined, enum_constantInputFormalParameterDefined */
  -1, /* enum_localConstantDefined, enum_constantInputFormalParameterUsed */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterDefined */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterDropped */
  -1, /* enum_localConstantDefined, enum_inputFormalParameterUsed */
  -1, /* enum_localConstantDefined, enum_localConstantDeclared */
  -1, /* enum_localConstantDefined, enum_localConstantDefined */
  -1, /* enum_localConstantDefined, enum_localContantUsed */
  -1, /* enum_localConstantDefined, enum_localVariableDeclared */
  -1, /* enum_localConstantDefined, enum_localVariableDropped */
  -1, /* enum_localConstantDefined, enum_localVariableUsed */
  -1, /* enum_localContantUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_localContantUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_localContantUsed, enum_inputFormalParameterDefined */
  -1, /* enum_localContantUsed, enum_inputFormalParameterDropped */
  -1, /* enum_localContantUsed, enum_inputFormalParameterUsed */
  -1, /* enum_localContantUsed, enum_localConstantDeclared */
  -1, /* enum_localContantUsed, enum_localConstantDefined */
  -1, /* enum_localContantUsed, enum_localContantUsed */
  -1, /* enum_localContantUsed, enum_localVariableDeclared */
  -1, /* enum_localContantUsed, enum_localVariableDropped */
  -1, /* enum_localContantUsed, enum_localVariableUsed */
  -1, /* enum_localVariableDeclared, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableDeclared, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableDeclared, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableDeclared, enum_localConstantDeclared */
  -1, /* enum_localVariableDeclared, enum_localConstantDefined */
  -1, /* enum_localVariableDeclared, enum_localContantUsed */
  -1, /* enum_localVariableDeclared, enum_localVariableDeclared */
  -1, /* enum_localVariableDeclared, enum_localVariableDropped */
  -1, /* enum_localVariableDeclared, enum_localVariableUsed */
  -1, /* enum_localVariableDropped, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableDropped, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableDropped, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableDropped, enum_localConstantDeclared */
  -1, /* enum_localVariableDropped, enum_localConstantDefined */
  -1, /* enum_localVariableDropped, enum_localContantUsed */
  -1, /* enum_localVariableDropped, enum_localVariableDeclared */
  -1, /* enum_localVariableDropped, enum_localVariableDropped */
  -1, /* enum_localVariableDropped, enum_localVariableUsed */
  -1, /* enum_localVariableUsed, enum_constantInputFormalParameterDefined */
  -1, /* enum_localVariableUsed, enum_constantInputFormalParameterUsed */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterDefined */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterDropped */
  -1, /* enum_localVariableUsed, enum_inputFormalParameterUsed */
  -1, /* enum_localVariableUsed, enum_localConstantDeclared */
  -1, /* enum_localVariableUsed, enum_localConstantDefined */
  -1, /* enum_localVariableUsed, enum_localContantUsed */
  -1, /* enum_localVariableUsed, enum_localVariableDeclared */
  -1, /* enum_localVariableUsed, enum_localVariableDropped */
  -1 /* enum_localVariableUsed, enum_localVariableUsed */
} ;

//---------------------------------------------------------------------------*

GGS_variableStateAutomaton GGS_variableStateAutomaton::
operator_endOfRepeatedBranch (C_Compiler & inLexique,
                                const GGS_variableStateAutomaton & inOperand,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) const {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::operator_endOfRepeatedBranch at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  enumeration result = kNotBuilt ;
  if ((mValue > 0) && (inOperand.mValue > 0)) {
    const PMSInt32 kIndex = (mValue - 1) * 11 + inOperand.mValue - 1 ;
    result = kResultForvariableStateAutomaton_endOfRepeatedBranch [kIndex] ;
    const PMSInt32 error = kErrorForvariableStateAutomaton_endOfRepeatedBranch [kIndex] ;
    if (error != 0) {
      switch (error) {
      case 1:
        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("error 1") COMMA_SOURCE_FILE_AT_LINE (122)) ;
      break ;
      case 2:
        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("warning 1") COMMA_SOURCE_FILE_AT_LINE (122)) ;
      break ;
      default: // error == -1
        { C_String errorMessage ;
          errorMessage << "Unhandled configuration in enum operator" ;
          inLexique.onTheFlySemanticError (errorMessage COMMA_HERE) ;
        }
      break ;
      }
    }
  }
  return GGS_variableStateAutomaton (result) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableStateAutomaton::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @variableStateAutomaton" ;
  switch (mValue) {
  case enum_constantInputFormalParameterDefined:
    s << " constantInputFormalParameterDefined>" ;
    break ;
  case enum_constantInputFormalParameterUsed:
    s << " constantInputFormalParameterUsed>" ;
    break ;
  case enum_inputFormalParameterDefined:
    s << " inputFormalParameterDefined>" ;
    break ;
  case enum_inputFormalParameterDropped:
    s << " inputFormalParameterDropped>" ;
    break ;
  case enum_inputFormalParameterUsed:
    s << " inputFormalParameterUsed>" ;
    break ;
  case enum_localConstantDeclared:
    s << " localConstantDeclared>" ;
    break ;
  case enum_localConstantDefined:
    s << " localConstantDefined>" ;
    break ;
  case enum_localContantUsed:
    s << " localContantUsed>" ;
    break ;
  case enum_localVariableDeclared:
    s << " localVariableDeclared>" ;
    break ;
  case enum_localVariableDropped:
    s << " localVariableDropped>" ;
    break ;
  case enum_localVariableUsed:
    s << " localVariableUsed>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@variableMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_variableMap::
elementOf_GGS_variableMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_variableMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_variableMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_variableMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_variableMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_variableMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_variableMap * info = (e_variableMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_variableMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_variableMap * info = (e_variableMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_variableMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableMap::
operator_isEqual (const GGS_variableMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableMap::
operator_isNotEqual (const GGS_variableMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_variableMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForReadOnlyAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('l'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForDestructiveReadAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForReadWriteAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('/'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kSearchMessage_searchForWriteAccess [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForReadOnlyAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForReadOnlyAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForDestructiveReadAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForDestructiveReadAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForReadWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForReadWriteAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
method_searchForWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchForWriteAccess,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertListOfEntitiesLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertSingleEntityLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertEntityAttributeLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUnusedInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertConstInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUsedConstInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUsedConstInArgumentNoShadow [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUnusedConstInArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertLocalVariable [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertOutProperty [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertInOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUsedInOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_variableMap::kInsertMessage_insertUnusedInOutArgument [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertListOfEntitiesLocalVariable (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertListOfEntitiesLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertSingleEntityLocalVariable (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertSingleEntityLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertEntityAttributeLocalVariable (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertEntityAttributeLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUnusedInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertConstInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertConstInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedConstInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUsedConstInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedConstInArgumentNoShadow (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUsedConstInArgumentNoShadow,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedConstInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUnusedConstInArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertLocalVariable (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertLocalVariable,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertOutProperty (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertOutProperty,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertInOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertInOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUsedInOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUsedInOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableMap::
modifier_insertUnusedInOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertUnusedInOutArgument,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_variableMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_variableMap GGS_variableMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_variableMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @variableMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ACGalgasType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ACGalgasType::
cPtr_ACGalgasType (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ACGalgasType * GGS_ACGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ACGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ACGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_checkTypeCrossReferences (C_Compiler & /* inLexique */,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generatePredeclarationInHeader (C_Compiler & /* inLexique */,
                                GGS_string& /* var_cas_ioGeneratedUserZone3 */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generateDeclaration_1_inHeader (C_Compiler & /* inLexique */,
                                GGS_string& /* var_cas_ioGeneratedUserZone3 */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generateDeclaration_2_inHeader (C_Compiler & /* inLexique */,
                                GGS_string& /* var_cas_ioGeneratedUserZone3 */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_generateImplementation (C_Compiler & /* inLexique */,
                                GGS_string& /* var_cas_ioGeneratedCode */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ACGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ACGalgasType (& typeid (cPtr_ACGalgasType), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ACGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__ACGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ACGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ACGalgasType GGS_ACGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ACGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ACGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ACGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ACGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ACGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ACGalgasType::actualTypeName (void) const {
  return "ACGalgasType" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_ACGalgasType::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__ACGalgasType ("ACGalgasType") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_typeMap'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeMap::e_typeMap (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@typeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeMap::
elementOf_GGS_typeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mType.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeMap * ptr = dynamic_cast <const elementOf_GGS_typeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mType.operator_isEqual (ptr->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
operator_isEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
operator_isNotEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ACGalgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeMap info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ACGalgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ACGalgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ACGalgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ACGalgasType  & GGS_typeMap::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        map index '@typeMapIndex'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapIndex GGS_typeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
operator_isEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
operator_isNotEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapIndex::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @typeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_typeMap & ioMap,
                               GGS_typeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

const utf32 GGS_typeMapIndex::kMapIndexSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
method_searchKey (C_Compiler & inLexique,
                   GGS_lstring & outKey,
                   GGS_ACGalgasType & outAttribute1
                   COMMA_LOCATION_ARGS) const {
  bool shouldDropArguments = true ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      AC_galgas_map::emitMapSemanticErrorMessage (inLexique, mKey,
                                                  kMapIndexSearchMessage_searchKey
                                                  COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_typeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_typeMap * p = (const elementOf_GGS_typeMap *) mIndex.retrieve () ;
      outKey = mKey ;
      outAttribute1 = p->mInfo.mType ;
      shouldDropArguments = false ;
    }
    break ;
  case kNull:
    inLexique.onTheFlyRunTimeError ("key access on a null index" COMMA_THERE) ;
    break ;
  }
  if (shouldDropArguments) {
    outKey.drop () ;
    outAttribute1.drop () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@sortedTypeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedTypeList::
elementOf_GGS_sortedTypeList (const GGS_ACGalgasType & argument_0,
                                const GGS_string& argument_1):
mType (argument_0),
mSortString (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedTypeList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedTypeList * ptr = dynamic_cast <const elementOf_GGS_sortedTypeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mSortString.operator_isEqual (ptr->mSortString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_sortedTypeList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_sortedTypeList * operand = (const elementOf_GGS_sortedTypeList *) inOperand ;
  PMSInt32 result = mSortString.compareForSortedList (operand->mSortString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedTypeList::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortString.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@sortedTypeList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedTypeList::GGS_sortedTypeList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList::
GGS_sortedTypeList (const GGS_sortedTypeList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedTypeList::
operator_isEqual (const GGS_sortedTypeList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedTypeList::
operator_isNotEqual (const GGS_sortedTypeList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
_internalAppendValues (const GGS_ACGalgasType & argument_0,
                    const GGS_string& argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
addAssign_operation (const GGS_ACGalgasType & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList GGS_sortedTypeList::
operator_concat (const GGS_sortedTypeList & inOperand) const {
  GGS_sortedTypeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
dotAssign_operation (const GGS_sortedTypeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_sortedTypeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ACGalgasType  p_0 = p->mType ;
          GGS_string p_1 = p->mSortString ;
          _internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mType,
                                ptr->mSortString) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList  GGS_sortedTypeList::
constructor_emptySortedList (void) {
  GGS_sortedTypeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList  GGS_sortedTypeList::
constructor_sortedListWithValue (const GGS_ACGalgasType & argument_0,
                           const GGS_string& argument_1) {
  GGS_sortedTypeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedTypeList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@sortedTypeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
method_smallest (C_Compiler & inLexique,
                 GGS_ACGalgasType & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
method_greatest (C_Compiler & inLexique,
             GGS_ACGalgasType & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_ACGalgasType & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_ACGalgasType & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_ACGalgasType  & GGS_sortedTypeList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_sortedTypeList::cEnumerator::_mSortString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@typeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeList::
elementOf_GGS_typeList (const GGS_ACGalgasType & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeList * ptr = dynamic_cast <const elementOf_GGS_typeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             List '@typeList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeList::
_internalAppendValues (const GGS_ACGalgasType & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
_internalPrependValues (const GGS_ACGalgasType & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
addAssign_operation (const GGS_ACGalgasType & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
operator_concat (const GGS_typeList & inOperand) const {
  GGS_typeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
dotAssign_operation (const GGS_typeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ACGalgasType  p_0 = p->mType ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_ACGalgasType & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mType
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeList  GGS_typeList::
constructor_emptyList (void) {
  GGS_typeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList  GGS_typeList::
constructor_listWithValue (const GGS_ACGalgasType & argument_0) {
  GGS_typeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
internalSubListWithRange (GGS_typeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
method_first (C_Compiler & inLexique,
              GGS_ACGalgasType & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
method_last (C_Compiler & inLexique,
             GGS_ACGalgasType & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_ACGalgasType & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_ACGalgasType & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_ACGalgasType  GGS_typeList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_ACGalgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_ACGalgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_ACGalgasType  & GGS_typeList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@signature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_signature::
elementOf_GGS_signature (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mFormalArgumentName (argument_1),
mFormalArgumentPassingMode (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_signature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_signature * ptr = dynamic_cast <const elementOf_GGS_signature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_signature::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@signature'                              *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_signature::
_internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalArgumentPassingMode& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
_internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalArgumentPassingMode& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
operator_concat (const GGS_signature & inOperand) const {
  GGS_signature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
dotAssign_operation (const GGS_signature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_signature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mFormalArgumentName ;
          GGS_formalArgumentPassingMode p_2 = p->mFormalArgumentPassingMode ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalArgumentPassingMode& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mFormalArgumentName,
                                ptr->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_signature::
constructor_emptyList (void) {
  GGS_signature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_signature::
constructor_listWithValue (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2) {
  GGS_signature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
internalSubListWithRange (GGS_signature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mFormalArgumentName, ptr->mFormalArgumentPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_signature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_signature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_signature::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@signature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
method_first (C_Compiler & inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1,
              GGS_formalArgumentPassingMode& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
method_last (C_Compiler & inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1,
             GGS_formalArgumentPassingMode& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalArgumentPassingMode& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1,
                GGS_formalArgumentPassingMode& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_signature::
reader_mAttributeTypeIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_signature::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingMode GGS_signature::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingMode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_setMAttributeTypeIndexAtIndex (C_Compiler & inLexique,
                              const GGS_typeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_signature::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_signature::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingMode & GGS_signature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@attributeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeList::
elementOf_GGS_attributeList (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeList * ptr = dynamic_cast <const elementOf_GGS_attributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@attributeList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_attributeList::
_internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
operator_concat (const GGS_attributeList & inOperand) const {
  GGS_attributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
dotAssign_operation (const GGS_attributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_attributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mAttributeName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_emptyList (void) {
  GGS_attributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_listWithValue (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_attributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
internalSubListWithRange (GGS_attributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@attributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_first (C_Compiler & inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_last (C_Compiler & inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_attributeList::
reader_mAttributeTypeIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_setMAttributeTypeIndexAtIndex (C_Compiler & inLexique,
                              const GGS_typeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_attributeList::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_locationGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_locationGalgasType::
cPtr_locationGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_locationGalgasType * GGS_locationGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_locationGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_locationGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_locationGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_locationGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@locationGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_locationGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_locationGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_locationGalgasType (& typeid (cPtr_locationGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_locationGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__locationGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_locationGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_locationGalgasType::
GGS_locationGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType::
GGS_locationGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_locationGalgasType GGS_locationGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_locationGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_locationGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_locationGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_locationGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_locationGalgasType * gSingleton_locationGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_locationGalgasType (void) {
  macroDetachPointer (gSingleton_locationGalgasType, cPtr_locationGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType GGS_locationGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType result ;
  if (NULL == gSingleton_locationGalgasType) {
    macroMyNew (gSingleton_locationGalgasType, cPtr_locationGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_locationGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_locationGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_locationGalgasType::actualTypeName (void) const {
  return "locationGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__locationGalgasType ("locationGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_stringGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringGalgasType::
cPtr_stringGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringGalgasType * GGS_stringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@stringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringGalgasType (& typeid (cPtr_stringGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_stringGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__stringGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_stringGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringGalgasType GGS_stringGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_stringGalgasType * gSingleton_stringGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_stringGalgasType (void) {
  macroDetachPointer (gSingleton_stringGalgasType, cPtr_stringGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType GGS_stringGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  if (NULL == gSingleton_stringGalgasType) {
    macroMyNew (gSingleton_stringGalgasType, cPtr_stringGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_stringGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_stringGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringGalgasType::actualTypeName (void) const {
  return "stringGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__stringGalgasType ("stringGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_charGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charGalgasType::
cPtr_charGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charGalgasType * GGS_charGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_charGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_charGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_charGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@charGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charGalgasType (& typeid (cPtr_charGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_charGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__charGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_charGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_charGalgasType GGS_charGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_charGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_charGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_charGalgasType * gSingleton_charGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_charGalgasType (void) {
  macroDetachPointer (gSingleton_charGalgasType, cPtr_charGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType GGS_charGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  if (NULL == gSingleton_charGalgasType) {
    macroMyNew (gSingleton_charGalgasType, cPtr_charGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_charGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_charGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charGalgasType::actualTypeName (void) const {
  return "charGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__charGalgasType ("charGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_boolGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolGalgasType::
cPtr_boolGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolGalgasType * GGS_boolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_boolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_boolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_boolGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@boolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolGalgasType (& typeid (cPtr_boolGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_boolGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__boolGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_boolGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_boolGalgasType GGS_boolGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_boolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_boolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_boolGalgasType * gSingleton_boolGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_boolGalgasType (void) {
  macroDetachPointer (gSingleton_boolGalgasType, cPtr_boolGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType GGS_boolGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  if (NULL == gSingleton_boolGalgasType) {
    macroMyNew (gSingleton_boolGalgasType, cPtr_boolGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_boolGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_boolGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolGalgasType::actualTypeName (void) const {
  return "boolGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__boolGalgasType ("boolGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_uintGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintGalgasType::
cPtr_uintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintGalgasType * GGS_uintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uintGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@uintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintGalgasType (& typeid (cPtr_uintGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__uintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_uintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uintGalgasType GGS_uintGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_uintGalgasType * gSingleton_uintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_uintGalgasType (void) {
  macroDetachPointer (gSingleton_uintGalgasType, cPtr_uintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType GGS_uintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  if (NULL == gSingleton_uintGalgasType) {
    macroMyNew (gSingleton_uintGalgasType, cPtr_uintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_uintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_uintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintGalgasType::actualTypeName (void) const {
  return "uintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uintGalgasType ("uintGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_sintGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintGalgasType::
cPtr_sintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintGalgasType * GGS_sintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sintGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@sintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintGalgasType (& typeid (cPtr_sintGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__sintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_sintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sintGalgasType GGS_sintGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_sintGalgasType * gSingleton_sintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_sintGalgasType (void) {
  macroDetachPointer (gSingleton_sintGalgasType, cPtr_sintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType GGS_sintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  if (NULL == gSingleton_sintGalgasType) {
    macroMyNew (gSingleton_sintGalgasType, cPtr_sintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_sintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_sintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintGalgasType::actualTypeName (void) const {
  return "sintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sintGalgasType ("sintGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_uint64GalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64GalgasType::
cPtr_uint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64GalgasType * GGS_uint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64GalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@uint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64GalgasType (& typeid (cPtr_uint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__uint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64GalgasType GGS_uint64GalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_uint64GalgasType * gSingleton_uint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_uint64GalgasType (void) {
  macroDetachPointer (gSingleton_uint64GalgasType, cPtr_uint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType GGS_uint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  if (NULL == gSingleton_uint64GalgasType) {
    macroMyNew (gSingleton_uint64GalgasType, cPtr_uint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_uint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_uint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64GalgasType::actualTypeName (void) const {
  return "uint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64GalgasType ("uint64GalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_sint64GalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64GalgasType::
cPtr_sint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64GalgasType * GGS_sint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64GalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@sint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64GalgasType (& typeid (cPtr_sint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__sint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64GalgasType GGS_sint64GalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_sint64GalgasType * gSingleton_sint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_sint64GalgasType (void) {
  macroDetachPointer (gSingleton_sint64GalgasType, cPtr_sint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType GGS_sint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  if (NULL == gSingleton_sint64GalgasType) {
    macroMyNew (gSingleton_sint64GalgasType, cPtr_sint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_sint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_sint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64GalgasType::actualTypeName (void) const {
  return "sint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64GalgasType ("sint64GalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_doubleGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doubleGalgasType::
cPtr_doubleGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doubleGalgasType * GGS_doubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_doubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_doubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_doubleGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@doubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doubleGalgasType (& typeid (cPtr_doubleGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_doubleGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__doubleGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_doubleGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_doubleGalgasType GGS_doubleGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_doubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_doubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_doubleGalgasType * gSingleton_doubleGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_doubleGalgasType (void) {
  macroDetachPointer (gSingleton_doubleGalgasType, cPtr_doubleGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType GGS_doubleGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  if (NULL == gSingleton_doubleGalgasType) {
    macroMyNew (gSingleton_doubleGalgasType, cPtr_doubleGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_doubleGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_doubleGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doubleGalgasType::actualTypeName (void) const {
  return "doubleGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__doubleGalgasType ("doubleGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_lstringGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lstringGalgasType::
cPtr_lstringGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lstringGalgasType * GGS_lstringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lstringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lstringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lstringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lstringGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lstringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lstringGalgasType (& typeid (cPtr_lstringGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lstringGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lstringGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lstringGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lstringGalgasType GGS_lstringGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lstringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lstringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lstringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lstringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lstringGalgasType * gSingleton_lstringGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lstringGalgasType (void) {
  macroDetachPointer (gSingleton_lstringGalgasType, cPtr_lstringGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType GGS_lstringGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  if (NULL == gSingleton_lstringGalgasType) {
    macroMyNew (gSingleton_lstringGalgasType, cPtr_lstringGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lstringGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lstringGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lstringGalgasType::actualTypeName (void) const {
  return "lstringGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lstringGalgasType ("lstringGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_lcharGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lcharGalgasType::
cPtr_lcharGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lcharGalgasType * GGS_lcharGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lcharGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lcharGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lcharGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lcharGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lcharGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lcharGalgasType (& typeid (cPtr_lcharGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lcharGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lcharGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lcharGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lcharGalgasType GGS_lcharGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lcharGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lcharGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lcharGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lcharGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lcharGalgasType * gSingleton_lcharGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lcharGalgasType (void) {
  macroDetachPointer (gSingleton_lcharGalgasType, cPtr_lcharGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType GGS_lcharGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  if (NULL == gSingleton_lcharGalgasType) {
    macroMyNew (gSingleton_lcharGalgasType, cPtr_lcharGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lcharGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lcharGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lcharGalgasType::actualTypeName (void) const {
  return "lcharGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lcharGalgasType ("lcharGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_lboolGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lboolGalgasType::
cPtr_lboolGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lboolGalgasType * GGS_lboolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lboolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lboolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lboolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lboolGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lboolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lboolGalgasType (& typeid (cPtr_lboolGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lboolGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lboolGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lboolGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lboolGalgasType GGS_lboolGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lboolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lboolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lboolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lboolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lboolGalgasType * gSingleton_lboolGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lboolGalgasType (void) {
  macroDetachPointer (gSingleton_lboolGalgasType, cPtr_lboolGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType GGS_lboolGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  if (NULL == gSingleton_lboolGalgasType) {
    macroMyNew (gSingleton_lboolGalgasType, cPtr_lboolGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lboolGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lboolGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lboolGalgasType::actualTypeName (void) const {
  return "lboolGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lboolGalgasType ("lboolGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_luintGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luintGalgasType::
cPtr_luintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luintGalgasType * GGS_luintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luintGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@luintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luintGalgasType (& typeid (cPtr_luintGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_luintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__luintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_luintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_luintGalgasType GGS_luintGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_luintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_luintGalgasType * gSingleton_luintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_luintGalgasType (void) {
  macroDetachPointer (gSingleton_luintGalgasType, cPtr_luintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType GGS_luintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  if (NULL == gSingleton_luintGalgasType) {
    macroMyNew (gSingleton_luintGalgasType, cPtr_luintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_luintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_luintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luintGalgasType::actualTypeName (void) const {
  return "luintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__luintGalgasType ("luintGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_lsintGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsintGalgasType::
cPtr_lsintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsintGalgasType * GGS_lsintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsintGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lsintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsintGalgasType (& typeid (cPtr_lsintGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lsintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lsintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lsintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lsintGalgasType GGS_lsintGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lsintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lsintGalgasType * gSingleton_lsintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lsintGalgasType (void) {
  macroDetachPointer (gSingleton_lsintGalgasType, cPtr_lsintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType GGS_lsintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  if (NULL == gSingleton_lsintGalgasType) {
    macroMyNew (gSingleton_lsintGalgasType, cPtr_lsintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lsintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lsintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsintGalgasType::actualTypeName (void) const {
  return "lsintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lsintGalgasType ("lsintGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_luint64GalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luint64GalgasType::
cPtr_luint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luint64GalgasType * GGS_luint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luint64GalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@luint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luint64GalgasType (& typeid (cPtr_luint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_luint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__luint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_luint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_luint64GalgasType GGS_luint64GalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_luint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_luint64GalgasType * gSingleton_luint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_luint64GalgasType (void) {
  macroDetachPointer (gSingleton_luint64GalgasType, cPtr_luint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType GGS_luint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  if (NULL == gSingleton_luint64GalgasType) {
    macroMyNew (gSingleton_luint64GalgasType, cPtr_luint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_luint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_luint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luint64GalgasType::actualTypeName (void) const {
  return "luint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__luint64GalgasType ("luint64GalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_lsint64GalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsint64GalgasType::
cPtr_lsint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsint64GalgasType * GGS_lsint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsint64GalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lsint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsint64GalgasType (& typeid (cPtr_lsint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lsint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lsint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lsint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lsint64GalgasType GGS_lsint64GalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lsint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lsint64GalgasType * gSingleton_lsint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lsint64GalgasType (void) {
  macroDetachPointer (gSingleton_lsint64GalgasType, cPtr_lsint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType GGS_lsint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  if (NULL == gSingleton_lsint64GalgasType) {
    macroMyNew (gSingleton_lsint64GalgasType, cPtr_lsint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lsint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lsint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsint64GalgasType::actualTypeName (void) const {
  return "lsint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lsint64GalgasType ("lsint64GalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ldoubleGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ldoubleGalgasType::
cPtr_ldoubleGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ldoubleGalgasType * GGS_ldoubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ldoubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ldoubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ldoubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_ldoubleGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ldoubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ldoubleGalgasType (& typeid (cPtr_ldoubleGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ldoubleGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__ldoubleGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ldoubleGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ldoubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ldoubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ldoubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ldoubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_ldoubleGalgasType * gSingleton_ldoubleGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_ldoubleGalgasType (void) {
  macroDetachPointer (gSingleton_ldoubleGalgasType, cPtr_ldoubleGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  if (NULL == gSingleton_ldoubleGalgasType) {
    macroMyNew (gSingleton_ldoubleGalgasType, cPtr_ldoubleGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_ldoubleGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_ldoubleGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ldoubleGalgasType::actualTypeName (void) const {
  return "ldoubleGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ldoubleGalgasType ("ldoubleGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_stringsetGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetGalgasType::
cPtr_stringsetGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetGalgasType * GGS_stringsetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringsetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringsetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@stringsetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetGalgasType (& typeid (cPtr_stringsetGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_stringsetGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__stringsetGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_stringsetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringsetGalgasType GGS_stringsetGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringsetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_stringsetGalgasType * gSingleton_stringsetGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_stringsetGalgasType (void) {
  macroDetachPointer (gSingleton_stringsetGalgasType, cPtr_stringsetGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType GGS_stringsetGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  if (NULL == gSingleton_stringsetGalgasType) {
    macroMyNew (gSingleton_stringsetGalgasType, cPtr_stringsetGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_stringsetGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_stringsetGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetGalgasType::actualTypeName (void) const {
  return "stringsetGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__stringsetGalgasType ("stringsetGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_binarysetGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetGalgasType::
cPtr_binarysetGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetGalgasType * GGS_binarysetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_binarysetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_binarysetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetGalgasType::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@binarysetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetGalgasType (& typeid (cPtr_binarysetGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_binarysetGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__binarysetGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_binarysetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_binarysetGalgasType GGS_binarysetGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_binarysetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_binarysetGalgasType * gSingleton_binarysetGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_binarysetGalgasType (void) {
  macroDetachPointer (gSingleton_binarysetGalgasType, cPtr_binarysetGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType GGS_binarysetGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  if (NULL == gSingleton_binarysetGalgasType) {
    macroMyNew (gSingleton_binarysetGalgasType, cPtr_binarysetGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_binarysetGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_binarysetGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetGalgasType::actualTypeName (void) const {
  return "binarysetGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__binarysetGalgasType ("binarysetGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@classMethodList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMethodList::
elementOf_GGS_classMethodList (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mMethodSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classMethodList * ptr = dynamic_cast <const elementOf_GGS_classMethodList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mMethodSignature.operator_isEqual (ptr->mMethodSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMethodList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodSignature.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@classMethodList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_classMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_signature & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_signature & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
operator_concat (const GGS_classMethodList & inOperand) const {
  GGS_classMethodList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
dotAssign_operation (const GGS_classMethodList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_classMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_signature  p_1 = p->mMethodSignature ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_signature & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mMethodName,
                                ptr->mMethodSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classMethodList::
constructor_emptyList (void) {
  GGS_classMethodList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1) {
  GGS_classMethodList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
internalSubListWithRange (GGS_classMethodList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mMethodSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classMethodList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classMethodList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMethodList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@classMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_signature & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_signature & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_signature & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_signature & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMethodList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_classMethodList::
reader_mMethodSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_signature  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_setMMethodSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_signature  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_classMethodList::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signature  & GGS_classMethodList::cEnumerator::_mMethodSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_classGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classGalgasType::
cPtr_classGalgasType (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeMapIndex & argument_2,
                                const GGS_attributeList & argument_3,
                                const GGS_classMethodList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mIsAbstract (argument_0),
mClassName (argument_1),
mSuperClassIndex (argument_2),
mAttributeList (argument_3),
mMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classGalgasType * GGS_classGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classGalgasType * ptr = dynamic_cast <const cPtr_classGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mSuperClassIndex.operator_isEqual (ptr->mSuperClassIndex).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
method_checkTypeCrossReferences (C_Compiler & inLexique,
                                GGS_uint  var_cas_inTypeCount COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_classPath = mClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (502)) ;
  GGS_stringset  var_cas_superClassSet = GGS_stringset ::constructor_setWithString (mClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (503))) ;
  GGS_typeMapIndex  var_cas_superClassIndex = mSuperClassIndex ;
  GGS_bool var_cas_circularityError = GGS_bool (false) ;
  GGS_bool var_cas_ok = GGS_bool (true) ;
  GGS_uint _variant_26713 = var_cas_inTypeCount ;
  GGS_bool _condition_26713 (_variant_26713.isBuilt (), true) ;
  while (_condition_26713.isBuiltAndTrue ()) {
    _condition_26713 = ((var_cas_superClassIndex.reader_isRegular (inLexique COMMA_SOURCE_FILE_AT_LINE (508))).operator_and (var_cas_ok)).operator_and ((var_cas_circularityError).operator_not ()) ;
    if (_condition_26713.isBuiltAndTrue ()) {
      if (_variant_26713.uintValue () == 0) {
        inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (529)) ;
        _condition_26713 = GGS_bool (false) ;
      }else{
        _variant_26713.decrement_operation (inLexique COMMA_HERE) ;
        GGS_lstring  var_cas_superClassName ;
        GGS_ACGalgasType  var_cas_t ;
        const GGS_typeMapIndex  temp_25968 = var_cas_superClassIndex ;
        if (temp_25968.isBuilt ()) {
          temp_25968 (HERE)->method_searchKey (inLexique, var_cas_superClassName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (512)) ;
        }
        var_cas_circularityError = var_cas_superClassSet.reader_hasKey (inLexique, var_cas_superClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (514)) COMMA_SOURCE_FILE_AT_LINE (514)) ;
        var_cas_superClassSet.addAssign_operation (var_cas_superClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (515))) ;
        var_cas_classPath.appendCString (".") ;
        var_cas_classPath.dotAssign_operation (var_cas_superClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (516))) ;
        GGS_typeMapIndex  var_cas_superSuperClassIndex ;
        { const GGS_ACGalgasType _var_26650 = var_cas_t ; // CAST instruction
          if (_var_26650.getPtr () != NULL) {
            macroValidPointer (_var_26650.getPtr ()) ;
            if (dynamic_cast <cPtr_classGalgasType *> (_var_26650.getPtr ()) != NULL) {
              const GGS_classGalgasType var_cas_kClassType (_var_26650.getPtr ()) ;
              var_cas_superSuperClassIndex = var_cas_kClassType.reader_mSuperClassIndex (inLexique COMMA_SOURCE_FILE_AT_LINE (521)) ;
            }else{
              mClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this class inherits from @")).operator_concat (var_cas_superClassName)).operator_concat (GGS_string (", but @"))).operator_concat (var_cas_superClassName)).operator_concat (GGS_string (" is not a class")) COMMA_SOURCE_FILE_AT_LINE (527)) ;
              var_cas_superSuperClassIndex.drop () ;
            }
          }
        }
        var_cas_superClassIndex = var_cas_superSuperClassIndex ;
      }
    }
  }
  const GGS_bool cond_26960 = var_cas_circularityError ;
  if (cond_26960.isBuiltAndTrue ()) {
    mClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("inheritance circularity for class '")).operator_concat (mClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (534)))).operator_concat (GGS_string ("': "))).operator_concat (var_cas_classPath.reader_stringByReplacingStringByString (inLexique, GGS_string ("."), GGS_string (" extends ") COMMA_SOURCE_FILE_AT_LINE (535))) COMMA_SOURCE_FILE_AT_LINE (536)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classGalgasType:"
           << mIsAbstract.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classGalgasType (& typeid (cPtr_classGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_classGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__classGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classGalgasType (mIsAbstract, mClassName, mSuperClassIndex, mAttributeList, mMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classGalgasType GGS_classGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_classGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType GGS_classGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeMapIndex & argument_2,
                 const GGS_attributeList & argument_3,
                 const GGS_classMethodList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  macroMyNew (result.mPointer, cPtr_classGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classGalgasType::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_classGalgasType::
reader_mSuperClassIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mSuperClassIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classGalgasType::actualTypeName (void) const {
  return "classGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__classGalgasType ("classGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_listGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listGalgasType::
cPtr_listGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listGalgasType * GGS_listGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listGalgasType * ptr = dynamic_cast <const cPtr_listGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listGalgasType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@listGalgasType:"
           << mListTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listGalgasType (& typeid (cPtr_listGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_listGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__listGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listGalgasType (mListTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_listGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listGalgasType GGS_listGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_listGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType GGS_listGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  macroMyNew (result.mPointer, cPtr_listGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listGalgasType::actualTypeName (void) const {
  return "listGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__listGalgasType ("listGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_listmapGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapGalgasType::
cPtr_listmapGalgasType (const GGS_lstring & argument_0,
                                const GGS_typeMapIndex & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListmapTypeName (argument_0),
mAssociatedListTypeIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapGalgasType * GGS_listmapGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listmapGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapGalgasType * ptr = dynamic_cast <const cPtr_listmapGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mAssociatedListTypeIndex.operator_isEqual (ptr->mAssociatedListTypeIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapGalgasType::
method_checkTypeCrossReferences (C_Compiler & inLexique,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring  var_cas_listTypeName ;
  GGS_ACGalgasType  var_cas_t ;
  const GGS_typeMapIndex  temp_28230 = mAssociatedListTypeIndex ;
  if (temp_28230.isBuilt ()) {
    temp_28230 (HERE)->method_searchKey (inLexique, var_cas_listTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (565)) ;
  }
  { const GGS_ACGalgasType _var_28499 = var_cas_t ; // CAST instruction
    if (_var_28499.getPtr () != NULL) {
      macroValidPointer (_var_28499.getPtr ()) ;
      if (dynamic_cast <cPtr_listGalgasType *> (_var_28499.getPtr ()) != NULL) {
      }else{
        var_cas_listTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this mapindex type refers to @")).operator_concat (var_cas_listTypeName)).operator_concat (GGS_string (" as a list, but @"))).operator_concat (var_cas_listTypeName)).operator_concat (GGS_string (" is not a list")) COMMA_SOURCE_FILE_AT_LINE (573)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_listmapGalgasType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@listmapGalgasType:"
           << mListmapTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAssociatedListTypeIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapGalgasType (& typeid (cPtr_listmapGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_listmapGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__listmapGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapGalgasType (mListmapTypeName, mAssociatedListTypeIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_listmapGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listmapGalgasType::
GGS_listmapGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapGalgasType::
GGS_listmapGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapGalgasType GGS_listmapGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_listmapGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapGalgasType GGS_listmapGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeMapIndex & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listmapGalgasType result ;
  macroMyNew (result.mPointer, cPtr_listmapGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapGalgasType::actualTypeName (void) const {
  return "listmapGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__listmapGalgasType ("listmapGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_structGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structGalgasType::
cPtr_structGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structGalgasType * GGS_structGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_structGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structGalgasType * ptr = dynamic_cast <const cPtr_structGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructTypeName.operator_isEqual (ptr->mStructTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structGalgasType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@structGalgasType:"
           << mStructTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structGalgasType (& typeid (cPtr_structGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_structGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__structGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structGalgasType (mStructTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_structGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_structGalgasType::
GGS_structGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structGalgasType::
GGS_structGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structGalgasType GGS_structGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_structGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structGalgasType GGS_structGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structGalgasType result ;
  macroMyNew (result.mPointer, cPtr_structGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structGalgasType::actualTypeName (void) const {
  return "structGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__structGalgasType ("structGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sortDescriptorList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortDescriptorList::
elementOf_GGS_sortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortDescriptorList * ptr = dynamic_cast <const elementOf_GGS_sortDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortDescriptorList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@sortDescriptorList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
operator_concat (const GGS_sortDescriptorList & inOperand) const {
  GGS_sortDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
dotAssign_operation (const GGS_sortDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_sortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mAttributeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_emptyList (void) {
  GGS_sortDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_sortDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
internalSubListWithRange (GGS_sortDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@sortDescriptorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortDescriptorList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortDescriptorList::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sortDescriptorList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortDescriptorList::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_sortedlistGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedlistGalgasType::
cPtr_sortedlistGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1,
                                const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedlistGalgasType * GGS_sortedlistGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sortedlistGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedlistGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedlistGalgasType * ptr = dynamic_cast <const cPtr_sortedlistGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedlistGalgasType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sortedlistGalgasType:"
           << mListTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSortDescriptorList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedlistGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedlistGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedlistGalgasType (& typeid (cPtr_sortedlistGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sortedlistGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__sortedlistGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedlistGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedlistGalgasType (mListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sortedlistGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType::
GGS_sortedlistGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType::
GGS_sortedlistGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedlistGalgasType GGS_sortedlistGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedlistGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sortedlistGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedlistGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedlistGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType GGS_sortedlistGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1,
                 const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType result ;
  macroMyNew (result.mPointer, cPtr_sortedlistGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortedlistGalgasType::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortDescriptorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedlistGalgasType *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedlistGalgasType::actualTypeName (void) const {
  return "sortedlistGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sortedlistGalgasType ("sortedlistGalgasType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_mapType'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapType::
cPtr_mapType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapType * GGS_mapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapType * ptr = dynamic_cast <const cPtr_mapType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapType:"
           << mMapTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapType (& typeid (cPtr_mapType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_mapType::galgasRTTI (void) const {
  return & gClassInfoFor__mapType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapType (mMapTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_mapType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapType::
GGS_mapType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapType::
GGS_mapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapType GGS_mapType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapType *> (inPointer) != NULL)
      : (typeid (cPtr_mapType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapType GGS_mapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_mapType result ;
  macroMyNew (result.mPointer, cPtr_mapType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapType::actualTypeName (void) const {
  return "mapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__mapType ("mapType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_mapindexType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexType::
cPtr_mapindexType (const GGS_lstring & argument_0,
                                const GGS_typeMapIndex & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapIndexTypeName (argument_0),
mIndexOfMapType (argument_1),
mSearchMethodName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexType * GGS_mapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexType * ptr = dynamic_cast <const cPtr_mapindexType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapIndexTypeName.operator_isEqual (ptr->mMapIndexTypeName).boolValue ()
         && mIndexOfMapType.operator_isEqual (ptr->mIndexOfMapType).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexType::
method_checkTypeCrossReferences (C_Compiler & inLexique,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring  var_cas_mapTypeName ;
  GGS_ACGalgasType  var_cas_t ;
  const GGS_typeMapIndex  temp_31069 = mIndexOfMapType ;
  if (temp_31069.isBuilt ()) {
    temp_31069 (HERE)->method_searchKey (inLexique, var_cas_mapTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (632)) ;
  }
  { const GGS_ACGalgasType _var_31323 = var_cas_t ; // CAST instruction
    if (_var_31323.getPtr () != NULL) {
      macroValidPointer (_var_31323.getPtr ()) ;
      if (dynamic_cast <cPtr_mapType *> (_var_31323.getPtr ()) != NULL) {
      }else{
        var_cas_mapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this mapindex type refers to @")).operator_concat (var_cas_mapTypeName)).operator_concat (GGS_string (" as a map, but @"))).operator_concat (var_cas_mapTypeName)).operator_concat (GGS_string (" is not a map")) COMMA_SOURCE_FILE_AT_LINE (640)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_mapindexType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapindexType:"
           << mMapIndexTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIndexOfMapType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexType (& typeid (cPtr_mapindexType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_mapindexType::galgasRTTI (void) const {
  return & gClassInfoFor__mapindexType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapindexType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapindexType (mMapIndexTypeName, mIndexOfMapType, mSearchMethodName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mapindexType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapindexType GGS_mapindexType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType GGS_mapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeMapIndex & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  macroMyNew (result.mPointer, cPtr_mapindexType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexType::actualTypeName (void) const {
  return "mapindexType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__mapindexType ("mapindexType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@enumConstructorMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumConstructorMap::
elementOf_GGS_enumConstructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstructorMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumConstructorMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstructorMap * info = (e_enumConstructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumConstructorMap * info = (e_enumConstructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumConstructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstructorMap::
operator_isEqual (const GGS_enumConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstructorMap::
operator_isNotEqual (const GGS_enumConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumConstructorMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumConstructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (','),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumConstructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumConstructorMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumConstructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_enumType'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumType::
cPtr_enumType (const GGS_lstring & argument_0,
                                const GGS_enumConstructorMap & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstructorMap (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumType * GGS_enumType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumType * ptr = dynamic_cast <const cPtr_enumType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mEnumConstructorMap.operator_isEqual (ptr->mEnumConstructorMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumType:"
           << mEnumTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEnumConstructorMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumType (& typeid (cPtr_enumType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_enumType::galgasRTTI (void) const {
  return & gClassInfoFor__enumType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumType (mEnumTypeName, mEnumConstructorMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_enumType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumType::
GGS_enumType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumType::
GGS_enumType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumType GGS_enumType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumType *> (inPointer) != NULL)
      : (typeid (cPtr_enumType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumType GGS_enumType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstructorMap & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumType result ;
  macroMyNew (result.mPointer, cPtr_enumType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumType::actualTypeName (void) const {
  return "enumType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__enumType ("enumType", gClassInfoFor__ACGalgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultTypeIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultTypeIndex.operator_isEqual (ptr->mInfo.mResultTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signature & inParameter0,
                const GGS_typeMapIndex & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultTypeIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signature   & outParameter0,
               GGS_typeMapIndex   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signature   & outParameter0,
                                GGS_typeMapIndex   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signature & inParameter0,
                                const GGS_typeMapIndex & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signature  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_functionMap::cEnumerator::_mResultTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultTypeIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@classIndexList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classIndexList::
elementOf_GGS_classIndexList (const GGS_typeMapIndex & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mClassMapindex (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classIndexList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classIndexList * ptr = dynamic_cast <const elementOf_GGS_classIndexList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassMapindex.operator_isEqual (ptr->mClassMapindex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classIndexList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassMapindex.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@classIndexList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_classIndexList::
_internalAppendValues (const GGS_typeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
_internalPrependValues (const GGS_typeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
addAssign_operation (const GGS_typeMapIndex & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::
operator_concat (const GGS_classIndexList & inOperand) const {
  GGS_classIndexList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
dotAssign_operation (const GGS_classIndexList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_classIndexList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mClassMapindex ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeMapIndex & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mClassMapindex
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList  GGS_classIndexList::
constructor_emptyList (void) {
  GGS_classIndexList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classIndexList  GGS_classIndexList::
constructor_listWithValue (const GGS_typeMapIndex & argument_0) {
  GGS_classIndexList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
internalSubListWithRange (GGS_classIndexList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mClassMapindex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classIndexList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_classIndexList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classIndexList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classIndexList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@classIndexList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
method_first (C_Compiler & inLexique,
              GGS_typeMapIndex & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
method_last (C_Compiler & inLexique,
             GGS_typeMapIndex & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeMapIndex & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeMapIndex & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassMapindex ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_classIndexList::
reader_mClassMapindexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassMapindex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classIndexList::
modifier_setMClassMapindexAtIndex (C_Compiler & inLexique,
                              const GGS_typeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassMapindex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_classIndexList::cEnumerator::_mClassMapindex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mClassMapindex ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_classIndexList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_descendantClassListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_descendantClassListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_descendantClassListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
constructor_emptyMap (void) {
  GGS_descendantClassListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_descendantClassListMap::
_typeNameForDescriptionReader (void) const {
  return "@descendantClassListMap" ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
operator_concat (const GGS_descendantClassListMap & inOperand) const {
  GGS_descendantClassListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
dotAssign_operation (const GGS_descendantClassListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_classIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_typeMapIndex & inAttribute0) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_classIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classIndexList GGS_descendantClassListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classIndexList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_classIndexList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_descendantClassListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_descendantClassListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cEnumerator::
cEnumerator (const GGS_descendantClassListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_classIndexList & GGS_descendantClassListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mDescendantClassListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mDescendantClassListMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mDescendantClassListMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isEqual (inOperand.mTypeMap)
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mDescendantClassListMap.operator_isEqual (inOperand.mDescendantClassListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isNotEqual (inOperand.mTypeMap)
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mDescendantClassListMap.operator_isNotEqual (inOperand.mDescendantClassListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_typeMap & argument_0,
                 const GGS_routineMap & argument_1,
                 const GGS_functionMap & argument_2,
                 const GGS_descendantClassListMap& argument_3) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  result.mRoutineMap = argument_1 ;
  result.mFunctionMap = argument_2 ;
  result.mDescendantClassListMap = argument_3 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDescendantClassListMap " ;
    _s << mDescendantClassListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

