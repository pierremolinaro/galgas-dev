//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsSemantics.cpp'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 8th, 2007, at 16h19'10"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semanticsSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_ACGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ACGalgasType::
cPtr_ACGalgasType (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ACGalgasType * GGS_ACGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ACGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ACGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ACGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ACGalgasType (& typeid (cPtr_ACGalgasType), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ACGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ACGalgasType GGS_ACGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ACGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ACGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ACGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ACGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ACGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ACGalgasType::actualTypeName (void) const {
  return "ACGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@typeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeMap::
elementOf_GGS_typeMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeMap * _p = dynamic_cast <const elementOf_GGS_typeMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType._operator_isEqual (_p->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
_operator_isEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
_operator_isNotEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ACGalgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeMap info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ACGalgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ACGalgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' type is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ACGalgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' type has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        map index '@typeMapIndex'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapIndex GGS_typeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
_operator_isEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
_operator_isNotEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapIndex::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map index @typeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_typeMap & ioMap,
                               GGS_typeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
method_searchKey (C_Compiler & inLexique,
                   GGS_lstring & outKey,
                   GGS_ACGalgasType & outAttribute1
                   COMMA_LOCATION_ARGS) const {
  bool shouldDropArguments = true ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      AC_galgas_map::emitMapSemanticErrorMessage (inLexique, mKey, "the '@%K' type is not declared" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_typeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_typeMap * p = (const elementOf_GGS_typeMap *) mIndex.retrieve () ;
      outKey = mKey ;
      outAttribute1 = p->mInfo.mType ;
      shouldDropArguments = false ;
    }
    break ;
  case kNull:
    inLexique.onTheFlyRunTimeError ("key access on a null index" COMMA_THERE) ;
    break ;
  }
  if (shouldDropArguments) {
    outKey._drop_operation () ;
    outAttribute1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@attributeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeList::
elementOf_GGS_attributeList (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeList * _p = dynamic_cast <const elementOf_GGS_attributeList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeIndex._operator_isEqual (_p->mAttributeTypeIndex).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@attributeList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_attributeList::
_internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
_operator_concat (const GGS_attributeList & inOperand) const {
  GGS_attributeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_attributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeIndex,
                                _p->mAttributeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeMapIndex & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
internalSubListWithRange (GGS_attributeList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    element_type * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributeTypeIndex, _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@attributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_first (C_Compiler & _inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_last (C_Compiler & _inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeIndex ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_stringGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringGalgasType::
cPtr_stringGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringGalgasType * GGS_stringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@stringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringGalgasType (& typeid (cPtr_stringGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_stringGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_stringGalgasType GGS_stringGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_stringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType GGS_stringGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  macroMyNew (result.mPointer, cPtr_stringGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringGalgasType::actualTypeName (void) const {
  return "stringGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_charGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charGalgasType::
cPtr_charGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charGalgasType * GGS_charGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_charGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_charGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_charGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@charGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charGalgasType (& typeid (cPtr_charGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_charGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_charGalgasType GGS_charGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_charGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_charGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType GGS_charGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  macroMyNew (result.mPointer, cPtr_charGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charGalgasType::actualTypeName (void) const {
  return "charGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_boolGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolGalgasType::
cPtr_boolGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolGalgasType * GGS_boolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_boolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_boolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_boolGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@boolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolGalgasType (& typeid (cPtr_boolGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_boolGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_boolGalgasType GGS_boolGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_boolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_boolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType GGS_boolGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  macroMyNew (result.mPointer, cPtr_boolGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolGalgasType::actualTypeName (void) const {
  return "boolGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_uintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintGalgasType::
cPtr_uintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintGalgasType * GGS_uintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@uintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintGalgasType (& typeid (cPtr_uintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_uintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_uintGalgasType GGS_uintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_uintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType GGS_uintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  macroMyNew (result.mPointer, cPtr_uintGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintGalgasType::actualTypeName (void) const {
  return "uintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_sintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintGalgasType::
cPtr_sintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintGalgasType * GGS_sintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@sintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintGalgasType (& typeid (cPtr_sintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_sintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sintGalgasType GGS_sintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType GGS_sintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  macroMyNew (result.mPointer, cPtr_sintGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintGalgasType::actualTypeName (void) const {
  return "sintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_uint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64GalgasType::
cPtr_uint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64GalgasType * GGS_uint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@uint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64GalgasType (& typeid (cPtr_uint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_uint64GalgasType GGS_uint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_uint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType GGS_uint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  macroMyNew (result.mPointer, cPtr_uint64GalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64GalgasType::actualTypeName (void) const {
  return "uint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_sint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64GalgasType::
cPtr_sint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64GalgasType * GGS_sint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@sint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64GalgasType (& typeid (cPtr_sint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sint64GalgasType GGS_sint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType GGS_sint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  macroMyNew (result.mPointer, cPtr_sint64GalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64GalgasType::actualTypeName (void) const {
  return "sint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_doubleGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doubleGalgasType::
cPtr_doubleGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doubleGalgasType * GGS_doubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_doubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_doubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_doubleGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@doubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doubleGalgasType (& typeid (cPtr_doubleGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_doubleGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_doubleGalgasType GGS_doubleGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_doubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_doubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType GGS_doubleGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  macroMyNew (result.mPointer, cPtr_doubleGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doubleGalgasType::actualTypeName (void) const {
  return "doubleGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lstringGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lstringGalgasType::
cPtr_lstringGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lstringGalgasType * GGS_lstringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lstringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lstringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lstringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lstringGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lstringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lstringGalgasType (& typeid (cPtr_lstringGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lstringGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lstringGalgasType GGS_lstringGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lstringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lstringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lstringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lstringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType GGS_lstringGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  macroMyNew (result.mPointer, cPtr_lstringGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lstringGalgasType::actualTypeName (void) const {
  return "lstringGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_lcharGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lcharGalgasType::
cPtr_lcharGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lcharGalgasType * GGS_lcharGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lcharGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lcharGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lcharGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lcharGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lcharGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lcharGalgasType (& typeid (cPtr_lcharGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lcharGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lcharGalgasType GGS_lcharGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lcharGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lcharGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lcharGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lcharGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType GGS_lcharGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  macroMyNew (result.mPointer, cPtr_lcharGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lcharGalgasType::actualTypeName (void) const {
  return "lcharGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_lboolGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lboolGalgasType::
cPtr_lboolGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lboolGalgasType * GGS_lboolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lboolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lboolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lboolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lboolGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lboolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lboolGalgasType (& typeid (cPtr_lboolGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lboolGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lboolGalgasType GGS_lboolGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lboolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lboolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lboolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lboolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType GGS_lboolGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  macroMyNew (result.mPointer, cPtr_lboolGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lboolGalgasType::actualTypeName (void) const {
  return "lboolGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_luintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luintGalgasType::
cPtr_luintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luintGalgasType * GGS_luintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@luintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luintGalgasType (& typeid (cPtr_luintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_luintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_luintGalgasType GGS_luintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_luintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType GGS_luintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  macroMyNew (result.mPointer, cPtr_luintGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luintGalgasType::actualTypeName (void) const {
  return "luintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_lsintGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsintGalgasType::
cPtr_lsintGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsintGalgasType * GGS_lsintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsintGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lsintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsintGalgasType (& typeid (cPtr_lsintGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lsintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lsintGalgasType GGS_lsintGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lsintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType GGS_lsintGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  macroMyNew (result.mPointer, cPtr_lsintGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsintGalgasType::actualTypeName (void) const {
  return "lsintGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_luint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luint64GalgasType::
cPtr_luint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luint64GalgasType * GGS_luint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@luint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luint64GalgasType (& typeid (cPtr_luint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_luint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_luint64GalgasType GGS_luint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_luint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType GGS_luint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  macroMyNew (result.mPointer, cPtr_luint64GalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luint64GalgasType::actualTypeName (void) const {
  return "luint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lsint64GalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsint64GalgasType::
cPtr_lsint64GalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsint64GalgasType * GGS_lsint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsint64GalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lsint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsint64GalgasType (& typeid (cPtr_lsint64GalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lsint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lsint64GalgasType GGS_lsint64GalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lsint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType GGS_lsint64GalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  macroMyNew (result.mPointer, cPtr_lsint64GalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsint64GalgasType::actualTypeName (void) const {
  return "lsint64GalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_ldoubleGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ldoubleGalgasType::
cPtr_ldoubleGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ldoubleGalgasType * GGS_ldoubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ldoubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ldoubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ldoubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_ldoubleGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@ldoubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ldoubleGalgasType (& typeid (cPtr_ldoubleGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ldoubleGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ldoubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ldoubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ldoubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ldoubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  macroMyNew (result.mPointer, cPtr_ldoubleGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ldoubleGalgasType::actualTypeName (void) const {
  return "ldoubleGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_stringsetGalgasType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetGalgasType::
cPtr_stringsetGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetGalgasType * GGS_stringsetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringsetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringsetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@stringsetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetGalgasType (& typeid (cPtr_stringsetGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_stringsetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_stringsetGalgasType GGS_stringsetGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_stringsetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType GGS_stringsetGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  macroMyNew (result.mPointer, cPtr_stringsetGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetGalgasType::actualTypeName (void) const {
  return "stringsetGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_binarysetGalgasType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetGalgasType::
cPtr_binarysetGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetGalgasType * GGS_binarysetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_binarysetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_binarysetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetGalgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@binarysetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetGalgasType (& typeid (cPtr_binarysetGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_binarysetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_binarysetGalgasType GGS_binarysetGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_binarysetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType GGS_binarysetGalgasType::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  macroMyNew (result.mPointer, cPtr_binarysetGalgasType (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetGalgasType::actualTypeName (void) const {
  return "binarysetGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_classGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classGalgasType::
cPtr_classGalgasType (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeMapIndex & argument_2,
                                const GGS_attributeList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mIsAbstract (argument_0),
mClassName (argument_1),
mSuperClassIndex (argument_2),
mAttributeList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classGalgasType * GGS_classGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classGalgasType * _p = dynamic_cast <const cPtr_classGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mSuperClassIndex._operator_isEqual (_p->mSuperClassIndex).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classGalgasType:"
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classGalgasType (& typeid (cPtr_classGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_classGalgasType GGS_classGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_classGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_classGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType GGS_classGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeMapIndex & argument_2,
                 const GGS_attributeList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  macroMyNew (result.mPointer, cPtr_classGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classGalgasType::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classGalgasType::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_classGalgasType::
reader_mSuperClassIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mSuperClassIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_classGalgasType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classGalgasType::actualTypeName (void) const {
  return "classGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_listGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listGalgasType::
cPtr_listGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listGalgasType * GGS_listGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listGalgasType * _p = dynamic_cast <const cPtr_listGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@listGalgasType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listGalgasType (& typeid (cPtr_listGalgasType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_listGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_listGalgasType GGS_listGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_listGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_listGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType GGS_listGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  macroMyNew (result.mPointer, cPtr_listGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listGalgasType::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listGalgasType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_listGalgasType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listGalgasType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listGalgasType::actualTypeName (void) const {
  return "listGalgasType" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_mapindexType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexType::
cPtr_mapindexType (const GGS_lstring & argument_0,
                                const GGS_typeMapIndex & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapIndexName (argument_0),
mMapTypeIndex (argument_1),
mSearchMethodName (argument_2),
mSearchMethodErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexType * GGS_mapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexType * _p = dynamic_cast <const cPtr_mapindexType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapIndexName._operator_isEqual (_p->mMapIndexName).boolValue ()
         && mMapTypeIndex._operator_isEqual (_p->mMapTypeIndex).boolValue ()
         && mSearchMethodName._operator_isEqual (_p->mSearchMethodName).boolValue ()
         && mSearchMethodErrorMessage._operator_isEqual (_p->mSearchMethodErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapindexType:"
           << mMapIndexName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexType (& typeid (cPtr_mapindexType), & typeid (cPtr_ACGalgasType), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mapindexType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_mapindexType GGS_mapindexType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_mapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType GGS_mapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeMapIndex & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  macroMyNew (result.mPointer, cPtr_mapindexType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexType::
reader_mMapIndexName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mMapIndexName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_mapindexType::
reader_mMapTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mMapTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexType::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexType::
reader_mSearchMethodErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexType *) mPointer)->mSearchMethodErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexType::actualTypeName (void) const {
  return "mapindexType" ;
}

//---------------------------------------------------------------------------*

