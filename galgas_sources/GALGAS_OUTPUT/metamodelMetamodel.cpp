//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'metamodelMetamodel.cpp'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      june 24th, 2007, at 15h56'11"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "metamodelMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "metamodelMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("metamodelMetamodel", 4) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_metamodelMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@metamodelComponentRoot'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelComponentRoot::
cPtr_metamodelComponentRoot (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS__list_metamodelEntity & argument_4
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mMetamodelComponentName (argument_0),
mSuperMetamodels (argument_1),
mMetamodelRootEntityName (argument_2),
mMetamodelImportedComponents (argument_3),
mMetamodelEntities (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelComponentRoot * _p = dynamic_cast <const cPtr_metamodelComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMetamodelComponentName._operator_isEqual (_p->mMetamodelComponentName).boolValue ()
         && mSuperMetamodels._operator_isEqual (_p->mSuperMetamodels).boolValue ()
         && mMetamodelRootEntityName._operator_isEqual (_p->mMetamodelRootEntityName).boolValue ()
         && mMetamodelImportedComponents._operator_isEqual (_p->mMetamodelImportedComponents).boolValue ()
         && mMetamodelEntities._operator_isEqual (_p->mMetamodelEntities).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperMetamodels.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelRootEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelImportedComponents.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelEntities.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelComponentRoot::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelComponentRoot::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelComponentRoot::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelComponentRoot::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "metamodelComponentRoot" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelComponentRoot * cPtr_metamodelComponentRoot::
_cloneObject (void) const {
  cPtr_metamodelComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelComponentRoot (mMetamodelComponentName, mSuperMetamodels, mMetamodelRootEntityName, mMetamodelImportedComponents, mMetamodelEntities COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_metamodelComponentRoot'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_metamodelComponentRoot::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS__list_metamodelEntity & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelComponentRoot::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS__list_metamodelEntity & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelComponentRoot::
_addAssign_operation (const GGS_metamodelComponentRoot & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_metamodelComponentRoot *) inElement.getPtr ())->mMetamodelComponentName,
                                ((cPtr_metamodelComponentRoot *) inElement.getPtr ())->mSuperMetamodels,
                                ((cPtr_metamodelComponentRoot *) inElement.getPtr ())->mMetamodelRootEntityName,
                                ((cPtr_metamodelComponentRoot *) inElement.getPtr ())->mMetamodelImportedComponents,
                                ((cPtr_metamodelComponentRoot *) inElement.getPtr ())->mMetamodelEntities) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelComponentRoot GGS__list_metamodelComponentRoot::
_operator_concat (const GGS__list_metamodelComponentRoot & inOperand) const {
  GGS__list_metamodelComponentRoot result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMetamodelComponentName ;
          GGS_lstringlist  p_1 = p->mSuperMetamodels ;
          GGS_lstring  p_2 = p->mMetamodelRootEntityName ;
          GGS_lstringlist  p_3 = p->mMetamodelImportedComponents ;
          GGS__list_metamodelEntity  p_4 = p->mMetamodelEntities ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelComponentRoot::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS__list_metamodelEntity & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelComponentRoot::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMetamodelComponentName,
                                _p->mSuperMetamodels,
                                _p->mMetamodelRootEntityName,
                                _p->mMetamodelImportedComponents,
                                _p->mMetamodelEntities) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelComponentRoot  GGS__list_metamodelComponentRoot::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelComponentRoot result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_metamodelComponentRoot  GGS__list_metamodelComponentRoot::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstringlist & argument_3,
                           const GGS__list_metamodelEntity & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelComponentRoot result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_metamodelComponentRoot::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_metamodelComponentRoot", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelComponentRoot::
_addModel (const GGS_metamodelComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelComponentRoot::
method_first (C_Compiler & _inLexique,
              GGS_metamodelComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelComponentRoot::constructor_new (_inLexique,
       _p->mMetamodelComponentName,
       _p->mSuperMetamodels,
       _p->mMetamodelRootEntityName,
       _p->mMetamodelImportedComponents,
       _p->mMetamodelEntities) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelComponentRoot::
method_last (C_Compiler & _inLexique,
             GGS_metamodelComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelComponentRoot::constructor_new (_inLexique,
       _p->mMetamodelComponentName,
       _p->mSuperMetamodels,
       _p->mMetamodelRootEntityName,
       _p->mMetamodelImportedComponents,
       _p->mMetamodelEntities) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelComponentRoot::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_metamodelComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelComponentRoot::constructor_new (_inLexique,
       _p->mMetamodelComponentName,
       _p->mSuperMetamodels,
       _p->mMetamodelRootEntityName,
       _p->mMetamodelImportedComponents,
       _p->mMetamodelEntities) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelComponentRoot::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_metamodelComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelComponentRoot::constructor_new (_inLexique,
       _p->mMetamodelComponentName,
       _p->mSuperMetamodels,
       _p->mMetamodelRootEntityName,
       _p->mMetamodelImportedComponents,
       _p->mMetamodelEntities) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@metamodelComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelComponentRoot GGS_metamodelComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS__list_metamodelEntity & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_metamodelComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelComponentRoot::
reader_mMetamodelComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelComponentRoot *) mPointer)->mMetamodelComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelComponentRoot::
reader_mSuperMetamodels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelComponentRoot *) mPointer)->mSuperMetamodels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelComponentRoot::
reader_mMetamodelRootEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelComponentRoot *) mPointer)->mMetamodelRootEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelComponentRoot::
reader_mMetamodelImportedComponents (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelComponentRoot *) mPointer)->mMetamodelImportedComponents ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_metamodelEntity  GGS_metamodelComponentRoot::
reader_mMetamodelEntities (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_metamodelEntity   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelComponentRoot *) mPointer)->mMetamodelEntities ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_metamodelComponentRoot::actualTypeName (void) const {
 return "metamodelComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelComponentRoot * GGS_metamodelComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_metamodelComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@metamodelEntity'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelEntity::
cPtr_metamodelEntity (const GGS_lstringlist & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS__list_metamodelProperty & argument_3
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mEntityNameList (argument_0),
mSuperEntityName (argument_1),
mIsAbstract (argument_2),
mProperties (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelEntity::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelEntity * _p = dynamic_cast <const cPtr_metamodelEntity *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntityNameList._operator_isEqual (_p->mEntityNameList).boolValue ()
         && mSuperEntityName._operator_isEqual (_p->mSuperEntityName).boolValue ()
         && mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mProperties._operator_isEqual (_p->mProperties).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelEntity::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelEntity" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityNameList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mProperties.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelEntity::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelEntity::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelEntity::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelEntity::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "metamodelEntity" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelEntity * cPtr_metamodelEntity::
_cloneObject (void) const {
  cPtr_metamodelEntity * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelEntity (mEntityNameList, mSuperEntityName, mIsAbstract, mProperties COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_metamodelEntity'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_metamodelEntity::
_internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS__list_metamodelProperty & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelEntity::
_internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS__list_metamodelProperty & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelEntity::
_addAssign_operation (const GGS_metamodelEntity & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_metamodelEntity *) inElement.getPtr ())->mEntityNameList,
                                ((cPtr_metamodelEntity *) inElement.getPtr ())->mSuperEntityName,
                                ((cPtr_metamodelEntity *) inElement.getPtr ())->mIsAbstract,
                                ((cPtr_metamodelEntity *) inElement.getPtr ())->mProperties) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelEntity GGS__list_metamodelEntity::
_operator_concat (const GGS__list_metamodelEntity & inOperand) const {
  GGS__list_metamodelEntity result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelEntity * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mEntityNameList ;
          GGS_lstring  p_1 = p->mSuperEntityName ;
          GGS_bool p_2 = p->mIsAbstract ;
          GGS__list_metamodelProperty  p_3 = p->mProperties ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelEntity::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2,
                     const GGS__list_metamodelProperty & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelEntity::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntityNameList,
                                _p->mSuperEntityName,
                                _p->mIsAbstract,
                                _p->mProperties) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelEntity  GGS__list_metamodelEntity::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelEntity result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_metamodelEntity  GGS__list_metamodelEntity::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstringlist & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_bool& argument_2,
                           const GGS__list_metamodelProperty & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelEntity result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_metamodelEntity::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_metamodelEntity", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelEntity::
_addModel (const GGS_metamodelEntity & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelEntity::
method_first (C_Compiler & _inLexique,
              GGS_metamodelEntity & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelEntity::constructor_new (_inLexique,
       _p->mEntityNameList,
       _p->mSuperEntityName,
       _p->mIsAbstract,
       _p->mProperties) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelEntity::
method_last (C_Compiler & _inLexique,
             GGS_metamodelEntity & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelEntity::constructor_new (_inLexique,
       _p->mEntityNameList,
       _p->mSuperEntityName,
       _p->mIsAbstract,
       _p->mProperties) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelEntity::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_metamodelEntity & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelEntity::constructor_new (_inLexique,
       _p->mEntityNameList,
       _p->mSuperEntityName,
       _p->mIsAbstract,
       _p->mProperties) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelEntity::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_metamodelEntity & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelEntity::constructor_new (_inLexique,
       _p->mEntityNameList,
       _p->mSuperEntityName,
       _p->mIsAbstract,
       _p->mProperties) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@metamodelEntity'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelEntity GGS_metamodelEntity::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS__list_metamodelProperty & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelEntity result ;
  macroMyNew (result.mPointer, cPtr_metamodelEntity (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelEntity::
reader_mEntityNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelEntity *) mPointer)->mEntityNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelEntity::
reader_mSuperEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelEntity *) mPointer)->mSuperEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelEntity::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelEntity *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_metamodelProperty  GGS_metamodelEntity::
reader_mProperties (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_metamodelProperty   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelEntity *) mPointer)->mProperties ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_metamodelEntity::actualTypeName (void) const {
 return "metamodelEntity" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelEntity * GGS_metamodelEntity::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_metamodelEntity *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@metamodelProperty'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelProperty::
cPtr_metamodelProperty (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelProperty::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelProperty * _p = dynamic_cast <const cPtr_metamodelProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelProperty::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelProperty" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelProperty::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelProperty::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelProperty::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelProperty::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "metamodelProperty" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelProperty * cPtr_metamodelProperty::
_cloneObject (void) const {
  cPtr_metamodelProperty * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelProperty (mAttributeTypeName, mAttributeName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_metamodelProperty'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_metamodelProperty::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelProperty::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelProperty::
_addAssign_operation (const GGS_metamodelProperty & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_metamodelProperty *) inElement.getPtr ())->mAttributeTypeName,
                                ((cPtr_metamodelProperty *) inElement.getPtr ())->mAttributeName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelProperty GGS__list_metamodelProperty::
_operator_concat (const GGS__list_metamodelProperty & inOperand) const {
  GGS__list_metamodelProperty result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelProperty * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelProperty::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelProperty::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelProperty  GGS__list_metamodelProperty::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelProperty result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_metamodelProperty  GGS__list_metamodelProperty::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelProperty result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_metamodelProperty::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_metamodelProperty", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelProperty::
_addModel (const GGS_metamodelProperty & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelProperty::
method_first (C_Compiler & _inLexique,
              GGS_metamodelProperty & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelProperty::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelProperty::
method_last (C_Compiler & _inLexique,
             GGS_metamodelProperty & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelProperty::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelProperty::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_metamodelProperty & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelProperty::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelProperty::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_metamodelProperty & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelProperty::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@metamodelProperty'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelProperty GGS_metamodelProperty::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelProperty result ;
  macroMyNew (result.mPointer, cPtr_metamodelProperty (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelProperty::
reader_mAttributeTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelProperty *) mPointer)->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelProperty::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelProperty *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_metamodelProperty::actualTypeName (void) const {
 return "metamodelProperty" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelProperty * GGS_metamodelProperty::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_metamodelProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@metamodelMultipleReference'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelMultipleReference::
cPtr_metamodelMultipleReference (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_metamodelProperty (argument_0, argument_1 COMMA_THERE),
mLowerBound (argument_2),
mUpperBound (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelMultipleReference::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelMultipleReference * _p = dynamic_cast <const cPtr_metamodelMultipleReference *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue ()
         && mLowerBound._operator_isEqual (_p->mLowerBound).boolValue ()
         && mUpperBound._operator_isEqual (_p->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelMultipleReference::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelMultipleReference" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowerBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUpperBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelMultipleReference::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_metamodelProperty::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelMultipleReference::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_metamodelProperty::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_metamodelMultipleReference::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = cPtr_metamodelProperty::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelMultipleReference::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "metamodelMultipleReference" ;
  if (inLevel > 0) {
    result = cPtr_metamodelProperty::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelMultipleReference * cPtr_metamodelMultipleReference::
_cloneObject (void) const {
  cPtr_metamodelMultipleReference * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelMultipleReference (mAttributeTypeName, mAttributeName, mLowerBound, mUpperBound COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@_list_metamodelMultipleReference'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_metamodelMultipleReference::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelMultipleReference::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelMultipleReference::
_addAssign_operation (const GGS_metamodelMultipleReference & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_metamodelMultipleReference *) inElement.getPtr ())->mAttributeTypeName,
                                ((cPtr_metamodelMultipleReference *) inElement.getPtr ())->mAttributeName,
                                ((cPtr_metamodelMultipleReference *) inElement.getPtr ())->mLowerBound,
                                ((cPtr_metamodelMultipleReference *) inElement.getPtr ())->mUpperBound) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelMultipleReference GGS__list_metamodelMultipleReference::
_operator_concat (const GGS__list_metamodelMultipleReference & inOperand) const {
  GGS__list_metamodelMultipleReference result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelMultipleReference * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          GGS_uint  p_2 = p->mLowerBound ;
          GGS_uint  p_3 = p->mUpperBound ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelMultipleReference::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_uint & argument_2,
                     const GGS_uint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelMultipleReference::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName,
                                _p->mLowerBound,
                                _p->mUpperBound) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_metamodelMultipleReference  GGS__list_metamodelMultipleReference::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelMultipleReference result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_metamodelMultipleReference  GGS__list_metamodelMultipleReference::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_uint & argument_2,
                           const GGS_uint & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_metamodelMultipleReference result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_metamodelMultipleReference::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_metamodelMultipleReference", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_metamodelMultipleReference::
_addModel (const GGS_metamodelMultipleReference & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelMultipleReference::
method_first (C_Compiler & _inLexique,
              GGS_metamodelMultipleReference & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelMultipleReference::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelMultipleReference::
method_last (C_Compiler & _inLexique,
             GGS_metamodelMultipleReference & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelMultipleReference::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelMultipleReference::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_metamodelMultipleReference & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelMultipleReference::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_metamodelMultipleReference::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_metamodelMultipleReference & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_metamodelMultipleReference::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS entity '@metamodelMultipleReference'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelMultipleReference GGS_metamodelMultipleReference::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelMultipleReference result ;
  macroMyNew (result.mPointer, cPtr_metamodelMultipleReference (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_metamodelMultipleReference::
reader_mLowerBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMultipleReference *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMultipleReference *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_metamodelMultipleReference::
reader_mUpperBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMultipleReference *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMultipleReference *) mPointer)->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_metamodelMultipleReference::actualTypeName (void) const {
 return "metamodelMultipleReference" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelMultipleReference * GGS_metamodelMultipleReference::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_metamodelMultipleReference *) mPointer ;
  }
#endif

