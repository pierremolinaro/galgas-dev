//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'buildMapsForSemantics.cpp'                      *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 8th, 2007, at 22h3'45"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//#define TRACE_TREE_WALKING

//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "buildMapsForSemantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "buildMapsForSemantics.gTreewalking", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Treewalking routine prototype declaration                  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticsComponentRoot (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                const GGS_string  var_cas_inSourceFileDirectory,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_stringset  & var_cas_ioImportedComponentSet,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_semanticDeclaration (C_Compiler & _inLexique,
                                const cPtr_semanticDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_classDeclaration (C_Compiler & _inLexique,
                                const cPtr_classDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_enumDeclaration (C_Compiler & _inLexique,
                                const cPtr_enumDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_mapDeclaration (C_Compiler & _inLexique,
                                const cPtr_mapDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_listDeclaration (C_Compiler & _inLexique,
                                const cPtr_listDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_attributeInCollection (C_Compiler & _inLexique,
                                const cPtr_attributeInCollection * _currentObject,
                                GGS_attributeList  & var_cas_ioAttributeList,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_mapindexDeclaration (C_Compiler & _inLexique,
                                const cPtr_mapindexDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Treewalking routine type declaration                    *
//                                                                           *
//---------------------------------------------------------------------------*

typedef void
_treewalking_routine_semanticsComponentRoot_type (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                const GGS_string  var_cas_inSourceFileDirectory,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_stringset  & var_cas_ioImportedComponentSet,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_semanticDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_semanticDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_classDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_classDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_enumDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_enumDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_mapDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_mapDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_listDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_listDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_attributeInCollection_type (C_Compiler & _inLexique,
                                const cPtr_attributeInCollection * _currentObject,
                                GGS_attributeList  & var_cas_ioAttributeList,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_mapindexDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_mapindexDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Dispatcher tables                              *
//                                                                           *
//---------------------------------------------------------------------------*


static const uint32 _kSize_instructionMetamodel = 1 ;

static const CTreewalkingVirtualMethod _kDispatcherFor_instructionMetamodel [_kSize_instructionMetamodel] = {
  {3, (void *) _treewalking_routine_semanticDeclaration}, // @semanticDeclaration, defined in 'instructionMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static const uint32 _kSize_semanticsMetamodel = 7 ;

static const CTreewalkingVirtualMethod _kDispatcherFor_semanticsMetamodel [_kSize_semanticsMetamodel] = {
  {0, (void *) _treewalking_routine_semanticsComponentRoot}, // @semanticsComponentRoot, defined in 'semanticsMetamodel' metamodel
  {1, (void *) _treewalking_routine_attributeInCollection}, // @attributeInCollection, defined in 'semanticsMetamodel' metamodel
  {10, (void *) _treewalking_routine_listDeclaration}, // @listDeclaration, defined in 'semanticsMetamodel' metamodel
  {13, (void *) _treewalking_routine_enumDeclaration}, // @enumDeclaration, defined in 'semanticsMetamodel' metamodel
  {2, (void *) _treewalking_routine_mapDeclaration}, // @mapDeclaration, defined in 'semanticsMetamodel' metamodel
  {4, (void *) _treewalking_routine_mapindexDeclaration}, // @mapindexDeclaration, defined in 'semanticsMetamodel' metamodel
  {5, (void *) _treewalking_routine_classDeclaration}, // @classDeclaration, defined in 'semanticsMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static C_TreewalkingDispacher _gDispatcherTree ;

//---------------------------------------------------------------------------*
//                                                                           *
//       'semanticsComponentRoot' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticsComponentRoot (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                const GGS_string  var_cas_inSourceFileDirectory,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_stringset  & var_cas_ioImportedComponentSet,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @semanticsComponentRoot\n") ; fflush (stdout) ;
  #endif
  const GGS_stringset _var_1974 = _currentObject->mImportedSemanticsComponentSet ;
  const GGS_stringset::element_type * operand_1974 = _var_1974.firstObject () ;
  while ((operand_1974 != NULL)) {
    macroValidPointer (operand_1974) ;
    if (((var_cas_ioImportedComponentSet.reader_hasKey (_inLexique, operand_1974->mKey COMMA_SOURCE_FILE_AT_LINE (36)))._operator_not ()).isBuiltAndTrue ()) {
      if (((operand_1974->mKey)._operator_isNotEqual (_currentObject->mSemanticsComponentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (37)))).isBuiltAndTrue ()) {
        GGS_lstring  var_cas_sourceFilePath ;
        var_cas_sourceFilePath = GGS_lstring::constructor_new (_inLexique, (((var_cas_inSourceFileDirectory)._operator_concat (GGS_string (true, "/")))._operator_concat (operand_1974->mKey))._operator_concat (GGS_string (true, ".gSemantics")), var_cas_inErrorLocation COMMA_HERE) ;
        GGS_semanticsComponentRoot  var_cas_semanticsComponentRoot ;
        GGS_location  var_cas_endOfSourceFile ;
        { galgas_scanner * scanner_ = NULL ;
          const C_String sourceFileName = var_cas_sourceFilePath.isAbsolutePath ()
            ? var_cas_sourceFilePath.string ()
            : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_sourceFilePath) ;
          if (sourceFileName.fileExists ()) {
            macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
            if (scanner_->sourceText () != NULL) {
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              semanticsSLRgrammar grammar_ ;
              var_cas_semanticsComponentRoot = grammar_.startParsing_ (*scanner_,
                                        var_cas_endOfSourceFile) ;
            }else{
              C_String message ;
              message << "the '" << sourceFileName << "' file exits, but cannot be read" ;
              var_cas_sourceFilePath.signalSemanticError (_inLexique, message COMMA_SOURCE_FILE_AT_LINE (44)) ;
            }
            macroDetachPointer (scanner_, galgas_scanner) ;
          }else{
            C_String message ;
            message << "the '" << sourceFileName << "' file does not exist" ;
            var_cas_sourceFilePath.signalSemanticError (_inLexique, message COMMA_SOURCE_FILE_AT_LINE (44)) ;
          }
        }
        _walk_throught_buildMapsForSemantics (_inLexique, var_cas_semanticsComponentRoot, var_cas_inSourceFileDirectory, var_cas_inErrorLocation, var_cas_ioImportedComponentSet, var_cas_ioTypeMap) ;
      }
      var_cas_ioImportedComponentSet._addAssign_operation (operand_1974->mKey) ;
    }
    operand_1974 = operand_1974->nextObject () ;
  }
  if ((var_cas_ioImportedComponentSet.reader_hasKey (_inLexique, _currentObject->mSemanticsComponentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (56)) COMMA_SOURCE_FILE_AT_LINE (56))).isBuiltAndTrue ()) {
    _currentObject->mSemanticsComponentName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this component is involved in a circularity in 'extends' definitions") COMMA_SOURCE_FILE_AT_LINE (58)) ;
  }else{
    macroValidPointer (_currentObject) ;
    { GGS_semanticDeclarationList::element_type * _ptr = _currentObject->mSemanticDeclarationList.firstObject () ;
      while (_ptr != NULL) {
        _treewalking_routine_semanticDeclaration_type * _f = (_treewalking_routine_semanticDeclaration_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
        (* _f) (_inLexique, _ptr, var_cas_ioTypeMap) ;
        _ptr = _ptr->nextObject () ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         'semanticDeclaration' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticDeclaration (C_Compiler &,
                                const cPtr_semanticDeclaration * /* _currentObject */,
                                GGS_typeMap  & /* var_cas_ioTypeMap */) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @semanticDeclaration\n") ; fflush (stdout) ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'classDeclaration' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_classDeclaration (C_Compiler & _inLexique,
                                const cPtr_classDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @classDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_typeMapIndex  var_cas_superClassIndex ;
  if (((_currentObject->mSuperClassName.ggs_string ().reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (77)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_superClassIndex = GGS_typeMapIndex::constructor_null (_inLexique COMMA_HERE) ;
  }else{
    GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, _currentObject->mSuperClassName, var_cas_ioTypeMap, var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (80)) ;
  }
  GGS_attributeList  var_cas_attributeList ;
  var_cas_attributeList = GGS_attributeList::constructor_emptyList (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { GGS_attributeInCollectionList::element_type * _ptr = _currentObject->mAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_attributeInCollection_type * _f = (_treewalking_routine_attributeInCollection_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_attributeList, var_cas_ioTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_classGalgasType::constructor_new (_inLexique, _currentObject->mIsAbstract, _currentObject->mClassTypeName, var_cas_superClassIndex, var_cas_attributeList COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mClassTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (92)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           'enumDeclaration' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_enumDeclaration (C_Compiler & _inLexique,
                                const cPtr_enumDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @enumDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_enumType::constructor_new (_inLexique, _currentObject->mEnumTypeName, _currentObject->mConstantList COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mEnumTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (107)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           'mapDeclaration' treewalking routine implementation             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_mapDeclaration (C_Compiler & _inLexique,
                                const cPtr_mapDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @mapDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_attributeList  var_cas_attributeList ;
  var_cas_attributeList = GGS_attributeList::constructor_emptyList (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { GGS_attributeInCollectionList::element_type * _ptr = _currentObject->mAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_attributeInCollection_type * _f = (_treewalking_routine_attributeInCollection_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_attributeList, var_cas_ioTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_mapType::constructor_new (_inLexique, _currentObject->mMapTypeName, var_cas_attributeList COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mMapTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (125)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           'listDeclaration' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_listDeclaration (C_Compiler & _inLexique,
                                const cPtr_listDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @listDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_attributeList  var_cas_attributeList ;
  var_cas_attributeList = GGS_attributeList::constructor_emptyList (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { GGS_attributeInCollectionList::element_type * _ptr = _currentObject->mAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_attributeInCollection_type * _f = (_treewalking_routine_attributeInCollection_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_attributeList, var_cas_ioTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_listGalgasType::constructor_new (_inLexique, _currentObject->mListTypeName, var_cas_attributeList COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mListTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (143)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        'attributeInCollection' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_attributeInCollection (C_Compiler & _inLexique,
                                const cPtr_attributeInCollection * _currentObject,
                                GGS_attributeList  & var_cas_ioAttributeList,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @attributeInCollection\n") ; fflush (stdout) ;
  #endif
  GGS_typeMapIndex  var_cas_index ;
  GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, _currentObject->mAttributeTypeName, var_cas_ioTypeMap, var_cas_index COMMA_SOURCE_FILE_AT_LINE (153)) ;
  var_cas_ioAttributeList._addAssign_operation (var_cas_index, _currentObject->mAttributeName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         'mapindexDeclaration' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_mapindexDeclaration (C_Compiler & _inLexique,
                                const cPtr_mapindexDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @mapindexDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_typeMapIndex  var_cas_index ;
  GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, _currentObject->mMapTypeName, var_cas_ioTypeMap, var_cas_index COMMA_SOURCE_FILE_AT_LINE (167)) ;
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_mapindexType::constructor_new (_inLexique, _currentObject->mMapIndexName, var_cas_index, _currentObject->mSearchMethodName, _currentObject->mSearchMethodErrorMessage COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mMapIndexName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (175)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Build Dispatcher Tree                            *
//                                                                           *
//---------------------------------------------------------------------------*

static void _build_dispacher_tree (void) {
  _gDispatcherTree.enterTable (_metamodel_index_for_instructionMetamodel (),
                                _kSize_instructionMetamodel,
                                _kDispatcherFor_instructionMetamodel
                                COMMA_HERE) ;
  _gDispatcherTree.enterTable (_metamodel_index_for_semanticsMetamodel (),
                                _kSize_semanticsMetamodel,
                                _kDispatcherFor_semanticsMetamodel
                                COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                               Root routine                                *
//                                                                           *
//---------------------------------------------------------------------------*

void
_walk_throught_buildMapsForSemantics (C_Compiler & _inLexique,
                                const GGS_semanticsComponentRoot & _rootObject,
                                const GGS_string  var_cas_inSourceFileDirectory,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_stringset  & var_cas_ioImportedComponentSet,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  if (_rootObject._isBuilt ()) {
    if (! _gDispatcherTree.isInited ()) {
      _build_dispacher_tree () ;
    }
    _treewalking_routine_semanticsComponentRoot_type * _f = (_treewalking_routine_semanticsComponentRoot_type *) _gDispatcherTree.entry (_rootObject.getPtr () COMMA_HERE) ;
    (* _f) (_inLexique, _rootObject.getPtr (), var_cas_inSourceFileDirectory, var_cas_inErrorLocation, var_cas_ioImportedComponentSet, var_cas_ioTypeMap) ;
  }else{
  }
}

//---------------------------------------------------------------------------*

