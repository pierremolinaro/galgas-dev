//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'semanticsCompilation.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                        may 20th, 2010, at 22h2'8"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "semanticsSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of wrapper 'semanticFileGenerationTemplate'         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_semanticFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_semanticFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_semanticFileGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_semanticFileGenerationTemplate_0,
  0,
  gWrapperAllDirectories_semanticFileGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'semanticFileHeader' template of 'semanticFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_semanticFileGenerationTemplate_semanticFileHeader (C_Compiler & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_lstringlist & var_cas_IMPORTED_COMPONENT_LIST,
                                const GGS_lstringlist & var_cas_TYPE_PREDECLARATION_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt ()
    && var_cas_TYPE_PREDECLARATION_LIST.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "#define " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"galgas2/predefined-types.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_321 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_lstringlist::cElement * operand_321 = NULL ;
    while (((operand_321 = enumerator_321.nextObject ()))) {
      macroValidPointer (operand_321) ;
      result << "#include \"" ;
      result << operand_321->mValue.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_537 (var_cas_TYPE_PREDECLARATION_LIST, true) ;
    const GGS_lstringlist::cElement * operand_537 = NULL ;
    while (((operand_537 = enumerator_537.nextObject ()))) {
      macroValidPointer (operand_537) ;
      result << "class GALGAS_" ;
      result << operand_537->mValue.ggs_string ().reader_identifierRepresentation () ;
      result << " ;\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'semanticFileImplementation' template of 'semanticFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_semanticFileGenerationTemplate_semanticFileImplementation (C_Compiler & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt () ;
  if (isBuilt) {
    result << "#include \"version_libpm.h\"\n"
      "#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER\n"
      "  #error \"This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".h\"\n"
      "#include \"C_Compiler.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "  #define SOURCE_FILE_AT_LINE(line) \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".gSemantics\", line\n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)\n"
      "#else\n"
      "  #define SOURCE_FILE_AT_LINE(line) \n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) \n"
      "#endif\n"
      "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "parseSemanticComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_parseSemanticComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_semanticsComponentAST  & var_cas_outSemanticsComponentRoot
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_parseSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  GGS_lstring  var_cas_basenameKey = GGS_lstring ::constructor_new (inLexique, var_cas_basename, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (59)) ;
  const GGS_bool cond_3418 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (60)).reader_hasKey (var_cas_basename) ;
  if (cond_3418.isBuiltAndTrue ()) {
    const GGS_parsedSemanticsComponentMap  temp_3368 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (61)) ;
    if (temp_3368.isBuilt ()) {
      temp_3368 (HERE)->method_searchKey (inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (61)) ;
    }
  }else if (cond_3418.isBuiltAndFalse ()) {
    const GGS_string _depExtension = GGS_string ("") ;
    const GGS_string _depPath = GGS_string ("") ;
    if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
      C_Grammar_semanticsSLRgrammar::_performSourceFileParsing_ (inLexique,
                                    _depExtension.string (),
                                    _depPath.string (),
                                    NULL,
                                    var_cas_inSourceFile,
                                    var_cas_outSemanticsComponentRoot
                                    COMMA_SOURCE_FILE_AT_LINE (63)) ;
    }
    var_cas_ioParsedComponentStruct.mParsedSemanticsComponentMap.modifier_insertKey (inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (64)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_parseSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@grammarComponentASTList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_grammarComponentASTList::
elementOf_GGS_grammarComponentASTList (const GGS_grammarComponentAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mGrammarComponentAST (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarComponentASTList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_grammarComponentASTList * ptr = dynamic_cast <const elementOf_GGS_grammarComponentASTList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGrammarComponentAST.operator_isEqual (ptr->mGrammarComponentAST).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarComponentASTList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarComponentAST.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@grammarComponentASTList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarComponentASTList ("grammarComponentASTList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalAppendValues (const GGS_grammarComponentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalPrependValues (const GGS_grammarComponentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
addAssign_operation (const GGS_grammarComponentAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
operator_concat (const GGS_grammarComponentASTList & inOperand) const {
  GGS_grammarComponentASTList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
dotAssign_operation (const GGS_grammarComponentASTList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_grammarComponentASTList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_grammarComponentAST  p_0 = p->mGrammarComponentAST ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_grammarComponentAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mGrammarComponentAST
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList  GGS_grammarComponentASTList::
constructor_emptyList (void) {
  GGS_grammarComponentASTList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList  GGS_grammarComponentASTList::
constructor_listWithValue (const GGS_grammarComponentAST & argument_0) {
  GGS_grammarComponentASTList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalSubListWithRange (GGS_grammarComponentASTList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mGrammarComponentAST) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentASTList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentASTList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarComponentASTList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@grammarComponentASTList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
method_first (C_Compiler & inLexique,
              GGS_grammarComponentAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
method_last (C_Compiler & inLexique,
             GGS_grammarComponentAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_grammarComponentAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_popLast (C_Compiler & inLexique,
                GGS_grammarComponentAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentAST  GGS_grammarComponentASTList::
reader_mGrammarComponentASTAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGrammarComponentAST ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_setMGrammarComponentASTAtIndex (C_Compiler & inLexique,
                              const GGS_grammarComponentAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGrammarComponentAST = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_grammarComponentAST  & GGS_grammarComponentASTList::cEnumerator::_mGrammarComponentAST (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGrammarComponentAST ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarComponentASTList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarComponentASTList * p = NULL ;
    macroMyNew (p, GGS_grammarComponentASTList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarComponentASTList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarComponentASTList * p = dynamic_cast <const GGS_grammarComponentASTList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarComponentASTList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarComponentASTList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarComponentASTList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "recursivelyImportSemanticComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_recursivelyImportSemanticComponent (C_Compiler & inLexique,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_lstringlist  & var_cas_ioOptionComponentFileNameList,
                                GGS_grammarComponentASTList  & var_cas_ioGrammarComponentASTList,
                                GGS_semanticDeclarationListAST  & var_cas_ioSemanticDeclarationList,
                                GGS_stringset  & var_cas_ioParsedFileSet,
                                const GGS_lstringlist   var_cas_inListOfFilesToParse,
                                const GGS_string  var_cas_inDirectory
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_recursivelyImportSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_4254 (var_cas_inListOfFilesToParse, true) ;
    const GGS_lstringlist::cElement * operand_4254 = NULL ;
    while (((operand_4254 = enumerator_4254.nextObject ()))) {
      macroValidPointer (operand_4254) ;
      const GGS_lstring  var_cas_filePath = GGS_lstring ::constructor_new (inLexique, operand_4254->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inDirectory), operand_4254->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (88)) COMMA_SOURCE_FILE_AT_LINE (86)) ;
      const GGS_bool cond_5748 = (var_cas_ioParsedFileSet.reader_hasKey (var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (90)))).operator_not () ;
      if (cond_5748.isBuiltAndTrue ()) {
        var_cas_ioParsedFileSet.addAssign_operation (var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (91))) ;
        const GGS_string var_cas_extension = var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92)).reader_pathExtension () ;
        const GGS_bool cond_4650 = (var_cas_extension).operator_isEqual (GGS_string ("gOption")) ;
        if (cond_4650.isBuiltAndTrue ()) {
          var_cas_ioOptionComponentFileNameList.addAssign_operation (var_cas_filePath) ;
        }else if (cond_4650.isBuiltAndFalse ()) {
          const GGS_bool cond_4929 = (var_cas_extension).operator_isEqual (GGS_string ("gGrammar")) ;
          if (cond_4929.isBuiltAndTrue ()) {
            GGS_grammarComponentAST  var_cas_grammarComponentAST ;
            ::routine_parseGrammarComponent (inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_grammarComponentAST COMMA_SOURCE_FILE_AT_LINE (97)) ;
            var_cas_ioGrammarComponentASTList.addAssign_operation (var_cas_grammarComponentAST) ;
          }else if (cond_4929.isBuiltAndFalse ()) {
            const GGS_bool cond_5735 = (var_cas_extension).operator_isEqual (GGS_string ("gSemantics")) ;
            if (cond_5735.isBuiltAndTrue ()) {
              GGS_semanticsComponentAST  var_cas_semanticsComponentRoot ;
              ::routine_parseSemanticComponent (inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (106)) ;
              var_cas_ioSemanticDeclarationList.dotAssign_operation (var_cas_semanticsComponentRoot.reader_mSemanticDeclarations (inLexique COMMA_SOURCE_FILE_AT_LINE (112)).reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (112))) ;
              ::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_ioOptionComponentFileNameList,  var_cas_ioGrammarComponentASTList,  var_cas_ioSemanticDeclarationList,  var_cas_ioParsedFileSet,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (120)),  var_cas_inDirectory COMMA_SOURCE_FILE_AT_LINE (114)) ;
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_recursivelyImportSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "buildOptionComponentMapForSemanticAnalysis"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildOptionComponentMapForSemanticAnalysis (C_Compiler & inLexique,
                                const GGS_lstringlist   var_cas_inOptionComponentFileNameList,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_optionComponentMapForSemanticAnalysis  & var_cas_ioOptionComponentMapForSemanticAnalysis
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildOptionComponentMapForSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_6137 (var_cas_inOptionComponentFileNameList, true) ;
    const GGS_lstringlist::cElement * operand_6137 = NULL ;
    while (((operand_6137 = enumerator_6137.nextObject ()))) {
      macroValidPointer (operand_6137) ;
      GGS_lstring  var_cas_optionComponentName ;
      GGS_commandLineOptionMap  var_cas_boolOptionMap ;
      GGS_commandLineOptionMap  var_cas_uintOptionMap ;
      GGS_commandLineOptionMap  var_cas_stringOptionMap ;
      ::routine_parseOptionComponent (inLexique,  operand_6137->mValue,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentName,  var_cas_boolOptionMap,  var_cas_uintOptionMap,  var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (140)) ;
      var_cas_ioOptionComponentMapForSemanticAnalysis.modifier_insertKey (inLexique, var_cas_optionComponentName, var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (148)) ;
    }
  }
  GGS_string2list  var_cas_optionNameList = GGS_system ::constructor_boolOptionNameList () ;
  GGS_commandLineOptionMap  var_cas_boolOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (157)) ;
  {
    GGS_string2list::cEnumerator enumerator_6822 (var_cas_optionNameList, true) ;
    const GGS_string2list::cElement * operand_6822 = NULL ;
    while (((operand_6822 = enumerator_6822.nextObject ()))) {
      macroValidPointer (operand_6822) ;
      const GGS_bool cond_7161 = (operand_6822->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
      if (cond_7161.isBuiltAndTrue ()) {
        var_cas_boolOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_6822->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (161)), GGS_system ::constructor_boolOptionInvocationLetter (operand_6822->mValue0, operand_6822->mValue1), GGS_system ::constructor_boolOptionInvocationString (operand_6822->mValue0, operand_6822->mValue1), GGS_system ::constructor_boolOptionCommentString (operand_6822->mValue0, operand_6822->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (160)) ;
      }
    }
  }
  var_cas_optionNameList = GGS_system ::constructor_uintOptionNameList () ;
  GGS_commandLineOptionMap  var_cas_uintOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (171)) ;
  {
    GGS_string2list::cEnumerator enumerator_7315 (var_cas_optionNameList, true) ;
    const GGS_string2list::cElement * operand_7315 = NULL ;
    while (((operand_7315 = enumerator_7315.nextObject ()))) {
      macroValidPointer (operand_7315) ;
      const GGS_bool cond_7654 = (operand_7315->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
      if (cond_7654.isBuiltAndTrue ()) {
        var_cas_uintOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_7315->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (175)), GGS_system ::constructor_uintOptionInvocationLetter (operand_7315->mValue0, operand_7315->mValue1), GGS_system ::constructor_uintOptionInvocationString (operand_7315->mValue0, operand_7315->mValue1), GGS_system ::constructor_uintOptionCommentString (operand_7315->mValue0, operand_7315->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (174)) ;
      }
    }
  }
  var_cas_optionNameList = GGS_system ::constructor_stringOptionNameList () ;
  GGS_commandLineOptionMap  var_cas_stringOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (185)) ;
  {
    GGS_string2list::cEnumerator enumerator_7812 (var_cas_optionNameList, true) ;
    const GGS_string2list::cElement * operand_7812 = NULL ;
    while (((operand_7812 = enumerator_7812.nextObject ()))) {
      macroValidPointer (operand_7812) ;
      const GGS_bool cond_8159 = (operand_7812->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
      if (cond_8159.isBuiltAndTrue ()) {
        var_cas_stringOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_7812->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (189)), GGS_system ::constructor_stringOptionInvocationLetter (operand_7812->mValue0, operand_7812->mValue1), GGS_system ::constructor_stringOptionInvocationString (operand_7812->mValue0, operand_7812->mValue1), GGS_system ::constructor_stringOptionCommentString (operand_7812->mValue0, operand_7812->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (188)) ;
      }
    }
  }
  var_cas_ioOptionComponentMapForSemanticAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("galgas_cli_options"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (199)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (198)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildOptionComponentMapForSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
// Implementation of routine "buildGrammarComponentMapForSemanticAnalysis"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildGrammarComponentMapForSemanticAnalysis (C_Compiler & inLexique,
                                const GGS_grammarComponentASTList   var_cas_inGrammarComponentASTList,
                                GGS_semanticContext & var_cas_ioSemanticContext
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildGrammarComponentMapForSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_grammarComponentASTList::cEnumerator enumerator_8684 (var_cas_inGrammarComponentASTList, true) ;
    const GGS_grammarComponentASTList::cElement * operand_8684 = NULL ;
    while (((operand_8684 = enumerator_8684.nextObject ()))) {
      macroValidPointer (operand_8684) ;
      GGS_grammarLabelMap  var_cas_grammarLabelMap = GGS_grammarLabelMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (215)) ;
      {
        GGS_nonTerminalLabelList::cEnumerator enumerator_8786 (operand_8684->mGrammarComponentAST.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (216)), true) ;
        const GGS_nonTerminalLabelList::cElement * operand_8786 = NULL ;
        while (((operand_8786 = enumerator_8786.nextObject ()))) {
          macroValidPointer (operand_8786) ;
          GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
          {
            GGS_formalParameterListAST::cEnumerator enumerator_8958 (operand_8786->mFormalArgumentList, true) ;
            const GGS_formalParameterListAST::cElement * operand_8958 = NULL ;
            while (((operand_8958 = enumerator_8958.nextObject ()))) {
              macroValidPointer (operand_8958) ;
              var_cas_formalArgumentList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_8958->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (221)), operand_8958->mFormalArgumentPassingMode) ;
            }
          }
          var_cas_grammarLabelMap.modifier_insertKey (inLexique, operand_8786->mLabelName, var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (225)) ;
        }
      }
      var_cas_ioSemanticContext.mGrammarMap.modifier_insertKey (inLexique, operand_8684->mGrammarComponentAST.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (232)), var_cas_grammarLabelMap COMMA_SOURCE_FILE_AT_LINE (231)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildGrammarComponentMapForSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileSemanticsComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticsComponentAST  var_cas_semanticsComponentRoot ;
  ::routine_parseSemanticComponent (inLexique,  var_cas_inSourceFile,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (247)) ;
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  const GGS_lstring  var_cas_componentName = var_cas_semanticsComponentRoot.reader_mSemanticsComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (254)) ;
  const GGS_bool cond_10302 = (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (255))).operator_isNotEqual (var_cas_basename) ;
  if (cond_10302.isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (257)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (259)) ;
  }
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationList = var_cas_semanticsComponentRoot.reader_mSemanticDeclarations (inLexique COMMA_SOURCE_FILE_AT_LINE (262)).reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (262)) ;
  GGS_stringset  var_cas_parsedFileSet = GGS_stringset ::constructor_setWithString (var_cas_inSourceFile.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (263))) ;
  GGS_lstringlist  var_cas_optionComponentFileNameList = GGS_lstringlist ::constructor_emptyList () ;
  GGS_grammarComponentASTList  var_cas_grammarComponentASTList = GGS_grammarComponentASTList ::constructor_emptyList () ;
  ::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentFileNameList,  var_cas_grammarComponentASTList,  var_cas_semanticDeclarationList,  var_cas_parsedFileSet,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (272)),  var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent () COMMA_SOURCE_FILE_AT_LINE (266)) ;
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationListWithPredefinedTypes = var_cas_semanticDeclarationList ;
  ::routine_appendPredefinedTypesASTs (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes COMMA_SOURCE_FILE_AT_LINE (277)) ;
  GGS_semanticContext var_cas_semanticContext ;
  ::routine_buildSemanticContext (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes,  var_cas_semanticsComponentRoot.reader_mEndOfSourceFile (inLexique COMMA_SOURCE_FILE_AT_LINE (282)),  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (280)) ;
  ::routine_buildOptionComponentMapForSemanticAnalysis (inLexique,  var_cas_optionComponentFileNameList,  var_cas_ioParsedComponentStruct,  var_cas_semanticContext.mOptionComponentMapForSemanticAnalysis COMMA_SOURCE_FILE_AT_LINE (286)) ;
  ::routine_buildGrammarComponentMapForSemanticAnalysis (inLexique,  var_cas_grammarComponentASTList,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (292)) ;
  GGS_semanticDeclarationListForGeneration  var_cas_decoratedDeclarationListForGeneration ;
  ::routine_performSemanticAnalysis (inLexique,  var_cas_semanticsComponentRoot.reader_mSemanticDeclarations (inLexique COMMA_SOURCE_FILE_AT_LINE (299)).reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (299)),  var_cas_semanticContext,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (298)) ;
  const GGS_bool cond_12717 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (304))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_12717.isBuiltAndTrue ()) {
    GGS_string var_cas_headerString = template_filewrapper_semanticFileGenerationTemplate_semanticFileHeader (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (306)), var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (307)), var_cas_semanticContext.mTypeMap.reader_allKeyList (inLexique COMMA_SOURCE_FILE_AT_LINE (308))) ;
    {
      GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_12419 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationListForGeneration::cElement * operand_12419 = NULL ;
      while (((operand_12419 = enumerator_12419.nextObject ()))) {
        macroValidPointer (operand_12419) ;
        var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration (operand_12419->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_12419->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (311)))) ;
      }
    }
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (315))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_headerString, GGS_string ("\n"
      "\n"), GGS_string ("#endif\n") COMMA_SOURCE_FILE_AT_LINE (313)) ;
  }
  const GGS_bool cond_13388 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (324))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_13388.isBuiltAndTrue ()) {
    GGS_string var_cas_implementationString = template_filewrapper_semanticFileGenerationTemplate_semanticFileImplementation (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (326))) ;
    {
      GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_12988 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationListForGeneration::cElement * operand_12988 = NULL ;
      while (((operand_12988 = enumerator_12988.nextObject ()))) {
        macroValidPointer (operand_12988) ;
        var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendTypeGenericImplementation (operand_12988->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_12988->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (329)))) ;
        var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendSpecificImplementation (operand_12988->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_12988->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (330)))) ;
      }
    }
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (334))).operator_concat (GGS_string (".cpp")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_implementationString, GGS_string ("\n"
      "\n"), GGS_string ("\n") COMMA_SOURCE_FILE_AT_LINE (332)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

