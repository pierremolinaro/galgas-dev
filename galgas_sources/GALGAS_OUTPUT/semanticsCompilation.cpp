//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'semanticsCompilation.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       june 16th, 2008, at 20h28'0"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semanticsCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "semanticsSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "constructBuiltinTypeMap"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_constructBuiltinTypeMap (C_Compiler & _inLexique,
                                GGS_typeMap  & var_cas_outTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_constructBuiltinTypeMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outTypeMap = GGS_typeMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE), GGS_stringGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (37)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE), GGS_charGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (38)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE), GGS_boolGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (39)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE), GGS_uintGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (40)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE), GGS_sintGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (41)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint64"), GGS_location (_inLexique) COMMA_HERE), GGS_uint64GalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (42)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "sint64"), GGS_location (_inLexique) COMMA_HERE), GGS_sint64GalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (43)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE), GGS_doubleGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (44)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE), GGS_lstringGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (45)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE), GGS_lcharGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (46)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE), GGS_lboolGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (47)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE), GGS_luintGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (48)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE), GGS_lsintGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (49)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "luint64"), GGS_location (_inLexique) COMMA_HERE), GGS_luint64GalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (50)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lsint64"), GGS_location (_inLexique) COMMA_HERE), GGS_lsint64GalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (51)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE), GGS_ldoubleGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (52)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "binaryset"), GGS_location (_inLexique) COMMA_HERE), GGS_binarysetGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (53)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE), GGS_stringsetGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (54)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "location"), GGS_location (_inLexique) COMMA_HERE), GGS_locationGalgasType ::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (55)) ;
  GGS_attributeList  var_cas_lstringAttribute ;
  var_cas_lstringAttribute = GGS_attributeList ::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_typeMapIndex  var_cas_lstringIndex ;
  GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE), var_cas_outTypeMap, var_cas_lstringIndex COMMA_SOURCE_FILE_AT_LINE (59)) ;
  var_cas_lstringAttribute._addAssign_operation (var_cas_lstringIndex, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_lstring  var_cas_lstringlist ;
  var_cas_lstringlist = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lstringlist"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, var_cas_lstringlist, GGS_listGalgasType ::constructor_new (_inLexique, var_cas_lstringlist, var_cas_lstringAttribute COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (62)) ;
  GGS_attributeList  var_cas_stringAttribute ;
  var_cas_stringAttribute = GGS_attributeList ::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_typeMapIndex  var_cas_stringIndex ;
  GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE), var_cas_outTypeMap, var_cas_stringIndex COMMA_SOURCE_FILE_AT_LINE (66)) ;
  var_cas_stringAttribute._addAssign_operation (var_cas_stringIndex, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_lstring  var_cas_stringlist ;
  var_cas_stringlist = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "stringlist"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, var_cas_stringlist, GGS_listGalgasType ::constructor_new (_inLexique, var_cas_stringlist, var_cas_stringAttribute COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (69)) ;
  GGS_attributeList  var_cas_uint64Attribute ;
  var_cas_uint64Attribute = GGS_attributeList ::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_typeMapIndex  var_cas_uint64Index ;
  GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_outTypeMap, var_cas_uint64Index COMMA_SOURCE_FILE_AT_LINE (73)) ;
  var_cas_uint64Attribute._addAssign_operation (var_cas_uint64Index, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_lstring  var_cas_uint64list ;
  var_cas_uint64list = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint64list"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, var_cas_uint64list, GGS_listGalgasType ::constructor_new (_inLexique, var_cas_uint64list, var_cas_uint64Attribute COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (76)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_constructBuiltinTypeMap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@semanticDeclaration.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclaration__enterType (C_Compiler &,
                                const cPtr_semanticDeclaration * operand_5612,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */) {
  if (operand_5612 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Virtual Table for category method '@semanticDeclaration.enterType'     *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclaration__enterType> gDispatchTableFor__semanticDeclaration__enterType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclaration__enterType (typeCategoryMethod__semanticDeclaration__enterType inRoutine,
                     const sint32 inclassID) {
  gDispatchTableFor__semanticDeclaration__enterType.makeRoomWithDefaultValue (inclassID + 1, NULL) ;
  gDispatchTableFor__semanticDeclaration__enterType (inclassID COMMA_HERE) = inRoutine ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclaration__enterType
findCategoryMethod__semanticDeclaration__enterType (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__semanticDeclaration__enterType result = gDispatchTableFor__semanticDeclaration__enterType (inClassPtr->slotID () COMMA_HERE) ;
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr == NULL) {
      result = findCategoryMethod__semanticDeclaration__enterType (superClassPtr) ;
      gDispatchTableFor__semanticDeclaration__enterType (inClassPtr->slotID () COMMA_HERE) = result ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Category method '@mapDeclaration.enterType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclaration__enterType (C_Compiler & _inLexique,
                                const cPtr_mapDeclaration * operand_5778,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */) {
  if (operand_5778 != NULL) {
    _inLexique.printMessage (C_String ("LOGGING mMapTypeName: ") + operand_5778->mMapTypeName.reader_description (_inLexique COMMA_HERE) + "\n" COMMA_SOURCE_FILE_AT_LINE (97)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSemanticContext"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSemanticContext (C_Compiler & _inLexique,
                                const GGS_semanticDeclarationList   var_cas_inSemanticDeclarationList,
                                GGS_semanticContext & var_cas_outSemanticContext COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSemanticContext at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeMap  var_cas_typeMap ;
  ::routine_constructBuiltinTypeMap (_inLexique,  var_cas_typeMap COMMA_SOURCE_FILE_AT_LINE (171)) ;
  var_cas_outSemanticContext = GGS_semanticContext::constructor_new (_inLexique, var_cas_typeMap COMMA_HERE) ;
  {
    GGS_semanticDeclarationList::cEnumerator enumerator_7745 (var_cas_inSemanticDeclarationList, true) ;
    const GGS_semanticDeclarationList::cElement * operand_7745 = NULL ;
    while (((operand_7745 = (GGS_semanticDeclarationList::cElement *) enumerator_7745.nextObject ()))) {
      macroValidPointer (operand_7745) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSemanticContext\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "parseSemanticComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_parseSemanticComponent (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_semanticsComponentRoot  & var_cas_outSemanticsComponentRoot COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_parseSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (194)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (194)) ;
  GGS_lstring  var_cas_basenameKey ;
  var_cas_basenameKey = GGS_lstring ::constructor_new (_inLexique, var_cas_basename, GGS_location (_inLexique) COMMA_HERE) ;
  if ((var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (196)).reader_hasKey (_inLexique, var_cas_basename COMMA_SOURCE_FILE_AT_LINE (196))).isBuiltAndTrue ()) {
    const GGS_parsedSemanticsComponentMap  _temp_8704 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (197)) ;
    if (_temp_8704._isBuilt ()) {
      _temp_8704 (HERE)->method_searchKey (_inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (197)) ;
    }
  }else{
    semanticsSLRgrammar::_performSourceFileParsing_ (_inLexique,
                                    NULL,
                                    var_cas_inSourceFile,
                                    var_cas_outSemanticsComponentRoot
                                    COMMA_SOURCE_FILE_AT_LINE (199)) ;
    var_cas_ioParsedComponentStruct.mParsedSemanticsComponentMap.modifier_insertKey (_inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (200)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_parseSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "recursivelyImportSemanticComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_recursivelyImportSemanticComponent (C_Compiler & _inLexique,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_semanticDeclarationList  & var_cas_ioSemanticDeclarationList,
                                GGS_stringset  & var_cas_ioParsedFileSet,
                                const GGS_lstringlist   var_cas_inListOfFilesToParse,
                                const GGS_string  var_cas_inDirectory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_recursivelyImportSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_9313 (var_cas_inListOfFilesToParse, true) ;
    const GGS_lstringlist::cElement * operand_9313 = NULL ;
    while (((operand_9313 = (GGS_lstringlist::cElement *) enumerator_9313.nextObject ()))) {
      macroValidPointer (operand_9313) ;
      if (((var_cas_ioParsedFileSet.reader_hasKey (_inLexique, operand_9313->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (214)) COMMA_SOURCE_FILE_AT_LINE (214)))._operator_not ()).isBuiltAndTrue ()) {
        var_cas_ioParsedFileSet._addAssign_operation (operand_9313->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (215))) ;
        GGS_string var_cas_extension ;
        var_cas_extension = operand_9313->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (216)).reader_pathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (216)) ;
        if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gSemantics"))).isBuiltAndTrue ()) {
          GGS_lstring  var_cas_filePath ;
          var_cas_filePath = GGS_lstring ::constructor_new (_inLexique, operand_9313->mValue.ggs_string ().reader_absolutePathFromPath (_inLexique, var_cas_inDirectory COMMA_SOURCE_FILE_AT_LINE (219)), operand_9313->mValue.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (220)) COMMA_HERE) ;
          GGS_semanticsComponentRoot  var_cas_semanticsComponentRoot ;
          ::routine_parseSemanticComponent (_inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (222)) ;
          var_cas_ioSemanticDeclarationList = (var_cas_ioSemanticDeclarationList)._operator_concat (var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (_inLexique COMMA_SOURCE_FILE_AT_LINE (228))) ;
          ::routine_recursivelyImportSemanticComponent (_inLexique,  var_cas_ioParsedComponentStruct,  var_cas_ioSemanticDeclarationList,  var_cas_ioParsedFileSet,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (_inLexique COMMA_SOURCE_FILE_AT_LINE (233)),  var_cas_inDirectory COMMA_SOURCE_FILE_AT_LINE (228)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_recursivelyImportSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileSemanticsComponent (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticsComponentRoot  var_cas_semanticsComponentRoot ;
  ::routine_parseSemanticComponent (_inLexique,  var_cas_inSourceFile,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (249)) ;
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (256)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (256)) ;
  GGS_lstring  var_cas_componentName ;
  var_cas_componentName = var_cas_semanticsComponentRoot.reader_mSemanticsComponentName (_inLexique COMMA_SOURCE_FILE_AT_LINE (257)) ;
  if (((var_cas_componentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (258)))._operator_isNotEqual (var_cas_basename)).isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, ((((GGS_string (true, "GALGAS checks "
      "the component name ('"))._operator_concat (var_cas_componentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (260))))._operator_concat (GGS_string (true, "') against the source file base name ('")))._operator_concat (var_cas_basename))._operator_concat (GGS_string (true, "'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (261)) ;
  }
  GGS_semanticDeclarationList  var_cas_semanticDeclarationList ;
  var_cas_semanticDeclarationList = var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (_inLexique COMMA_SOURCE_FILE_AT_LINE (265)) ;
  GGS_stringset  var_cas_parsedFileSet ;
  var_cas_parsedFileSet = GGS_stringset ::constructor_setWithString (_inLexique, var_cas_inSourceFile.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (266)) COMMA_HERE) ;
  ::routine_recursivelyImportSemanticComponent (_inLexique,  var_cas_ioParsedComponentStruct,  var_cas_semanticDeclarationList,  var_cas_parsedFileSet,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (_inLexique COMMA_SOURCE_FILE_AT_LINE (271)),  var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (272)) COMMA_SOURCE_FILE_AT_LINE (266)) ;
  GGS_semanticContext var_cas_semanticContext ;
  ::routine_buildSemanticContext (_inLexique,  var_cas_semanticDeclarationList,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (275)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsCompilation (void) {
 enterCategoryMethod__semanticDeclaration__enterType (category_method__semanticDeclaration__enterType, gClassInfoFor__semanticDeclaration.slotID ()) ;
 enterCategoryMethod__semanticDeclaration__enterType ((typeCategoryMethod__semanticDeclaration__enterType) category_method__mapDeclaration__enterType, gClassInfoFor__mapDeclaration.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_semanticsCompilation (prologueRoutineFor_semanticsCompilation,
                                   NULL) ;

//---------------------------------------------------------------------------*

