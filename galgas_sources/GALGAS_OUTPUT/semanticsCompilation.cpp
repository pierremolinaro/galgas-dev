//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'semanticsCompilation.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 28th, 2010, at 20h53'20"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "semanticsCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "semanticsSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of wrapper 'semanticFileGenerationTemplate'         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapperEx * gWrapperAllFiles_semanticFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapperEx * gWrapperAllDirectories_semanticFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapperEx gWrapperDirectory_0_semanticFileGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_semanticFileGenerationTemplate_0,
  0,
  gWrapperAllDirectories_semanticFileGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'semanticFileHeader' template of 'semanticFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_semanticFileGenerationTemplate_semanticFileHeader (C_CompilerEx & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_stringlist & var_cas_IMPORTED_COMPONENT_LIST,
                                const GGS_lstringlist & var_cas_TYPE_PREDECLARATION_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt ()
    && var_cas_TYPE_PREDECLARATION_LIST.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "#define " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"galgas2/predefined-types.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_321 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_stringlist::cElement * operand_321 = NULL ;
    while (((operand_321 = enumerator_321.nextObject ()))) {
      macroValidPointer (operand_321) ;
      result << "#include \"" ;
      result << operand_321->mValue ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_485 (var_cas_TYPE_PREDECLARATION_LIST, true) ;
    const GGS_lstringlist::cElement * operand_485 = NULL ;
    while (((operand_485 = enumerator_485.nextObject ()))) {
      macroValidPointer (operand_485) ;
      result << "class GALGAS_" ;
      result << operand_485->mValue.ggs_string ().reader_identifierRepresentation () ;
      result << " ;\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'semanticFileImplementation' template of 'semanticFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_semanticFileGenerationTemplate_semanticFileImplementation (C_CompilerEx & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_stringlist & var_cas_IMPORTED_COMPONENT_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt () ;
  if (isBuilt) {
    result << "#include \"version_libpm.h\"\n"
      "#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER\n"
      "  #error \"This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".h\"\n"
      "#include \"galgas2/C_Compiler.h\"\n"
      "#include \"galgas2/C_galgas_CLI_Options.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_604 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_stringlist::cElement * operand_604 = NULL ;
    while (((operand_604 = enumerator_604.nextObject ()))) {
      macroValidPointer (operand_604) ;
      result << "#include \"" ;
      result << operand_604->mValue ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "  #define SOURCE_FILE_AT_LINE(line) \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".gSemantics\", line\n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)\n"
      "#else\n"
      "  #define SOURCE_FILE_AT_LINE(line) \n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) \n"
      "#endif\n"
      "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "parseSemanticComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_parseSemanticComponent (C_CompilerEx & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_semanticsComponentAST  & var_cas_outSemanticsComponentRoot
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_parseSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  GGS_lstring  var_cas_basenameKey = GGS_lstring ::constructor_new (inLexique, var_cas_basename, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (61)) ;
  const GGS_bool cond_3500 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (62)).reader_hasKey (var_cas_basename) ;
  if (cond_3500.isBuiltAndTrue ()) {
    const GGS_parsedSemanticsComponentMap  temp_3450 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (63)) ;
    if (temp_3450.isBuilt ()) {
      temp_3450 (HERE)->method_searchKey (inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (63)) ;
    }
  }else if (cond_3500.isBuiltAndFalse ()) {
    const GGS_string _depExtension = GGS_string ("") ;
    const GGS_string _depPath = GGS_string ("") ;
    if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
      C_Grammar_semanticsSLRgrammar::_performSourceFileParsing_ (inLexique,
                                    _depExtension.string (),
                                    _depPath.string (),
                                    NULL,
                                    var_cas_inSourceFile,
                                    var_cas_outSemanticsComponentRoot
                                    COMMA_SOURCE_FILE_AT_LINE (65)) ;
    }
    var_cas_ioParsedComponentStruct.mParsedSemanticsComponentMap.modifier_insertKey (inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (66)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_parseSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@grammarComponentASTList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_grammarComponentASTList::
elementOf_GGS_grammarComponentASTList (const GGS_grammarComponentAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mGrammarComponentAST (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarComponentASTList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_grammarComponentASTList * ptr = dynamic_cast <const elementOf_GGS_grammarComponentASTList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGrammarComponentAST.operator_isEqual (ptr->mGrammarComponentAST).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarComponentASTList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarComponentAST.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@grammarComponentASTList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarComponentASTList ("grammarComponentASTList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalAppendValues (const GGS_grammarComponentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalPrependValues (const GGS_grammarComponentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
addAssign_operation (const GGS_grammarComponentAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
operator_concat (const GGS_grammarComponentASTList & inOperand) const {
  GGS_grammarComponentASTList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
dotAssign_operation (const GGS_grammarComponentASTList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_grammarComponentASTList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_grammarComponentAST  p_0 = p->mGrammarComponentAST ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_grammarComponentAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mGrammarComponentAST
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList  GGS_grammarComponentASTList::
constructor_emptyList (void) {
  GGS_grammarComponentASTList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList  GGS_grammarComponentASTList::
constructor_listWithValue (const GGS_grammarComponentAST & argument_0) {
  GGS_grammarComponentASTList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalSubListWithRange (GGS_grammarComponentASTList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mGrammarComponentAST) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentASTList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentASTList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarComponentASTList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@grammarComponentASTList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
method_first (C_CompilerEx & inLexique,
              GGS_grammarComponentAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
method_last (C_CompilerEx & inLexique,
             GGS_grammarComponentAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_grammarComponentAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_grammarComponentAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentAST  GGS_grammarComponentASTList::
reader_mGrammarComponentASTAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGrammarComponentAST ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_setMGrammarComponentASTAtIndex (C_CompilerEx & inLexique,
                              const GGS_grammarComponentAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGrammarComponentAST = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_grammarComponentAST  & GGS_grammarComponentASTList::cEnumerator::_mGrammarComponentAST (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGrammarComponentAST ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarComponentASTList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarComponentASTList * p = NULL ;
    macroMyNew (p, GGS_grammarComponentASTList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarComponentASTList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarComponentASTList * p = dynamic_cast <const GGS_grammarComponentASTList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarComponentASTList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarComponentASTList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarComponentASTList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "recursivelyImportSemanticComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_recursivelyImportSemanticComponent (C_CompilerEx & inLexique,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_lstringlist  & var_cas_ioOptionComponentFileNameList,
                                GGS_grammarComponentASTList  & var_cas_ioGrammarComponentASTList,
                                GGS_semanticDeclarationListAST  & var_cas_ioSemanticDeclarationList,
                                GGS_stringset  & var_cas_ioParsedFileSet,
                                GGS_stringlist  & var_cas_ioHeaderIncludeList,
                                GGS_stringlist  & var_cas_ioImplementationIncludeList,
                                const GGS_lstringlist   var_cas_inListOfFilesToParse,
                                const GGS_string  var_cas_inDirectory
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_recursivelyImportSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_4416 (var_cas_inListOfFilesToParse, true) ;
    const GGS_lstringlist::cElement * operand_4416 = NULL ;
    while (((operand_4416 = enumerator_4416.nextObject ()))) {
      macroValidPointer (operand_4416) ;
      const GGS_lstring  var_cas_filePath = GGS_lstring ::constructor_new (inLexique, operand_4416->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inDirectory), operand_4416->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (92)) COMMA_SOURCE_FILE_AT_LINE (90)) ;
      const GGS_bool cond_6239 = (var_cas_ioParsedFileSet.reader_hasKey (var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (94)))).operator_not () ;
      if (cond_6239.isBuiltAndTrue ()) {
        var_cas_ioParsedFileSet.addAssign_operation (var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95))) ;
        const GGS_string var_cas_extension = var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (96)).reader_pathExtension () ;
        const GGS_bool cond_4915 = (var_cas_extension).operator_isEqual (GGS_string ("gOption")) ;
        if (cond_4915.isBuiltAndTrue ()) {
          var_cas_ioOptionComponentFileNameList.addAssign_operation (var_cas_filePath) ;
          var_cas_ioImplementationIncludeList.addAssign_operation (var_cas_filePath.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension ()) ;
        }else if (cond_4915.isBuiltAndFalse ()) {
          const GGS_bool cond_5280 = (var_cas_extension).operator_isEqual (GGS_string ("gGrammar")) ;
          if (cond_5280.isBuiltAndTrue ()) {
            GGS_grammarComponentAST  var_cas_grammarComponentAST ;
            ::routine_parseGrammarComponent (inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_grammarComponentAST COMMA_SOURCE_FILE_AT_LINE (102)) ;
            var_cas_ioGrammarComponentASTList.addAssign_operation (var_cas_grammarComponentAST) ;
            var_cas_ioImplementationIncludeList.addAssign_operation (var_cas_grammarComponentAST.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (108)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (108))) ;
          }else if (cond_5280.isBuiltAndFalse ()) {
            const GGS_bool cond_6226 = (var_cas_extension).operator_isEqual (GGS_string ("gSemantics")) ;
            if (cond_6226.isBuiltAndTrue ()) {
              GGS_semanticsComponentAST  var_cas_semanticsComponentRoot ;
              ::routine_parseSemanticComponent (inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (112)) ;
              var_cas_ioHeaderIncludeList.addAssign_operation (var_cas_semanticsComponentRoot.reader_mSemanticsComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (117)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (117))) ;
              var_cas_ioSemanticDeclarationList.dotAssign_operation (var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (119))) ;
              ::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_ioOptionComponentFileNameList,  var_cas_ioGrammarComponentASTList,  var_cas_ioSemanticDeclarationList,  var_cas_ioParsedFileSet,  var_cas_ioHeaderIncludeList,  var_cas_ioImplementationIncludeList,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (129)),  var_cas_inDirectory COMMA_SOURCE_FILE_AT_LINE (121)) ;
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_recursivelyImportSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "buildOptionComponentMapForSemanticAnalysis"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildOptionComponentMapForSemanticAnalysis (C_CompilerEx & inLexique,
                                const GGS_lstringlist   var_cas_inOptionComponentFileNameList,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_optionComponentMapForSemanticAnalysis  & var_cas_ioOptionComponentMapForSemanticAnalysis
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildOptionComponentMapForSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_6628 (var_cas_inOptionComponentFileNameList, true) ;
    const GGS_lstringlist::cElement * operand_6628 = NULL ;
    while (((operand_6628 = enumerator_6628.nextObject ()))) {
      macroValidPointer (operand_6628) ;
      GGS_lstring  var_cas_optionComponentName ;
      GGS_commandLineOptionMap  var_cas_boolOptionMap ;
      GGS_commandLineOptionMap  var_cas_uintOptionMap ;
      GGS_commandLineOptionMap  var_cas_stringOptionMap ;
      ::routine_parseOptionComponent (inLexique,  operand_6628->mValue,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentName,  var_cas_boolOptionMap,  var_cas_uintOptionMap,  var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (149)) ;
      var_cas_ioOptionComponentMapForSemanticAnalysis.modifier_insertKey (inLexique, var_cas_optionComponentName, var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (157)) ;
    }
  }
  const GGS_bool cond_9091 = (var_cas_ioOptionComponentMapForSemanticAnalysis.reader_hasKey (GGS_string ("galgas_cli_options"))).operator_not () ;
  if (cond_9091.isBuiltAndTrue ()) {
    GGS_2stringlist  var_cas_optionNameList = GGS_application ::constructor_boolOptionNameList () ;
    GGS_commandLineOptionMap  var_cas_boolOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (167)) ;
    {
      GGS_2stringlist::cEnumerator enumerator_7409 (var_cas_optionNameList, true) ;
      const GGS_2stringlist::cElement * operand_7409 = NULL ;
      while (((operand_7409 = enumerator_7409.nextObject ()))) {
        macroValidPointer (operand_7409) ;
        const GGS_bool cond_7781 = (operand_7409->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
        if (cond_7781.isBuiltAndTrue ()) {
          var_cas_boolOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_7409->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (171)), GGS_application ::constructor_boolOptionInvocationLetter (operand_7409->mValue0, operand_7409->mValue1), GGS_application ::constructor_boolOptionInvocationString (operand_7409->mValue0, operand_7409->mValue1), GGS_application ::constructor_boolOptionCommentString (operand_7409->mValue0, operand_7409->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (170)) ;
        }
      }
    }
    var_cas_optionNameList = GGS_application ::constructor_uintOptionNameList () ;
    GGS_commandLineOptionMap  var_cas_uintOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (181)) ;
    {
      GGS_2stringlist::cEnumerator enumerator_7950 (var_cas_optionNameList, true) ;
      const GGS_2stringlist::cElement * operand_7950 = NULL ;
      while (((operand_7950 = enumerator_7950.nextObject ()))) {
        macroValidPointer (operand_7950) ;
        const GGS_bool cond_8322 = (operand_7950->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
        if (cond_8322.isBuiltAndTrue ()) {
          var_cas_uintOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_7950->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (185)), GGS_application ::constructor_uintOptionInvocationLetter (operand_7950->mValue0, operand_7950->mValue1), GGS_application ::constructor_uintOptionInvocationString (operand_7950->mValue0, operand_7950->mValue1), GGS_application ::constructor_uintOptionCommentString (operand_7950->mValue0, operand_7950->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (184)) ;
        }
      }
    }
    var_cas_optionNameList = GGS_application ::constructor_stringOptionNameList () ;
    GGS_commandLineOptionMap  var_cas_stringOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (195)) ;
    {
      GGS_2stringlist::cEnumerator enumerator_8495 (var_cas_optionNameList, true) ;
      const GGS_2stringlist::cElement * operand_8495 = NULL ;
      while (((operand_8495 = enumerator_8495.nextObject ()))) {
        macroValidPointer (operand_8495) ;
        const GGS_bool cond_8875 = (operand_8495->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
        if (cond_8875.isBuiltAndTrue ()) {
          var_cas_stringOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_8495->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (199)), GGS_application ::constructor_stringOptionInvocationLetter (operand_8495->mValue0, operand_8495->mValue1), GGS_application ::constructor_stringOptionInvocationString (operand_8495->mValue0, operand_8495->mValue1), GGS_application ::constructor_stringOptionCommentString (operand_8495->mValue0, operand_8495->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (198)) ;
        }
      }
    }
    var_cas_ioOptionComponentMapForSemanticAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("galgas_cli_options"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (209)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (208)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildOptionComponentMapForSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
// Implementation of routine "buildGrammarComponentMapForSemanticAnalysis"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildGrammarComponentMapForSemanticAnalysis (C_CompilerEx & inLexique,
                                const GGS_grammarComponentASTList   var_cas_inGrammarComponentASTList,
                                GGS_semanticContext & var_cas_ioSemanticContext
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildGrammarComponentMapForSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_grammarComponentASTList::cEnumerator enumerator_9427 (var_cas_inGrammarComponentASTList, true) ;
    const GGS_grammarComponentASTList::cElement * operand_9427 = NULL ;
    while (((operand_9427 = enumerator_9427.nextObject ()))) {
      macroValidPointer (operand_9427) ;
      GGS_grammarLabelMap  var_cas_grammarLabelMap = GGS_grammarLabelMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (226)) ;
      {
        GGS_nonTerminalLabelListAST::cEnumerator enumerator_9529 (operand_9427->mGrammarComponentAST.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (227)), true) ;
        const GGS_nonTerminalLabelListAST::cElement * operand_9529 = NULL ;
        while (((operand_9529 = enumerator_9529.nextObject ()))) {
          macroValidPointer (operand_9529) ;
          GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
          {
            GGS_formalParameterListAST::cEnumerator enumerator_9701 (operand_9529->mFormalArgumentList, true) ;
            const GGS_formalParameterListAST::cElement * operand_9701 = NULL ;
            while (((operand_9701 = enumerator_9701.nextObject ()))) {
              macroValidPointer (operand_9701) ;
              var_cas_formalArgumentList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_9701->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (232)), operand_9701->mFormalArgumentPassingMode) ;
            }
          }
          var_cas_grammarLabelMap.modifier_insertKey (inLexique, operand_9529->mLabelName, var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (236)) ;
        }
      }
      var_cas_ioSemanticContext.mGrammarMap.modifier_insertKey (inLexique, operand_9427->mGrammarComponentAST.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (243)), var_cas_grammarLabelMap COMMA_SOURCE_FILE_AT_LINE (242)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildGrammarComponentMapForSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileSemanticsComponent (C_CompilerEx & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticsComponentAST  var_cas_semanticsComponentRoot ;
  ::routine_parseSemanticComponent (inLexique,  var_cas_inSourceFile,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (258)) ;
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  const GGS_lstring  var_cas_componentName = var_cas_semanticsComponentRoot.reader_mSemanticsComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (265)) ;
  const GGS_bool cond_11045 = (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (266))).operator_isNotEqual (var_cas_basename) ;
  if (cond_11045.isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (268)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (270)) ;
  }
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationList = var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (273)) ;
  GGS_stringset  var_cas_parsedFileSet = GGS_stringset ::constructor_setWithString (var_cas_inSourceFile.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (274))) ;
  GGS_lstringlist  var_cas_optionComponentFileNameList = GGS_lstringlist ::constructor_emptyList () ;
  GGS_grammarComponentASTList  var_cas_grammarComponentASTList = GGS_grammarComponentASTList ::constructor_emptyList () ;
  GGS_stringlist  var_cas_headerIncludeList = GGS_stringlist ::constructor_emptyList () ;
  GGS_stringlist  var_cas_implementationIncludeList = GGS_stringlist ::constructor_emptyList () ;
  ::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentFileNameList,  var_cas_grammarComponentASTList,  var_cas_semanticDeclarationList,  var_cas_parsedFileSet,  var_cas_headerIncludeList,  var_cas_implementationIncludeList,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (287)),  var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent () COMMA_SOURCE_FILE_AT_LINE (279)) ;
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationListWithPredefinedTypes = var_cas_semanticDeclarationList ;
  ::routine_appendPredefinedTypesASTs (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes COMMA_SOURCE_FILE_AT_LINE (292)) ;
  GGS_semanticContext var_cas_semanticContext ;
  ::routine_buildSemanticContext (inLexique,  var_cas_inSourceFile.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (296)),  var_cas_semanticDeclarationListWithPredefinedTypes,  var_cas_semanticsComponentRoot.reader_mEndOfSourceFile (inLexique COMMA_SOURCE_FILE_AT_LINE (298)),  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (295)) ;
  ::routine_buildOptionComponentMapForSemanticAnalysis (inLexique,  var_cas_optionComponentFileNameList,  var_cas_ioParsedComponentStruct,  var_cas_semanticContext.mOptionComponentMapForSemanticAnalysis COMMA_SOURCE_FILE_AT_LINE (302)) ;
  ::routine_buildGrammarComponentMapForSemanticAnalysis (inLexique,  var_cas_grammarComponentASTList,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (308)) ;
  GGS_semanticDeclarationSortedListForGeneration  var_cas_decoratedDeclarationListForGeneration ;
  ::routine_performSemanticAnalysis (inLexique,  var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (315)),  var_cas_semanticContext,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (314)) ;
  const GGS_bool cond_13699 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (320))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_13699.isBuiltAndTrue ()) {
    GGS_string var_cas_headerString = template_filewrapper_semanticFileGenerationTemplate_semanticFileHeader (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (322)), var_cas_headerIncludeList, var_cas_semanticContext.mTypeMap.reader_allKeyList (inLexique COMMA_SOURCE_FILE_AT_LINE (324))) ;
    {
      GGS_semanticDeclarationSortedListForGeneration::cEnumerator enumerator_13271 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationSortedListForGeneration::cElement * operand_13271 = NULL ;
      while (((operand_13271 = enumerator_13271.nextObject ()))) {
        macroValidPointer (operand_13271) ;
        var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration1 (operand_13271->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_13271->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (327)))) ;
      }
    }
    {
      GGS_semanticDeclarationSortedListForGeneration::cEnumerator enumerator_13400 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationSortedListForGeneration::cElement * operand_13400 = NULL ;
      while (((operand_13400 = enumerator_13400.nextObject ()))) {
        macroValidPointer (operand_13400) ;
        var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration2 (operand_13400->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_13400->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (330)))) ;
      }
    }
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (334))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_headerString, GGS_string ("\n"
      "\n"), GGS_string ("#endif\n") COMMA_SOURCE_FILE_AT_LINE (332)) ;
  }
  const GGS_bool cond_14536 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (343))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_14536.isBuiltAndTrue ()) {
    GGS_string var_cas_implementationString = template_filewrapper_semanticFileGenerationTemplate_semanticFileImplementation (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (345)), var_cas_implementationIncludeList) ;
    {
      GGS_semanticDeclarationSortedListForGeneration::cEnumerator enumerator_14003 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationSortedListForGeneration::cElement * operand_14003 = NULL ;
      while (((operand_14003 = enumerator_14003.nextObject ()))) {
        macroValidPointer (operand_14003) ;
        var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendSpecificImplementation (operand_14003->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_14003->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (350)))) ;
        var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendTypeGenericImplementation (operand_14003->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_14003->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (352)))) ;
      }
    }
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (356))).operator_concat (GGS_string (".cpp")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_implementationString, GGS_string ("\n"
      "\n"), GGS_string ("\n") COMMA_SOURCE_FILE_AT_LINE (354)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

