//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'semanticsCompilation.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      october 2nd, 2010, at 14h5'45"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "semanticsSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of wrapper 'semanticFileGenerationTemplate'         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_semanticFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_semanticFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_semanticFileGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_semanticFileGenerationTemplate_0,
  0,
  gWrapperAllDirectories_semanticFileGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'semanticFileHeader' template of 'semanticFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_semanticFileGenerationTemplate_semanticFileHeader (C_Compiler & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_stringlist & var_cas_IMPORTED_COMPONENT_LIST,
                                const GGS_lstringlist & var_cas_TYPE_PREDECLARATION_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt ()
    && var_cas_TYPE_PREDECLARATION_LIST.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "#define " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"galgas2/predefined-types.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_321 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_stringlist::cElement * operand_321 = NULL ;
    while (((operand_321 = enumerator_321.nextObject ()))) {
      macroValidPointer (operand_321) ;
      result << "#include \"" ;
      result << operand_321->mValue ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_485 (var_cas_TYPE_PREDECLARATION_LIST, true) ;
    const GGS_lstringlist::cElement * operand_485 = NULL ;
    while (((operand_485 = enumerator_485.nextObject ()))) {
      macroValidPointer (operand_485) ;
      result << "class GALGAS_" ;
      result << operand_485->mValue.ggs_string ().reader_identifierRepresentation () ;
      result << " ;\n"
        "class GALGASap_" ;
      result << operand_485->mValue.ggs_string ().reader_identifierRepresentation () ;
      result << " ;\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'semanticFileImplementation' template of 'semanticFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_semanticFileGenerationTemplate_semanticFileImplementation (C_Compiler & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_stringlist & var_cas_IMPORTED_COMPONENT_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt () ;
  if (isBuilt) {
    result << "#include \"version_libpm.h\"\n"
      "#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER\n"
      "  #error \"This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".h\"\n"
      "#include \"galgas-utilities/C_Compiler.h\"\n"
      "#include \"galgas/C_galgas_CLI_Options.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_612 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_stringlist::cElement * operand_612 = NULL ;
    while (((operand_612 = enumerator_612.nextObject ()))) {
      macroValidPointer (operand_612) ;
      result << "#include \"" ;
      result << operand_612->mValue ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "  #define SOURCE_FILE_AT_LINE(line) \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".gSemantics\", line\n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)\n"
      "#else\n"
      "  #define SOURCE_FILE_AT_LINE(line) \n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) \n"
      "#endif\n"
      "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "parseSemanticComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_parseSemanticComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_semanticsComponentAST  & var_cas_outSemanticsComponentRoot
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_parseSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  GGS_lstring  var_cas_basenameKey = GGS_lstring ::constructor_new (inLexique, var_cas_basename, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (60)) ;
  const GGS_bool cond_3458 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (61)).reader_hasKey (var_cas_basename) ;
  if (cond_3458.isBuiltAndTrue ()) {
    const GGS_parsedSemanticsComponentMap  temp_3408 = var_cas_ioParsedComponentStruct.reader_mParsedSemanticsComponentMap (inLexique COMMA_SOURCE_FILE_AT_LINE (62)) ;
    if (temp_3408.isBuilt ()) {
      temp_3408 (HERE)->method_searchKey (inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (62)) ;
    }
  }else if (cond_3458.isBuiltAndFalse ()) {
    const GGS_string _depExtension = GGS_string ("") ;
    const GGS_string _depPath = GGS_string ("") ;
    if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
      C_Grammar_semanticsSLRgrammar::_performSourceFileParsing_ (inLexique,
                                    _depExtension.string (),
                                    _depPath.string (),
                                    NULL,
                                    var_cas_inSourceFile,
                                    var_cas_outSemanticsComponentRoot
                                    COMMA_SOURCE_FILE_AT_LINE (64)) ;
    }
    var_cas_ioParsedComponentStruct.mParsedSemanticsComponentMap.modifier_insertKey (inLexique, var_cas_basenameKey, var_cas_outSemanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (65)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_parseSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@grammarComponentASTList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_grammarComponentASTList::
elementOf_GGS_grammarComponentASTList (const GGS_grammarComponentAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mGrammarComponentAST (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarComponentASTList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_grammarComponentASTList * ptr = dynamic_cast <const elementOf_GGS_grammarComponentASTList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGrammarComponentAST.operator_isEqual (ptr->mGrammarComponentAST).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarComponentASTList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarComponentAST.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@grammarComponentASTList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarComponentASTList ("grammarComponentASTList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalAppendValues (const GGS_grammarComponentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalPrependValues (const GGS_grammarComponentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
addAssign_operation (const GGS_grammarComponentAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
operator_concat (const GGS_grammarComponentASTList & inOperand) const {
  GGS_grammarComponentASTList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
dotAssign_operation (const GGS_grammarComponentASTList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_grammarComponentASTList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_grammarComponentAST  p_0 = p->mGrammarComponentAST ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_grammarComponentAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mGrammarComponentAST
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList  GGS_grammarComponentASTList::
constructor_emptyList (void) {
  GGS_grammarComponentASTList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList  GGS_grammarComponentASTList::
constructor_listWithValue (const GGS_grammarComponentAST & argument_0) {
  GGS_grammarComponentASTList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
internalSubListWithRange (GGS_grammarComponentASTList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mGrammarComponentAST) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentASTList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentASTList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarComponentASTList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@grammarComponentASTList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
method_first (C_Compiler & inLexique,
              GGS_grammarComponentAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
method_last (C_Compiler & inLexique,
             GGS_grammarComponentAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_grammarComponentAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_popLast (C_Compiler & inLexique,
                GGS_grammarComponentAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mGrammarComponentAST ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_grammarComponentAST  GGS_grammarComponentASTList::
reader_mGrammarComponentASTAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_grammarComponentAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGrammarComponentAST ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarComponentASTList::
modifier_setMGrammarComponentASTAtIndex (C_Compiler & inLexique,
                              const GGS_grammarComponentAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGrammarComponentAST = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_grammarComponentAST  & GGS_grammarComponentASTList::cEnumerator::_mGrammarComponentAST (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGrammarComponentAST ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarComponentASTList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarComponentASTList * p = NULL ;
    macroMyNew (p, GGS_grammarComponentASTList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarComponentASTList GGS_grammarComponentASTList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarComponentASTList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarComponentASTList * p = dynamic_cast <const GGS_grammarComponentASTList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarComponentASTList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarComponentASTList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarComponentASTList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "recursivelyImportSemanticComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_recursivelyImportSemanticComponent (C_Compiler & inLexique,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_lstringlist  & var_cas_ioOptionComponentFileNameList,
                                GGS_grammarComponentASTList  & var_cas_ioGrammarComponentASTList,
                                GGS_semanticDeclarationListAST  & var_cas_ioSemanticDeclarationList,
                                GGS_stringset  & var_cas_ioParsedFileSet,
                                GGS_stringlist  & var_cas_ioHeaderIncludeList,
                                GGS_stringlist  & var_cas_ioImplementationIncludeList,
                                const GGS_lstringlist   var_cas_inListOfFilesToParse,
                                const GGS_string  var_cas_inDirectory
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_recursivelyImportSemanticComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_4374 (var_cas_inListOfFilesToParse, true) ;
    const GGS_lstringlist::cElement * operand_4374 = NULL ;
    while (((operand_4374 = enumerator_4374.nextObject ()))) {
      macroValidPointer (operand_4374) ;
      const GGS_lstring  var_cas_filePath = GGS_lstring ::constructor_new (inLexique, operand_4374->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inDirectory), operand_4374->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (91)) COMMA_SOURCE_FILE_AT_LINE (89)) ;
      const GGS_bool cond_6197 = (var_cas_ioParsedFileSet.reader_hasKey (var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (93)))).operator_not () ;
      if (cond_6197.isBuiltAndTrue ()) {
        var_cas_ioParsedFileSet.addAssign_operation (var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (94))) ;
        const GGS_string var_cas_extension = var_cas_filePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95)).reader_pathExtension () ;
        const GGS_bool cond_4873 = (var_cas_extension).operator_isEqual (GGS_string ("gOption")) ;
        if (cond_4873.isBuiltAndTrue ()) {
          var_cas_ioOptionComponentFileNameList.addAssign_operation (var_cas_filePath) ;
          var_cas_ioImplementationIncludeList.addAssign_operation (var_cas_filePath.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension ()) ;
        }else if (cond_4873.isBuiltAndFalse ()) {
          const GGS_bool cond_5238 = (var_cas_extension).operator_isEqual (GGS_string ("gGrammar")) ;
          if (cond_5238.isBuiltAndTrue ()) {
            GGS_grammarComponentAST  var_cas_grammarComponentAST ;
            ::routine_parseGrammarComponent (inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_grammarComponentAST COMMA_SOURCE_FILE_AT_LINE (101)) ;
            var_cas_ioGrammarComponentASTList.addAssign_operation (var_cas_grammarComponentAST) ;
            var_cas_ioImplementationIncludeList.addAssign_operation (var_cas_grammarComponentAST.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (107)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (107))) ;
          }else if (cond_5238.isBuiltAndFalse ()) {
            const GGS_bool cond_6184 = (var_cas_extension).operator_isEqual (GGS_string ("gSemantics")) ;
            if (cond_6184.isBuiltAndTrue ()) {
              GGS_semanticsComponentAST  var_cas_semanticsComponentRoot ;
              ::routine_parseSemanticComponent (inLexique,  var_cas_filePath,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (111)) ;
              var_cas_ioHeaderIncludeList.addAssign_operation (var_cas_semanticsComponentRoot.reader_mSemanticsComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (116)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (116))) ;
              var_cas_ioSemanticDeclarationList.dotAssign_operation (var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (118))) ;
              ::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_ioOptionComponentFileNameList,  var_cas_ioGrammarComponentASTList,  var_cas_ioSemanticDeclarationList,  var_cas_ioParsedFileSet,  var_cas_ioHeaderIncludeList,  var_cas_ioImplementationIncludeList,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (128)),  var_cas_inDirectory COMMA_SOURCE_FILE_AT_LINE (120)) ;
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_recursivelyImportSemanticComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "buildOptionComponentMapForSemanticAnalysis"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildOptionComponentMapForSemanticAnalysis (C_Compiler & inLexique,
                                const GGS_lstringlist   var_cas_inOptionComponentFileNameList,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct,
                                GGS_optionComponentMapForSemanticAnalysis  & var_cas_ioOptionComponentMapForSemanticAnalysis
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildOptionComponentMapForSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_lstringlist::cEnumerator enumerator_6586 (var_cas_inOptionComponentFileNameList, true) ;
    const GGS_lstringlist::cElement * operand_6586 = NULL ;
    while (((operand_6586 = enumerator_6586.nextObject ()))) {
      macroValidPointer (operand_6586) ;
      GGS_lstring  var_cas_optionComponentName ;
      GGS_commandLineOptionMap  var_cas_boolOptionMap ;
      GGS_commandLineOptionMap  var_cas_uintOptionMap ;
      GGS_commandLineOptionMap  var_cas_stringOptionMap ;
      ::routine_parseOptionComponent (inLexique,  operand_6586->mValue,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentName,  var_cas_boolOptionMap,  var_cas_uintOptionMap,  var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (148)) ;
      var_cas_ioOptionComponentMapForSemanticAnalysis.modifier_insertKey (inLexique, var_cas_optionComponentName, var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (156)) ;
    }
  }
  GGS_string2list  var_cas_optionNameList = GGS_system ::constructor_boolOptionNameList () ;
  GGS_commandLineOptionMap  var_cas_boolOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (165)) ;
  {
    GGS_string2list::cEnumerator enumerator_7271 (var_cas_optionNameList, true) ;
    const GGS_string2list::cElement * operand_7271 = NULL ;
    while (((operand_7271 = enumerator_7271.nextObject ()))) {
      macroValidPointer (operand_7271) ;
      const GGS_bool cond_7610 = (operand_7271->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
      if (cond_7610.isBuiltAndTrue ()) {
        var_cas_boolOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_7271->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (169)), GGS_system ::constructor_boolOptionInvocationLetter (operand_7271->mValue0, operand_7271->mValue1), GGS_system ::constructor_boolOptionInvocationString (operand_7271->mValue0, operand_7271->mValue1), GGS_system ::constructor_boolOptionCommentString (operand_7271->mValue0, operand_7271->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (168)) ;
      }
    }
  }
  var_cas_optionNameList = GGS_system ::constructor_uintOptionNameList () ;
  GGS_commandLineOptionMap  var_cas_uintOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (179)) ;
  {
    GGS_string2list::cEnumerator enumerator_7764 (var_cas_optionNameList, true) ;
    const GGS_string2list::cElement * operand_7764 = NULL ;
    while (((operand_7764 = enumerator_7764.nextObject ()))) {
      macroValidPointer (operand_7764) ;
      const GGS_bool cond_8103 = (operand_7764->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
      if (cond_8103.isBuiltAndTrue ()) {
        var_cas_uintOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_7764->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (183)), GGS_system ::constructor_uintOptionInvocationLetter (operand_7764->mValue0, operand_7764->mValue1), GGS_system ::constructor_uintOptionInvocationString (operand_7764->mValue0, operand_7764->mValue1), GGS_system ::constructor_uintOptionCommentString (operand_7764->mValue0, operand_7764->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (182)) ;
      }
    }
  }
  var_cas_optionNameList = GGS_system ::constructor_stringOptionNameList () ;
  GGS_commandLineOptionMap  var_cas_stringOptionMap = GGS_commandLineOptionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (193)) ;
  {
    GGS_string2list::cEnumerator enumerator_8261 (var_cas_optionNameList, true) ;
    const GGS_string2list::cElement * operand_8261 = NULL ;
    while (((operand_8261 = enumerator_8261.nextObject ()))) {
      macroValidPointer (operand_8261) ;
      const GGS_bool cond_8608 = (operand_8261->mValue0).operator_isEqual (GGS_string ("galgas_cli_options")) ;
      if (cond_8608.isBuiltAndTrue ()) {
        var_cas_stringOptionMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_8261->mValue1, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (197)), GGS_system ::constructor_stringOptionInvocationLetter (operand_8261->mValue0, operand_8261->mValue1), GGS_system ::constructor_stringOptionInvocationString (operand_8261->mValue0, operand_8261->mValue1), GGS_system ::constructor_stringOptionCommentString (operand_8261->mValue0, operand_8261->mValue1), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (196)) ;
      }
    }
  }
  var_cas_ioOptionComponentMapForSemanticAnalysis.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("galgas_cli_options"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (207)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap COMMA_SOURCE_FILE_AT_LINE (206)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildOptionComponentMapForSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
// Implementation of routine "buildGrammarComponentMapForSemanticAnalysis"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildGrammarComponentMapForSemanticAnalysis (C_Compiler & inLexique,
                                const GGS_grammarComponentASTList   var_cas_inGrammarComponentASTList,
                                GGS_semanticContext & var_cas_ioSemanticContext
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildGrammarComponentMapForSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_grammarComponentASTList::cEnumerator enumerator_9133 (var_cas_inGrammarComponentASTList, true) ;
    const GGS_grammarComponentASTList::cElement * operand_9133 = NULL ;
    while (((operand_9133 = enumerator_9133.nextObject ()))) {
      macroValidPointer (operand_9133) ;
      GGS_grammarLabelMap  var_cas_grammarLabelMap = GGS_grammarLabelMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (223)) ;
      {
        GGS_nonTerminalLabelListAST::cEnumerator enumerator_9235 (operand_9133->mGrammarComponentAST.reader_mStartSymbolLabelList (inLexique COMMA_SOURCE_FILE_AT_LINE (224)), true) ;
        const GGS_nonTerminalLabelListAST::cElement * operand_9235 = NULL ;
        while (((operand_9235 = enumerator_9235.nextObject ()))) {
          macroValidPointer (operand_9235) ;
          GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
          {
            GGS_formalParameterListAST::cEnumerator enumerator_9407 (operand_9235->mFormalArgumentList, true) ;
            const GGS_formalParameterListAST::cElement * operand_9407 = NULL ;
            while (((operand_9407 = enumerator_9407.nextObject ()))) {
              macroValidPointer (operand_9407) ;
              var_cas_formalArgumentList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_9407->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (229)), operand_9407->mFormalArgumentPassingMode) ;
            }
          }
          var_cas_grammarLabelMap.modifier_insertKey (inLexique, operand_9235->mLabelName, var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (233)) ;
        }
      }
      var_cas_ioSemanticContext.mGrammarMap.modifier_insertKey (inLexique, operand_9133->mGrammarComponentAST.reader_mGrammarName (inLexique COMMA_SOURCE_FILE_AT_LINE (240)), var_cas_grammarLabelMap COMMA_SOURCE_FILE_AT_LINE (239)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildGrammarComponentMapForSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileSemanticsComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticsComponentAST  var_cas_semanticsComponentRoot ;
  ::routine_parseSemanticComponent (inLexique,  var_cas_inSourceFile,  var_cas_ioParsedComponentStruct,  var_cas_semanticsComponentRoot COMMA_SOURCE_FILE_AT_LINE (255)) ;
  const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  const GGS_lstring  var_cas_componentName = var_cas_semanticsComponentRoot.reader_mSemanticsComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (262)) ;
  const GGS_bool cond_10751 = (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (263))).operator_isNotEqual (var_cas_basename) ;
  if (cond_10751.isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (265)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (267)) ;
  }
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationList = var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (270)) ;
  GGS_stringset  var_cas_parsedFileSet = GGS_stringset ::constructor_setWithString (var_cas_inSourceFile.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (271))) ;
  GGS_lstringlist  var_cas_optionComponentFileNameList = GGS_lstringlist ::constructor_emptyList () ;
  GGS_grammarComponentASTList  var_cas_grammarComponentASTList = GGS_grammarComponentASTList ::constructor_emptyList () ;
  GGS_stringlist  var_cas_headerIncludeList = GGS_stringlist ::constructor_emptyList () ;
  GGS_stringlist  var_cas_implementationIncludeList = GGS_stringlist ::constructor_emptyList () ;
  ::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentFileNameList,  var_cas_grammarComponentASTList,  var_cas_semanticDeclarationList,  var_cas_parsedFileSet,  var_cas_headerIncludeList,  var_cas_implementationIncludeList,  var_cas_semanticsComponentRoot.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (284)),  var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent () COMMA_SOURCE_FILE_AT_LINE (276)) ;
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationListWithPredefinedTypes = var_cas_semanticDeclarationList ;
  ::routine_appendPredefinedTypesASTs (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes COMMA_SOURCE_FILE_AT_LINE (289)) ;
  GGS_semanticContext var_cas_semanticContext ;
  ::routine_buildSemanticContext (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes,  var_cas_semanticsComponentRoot.reader_mEndOfSourceFile (inLexique COMMA_SOURCE_FILE_AT_LINE (294)),  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (292)) ;
  ::routine_buildOptionComponentMapForSemanticAnalysis (inLexique,  var_cas_optionComponentFileNameList,  var_cas_ioParsedComponentStruct,  var_cas_semanticContext.mOptionComponentMapForSemanticAnalysis COMMA_SOURCE_FILE_AT_LINE (298)) ;
  ::routine_buildGrammarComponentMapForSemanticAnalysis (inLexique,  var_cas_grammarComponentASTList,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (304)) ;
  GGS_semanticDeclarationListForGeneration  var_cas_decoratedDeclarationListForGeneration ;
  ::routine_performSemanticAnalysis (inLexique,  var_cas_semanticsComponentRoot.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (311)),  var_cas_semanticContext,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (310)) ;
  const GGS_bool cond_13366 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (316))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_13366.isBuiltAndTrue ()) {
    GGS_string var_cas_headerString = template_filewrapper_semanticFileGenerationTemplate_semanticFileHeader (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (318)), var_cas_headerIncludeList, var_cas_semanticContext.mTypeMap.reader_allKeyList (inLexique COMMA_SOURCE_FILE_AT_LINE (320))) ;
    {
      GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_12938 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationListForGeneration::cElement * operand_12938 = NULL ;
      while (((operand_12938 = enumerator_12938.nextObject ()))) {
        macroValidPointer (operand_12938) ;
        var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration1 (operand_12938->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_12938->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (323)))) ;
      }
    }
    {
      GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_13067 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationListForGeneration::cElement * operand_13067 = NULL ;
      while (((operand_13067 = enumerator_13067.nextObject ()))) {
        macroValidPointer (operand_13067) ;
        var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration2 (operand_13067->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_13067->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (326)))) ;
      }
    }
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (330))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_headerString, GGS_string ("\n"
      "\n"), GGS_string ("#endif\n") COMMA_SOURCE_FILE_AT_LINE (328)) ;
  }
  const GGS_bool cond_14070 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (339))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_14070.isBuiltAndTrue ()) {
    GGS_string var_cas_implementationString = template_filewrapper_semanticFileGenerationTemplate_semanticFileImplementation (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (341)), var_cas_implementationIncludeList) ;
    {
      GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_13670 (var_cas_decoratedDeclarationListForGeneration, true) ;
      const GGS_semanticDeclarationListForGeneration::cElement * operand_13670 = NULL ;
      while (((operand_13670 = enumerator_13670.nextObject ()))) {
        macroValidPointer (operand_13670) ;
        var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendSpecificImplementation (operand_13670->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_13670->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (345)))) ;
        var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendTypeGenericImplementation (operand_13670->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_13670->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (346)))) ;
      }
    }
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (350))).operator_concat (GGS_string (".cpp")), GGS_string ("//"), GGS_string ("\n"
      "\n"), var_cas_implementationString, GGS_string ("\n"
      "\n"), GGS_string ("\n") COMMA_SOURCE_FILE_AT_LINE (348)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

