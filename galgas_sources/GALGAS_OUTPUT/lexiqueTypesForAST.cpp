//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'lexiqueTypesForAST.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 28th, 2010, at 23h18'56"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "lexiqueTypesForAST.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueTypesForAST.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExpressionAST::
cPtr_lexicalExpressionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExpressionAST * GGS_lexicalExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalExpressionAST) ;
    return (cPtr_lexicalExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalExpressionAST (& typeid (cPtr_lexicalExpressionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalExpressionAST ("lexicalExpressionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST::
GGS_lexicalExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST::
GGS_lexicalExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalExpressionAST GGS_lexicalExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExpressionAST::actualTypeName (void) const {
  return "lexicalExpressionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_lexicalExpressionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__lexicalExpressionAST ("lexicalExpressionAST", & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalExpressionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST GGS_lexicalExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalExpressionAST * p = dynamic_cast <const GGS_lexicalExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalInstructionAST::
cPtr_lexicalInstructionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalInstructionAST * GGS_lexicalInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalInstructionAST) ;
    return (cPtr_lexicalInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalInstructionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalInstructionAST (& typeid (cPtr_lexicalInstructionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalInstructionAST ("lexicalInstructionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_lexicalInstructionAST::
GGS_lexicalInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionAST::
GGS_lexicalInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalInstructionAST GGS_lexicalInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalInstructionAST::actualTypeName (void) const {
  return "lexicalInstructionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_lexicalInstructionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__lexicalInstructionAST ("lexicalInstructionAST", & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionAST GGS_lexicalInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalInstructionAST * p = dynamic_cast <const GGS_lexicalInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalInstructionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalInstructionListAST::
elementOf_GGS_lexicalInstructionListAST (const GGS_lexicalInstructionAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalInstructionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalInstructionListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalInstructionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalInstructionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalInstructionListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalInstructionListAST ("lexicalInstructionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
internalAppendValues (const GGS_lexicalInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
internalPrependValues (const GGS_lexicalInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
addAssign_operation (const GGS_lexicalInstructionAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST GGS_lexicalInstructionListAST::
operator_concat (const GGS_lexicalInstructionListAST & inOperand) const {
  GGS_lexicalInstructionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
dotAssign_operation (const GGS_lexicalInstructionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalInstructionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalInstructionAST  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lexicalInstructionAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalInstructionListAST::
constructor_emptyList (void) {
  GGS_lexicalInstructionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalInstructionListAST::
constructor_listWithValue (const GGS_lexicalInstructionAST & argument_0) {
  GGS_lexicalInstructionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
internalSubListWithRange (GGS_lexicalInstructionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST GGS_lexicalInstructionListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST GGS_lexicalInstructionListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalInstructionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalInstructionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lexicalInstructionAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lexicalInstructionAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lexicalInstructionAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lexicalInstructionAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionAST  GGS_lexicalInstructionListAST::
reader_mInstructionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionListAST::
modifier_setMInstructionAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalInstructionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionAST  & GGS_lexicalInstructionListAST::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalInstructionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalInstructionListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalInstructionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST GGS_lexicalInstructionListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalInstructionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalInstructionListAST * p = dynamic_cast <const GGS_lexicalInstructionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalInstructionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalInstructionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalInstructionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@metamodelTemplateDelimitorListAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_metamodelTemplateDelimitorListAST::
elementOf_GGS_metamodelTemplateDelimitorListAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mStartString (argument_0),
mOptionList (argument_1),
mEndString (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_metamodelTemplateDelimitorListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_metamodelTemplateDelimitorListAST * ptr = dynamic_cast <const elementOf_GGS_metamodelTemplateDelimitorListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartString.operator_isEqual (ptr->mStartString).boolValue ()
         && mOptionList.operator_isEqual (ptr->mOptionList).boolValue ()
         && mEndString.operator_isEqual (ptr->mEndString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_metamodelTemplateDelimitorListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndString.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@metamodelTemplateDelimitorListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_metamodelTemplateDelimitorListAST ("metamodelTemplateDelimitorListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST GGS_metamodelTemplateDelimitorListAST::
operator_concat (const GGS_metamodelTemplateDelimitorListAST & inOperand) const {
  GGS_metamodelTemplateDelimitorListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
dotAssign_operation (const GGS_metamodelTemplateDelimitorListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_metamodelTemplateDelimitorListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mStartString ;
          GGS_lstringlist  p_1 = p->mOptionList ;
          GGS_lstring  p_2 = p->mEndString ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStartString,
                                ptr->mOptionList,
                                ptr->mEndString
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST  GGS_metamodelTemplateDelimitorListAST::
constructor_emptyList (void) {
  GGS_metamodelTemplateDelimitorListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST  GGS_metamodelTemplateDelimitorListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_metamodelTemplateDelimitorListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
internalSubListWithRange (GGS_metamodelTemplateDelimitorListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mStartString, ptr->mOptionList, ptr->mEndString) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST GGS_metamodelTemplateDelimitorListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_metamodelTemplateDelimitorListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST GGS_metamodelTemplateDelimitorListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_metamodelTemplateDelimitorListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelTemplateDelimitorListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@metamodelTemplateDelimitorListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelTemplateDelimitorListAST::
reader_mStartStringAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStartString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelTemplateDelimitorListAST::
reader_mOptionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelTemplateDelimitorListAST::
reader_mEndStringAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
modifier_setMStartStringAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStartString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
modifier_setMOptionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorListAST::
modifier_setMEndStringAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_metamodelTemplateDelimitorListAST::cEnumerator::_mStartString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStartString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_metamodelTemplateDelimitorListAST::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_metamodelTemplateDelimitorListAST::cEnumerator::_mEndString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndString ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_metamodelTemplateDelimitorListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_metamodelTemplateDelimitorListAST * p = NULL ;
    macroMyNew (p, GGS_metamodelTemplateDelimitorListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST GGS_metamodelTemplateDelimitorListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_metamodelTemplateDelimitorListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_metamodelTemplateDelimitorListAST * p = dynamic_cast <const GGS_metamodelTemplateDelimitorListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_metamodelTemplateDelimitorListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_metamodelTemplateDelimitorListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_metamodelTemplateDelimitorListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@templateReplacementListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateReplacementListAST::
elementOf_GGS_templateReplacementListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMatchString (argument_0),
mReplacementString (argument_1),
mReplacementFunction (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateReplacementListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateReplacementListAST * ptr = dynamic_cast <const elementOf_GGS_templateReplacementListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchString.operator_isEqual (ptr->mMatchString).boolValue ()
         && mReplacementString.operator_isEqual (ptr->mReplacementString).boolValue ()
         && mReplacementFunction.operator_isEqual (ptr->mReplacementFunction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateReplacementListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReplacementString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReplacementFunction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@templateReplacementListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateReplacementListAST ("templateReplacementListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST GGS_templateReplacementListAST::
operator_concat (const GGS_templateReplacementListAST & inOperand) const {
  GGS_templateReplacementListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
dotAssign_operation (const GGS_templateReplacementListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateReplacementListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMatchString ;
          GGS_lstring  p_1 = p->mReplacementString ;
          GGS_lstring  p_2 = p->mReplacementFunction ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMatchString,
                                ptr->mReplacementString,
                                ptr->mReplacementFunction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST  GGS_templateReplacementListAST::
constructor_emptyList (void) {
  GGS_templateReplacementListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST  GGS_templateReplacementListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_templateReplacementListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
internalSubListWithRange (GGS_templateReplacementListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchString, ptr->mReplacementString, ptr->mReplacementFunction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST GGS_templateReplacementListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateReplacementListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST GGS_templateReplacementListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateReplacementListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateReplacementListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateReplacementListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementListAST::
reader_mMatchStringAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementListAST::
reader_mReplacementStringAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReplacementString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementListAST::
reader_mReplacementFunctionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReplacementFunction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
modifier_setMMatchStringAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
modifier_setMReplacementStringAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReplacementString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementListAST::
modifier_setMReplacementFunctionAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReplacementFunction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementListAST::cEnumerator::_mMatchString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementListAST::cEnumerator::_mReplacementString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReplacementString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementListAST::cEnumerator::_mReplacementFunction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReplacementFunction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateReplacementListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateReplacementListAST * p = NULL ;
    macroMyNew (p, GGS_templateReplacementListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST GGS_templateReplacementListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateReplacementListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateReplacementListAST * p = dynamic_cast <const GGS_templateReplacementListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateReplacementListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateReplacementListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateReplacementListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_abstractLexicalRuleAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractLexicalRuleAST::
cPtr_abstractLexicalRuleAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractLexicalRuleAST * GGS_abstractLexicalRuleAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_abstractLexicalRuleAST) ;
    return (cPtr_abstractLexicalRuleAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_abstractLexicalRuleAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@abstractLexicalRuleAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRuleAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRuleAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractLexicalRuleAST (& typeid (cPtr_abstractLexicalRuleAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_abstractLexicalRuleAST::galgasRTTI (void) const {
  return & gClassInfoFor__abstractLexicalRuleAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_abstractLexicalRuleAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractLexicalRuleAST ("abstractLexicalRuleAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractLexicalRuleAST::
GGS_abstractLexicalRuleAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRuleAST::
GGS_abstractLexicalRuleAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractLexicalRuleAST GGS_abstractLexicalRuleAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractLexicalRuleAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractLexicalRuleAST *> (inPointer) != NULL)
      : (typeid (cPtr_abstractLexicalRuleAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractLexicalRuleAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractLexicalRuleAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractLexicalRuleAST::actualTypeName (void) const {
  return "abstractLexicalRuleAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_abstractLexicalRuleAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__abstractLexicalRuleAST ("abstractLexicalRuleAST", & kTypeDescriptor_GGS_abstractLexicalRuleAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_abstractLexicalRuleAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractLexicalRuleAST * p = NULL ;
    macroMyNew (p, GGS_abstractLexicalRuleAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRuleAST GGS_abstractLexicalRuleAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractLexicalRuleAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractLexicalRuleAST * p = dynamic_cast <const GGS_abstractLexicalRuleAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractLexicalRuleAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractLexicalRuleAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractLexicalRuleAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalRuleListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalRuleListAST::
elementOf_GGS_lexicalRuleListAST (const GGS_abstractLexicalRuleAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLexicalRule (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalRuleListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalRuleListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalRuleListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalRule.operator_isEqual (ptr->mLexicalRule).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalRuleListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRule.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@lexicalRuleListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalRuleListAST ("lexicalRuleListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
internalAppendValues (const GGS_abstractLexicalRuleAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
internalPrependValues (const GGS_abstractLexicalRuleAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
addAssign_operation (const GGS_abstractLexicalRuleAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST GGS_lexicalRuleListAST::
operator_concat (const GGS_lexicalRuleListAST & inOperand) const {
  GGS_lexicalRuleListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
dotAssign_operation (const GGS_lexicalRuleListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalRuleListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_abstractLexicalRuleAST  p_0 = p->mLexicalRule ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_abstractLexicalRuleAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalRule
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST  GGS_lexicalRuleListAST::
constructor_emptyList (void) {
  GGS_lexicalRuleListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST  GGS_lexicalRuleListAST::
constructor_listWithValue (const GGS_abstractLexicalRuleAST & argument_0) {
  GGS_lexicalRuleListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
internalSubListWithRange (GGS_lexicalRuleListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalRule) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST GGS_lexicalRuleListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRuleListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST GGS_lexicalRuleListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRuleListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalRuleListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalRuleListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
method_first (C_CompilerEx & inLexique,
              GGS_abstractLexicalRuleAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
method_last (C_CompilerEx & inLexique,
             GGS_abstractLexicalRuleAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_abstractLexicalRuleAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_abstractLexicalRuleAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRuleAST  GGS_lexicalRuleListAST::
reader_mLexicalRuleAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_abstractLexicalRuleAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRule ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleListAST::
modifier_setMLexicalRuleAtIndex (C_CompilerEx & inLexique,
                              const GGS_abstractLexicalRuleAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRule = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_abstractLexicalRuleAST  & GGS_lexicalRuleListAST::cEnumerator::_mLexicalRule (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalRule ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalRuleListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalRuleListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalRuleListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST GGS_lexicalRuleListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalRuleListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalRuleListAST * p = dynamic_cast <const GGS_lexicalRuleListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalRuleListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalRuleListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalRuleListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalImplicitRuleAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalImplicitRuleAST::
cPtr_lexicalImplicitRuleAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRuleAST (THERE),
mListName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalImplicitRuleAST * GGS_lexicalImplicitRuleAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalImplicitRuleAST) ;
    return (cPtr_lexicalImplicitRuleAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalImplicitRuleAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalImplicitRuleAST * ptr = dynamic_cast <const cPtr_lexicalImplicitRuleAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListName.operator_isEqual (ptr->mListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalImplicitRuleAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalImplicitRuleAST:"
           << mListName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRuleAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRuleAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalImplicitRuleAST (& typeid (cPtr_lexicalImplicitRuleAST), & typeid (cPtr_abstractLexicalRuleAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalImplicitRuleAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalImplicitRuleAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalImplicitRuleAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalImplicitRuleAST (mListName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalImplicitRuleAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalImplicitRuleAST ("lexicalImplicitRuleAST", true, & kTypeDescriptor_GGS_abstractLexicalRuleAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleAST::
GGS_lexicalImplicitRuleAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleAST::
GGS_lexicalImplicitRuleAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalImplicitRuleAST GGS_lexicalImplicitRuleAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRuleAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalImplicitRuleAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalImplicitRuleAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalImplicitRuleAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalImplicitRuleAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleAST GGS_lexicalImplicitRuleAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRuleAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalImplicitRuleAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalImplicitRuleAST::
reader_mListName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalImplicitRuleAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalImplicitRuleAST *) mPointer)->mListName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalImplicitRuleAST::actualTypeName (void) const {
  return "lexicalImplicitRuleAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalImplicitRuleAST ("lexicalImplicitRuleAST", gClassInfoFor__abstractLexicalRuleAST, & kTypeDescriptor_GGS_lexicalImplicitRuleAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalImplicitRuleAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalImplicitRuleAST * p = NULL ;
    macroMyNew (p, GGS_lexicalImplicitRuleAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleAST GGS_lexicalImplicitRuleAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRuleAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalImplicitRuleAST * p = dynamic_cast <const GGS_lexicalImplicitRuleAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalImplicitRuleAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalImplicitRuleAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalImplicitRuleAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalExplicitRuleAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExplicitRuleAST::
cPtr_lexicalExplicitRuleAST (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRuleAST (THERE),
mLexicalRuleExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExplicitRuleAST * GGS_lexicalExplicitRuleAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalExplicitRuleAST) ;
    return (cPtr_lexicalExplicitRuleAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalExplicitRuleAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalExplicitRuleAST * ptr = dynamic_cast <const cPtr_lexicalExplicitRuleAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalRuleExpression.operator_isEqual (ptr->mLexicalRuleExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalExplicitRuleAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalExplicitRuleAST:"
           << mLexicalRuleExpression.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRuleAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRuleAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalExplicitRuleAST (& typeid (cPtr_lexicalExplicitRuleAST), & typeid (cPtr_abstractLexicalRuleAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalExplicitRuleAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalExplicitRuleAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalExplicitRuleAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalExplicitRuleAST (mLexicalRuleExpression, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalExplicitRuleAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalExplicitRuleAST ("lexicalExplicitRuleAST", true, & kTypeDescriptor_GGS_abstractLexicalRuleAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleAST::
GGS_lexicalExplicitRuleAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleAST::
GGS_lexicalExplicitRuleAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalExplicitRuleAST GGS_lexicalExplicitRuleAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRuleAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalExplicitRuleAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalExplicitRuleAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalExplicitRuleAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalExplicitRuleAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleAST GGS_lexicalExplicitRuleAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lexicalExpressionAST & argument_0,
                 const GGS_lexicalInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRuleAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalExplicitRuleAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST  GGS_lexicalExplicitRuleAST::
reader_mLexicalRuleExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRuleAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRuleAST *) mPointer)->mLexicalRuleExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalExplicitRuleAST::
reader_mInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRuleAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRuleAST *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExplicitRuleAST::actualTypeName (void) const {
  return "lexicalExplicitRuleAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalExplicitRuleAST ("lexicalExplicitRuleAST", gClassInfoFor__abstractLexicalRuleAST, & kTypeDescriptor_GGS_lexicalExplicitRuleAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalExplicitRuleAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalExplicitRuleAST * p = NULL ;
    macroMyNew (p, GGS_lexicalExplicitRuleAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleAST GGS_lexicalExplicitRuleAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRuleAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalExplicitRuleAST * p = dynamic_cast <const GGS_lexicalExplicitRuleAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalExplicitRuleAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalExplicitRuleAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalExplicitRuleAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalMessageDeclarationListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalMessageDeclarationListAST::
elementOf_GGS_lexicalMessageDeclarationListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalMessageDeclarationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalMessageDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalMessageDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessageName.operator_isEqual (ptr->mMessageName).boolValue ()
         && mMessageValue.operator_isEqual (ptr->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalMessageDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@lexicalMessageDeclarationListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalMessageDeclarationListAST ("lexicalMessageDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST GGS_lexicalMessageDeclarationListAST::
operator_concat (const GGS_lexicalMessageDeclarationListAST & inOperand) const {
  GGS_lexicalMessageDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
dotAssign_operation (const GGS_lexicalMessageDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalMessageDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMessageName,
                                ptr->mMessageValue
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST  GGS_lexicalMessageDeclarationListAST::
constructor_emptyList (void) {
  GGS_lexicalMessageDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST  GGS_lexicalMessageDeclarationListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalMessageDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
internalSubListWithRange (GGS_lexicalMessageDeclarationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMessageName, ptr->mMessageValue) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST GGS_lexicalMessageDeclarationListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalMessageDeclarationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST GGS_lexicalMessageDeclarationListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalMessageDeclarationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalMessageDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalMessageDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalMessageDeclarationListAST::
reader_mMessageNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalMessageDeclarationListAST::
reader_mMessageValueAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
modifier_setMMessageNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationListAST::
modifier_setMMessageValueAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalMessageDeclarationListAST::cEnumerator::_mMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalMessageDeclarationListAST::cEnumerator::_mMessageValue (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageValue ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalMessageDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalMessageDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalMessageDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST GGS_lexicalMessageDeclarationListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalMessageDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalMessageDeclarationListAST * p = dynamic_cast <const GGS_lexicalMessageDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalMessageDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalMessageDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalMessageDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalAttributeListAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalAttributeListAST::
elementOf_GGS_lexicalAttributeListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mTypeName (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalAttributeListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalAttributeListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalAttributeListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalAttributeListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalAttributeListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalAttributeListAST ("lexicalAttributeListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST GGS_lexicalAttributeListAST::
operator_concat (const GGS_lexicalAttributeListAST & inOperand) const {
  GGS_lexicalAttributeListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
dotAssign_operation (const GGS_lexicalAttributeListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalAttributeListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTypeName,
                                ptr->mName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST  GGS_lexicalAttributeListAST::
constructor_emptyList (void) {
  GGS_lexicalAttributeListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST  GGS_lexicalAttributeListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalAttributeListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
internalSubListWithRange (GGS_lexicalAttributeListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTypeName, ptr->mName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST GGS_lexicalAttributeListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalAttributeListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST GGS_lexicalAttributeListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalAttributeListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalAttributeListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalAttributeListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeListAST::
reader_mTypeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeListAST::
reader_mNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
modifier_setMTypeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeListAST::
modifier_setMNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalAttributeListAST::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalAttributeListAST::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalAttributeListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalAttributeListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalAttributeListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST GGS_lexicalAttributeListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalAttributeListAST * p = dynamic_cast <const GGS_lexicalAttributeListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalAttributeListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalAttributeListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalAttributeListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalStyleListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalStyleListAST::
elementOf_GGS_lexicalStyleListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mName (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalStyleListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalStyleListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalStyleListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mComment.operator_isEqual (ptr->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalStyleListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalStyleListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalStyleListAST ("lexicalStyleListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST GGS_lexicalStyleListAST::
operator_concat (const GGS_lexicalStyleListAST & inOperand) const {
  GGS_lexicalStyleListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
dotAssign_operation (const GGS_lexicalStyleListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalStyleListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mComment ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mName,
                                ptr->mComment
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST  GGS_lexicalStyleListAST::
constructor_emptyList (void) {
  GGS_lexicalStyleListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST  GGS_lexicalStyleListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalStyleListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
internalSubListWithRange (GGS_lexicalStyleListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mName, ptr->mComment) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST GGS_lexicalStyleListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalStyleListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST GGS_lexicalStyleListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalStyleListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStyleListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalStyleListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyleListAST::
reader_mNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyleListAST::
reader_mCommentAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
modifier_setMNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleListAST::
modifier_setMCommentAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalStyleListAST::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalStyleListAST::cEnumerator::_mComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mComment ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalStyleListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalStyleListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalStyleListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST GGS_lexicalStyleListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalStyleListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalStyleListAST * p = dynamic_cast <const GGS_lexicalStyleListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalStyleListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalStyleListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalStyleListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@terminalDeclarationListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_terminalDeclarationListAST::
elementOf_GGS_terminalDeclarationListAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mName (argument_0),
mSentAttributeList (argument_1),
mSyntaxErrorMessage (argument_2),
mStyle (argument_3),
mOptionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_terminalDeclarationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_terminalDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_terminalDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mSentAttributeList.operator_isEqual (ptr->mSentAttributeList).boolValue ()
         && mSyntaxErrorMessage.operator_isEqual (ptr->mSyntaxErrorMessage).boolValue ()
         && mStyle.operator_isEqual (ptr->mStyle).boolValue ()
         && mOptionList.operator_isEqual (ptr->mOptionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_terminalDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@terminalDeclarationListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_terminalDeclarationListAST ("terminalDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_lstringlist & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_lstringlist & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST GGS_terminalDeclarationListAST::
operator_concat (const GGS_terminalDeclarationListAST & inOperand) const {
  GGS_terminalDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
dotAssign_operation (const GGS_terminalDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_terminalDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstringlist  p_1 = p->mSentAttributeList ;
          GGS_lstring  p_2 = p->mSyntaxErrorMessage ;
          GGS_lstring  p_3 = p->mStyle ;
          GGS_lstringlist  p_4 = p->mOptionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_lstringlist & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mName,
                                ptr->mSentAttributeList,
                                ptr->mSyntaxErrorMessage,
                                ptr->mStyle,
                                ptr->mOptionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST  GGS_terminalDeclarationListAST::
constructor_emptyList (void) {
  GGS_terminalDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST  GGS_terminalDeclarationListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) {
  GGS_terminalDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
internalSubListWithRange (GGS_terminalDeclarationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mName, ptr->mSentAttributeList, ptr->mSyntaxErrorMessage, ptr->mStyle, ptr->mOptionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST GGS_terminalDeclarationListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalDeclarationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST GGS_terminalDeclarationListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalDeclarationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@terminalDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_lstringlist & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_lstringlist & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_lstringlist & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_lstringlist & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationListAST::
reader_mNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclarationListAST::
reader_mSentAttributeListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSentAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationListAST::
reader_mSyntaxErrorMessageAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationListAST::
reader_mStyleAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclarationListAST::
reader_mOptionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_setMNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_setMSentAttributeListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSentAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_setMSyntaxErrorMessageAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_setMStyleAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationListAST::
modifier_setMOptionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationListAST::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_terminalDeclarationListAST::cEnumerator::_mSentAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSentAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationListAST::cEnumerator::_mSyntaxErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationListAST::cEnumerator::_mStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_terminalDeclarationListAST::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_terminalDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_terminalDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_terminalDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST GGS_terminalDeclarationListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_terminalDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_terminalDeclarationListAST * p = dynamic_cast <const GGS_terminalDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_terminalDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_terminalDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_terminalDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalListEntryListAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalListEntryListAST::
elementOf_GGS_lexicalListEntryListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEntrySpelling (argument_0),
mTerminalSpelling (argument_1),
mFeatureList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalListEntryListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalListEntryListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalListEntryListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntrySpelling.operator_isEqual (ptr->mEntrySpelling).boolValue ()
         && mTerminalSpelling.operator_isEqual (ptr->mTerminalSpelling).boolValue ()
         && mFeatureList.operator_isEqual (ptr->mFeatureList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalListEntryListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntrySpelling.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalSpelling.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFeatureList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalListEntryListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalListEntryListAST ("lexicalListEntryListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST GGS_lexicalListEntryListAST::
operator_concat (const GGS_lexicalListEntryListAST & inOperand) const {
  GGS_lexicalListEntryListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
dotAssign_operation (const GGS_lexicalListEntryListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalListEntryListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEntrySpelling ;
          GGS_lstring  p_1 = p->mTerminalSpelling ;
          GGS_lstringlist  p_2 = p->mFeatureList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEntrySpelling,
                                ptr->mTerminalSpelling,
                                ptr->mFeatureList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST  GGS_lexicalListEntryListAST::
constructor_emptyList (void) {
  GGS_lexicalListEntryListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST  GGS_lexicalListEntryListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  GGS_lexicalListEntryListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
internalSubListWithRange (GGS_lexicalListEntryListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntrySpelling, ptr->mTerminalSpelling, ptr->mFeatureList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST GGS_lexicalListEntryListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST GGS_lexicalListEntryListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListEntryListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalListEntryListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstringlist & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstringlist & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstringlist & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstringlist & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntryListAST::
reader_mEntrySpellingAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntrySpelling ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntryListAST::
reader_mTerminalSpellingAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminalSpelling ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListEntryListAST::
reader_mFeatureListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFeatureList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
modifier_setMEntrySpellingAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntrySpelling = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
modifier_setMTerminalSpellingAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminalSpelling = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryListAST::
modifier_setMFeatureListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFeatureList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListEntryListAST::cEnumerator::_mEntrySpelling (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntrySpelling ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListEntryListAST::cEnumerator::_mTerminalSpelling (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTerminalSpelling ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_lexicalListEntryListAST::cEnumerator::_mFeatureList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFeatureList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalListEntryListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalListEntryListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalListEntryListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST GGS_lexicalListEntryListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalListEntryListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalListEntryListAST * p = dynamic_cast <const GGS_lexicalListEntryListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalListEntryListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalListEntryListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalListEntryListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalListDeclarationListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalListDeclarationListAST::
elementOf_GGS_lexicalListDeclarationListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryListAST & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mName (argument_0),
mStyle (argument_1),
mSyntaxErrorMessage (argument_2),
mSentAttributeList (argument_3),
mEntryList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalListDeclarationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalListDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalListDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mStyle.operator_isEqual (ptr->mStyle).boolValue ()
         && mSyntaxErrorMessage.operator_isEqual (ptr->mSyntaxErrorMessage).boolValue ()
         && mSentAttributeList.operator_isEqual (ptr->mSentAttributeList).boolValue ()
         && mEntryList.operator_isEqual (ptr->mEntryList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalListDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntryList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@lexicalListDeclarationListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalListDeclarationListAST ("lexicalListDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryListAST & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST GGS_lexicalListDeclarationListAST::
operator_concat (const GGS_lexicalListDeclarationListAST & inOperand) const {
  GGS_lexicalListDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
dotAssign_operation (const GGS_lexicalListDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalListDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mStyle ;
          GGS_lstring  p_2 = p->mSyntaxErrorMessage ;
          GGS_lstringlist  p_3 = p->mSentAttributeList ;
          GGS_lexicalListEntryListAST  p_4 = p->mEntryList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS_lexicalListEntryListAST & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mName,
                                ptr->mStyle,
                                ptr->mSyntaxErrorMessage,
                                ptr->mSentAttributeList,
                                ptr->mEntryList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST  GGS_lexicalListDeclarationListAST::
constructor_emptyList (void) {
  GGS_lexicalListDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST  GGS_lexicalListDeclarationListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryListAST & argument_4) {
  GGS_lexicalListDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
internalSubListWithRange (GGS_lexicalListDeclarationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mName, ptr->mStyle, ptr->mSyntaxErrorMessage, ptr->mSentAttributeList, ptr->mEntryList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST GGS_lexicalListDeclarationListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST GGS_lexicalListDeclarationListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalListDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstringlist & _out_3,
              GGS_lexicalListEntryListAST & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstringlist & _out_3,
             GGS_lexicalListEntryListAST & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstringlist & _out_3,
                 GGS_lexicalListEntryListAST & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstringlist & _out_3,
                GGS_lexicalListEntryListAST & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationListAST::
reader_mNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationListAST::
reader_mStyleAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationListAST::
reader_mSyntaxErrorMessageAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListDeclarationListAST::
reader_mSentAttributeListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSentAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryListAST  GGS_lexicalListDeclarationListAST::
reader_mEntryListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_setMNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_setMStyleAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_setMSyntaxErrorMessageAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_setMSentAttributeListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSentAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationListAST::
modifier_setMEntryListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalListEntryListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationListAST::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationListAST::cEnumerator::_mStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationListAST::cEnumerator::_mSyntaxErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_lexicalListDeclarationListAST::cEnumerator::_mSentAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSentAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalListEntryListAST  & GGS_lexicalListDeclarationListAST::cEnumerator::_mEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntryList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalListDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalListDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalListDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST GGS_lexicalListDeclarationListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalListDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalListDeclarationListAST * p = dynamic_cast <const GGS_lexicalListDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalListDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalListDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalListDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalOrExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalOrExpressionAST::
cPtr_lexicalOrExpressionAST (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpressionAST (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalOrExpressionAST * GGS_lexicalOrExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalOrExpressionAST) ;
    return (cPtr_lexicalOrExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalOrExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalOrExpressionAST * ptr = dynamic_cast <const cPtr_lexicalOrExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftOperand.operator_isEqual (ptr->mLeftOperand).boolValue ()
         && mRightOperand.operator_isEqual (ptr->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalOrExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalOrExpressionAST:"
           << mLeftOperand.reader_description (inIndentation + 1)
           << mRightOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalOrExpressionAST (& typeid (cPtr_lexicalOrExpressionAST), & typeid (cPtr_lexicalExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalOrExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalOrExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalOrExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalOrExpressionAST (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalOrExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalOrExpressionAST ("lexicalOrExpressionAST", true, & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionAST::
GGS_lexicalOrExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionAST::
GGS_lexicalOrExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalOrExpressionAST GGS_lexicalOrExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalOrExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalOrExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalOrExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalOrExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionAST GGS_lexicalOrExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lexicalExpressionAST & argument_0,
                 const GGS_lexicalExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalOrExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST  GGS_lexicalOrExpressionAST::
reader_mLeftOperand (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpressionAST *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST  GGS_lexicalOrExpressionAST::
reader_mRightOperand (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpressionAST *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalOrExpressionAST::actualTypeName (void) const {
  return "lexicalOrExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalOrExpressionAST ("lexicalOrExpressionAST", gClassInfoFor__lexicalExpressionAST, & kTypeDescriptor_GGS_lexicalOrExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalOrExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalOrExpressionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalOrExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionAST GGS_lexicalOrExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalOrExpressionAST * p = dynamic_cast <const GGS_lexicalOrExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalOrExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalOrExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalOrExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalCharacterSetMatchAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterSetMatchAST::
cPtr_lexicalCharacterSetMatchAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpressionAST (THERE),
mCharacterSetName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterSetMatchAST * GGS_lexicalCharacterSetMatchAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalCharacterSetMatchAST) ;
    return (cPtr_lexicalCharacterSetMatchAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterSetMatchAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterSetMatchAST * ptr = dynamic_cast <const cPtr_lexicalCharacterSetMatchAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacterSetName.operator_isEqual (ptr->mCharacterSetName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterSetMatchAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterSetMatchAST:"
           << mCharacterSetName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterSetMatchAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterSetMatchAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterSetMatchAST (& typeid (cPtr_lexicalCharacterSetMatchAST), & typeid (cPtr_lexicalExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalCharacterSetMatchAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterSetMatchAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterSetMatchAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterSetMatchAST (mCharacterSetName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalCharacterSetMatchAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalCharacterSetMatchAST ("lexicalCharacterSetMatchAST", true, & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatchAST::
GGS_lexicalCharacterSetMatchAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatchAST::
GGS_lexicalCharacterSetMatchAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterSetMatchAST GGS_lexicalCharacterSetMatchAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatchAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterSetMatchAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterSetMatchAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterSetMatchAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterSetMatchAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatchAST GGS_lexicalCharacterSetMatchAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatchAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterSetMatchAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalCharacterSetMatchAST::
reader_mCharacterSetName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterSetMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterSetMatchAST *) mPointer)->mCharacterSetName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterSetMatchAST::actualTypeName (void) const {
  return "lexicalCharacterSetMatchAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalCharacterSetMatchAST ("lexicalCharacterSetMatchAST", gClassInfoFor__lexicalExpressionAST, & kTypeDescriptor_GGS_lexicalCharacterSetMatchAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalCharacterSetMatchAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalCharacterSetMatchAST * p = NULL ;
    macroMyNew (p, GGS_lexicalCharacterSetMatchAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatchAST GGS_lexicalCharacterSetMatchAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatchAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalCharacterSetMatchAST * p = dynamic_cast <const GGS_lexicalCharacterSetMatchAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalCharacterSetMatchAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalCharacterSetMatchAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalCharacterSetMatchAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalCharacterMatchAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatchAST::
cPtr_lexicalCharacterMatchAST (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpressionAST (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterMatchAST * GGS_lexicalCharacterMatchAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalCharacterMatchAST) ;
    return (cPtr_lexicalCharacterMatchAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterMatchAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterMatchAST * ptr = dynamic_cast <const cPtr_lexicalCharacterMatchAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterMatchAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterMatchAST:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatchAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatchAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterMatchAST (& typeid (cPtr_lexicalCharacterMatchAST), & typeid (cPtr_lexicalExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalCharacterMatchAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterMatchAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterMatchAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterMatchAST (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterMatchAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalCharacterMatchAST ("lexicalCharacterMatchAST", true, & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchAST::
GGS_lexicalCharacterMatchAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchAST::
GGS_lexicalCharacterMatchAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterMatchAST GGS_lexicalCharacterMatchAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatchAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterMatchAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterMatchAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterMatchAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterMatchAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchAST GGS_lexicalCharacterMatchAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatchAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterMatchAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterMatchAST::
reader_mCharacter (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterMatchAST *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterMatchAST::actualTypeName (void) const {
  return "lexicalCharacterMatchAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalCharacterMatchAST ("lexicalCharacterMatchAST", gClassInfoFor__lexicalExpressionAST, & kTypeDescriptor_GGS_lexicalCharacterMatchAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalCharacterMatchAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalCharacterMatchAST * p = NULL ;
    macroMyNew (p, GGS_lexicalCharacterMatchAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchAST GGS_lexicalCharacterMatchAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatchAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalCharacterMatchAST * p = dynamic_cast <const GGS_lexicalCharacterMatchAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalCharacterMatchAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalCharacterMatchAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalCharacterMatchAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_lexicalCharacterIntervalMatchAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatchAST::
cPtr_lexicalCharacterIntervalMatchAST (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpressionAST (THERE),
mLowerBound (argument_0),
mUpperBound (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterIntervalMatchAST * GGS_lexicalCharacterIntervalMatchAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalCharacterIntervalMatchAST) ;
    return (cPtr_lexicalCharacterIntervalMatchAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterIntervalMatchAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterIntervalMatchAST * ptr = dynamic_cast <const cPtr_lexicalCharacterIntervalMatchAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLowerBound.operator_isEqual (ptr->mLowerBound).boolValue ()
         && mUpperBound.operator_isEqual (ptr->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterIntervalMatchAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterIntervalMatchAST:"
           << mLowerBound.reader_description (inIndentation + 1)
           << mUpperBound.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatchAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatchAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterIntervalMatchAST (& typeid (cPtr_lexicalCharacterIntervalMatchAST), & typeid (cPtr_lexicalExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalCharacterIntervalMatchAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterIntervalMatchAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterIntervalMatchAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterIntervalMatchAST (mLowerBound, mUpperBound COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalCharacterIntervalMatchAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalCharacterIntervalMatchAST ("lexicalCharacterIntervalMatchAST", true, & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchAST::
GGS_lexicalCharacterIntervalMatchAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchAST::
GGS_lexicalCharacterIntervalMatchAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterIntervalMatchAST GGS_lexicalCharacterIntervalMatchAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatchAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterIntervalMatchAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterIntervalMatchAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterIntervalMatchAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterIntervalMatchAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchAST GGS_lexicalCharacterIntervalMatchAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatchAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterIntervalMatchAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatchAST::
reader_mLowerBound (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatchAST *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatchAST::
reader_mUpperBound (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatchAST *) mPointer)->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterIntervalMatchAST::actualTypeName (void) const {
  return "lexicalCharacterIntervalMatchAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalCharacterIntervalMatchAST ("lexicalCharacterIntervalMatchAST", gClassInfoFor__lexicalExpressionAST, & kTypeDescriptor_GGS_lexicalCharacterIntervalMatchAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalCharacterIntervalMatchAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalCharacterIntervalMatchAST * p = NULL ;
    macroMyNew (p, GGS_lexicalCharacterIntervalMatchAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchAST GGS_lexicalCharacterIntervalMatchAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatchAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalCharacterIntervalMatchAST * p = dynamic_cast <const GGS_lexicalCharacterIntervalMatchAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalCharacterIntervalMatchAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalCharacterIntervalMatchAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalCharacterIntervalMatchAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalStringMatchAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringMatchAST::
cPtr_lexicalStringMatchAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpressionAST (THERE),
mString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringMatchAST * GGS_lexicalStringMatchAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalStringMatchAST) ;
    return (cPtr_lexicalStringMatchAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringMatchAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStringMatchAST * ptr = dynamic_cast <const cPtr_lexicalStringMatchAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mString.operator_isEqual (ptr->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringMatchAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalStringMatchAST:"
           << mString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatchAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatchAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStringMatchAST (& typeid (cPtr_lexicalStringMatchAST), & typeid (cPtr_lexicalExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalStringMatchAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStringMatchAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStringMatchAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStringMatchAST (mString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringMatchAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalStringMatchAST ("lexicalStringMatchAST", true, & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchAST::
GGS_lexicalStringMatchAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchAST::
GGS_lexicalStringMatchAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalStringMatchAST GGS_lexicalStringMatchAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatchAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStringMatchAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStringMatchAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalStringMatchAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStringMatchAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchAST GGS_lexicalStringMatchAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatchAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringMatchAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringMatchAST::
reader_mString (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringMatchAST *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringMatchAST::actualTypeName (void) const {
  return "lexicalStringMatchAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalStringMatchAST ("lexicalStringMatchAST", gClassInfoFor__lexicalExpressionAST, & kTypeDescriptor_GGS_lexicalStringMatchAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalStringMatchAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalStringMatchAST * p = NULL ;
    macroMyNew (p, GGS_lexicalStringMatchAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchAST GGS_lexicalStringMatchAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatchAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalStringMatchAST * p = dynamic_cast <const GGS_lexicalStringMatchAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalStringMatchAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalStringMatchAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalStringMatchAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalStringNotMatchAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatchAST::
cPtr_lexicalStringNotMatchAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpressionAST (THERE),
mString (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringNotMatchAST * GGS_lexicalStringNotMatchAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalStringNotMatchAST) ;
    return (cPtr_lexicalStringNotMatchAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringNotMatchAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStringNotMatchAST * ptr = dynamic_cast <const cPtr_lexicalStringNotMatchAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mString.operator_isEqual (ptr->mString).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringNotMatchAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalStringNotMatchAST:"
           << mString.reader_description (inIndentation + 1)
           << mErrorMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatchAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatchAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStringNotMatchAST (& typeid (cPtr_lexicalStringNotMatchAST), & typeid (cPtr_lexicalExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalStringNotMatchAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStringNotMatchAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStringNotMatchAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStringNotMatchAST (mString, mErrorMessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalStringNotMatchAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalStringNotMatchAST ("lexicalStringNotMatchAST", true, & kTypeDescriptor_GGS_lexicalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchAST::
GGS_lexicalStringNotMatchAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchAST::
GGS_lexicalStringNotMatchAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalStringNotMatchAST GGS_lexicalStringNotMatchAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatchAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStringNotMatchAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStringNotMatchAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalStringNotMatchAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStringNotMatchAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchAST GGS_lexicalStringNotMatchAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatchAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringNotMatchAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatchAST::
reader_mString (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatchAST *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatchAST::
reader_mErrorMessage (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatchAST *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringNotMatchAST::actualTypeName (void) const {
  return "lexicalStringNotMatchAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalStringNotMatchAST ("lexicalStringNotMatchAST", gClassInfoFor__lexicalExpressionAST, & kTypeDescriptor_GGS_lexicalStringNotMatchAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalStringNotMatchAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalStringNotMatchAST * p = NULL ;
    macroMyNew (p, GGS_lexicalStringNotMatchAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchAST GGS_lexicalStringNotMatchAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatchAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalStringNotMatchAST * p = dynamic_cast <const GGS_lexicalStringNotMatchAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalStringNotMatchAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalStringNotMatchAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalStringNotMatchAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalSendSearchListAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalSendSearchListAST::
elementOf_GGS_lexicalSendSearchListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeName (argument_0),
mSearchListName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalSendSearchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalSendSearchListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalSendSearchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mSearchListName.operator_isEqual (ptr->mSearchListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalSendSearchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchListName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalSendSearchListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalSendSearchListAST ("lexicalSendSearchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST GGS_lexicalSendSearchListAST::
operator_concat (const GGS_lexicalSendSearchListAST & inOperand) const {
  GGS_lexicalSendSearchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
dotAssign_operation (const GGS_lexicalSendSearchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalSendSearchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_lstring  p_1 = p->mSearchListName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeName,
                                ptr->mSearchListName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST  GGS_lexicalSendSearchListAST::
constructor_emptyList (void) {
  GGS_lexicalSendSearchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST  GGS_lexicalSendSearchListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalSendSearchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
internalSubListWithRange (GGS_lexicalSendSearchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeName, ptr->mSearchListName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST GGS_lexicalSendSearchListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSendSearchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST GGS_lexicalSendSearchListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSendSearchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSendSearchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalSendSearchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearchListAST::
reader_mAttributeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearchListAST::
reader_mSearchListNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSearchListName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
modifier_setMAttributeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchListAST::
modifier_setMSearchListNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSearchListName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalSendSearchListAST::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalSendSearchListAST::cEnumerator::_mSearchListName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSearchListName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalSendSearchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalSendSearchListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalSendSearchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST GGS_lexicalSendSearchListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalSendSearchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalSendSearchListAST * p = dynamic_cast <const GGS_lexicalSendSearchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalSendSearchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalSendSearchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalSendSearchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalSendDefaultActionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultActionAST::
cPtr_lexicalSendDefaultActionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendDefaultActionAST * GGS_lexicalSendDefaultActionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalSendDefaultActionAST) ;
    return (cPtr_lexicalSendDefaultActionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalSendDefaultActionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalSendDefaultActionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultActionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultActionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSendDefaultActionAST (& typeid (cPtr_lexicalSendDefaultActionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalSendDefaultActionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSendDefaultActionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalSendDefaultActionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalSendDefaultActionAST ("lexicalSendDefaultActionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionAST::
GGS_lexicalSendDefaultActionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionAST::
GGS_lexicalSendDefaultActionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSendDefaultActionAST GGS_lexicalSendDefaultActionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSendDefaultActionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSendDefaultActionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSendDefaultActionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSendDefaultActionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSendDefaultActionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendDefaultActionAST::actualTypeName (void) const {
  return "lexicalSendDefaultActionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_lexicalSendDefaultActionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__lexicalSendDefaultActionAST ("lexicalSendDefaultActionAST", & kTypeDescriptor_GGS_lexicalSendDefaultActionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalSendDefaultActionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalSendDefaultActionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalSendDefaultActionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionAST GGS_lexicalSendDefaultActionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalSendDefaultActionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalSendDefaultActionAST * p = dynamic_cast <const GGS_lexicalSendDefaultActionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalSendDefaultActionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalSendDefaultActionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalSendDefaultActionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_lexicalStructuredSendInstructionAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstructionAST::
cPtr_lexicalStructuredSendInstructionAST (const GGS_lexicalSendSearchListAST & argument_0,
                                const GGS_lexicalSendDefaultActionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mLexicalSendSearchList (argument_0),
mLexicalSendDefaultAction (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStructuredSendInstructionAST * GGS_lexicalStructuredSendInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalStructuredSendInstructionAST) ;
    return (cPtr_lexicalStructuredSendInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStructuredSendInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStructuredSendInstructionAST * ptr = dynamic_cast <const cPtr_lexicalStructuredSendInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalSendSearchList.operator_isEqual (ptr->mLexicalSendSearchList).boolValue ()
         && mLexicalSendDefaultAction.operator_isEqual (ptr->mLexicalSendDefaultAction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStructuredSendInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalStructuredSendInstructionAST:"
           << mLexicalSendSearchList.reader_description (inIndentation + 1)
           << mLexicalSendDefaultAction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStructuredSendInstructionAST (& typeid (cPtr_lexicalStructuredSendInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalStructuredSendInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStructuredSendInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStructuredSendInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStructuredSendInstructionAST (mLexicalSendSearchList, mLexicalSendDefaultAction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_lexicalStructuredSendInstructionAST'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalStructuredSendInstructionAST ("lexicalStructuredSendInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionAST::
GGS_lexicalStructuredSendInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionAST::
GGS_lexicalStructuredSendInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalStructuredSendInstructionAST GGS_lexicalStructuredSendInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStructuredSendInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStructuredSendInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalStructuredSendInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStructuredSendInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionAST GGS_lexicalStructuredSendInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lexicalSendSearchListAST & argument_0,
                 const GGS_lexicalSendDefaultActionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalStructuredSendInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchListAST  GGS_lexicalStructuredSendInstructionAST::
reader_mLexicalSendSearchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendSearchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstructionAST *) mPointer)->mLexicalSendSearchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionAST  GGS_lexicalStructuredSendInstructionAST::
reader_mLexicalSendDefaultAction (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendDefaultActionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstructionAST *) mPointer)->mLexicalSendDefaultAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStructuredSendInstructionAST::actualTypeName (void) const {
  return "lexicalStructuredSendInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalStructuredSendInstructionAST ("lexicalStructuredSendInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalStructuredSendInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalStructuredSendInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalStructuredSendInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalStructuredSendInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionAST GGS_lexicalStructuredSendInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalStructuredSendInstructionAST * p = dynamic_cast <const GGS_lexicalStructuredSendInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalStructuredSendInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalStructuredSendInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalStructuredSendInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_lexicalSimpleSendInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstructionAST::
cPtr_lexicalSimpleSendInstructionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSimpleSendInstructionAST * GGS_lexicalSimpleSendInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalSimpleSendInstructionAST) ;
    return (cPtr_lexicalSimpleSendInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSimpleSendInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSimpleSendInstructionAST * ptr = dynamic_cast <const cPtr_lexicalSimpleSendInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSentTerminal.operator_isEqual (ptr->mSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSimpleSendInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalSimpleSendInstructionAST:"
           << mSentTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSimpleSendInstructionAST (& typeid (cPtr_lexicalSimpleSendInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalSimpleSendInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSimpleSendInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSimpleSendInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSimpleSendInstructionAST (mSentTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalSimpleSendInstructionAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalSimpleSendInstructionAST ("lexicalSimpleSendInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionAST::
GGS_lexicalSimpleSendInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionAST::
GGS_lexicalSimpleSendInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSimpleSendInstructionAST GGS_lexicalSimpleSendInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSimpleSendInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSimpleSendInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSimpleSendInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSimpleSendInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionAST GGS_lexicalSimpleSendInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalSimpleSendInstructionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSimpleSendInstructionAST::
reader_mSentTerminal (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSimpleSendInstructionAST *) mPointer)->mSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSimpleSendInstructionAST::actualTypeName (void) const {
  return "lexicalSimpleSendInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalSimpleSendInstructionAST ("lexicalSimpleSendInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalSimpleSendInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalSimpleSendInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalSimpleSendInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalSimpleSendInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionAST GGS_lexicalSimpleSendInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalSimpleSendInstructionAST * p = dynamic_cast <const GGS_lexicalSimpleSendInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalSimpleSendInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalSimpleSendInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalSimpleSendInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_lexicalSendTerminalByDefaultAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefaultAST::
cPtr_lexicalSendTerminalByDefaultAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalSendDefaultActionAST (THERE),
mDefaultSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendTerminalByDefaultAST * GGS_lexicalSendTerminalByDefaultAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalSendTerminalByDefaultAST) ;
    return (cPtr_lexicalSendTerminalByDefaultAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendTerminalByDefaultAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSendTerminalByDefaultAST * ptr = dynamic_cast <const cPtr_lexicalSendTerminalByDefaultAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDefaultSentTerminal.operator_isEqual (ptr->mDefaultSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendTerminalByDefaultAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalSendTerminalByDefaultAST:"
           << mDefaultSentTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefaultAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefaultAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSendTerminalByDefaultAST (& typeid (cPtr_lexicalSendTerminalByDefaultAST), & typeid (cPtr_lexicalSendDefaultActionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalSendTerminalByDefaultAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSendTerminalByDefaultAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSendTerminalByDefaultAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSendTerminalByDefaultAST (mDefaultSentTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalSendTerminalByDefaultAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalSendTerminalByDefaultAST ("lexicalSendTerminalByDefaultAST", true, & kTypeDescriptor_GGS_lexicalSendDefaultActionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultAST::
GGS_lexicalSendTerminalByDefaultAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultAST::
GGS_lexicalSendTerminalByDefaultAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSendTerminalByDefaultAST GGS_lexicalSendTerminalByDefaultAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefaultAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSendTerminalByDefaultAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSendTerminalByDefaultAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSendTerminalByDefaultAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSendTerminalByDefaultAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultAST GGS_lexicalSendTerminalByDefaultAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefaultAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendTerminalByDefaultAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendTerminalByDefaultAST::
reader_mDefaultSentTerminal (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefaultAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendTerminalByDefaultAST *) mPointer)->mDefaultSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendTerminalByDefaultAST::actualTypeName (void) const {
  return "lexicalSendTerminalByDefaultAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalSendTerminalByDefaultAST ("lexicalSendTerminalByDefaultAST", gClassInfoFor__lexicalSendDefaultActionAST, & kTypeDescriptor_GGS_lexicalSendTerminalByDefaultAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalSendTerminalByDefaultAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalSendTerminalByDefaultAST * p = NULL ;
    macroMyNew (p, GGS_lexicalSendTerminalByDefaultAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultAST GGS_lexicalSendTerminalByDefaultAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefaultAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalSendTerminalByDefaultAST * p = dynamic_cast <const GGS_lexicalSendTerminalByDefaultAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalSendTerminalByDefaultAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalSendTerminalByDefaultAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalSendTerminalByDefaultAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalErrorByDefaultAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefaultAST::
cPtr_lexicalErrorByDefaultAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalSendDefaultActionAST (THERE),
mDefaultErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorByDefaultAST * GGS_lexicalErrorByDefaultAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalErrorByDefaultAST) ;
    return (cPtr_lexicalErrorByDefaultAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorByDefaultAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalErrorByDefaultAST * ptr = dynamic_cast <const cPtr_lexicalErrorByDefaultAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDefaultErrorMessageName.operator_isEqual (ptr->mDefaultErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorByDefaultAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalErrorByDefaultAST:"
           << mDefaultErrorMessageName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefaultAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefaultAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalErrorByDefaultAST (& typeid (cPtr_lexicalErrorByDefaultAST), & typeid (cPtr_lexicalSendDefaultActionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalErrorByDefaultAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalErrorByDefaultAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalErrorByDefaultAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalErrorByDefaultAST (mDefaultErrorMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalErrorByDefaultAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalErrorByDefaultAST ("lexicalErrorByDefaultAST", true, & kTypeDescriptor_GGS_lexicalSendDefaultActionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultAST::
GGS_lexicalErrorByDefaultAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultAST::
GGS_lexicalErrorByDefaultAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalErrorByDefaultAST GGS_lexicalErrorByDefaultAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefaultAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalErrorByDefaultAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalErrorByDefaultAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalErrorByDefaultAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalErrorByDefaultAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultAST GGS_lexicalErrorByDefaultAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefaultAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorByDefaultAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorByDefaultAST::
reader_mDefaultErrorMessageName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefaultAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorByDefaultAST *) mPointer)->mDefaultErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorByDefaultAST::actualTypeName (void) const {
  return "lexicalErrorByDefaultAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalErrorByDefaultAST ("lexicalErrorByDefaultAST", gClassInfoFor__lexicalSendDefaultActionAST, & kTypeDescriptor_GGS_lexicalErrorByDefaultAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalErrorByDefaultAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalErrorByDefaultAST * p = NULL ;
    macroMyNew (p, GGS_lexicalErrorByDefaultAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultAST GGS_lexicalErrorByDefaultAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefaultAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalErrorByDefaultAST * p = dynamic_cast <const GGS_lexicalErrorByDefaultAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalErrorByDefaultAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalErrorByDefaultAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalErrorByDefaultAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalWhileBranchListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalWhileBranchListAST::
elementOf_GGS_lexicalWhileBranchListAST (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mWhileExpression (argument_0),
mWhileInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalWhileBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalWhileBranchListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalWhileBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mWhileInstructionList.operator_isEqual (ptr->mWhileInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalWhileBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalWhileBranchListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalWhileBranchListAST ("lexicalWhileBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
internalAppendValues (const GGS_lexicalExpressionAST & argument_0,
                    const GGS_lexicalInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
internalPrependValues (const GGS_lexicalExpressionAST & argument_0,
                    const GGS_lexicalInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
addAssign_operation (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST GGS_lexicalWhileBranchListAST::
operator_concat (const GGS_lexicalWhileBranchListAST & inOperand) const {
  GGS_lexicalWhileBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
dotAssign_operation (const GGS_lexicalWhileBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalWhileBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpressionAST  p_0 = p->mWhileExpression ;
          GGS_lexicalInstructionListAST  p_1 = p->mWhileInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lexicalExpressionAST & argument_0,
                     const GGS_lexicalInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mWhileExpression,
                                ptr->mWhileInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST  GGS_lexicalWhileBranchListAST::
constructor_emptyList (void) {
  GGS_lexicalWhileBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST  GGS_lexicalWhileBranchListAST::
constructor_listWithValue (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1) {
  GGS_lexicalWhileBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
internalSubListWithRange (GGS_lexicalWhileBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mWhileExpression, ptr->mWhileInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST GGS_lexicalWhileBranchListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST GGS_lexicalWhileBranchListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalWhileBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalWhileBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lexicalExpressionAST & _out_0,
              GGS_lexicalInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lexicalExpressionAST & _out_0,
             GGS_lexicalInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lexicalExpressionAST & _out_0,
                 GGS_lexicalInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lexicalExpressionAST & _out_0,
                GGS_lexicalInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST  GGS_lexicalWhileBranchListAST::
reader_mWhileExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mWhileExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalWhileBranchListAST::
reader_mWhileInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mWhileInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
modifier_setMWhileExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mWhileExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchListAST::
modifier_setMWhileInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mWhileInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpressionAST  & GGS_lexicalWhileBranchListAST::cEnumerator::_mWhileExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWhileExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionListAST  & GGS_lexicalWhileBranchListAST::cEnumerator::_mWhileInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWhileInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalWhileBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalWhileBranchListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalWhileBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST GGS_lexicalWhileBranchListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalWhileBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalWhileBranchListAST * p = dynamic_cast <const GGS_lexicalWhileBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalWhileBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalWhileBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalWhileBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalRepeatInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstructionAST::
cPtr_lexicalRepeatInstructionAST (const GGS_lexicalInstructionListAST & argument_0,
                                const GGS_lexicalWhileBranchListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mRepeatedInstructionList (argument_0),
mLexicalWhileBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRepeatInstructionAST * GGS_lexicalRepeatInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalRepeatInstructionAST) ;
    return (cPtr_lexicalRepeatInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRepeatInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRepeatInstructionAST * ptr = dynamic_cast <const cPtr_lexicalRepeatInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRepeatedInstructionList.operator_isEqual (ptr->mRepeatedInstructionList).boolValue ()
         && mLexicalWhileBranchList.operator_isEqual (ptr->mLexicalWhileBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRepeatInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalRepeatInstructionAST:"
           << mRepeatedInstructionList.reader_description (inIndentation + 1)
           << mLexicalWhileBranchList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRepeatInstructionAST (& typeid (cPtr_lexicalRepeatInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalRepeatInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRepeatInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRepeatInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRepeatInstructionAST (mRepeatedInstructionList, mLexicalWhileBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalRepeatInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalRepeatInstructionAST ("lexicalRepeatInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionAST::
GGS_lexicalRepeatInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionAST::
GGS_lexicalRepeatInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRepeatInstructionAST GGS_lexicalRepeatInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRepeatInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRepeatInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRepeatInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRepeatInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionAST GGS_lexicalRepeatInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lexicalInstructionListAST & argument_0,
                 const GGS_lexicalWhileBranchListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalRepeatInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalRepeatInstructionAST::
reader_mRepeatedInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstructionAST *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchListAST  GGS_lexicalRepeatInstructionAST::
reader_mLexicalWhileBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstructionAST *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRepeatInstructionAST::actualTypeName (void) const {
  return "lexicalRepeatInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalRepeatInstructionAST ("lexicalRepeatInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalRepeatInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalRepeatInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalRepeatInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalRepeatInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionAST GGS_lexicalRepeatInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalRepeatInstructionAST * p = dynamic_cast <const GGS_lexicalRepeatInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalRepeatInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalRepeatInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalRepeatInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalSelectBranchListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalSelectBranchListAST::
elementOf_GGS_lexicalSelectBranchListAST (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSelectExpression (argument_0),
mSelectInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalSelectBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalSelectBranchListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalSelectBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSelectExpression.operator_isEqual (ptr->mSelectExpression).boolValue ()
         && mSelectInstructionList.operator_isEqual (ptr->mSelectInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalSelectBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalSelectBranchListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalSelectBranchListAST ("lexicalSelectBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
internalAppendValues (const GGS_lexicalExpressionAST & argument_0,
                    const GGS_lexicalInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
internalPrependValues (const GGS_lexicalExpressionAST & argument_0,
                    const GGS_lexicalInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
addAssign_operation (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST GGS_lexicalSelectBranchListAST::
operator_concat (const GGS_lexicalSelectBranchListAST & inOperand) const {
  GGS_lexicalSelectBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
dotAssign_operation (const GGS_lexicalSelectBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalSelectBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpressionAST  p_0 = p->mSelectExpression ;
          GGS_lexicalInstructionListAST  p_1 = p->mSelectInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lexicalExpressionAST & argument_0,
                     const GGS_lexicalInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSelectExpression,
                                ptr->mSelectInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST  GGS_lexicalSelectBranchListAST::
constructor_emptyList (void) {
  GGS_lexicalSelectBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST  GGS_lexicalSelectBranchListAST::
constructor_listWithValue (const GGS_lexicalExpressionAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1) {
  GGS_lexicalSelectBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
internalSubListWithRange (GGS_lexicalSelectBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSelectExpression, ptr->mSelectInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST GGS_lexicalSelectBranchListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST GGS_lexicalSelectBranchListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSelectBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalSelectBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lexicalExpressionAST & _out_0,
              GGS_lexicalInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lexicalExpressionAST & _out_0,
             GGS_lexicalInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lexicalExpressionAST & _out_0,
                 GGS_lexicalInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lexicalExpressionAST & _out_0,
                GGS_lexicalInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionAST  GGS_lexicalSelectBranchListAST::
reader_mSelectExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSelectExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalSelectBranchListAST::
reader_mSelectInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSelectInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
modifier_setMSelectExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSelectExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchListAST::
modifier_setMSelectInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSelectInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpressionAST  & GGS_lexicalSelectBranchListAST::cEnumerator::_mSelectExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSelectExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionListAST  & GGS_lexicalSelectBranchListAST::cEnumerator::_mSelectInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSelectInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalSelectBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalSelectBranchListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalSelectBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST GGS_lexicalSelectBranchListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalSelectBranchListAST * p = dynamic_cast <const GGS_lexicalSelectBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalSelectBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalSelectBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalSelectBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalSelectInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstructionAST::
cPtr_lexicalSelectInstructionAST (const GGS_lexicalSelectBranchListAST & argument_0,
                                const GGS_lexicalInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mLexicalSelectBranchList (argument_0),
mDefaultInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectInstructionAST * GGS_lexicalSelectInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalSelectInstructionAST) ;
    return (cPtr_lexicalSelectInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSelectInstructionAST * ptr = dynamic_cast <const cPtr_lexicalSelectInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalSelectBranchList.operator_isEqual (ptr->mLexicalSelectBranchList).boolValue ()
         && mDefaultInstructionList.operator_isEqual (ptr->mDefaultInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalSelectInstructionAST:"
           << mLexicalSelectBranchList.reader_description (inIndentation + 1)
           << mDefaultInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSelectInstructionAST (& typeid (cPtr_lexicalSelectInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalSelectInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSelectInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSelectInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSelectInstructionAST (mLexicalSelectBranchList, mDefaultInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalSelectInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalSelectInstructionAST ("lexicalSelectInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionAST::
GGS_lexicalSelectInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionAST::
GGS_lexicalSelectInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSelectInstructionAST GGS_lexicalSelectInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSelectInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSelectInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSelectInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSelectInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionAST GGS_lexicalSelectInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lexicalSelectBranchListAST & argument_0,
                 const GGS_lexicalInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchListAST  GGS_lexicalSelectInstructionAST::
reader_mLexicalSelectBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstructionAST *) mPointer)->mLexicalSelectBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionListAST  GGS_lexicalSelectInstructionAST::
reader_mDefaultInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstructionAST *) mPointer)->mDefaultInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectInstructionAST::actualTypeName (void) const {
  return "lexicalSelectInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalSelectInstructionAST ("lexicalSelectInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalSelectInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalSelectInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalSelectInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalSelectInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionAST GGS_lexicalSelectInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalSelectInstructionAST * p = dynamic_cast <const GGS_lexicalSelectInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalSelectInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalSelectInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalSelectInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_abstractLexicalRoutineActualArgumentAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractLexicalRoutineActualArgumentAST::
cPtr_abstractLexicalRoutineActualArgumentAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mActualPassingModeLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractLexicalRoutineActualArgumentAST * GGS_abstractLexicalRoutineActualArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_abstractLexicalRoutineActualArgumentAST) ;
    return (cPtr_abstractLexicalRoutineActualArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_abstractLexicalRoutineActualArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@abstractLexicalRoutineActualArgumentAST:"
           << mActualPassingModeLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRoutineActualArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRoutineActualArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractLexicalRoutineActualArgumentAST (& typeid (cPtr_abstractLexicalRoutineActualArgumentAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_abstractLexicalRoutineActualArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__abstractLexicalRoutineActualArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_abstractLexicalRoutineActualArgumentAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractLexicalRoutineActualArgumentAST ("abstractLexicalRoutineActualArgumentAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgumentAST::
GGS_abstractLexicalRoutineActualArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgumentAST::
GGS_abstractLexicalRoutineActualArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractLexicalRoutineActualArgumentAST GGS_abstractLexicalRoutineActualArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractLexicalRoutineActualArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractLexicalRoutineActualArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_abstractLexicalRoutineActualArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractLexicalRoutineActualArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractLexicalRoutineActualArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_abstractLexicalRoutineActualArgumentAST::
reader_mActualPassingModeLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractLexicalRoutineActualArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractLexicalRoutineActualArgumentAST *) mPointer)->mActualPassingModeLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractLexicalRoutineActualArgumentAST::actualTypeName (void) const {
  return "abstractLexicalRoutineActualArgumentAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_abstractLexicalRoutineActualArgumentAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__abstractLexicalRoutineActualArgumentAST ("abstractLexicalRoutineActualArgumentAST", & kTypeDescriptor_GGS_abstractLexicalRoutineActualArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_abstractLexicalRoutineActualArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractLexicalRoutineActualArgumentAST * p = NULL ;
    macroMyNew (p, GGS_abstractLexicalRoutineActualArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgumentAST GGS_abstractLexicalRoutineActualArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractLexicalRoutineActualArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractLexicalRoutineActualArgumentAST * p = dynamic_cast <const GGS_abstractLexicalRoutineActualArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractLexicalRoutineActualArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractLexicalRoutineActualArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractLexicalRoutineActualArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@lexicalRoutineCallActualArgumentListAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalRoutineCallActualArgumentListAST::
elementOf_GGS_lexicalRoutineCallActualArgumentListAST (const GGS_abstractLexicalRoutineActualArgumentAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLexicalRoutineActualArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalRoutineCallActualArgumentListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalRoutineCallActualArgumentListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalRoutineCallActualArgumentListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalRoutineActualArgument.operator_isEqual (ptr->mLexicalRoutineActualArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalRoutineCallActualArgumentListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRoutineActualArgument.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@lexicalRoutineCallActualArgumentListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalRoutineCallActualArgumentListAST ("lexicalRoutineCallActualArgumentListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
internalAppendValues (const GGS_abstractLexicalRoutineActualArgumentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
internalPrependValues (const GGS_abstractLexicalRoutineActualArgumentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
addAssign_operation (const GGS_abstractLexicalRoutineActualArgumentAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST GGS_lexicalRoutineCallActualArgumentListAST::
operator_concat (const GGS_lexicalRoutineCallActualArgumentListAST & inOperand) const {
  GGS_lexicalRoutineCallActualArgumentListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
dotAssign_operation (const GGS_lexicalRoutineCallActualArgumentListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalRoutineCallActualArgumentListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_abstractLexicalRoutineActualArgumentAST  p_0 = p->mLexicalRoutineActualArgument ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_abstractLexicalRoutineActualArgumentAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalRoutineActualArgument
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST  GGS_lexicalRoutineCallActualArgumentListAST::
constructor_emptyList (void) {
  GGS_lexicalRoutineCallActualArgumentListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST  GGS_lexicalRoutineCallActualArgumentListAST::
constructor_listWithValue (const GGS_abstractLexicalRoutineActualArgumentAST & argument_0) {
  GGS_lexicalRoutineCallActualArgumentListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
internalSubListWithRange (GGS_lexicalRoutineCallActualArgumentListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalRoutineActualArgument) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST GGS_lexicalRoutineCallActualArgumentListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRoutineCallActualArgumentListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST GGS_lexicalRoutineCallActualArgumentListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRoutineCallActualArgumentListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalRoutineCallActualArgumentListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalRoutineCallActualArgumentListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
method_first (C_CompilerEx & inLexique,
              GGS_abstractLexicalRoutineActualArgumentAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
method_last (C_CompilerEx & inLexique,
             GGS_abstractLexicalRoutineActualArgumentAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_abstractLexicalRoutineActualArgumentAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_abstractLexicalRoutineActualArgumentAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgumentAST  GGS_lexicalRoutineCallActualArgumentListAST::
reader_mLexicalRoutineActualArgumentAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_abstractLexicalRoutineActualArgumentAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRoutineActualArgument ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentListAST::
modifier_setMLexicalRoutineActualArgumentAtIndex (C_CompilerEx & inLexique,
                              const GGS_abstractLexicalRoutineActualArgumentAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRoutineActualArgument = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_abstractLexicalRoutineActualArgumentAST  & GGS_lexicalRoutineCallActualArgumentListAST::cEnumerator::_mLexicalRoutineActualArgument (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalRoutineActualArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalRoutineCallActualArgumentListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalRoutineCallActualArgumentListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalRoutineCallActualArgumentListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST GGS_lexicalRoutineCallActualArgumentListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineCallActualArgumentListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalRoutineCallActualArgumentListAST * p = dynamic_cast <const GGS_lexicalRoutineCallActualArgumentListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalRoutineCallActualArgumentListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalRoutineCallActualArgumentListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalRoutineCallActualArgumentListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalRoutineInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRoutineInstructionAST::
cPtr_lexicalRoutineInstructionAST (const GGS_lstring & argument_0,
                                const GGS_lexicalRoutineCallActualArgumentListAST & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mRoutineName (argument_0),
mActualArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRoutineInstructionAST * GGS_lexicalRoutineInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalRoutineInstructionAST) ;
    return (cPtr_lexicalRoutineInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRoutineInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRoutineInstructionAST * ptr = dynamic_cast <const cPtr_lexicalRoutineInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualArgumentList.operator_isEqual (ptr->mActualArgumentList).boolValue ()
         && mErrorMessageList.operator_isEqual (ptr->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRoutineInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalRoutineInstructionAST:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualArgumentList.reader_description (inIndentation + 1)
           << mErrorMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRoutineInstructionAST (& typeid (cPtr_lexicalRoutineInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalRoutineInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRoutineInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRoutineInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRoutineInstructionAST (mRoutineName, mActualArgumentList, mErrorMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalRoutineInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalRoutineInstructionAST ("lexicalRoutineInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstructionAST::
GGS_lexicalRoutineInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstructionAST::
GGS_lexicalRoutineInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRoutineInstructionAST GGS_lexicalRoutineInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRoutineInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRoutineInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRoutineInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRoutineInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstructionAST GGS_lexicalRoutineInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalRoutineCallActualArgumentListAST & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalRoutineInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRoutineInstructionAST::
reader_mRoutineName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRoutineInstructionAST *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentListAST  GGS_lexicalRoutineInstructionAST::
reader_mActualArgumentList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalRoutineCallActualArgumentListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRoutineInstructionAST *) mPointer)->mActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalRoutineInstructionAST::
reader_mErrorMessageList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRoutineInstructionAST *) mPointer)->mErrorMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRoutineInstructionAST::actualTypeName (void) const {
  return "lexicalRoutineInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalRoutineInstructionAST ("lexicalRoutineInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalRoutineInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalRoutineInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalRoutineInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalRoutineInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstructionAST GGS_lexicalRoutineInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalRoutineInstructionAST * p = dynamic_cast <const GGS_lexicalRoutineInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalRoutineInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalRoutineInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalRoutineInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_lexicalAttributeInputOutputArgumentAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeInputOutputArgumentAST::
cPtr_lexicalAttributeInputOutputArgumentAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRoutineActualArgumentAST (argument_0 COMMA_THERE),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeInputOutputArgumentAST * GGS_lexicalAttributeInputOutputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalAttributeInputOutputArgumentAST) ;
    return (cPtr_lexicalAttributeInputOutputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeInputOutputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalAttributeInputOutputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalAttributeInputOutputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualPassingModeLocation.operator_isEqual (ptr->mActualPassingModeLocation).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeInputOutputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalAttributeInputOutputArgumentAST:"
           << mActualPassingModeLocation.reader_description (inIndentation + 1)
           << mAttributeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputOutputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputOutputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalAttributeInputOutputArgumentAST (& typeid (cPtr_lexicalAttributeInputOutputArgumentAST), & typeid (cPtr_abstractLexicalRoutineActualArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalAttributeInputOutputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalAttributeInputOutputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalAttributeInputOutputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalAttributeInputOutputArgumentAST (mActualPassingModeLocation, mAttributeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_lexicalAttributeInputOutputArgumentAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalAttributeInputOutputArgumentAST ("lexicalAttributeInputOutputArgumentAST", true, & kTypeDescriptor_GGS_abstractLexicalRoutineActualArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgumentAST::
GGS_lexicalAttributeInputOutputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgumentAST::
GGS_lexicalAttributeInputOutputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalAttributeInputOutputArgumentAST GGS_lexicalAttributeInputOutputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputOutputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalAttributeInputOutputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalAttributeInputOutputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalAttributeInputOutputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalAttributeInputOutputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgumentAST GGS_lexicalAttributeInputOutputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputOutputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeInputOutputArgumentAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeInputOutputArgumentAST::
reader_mAttributeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeInputOutputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeInputOutputArgumentAST *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeInputOutputArgumentAST::actualTypeName (void) const {
  return "lexicalAttributeInputOutputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalAttributeInputOutputArgumentAST ("lexicalAttributeInputOutputArgumentAST", gClassInfoFor__abstractLexicalRoutineActualArgumentAST, & kTypeDescriptor_GGS_lexicalAttributeInputOutputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalAttributeInputOutputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalAttributeInputOutputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalAttributeInputOutputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgumentAST GGS_lexicalAttributeInputOutputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputOutputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalAttributeInputOutputArgumentAST * p = dynamic_cast <const GGS_lexicalAttributeInputOutputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalAttributeInputOutputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalAttributeInputOutputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalAttributeInputOutputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       class 'cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST::
cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST * GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST) ;
    return (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalRoutineOrFunctionFormalInputArgumentAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRoutineOrFunctionFormalInputArgumentAST (& typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    GALGAS class 'GGS_lexicalRoutineOrFunctionFormalInputArgumentAST'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST ("lexicalRoutineOrFunctionFormalInputArgumentAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::
GGS_lexicalRoutineOrFunctionFormalInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::
GGS_lexicalRoutineOrFunctionFormalInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRoutineOrFunctionFormalInputArgumentAST GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineOrFunctionFormalInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRoutineOrFunctionFormalInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::actualTypeName (void) const {
  return "lexicalRoutineOrFunctionFormalInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST ("lexicalRoutineOrFunctionFormalInputArgumentAST", & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalRoutineOrFunctionFormalInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalRoutineOrFunctionFormalInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgumentAST GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineOrFunctionFormalInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST * p = dynamic_cast <const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalRoutineOrFunctionFormalInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalFormalInputArgumentAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFormalInputArgumentAST::
cPtr_lexicalFormalInputArgumentAST (const GGS_location & argument_0,
                                const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRoutineActualArgumentAST (argument_0 COMMA_THERE),
mRoutineOrFunctionFormalInputArgument (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFormalInputArgumentAST * GGS_lexicalFormalInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalFormalInputArgumentAST) ;
    return (cPtr_lexicalFormalInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalFormalInputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalFormalInputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalFormalInputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualPassingModeLocation.operator_isEqual (ptr->mActualPassingModeLocation).boolValue ()
         && mRoutineOrFunctionFormalInputArgument.operator_isEqual (ptr->mRoutineOrFunctionFormalInputArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFormalInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalFormalInputArgumentAST:"
           << mActualPassingModeLocation.reader_description (inIndentation + 1)
           << mRoutineOrFunctionFormalInputArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalFormalInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFormalInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalFormalInputArgumentAST (& typeid (cPtr_lexicalFormalInputArgumentAST), & typeid (cPtr_abstractLexicalRoutineActualArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalFormalInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalFormalInputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalFormalInputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalFormalInputArgumentAST (mActualPassingModeLocation, mRoutineOrFunctionFormalInputArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalFormalInputArgumentAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalFormalInputArgumentAST ("lexicalFormalInputArgumentAST", true, & kTypeDescriptor_GGS_abstractLexicalRoutineActualArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgumentAST::
GGS_lexicalFormalInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgumentAST::
GGS_lexicalFormalInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalFormalInputArgumentAST GGS_lexicalFormalInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalFormalInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalFormalInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalFormalInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalFormalInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalFormalInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgumentAST GGS_lexicalFormalInputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFormalInputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalFormalInputArgumentAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgumentAST  GGS_lexicalFormalInputArgumentAST::
reader_mRoutineOrFunctionFormalInputArgument (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalRoutineOrFunctionFormalInputArgumentAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFormalInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFormalInputArgumentAST *) mPointer)->mRoutineOrFunctionFormalInputArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFormalInputArgumentAST::actualTypeName (void) const {
  return "lexicalFormalInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalFormalInputArgumentAST ("lexicalFormalInputArgumentAST", gClassInfoFor__abstractLexicalRoutineActualArgumentAST, & kTypeDescriptor_GGS_lexicalFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalFormalInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalFormalInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalFormalInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgumentAST GGS_lexicalFormalInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalFormalInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalFormalInputArgumentAST * p = dynamic_cast <const GGS_lexicalFormalInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalFormalInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalFormalInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalFormalInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@lexicalFunctionCallActualArgumentListAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalFunctionCallActualArgumentListAST::
elementOf_GGS_lexicalFunctionCallActualArgumentListAST (const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLexicalActualInputArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalFunctionCallActualArgumentListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalFunctionCallActualArgumentListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalFunctionCallActualArgumentListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalActualInputArgument.operator_isEqual (ptr->mLexicalActualInputArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalFunctionCallActualArgumentListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalActualInputArgument.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@lexicalFunctionCallActualArgumentListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalFunctionCallActualArgumentListAST ("lexicalFunctionCallActualArgumentListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
internalAppendValues (const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
internalPrependValues (const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
addAssign_operation (const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST GGS_lexicalFunctionCallActualArgumentListAST::
operator_concat (const GGS_lexicalFunctionCallActualArgumentListAST & inOperand) const {
  GGS_lexicalFunctionCallActualArgumentListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
dotAssign_operation (const GGS_lexicalFunctionCallActualArgumentListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalFunctionCallActualArgumentListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalRoutineOrFunctionFormalInputArgumentAST  p_0 = p->mLexicalActualInputArgument ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalActualInputArgument
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST  GGS_lexicalFunctionCallActualArgumentListAST::
constructor_emptyList (void) {
  GGS_lexicalFunctionCallActualArgumentListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST  GGS_lexicalFunctionCallActualArgumentListAST::
constructor_listWithValue (const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & argument_0) {
  GGS_lexicalFunctionCallActualArgumentListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
internalSubListWithRange (GGS_lexicalFunctionCallActualArgumentListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalActualInputArgument) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST GGS_lexicalFunctionCallActualArgumentListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalFunctionCallActualArgumentListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST GGS_lexicalFunctionCallActualArgumentListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalFunctionCallActualArgumentListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalFunctionCallActualArgumentListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalFunctionCallActualArgumentListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lexicalRoutineOrFunctionFormalInputArgumentAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgumentAST  GGS_lexicalFunctionCallActualArgumentListAST::
reader_mLexicalActualInputArgumentAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalRoutineOrFunctionFormalInputArgumentAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalActualInputArgument ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentListAST::
modifier_setMLexicalActualInputArgumentAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalRoutineOrFunctionFormalInputArgumentAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalActualInputArgument = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalRoutineOrFunctionFormalInputArgumentAST  & GGS_lexicalFunctionCallActualArgumentListAST::cEnumerator::_mLexicalActualInputArgument (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalActualInputArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalFunctionCallActualArgumentListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalFunctionCallActualArgumentListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalFunctionCallActualArgumentListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST GGS_lexicalFunctionCallActualArgumentListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionCallActualArgumentListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalFunctionCallActualArgumentListAST * p = dynamic_cast <const GGS_lexicalFunctionCallActualArgumentListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalFunctionCallActualArgumentListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalFunctionCallActualArgumentListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalFunctionCallActualArgumentListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_lexicalAttributeInputArgumentAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeInputArgumentAST::
cPtr_lexicalAttributeInputArgumentAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST (THERE),
mAttributeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeInputArgumentAST * GGS_lexicalAttributeInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalAttributeInputArgumentAST) ;
    return (cPtr_lexicalAttributeInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeInputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalAttributeInputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalAttributeInputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalAttributeInputArgumentAST:"
           << mAttributeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalAttributeInputArgumentAST (& typeid (cPtr_lexicalAttributeInputArgumentAST), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalAttributeInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalAttributeInputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalAttributeInputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalAttributeInputArgumentAST (mAttributeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalAttributeInputArgumentAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalAttributeInputArgumentAST ("lexicalAttributeInputArgumentAST", true, & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgumentAST::
GGS_lexicalAttributeInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgumentAST::
GGS_lexicalAttributeInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalAttributeInputArgumentAST GGS_lexicalAttributeInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalAttributeInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalAttributeInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalAttributeInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalAttributeInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgumentAST GGS_lexicalAttributeInputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeInputArgumentAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeInputArgumentAST::
reader_mAttributeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeInputArgumentAST *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeInputArgumentAST::actualTypeName (void) const {
  return "lexicalAttributeInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalAttributeInputArgumentAST ("lexicalAttributeInputArgumentAST", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST, & kTypeDescriptor_GGS_lexicalAttributeInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalAttributeInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalAttributeInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalAttributeInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgumentAST GGS_lexicalAttributeInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalAttributeInputArgumentAST * p = dynamic_cast <const GGS_lexicalAttributeInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalAttributeInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalAttributeInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalAttributeInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_lexicalCharacterInputArgumentAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterInputArgumentAST::
cPtr_lexicalCharacterInputArgumentAST (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterInputArgumentAST * GGS_lexicalCharacterInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalCharacterInputArgumentAST) ;
    return (cPtr_lexicalCharacterInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterInputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterInputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalCharacterInputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterInputArgumentAST:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterInputArgumentAST (& typeid (cPtr_lexicalCharacterInputArgumentAST), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalCharacterInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterInputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterInputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterInputArgumentAST (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalCharacterInputArgumentAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalCharacterInputArgumentAST ("lexicalCharacterInputArgumentAST", true, & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgumentAST::
GGS_lexicalCharacterInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgumentAST::
GGS_lexicalCharacterInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterInputArgumentAST GGS_lexicalCharacterInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgumentAST GGS_lexicalCharacterInputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterInputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterInputArgumentAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterInputArgumentAST::
reader_mCharacter (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterInputArgumentAST *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterInputArgumentAST::actualTypeName (void) const {
  return "lexicalCharacterInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalCharacterInputArgumentAST ("lexicalCharacterInputArgumentAST", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST, & kTypeDescriptor_GGS_lexicalCharacterInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalCharacterInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalCharacterInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalCharacterInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgumentAST GGS_lexicalCharacterInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalCharacterInputArgumentAST * p = dynamic_cast <const GGS_lexicalCharacterInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalCharacterInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalCharacterInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalCharacterInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_lexicalUnsignedInputArgumentAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalUnsignedInputArgumentAST::
cPtr_lexicalUnsignedInputArgumentAST (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST (THERE),
mUnsigned (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalUnsignedInputArgumentAST * GGS_lexicalUnsignedInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalUnsignedInputArgumentAST) ;
    return (cPtr_lexicalUnsignedInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalUnsignedInputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalUnsignedInputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalUnsignedInputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUnsigned.operator_isEqual (ptr->mUnsigned).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalUnsignedInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalUnsignedInputArgumentAST:"
           << mUnsigned.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalUnsignedInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalUnsignedInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalUnsignedInputArgumentAST (& typeid (cPtr_lexicalUnsignedInputArgumentAST), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalUnsignedInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalUnsignedInputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalUnsignedInputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalUnsignedInputArgumentAST (mUnsigned COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalUnsignedInputArgumentAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalUnsignedInputArgumentAST ("lexicalUnsignedInputArgumentAST", true, & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgumentAST::
GGS_lexicalUnsignedInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgumentAST::
GGS_lexicalUnsignedInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalUnsignedInputArgumentAST GGS_lexicalUnsignedInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalUnsignedInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalUnsignedInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalUnsignedInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalUnsignedInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalUnsignedInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgumentAST GGS_lexicalUnsignedInputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalUnsignedInputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalUnsignedInputArgumentAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_lexicalUnsignedInputArgumentAST::
reader_mUnsigned (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalUnsignedInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalUnsignedInputArgumentAST *) mPointer)->mUnsigned ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalUnsignedInputArgumentAST::actualTypeName (void) const {
  return "lexicalUnsignedInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalUnsignedInputArgumentAST ("lexicalUnsignedInputArgumentAST", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST, & kTypeDescriptor_GGS_lexicalUnsignedInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalUnsignedInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalUnsignedInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalUnsignedInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgumentAST GGS_lexicalUnsignedInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalUnsignedInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalUnsignedInputArgumentAST * p = dynamic_cast <const GGS_lexicalUnsignedInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalUnsignedInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalUnsignedInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalUnsignedInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_lexicalCurrentCharacterInputArgumentAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterInputArgumentAST::
cPtr_lexicalCurrentCharacterInputArgumentAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCurrentCharacterInputArgumentAST * GGS_lexicalCurrentCharacterInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalCurrentCharacterInputArgumentAST) ;
    return (cPtr_lexicalCurrentCharacterInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCurrentCharacterInputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCurrentCharacterInputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalCurrentCharacterInputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCurrentCharacterInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCurrentCharacterInputArgumentAST:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCurrentCharacterInputArgumentAST (& typeid (cPtr_lexicalCurrentCharacterInputArgumentAST), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalCurrentCharacterInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCurrentCharacterInputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCurrentCharacterInputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCurrentCharacterInputArgumentAST (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_lexicalCurrentCharacterInputArgumentAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalCurrentCharacterInputArgumentAST ("lexicalCurrentCharacterInputArgumentAST", true, & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgumentAST::
GGS_lexicalCurrentCharacterInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgumentAST::
GGS_lexicalCurrentCharacterInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCurrentCharacterInputArgumentAST GGS_lexicalCurrentCharacterInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCurrentCharacterInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCurrentCharacterInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCurrentCharacterInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCurrentCharacterInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgumentAST GGS_lexicalCurrentCharacterInputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterInputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalCurrentCharacterInputArgumentAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lexicalCurrentCharacterInputArgumentAST::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCurrentCharacterInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCurrentCharacterInputArgumentAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCurrentCharacterInputArgumentAST::actualTypeName (void) const {
  return "lexicalCurrentCharacterInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalCurrentCharacterInputArgumentAST ("lexicalCurrentCharacterInputArgumentAST", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST, & kTypeDescriptor_GGS_lexicalCurrentCharacterInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalCurrentCharacterInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalCurrentCharacterInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalCurrentCharacterInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgumentAST GGS_lexicalCurrentCharacterInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalCurrentCharacterInputArgumentAST * p = dynamic_cast <const GGS_lexicalCurrentCharacterInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalCurrentCharacterInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalCurrentCharacterInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalCurrentCharacterInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_lexicalFunctionInputArgumentAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFunctionInputArgumentAST::
cPtr_lexicalFunctionInputArgumentAST (const GGS_lstring & argument_0,
                                const GGS_lexicalFunctionCallActualArgumentListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST (THERE),
mFunctionName (argument_0),
mFunctionActualArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFunctionInputArgumentAST * GGS_lexicalFunctionInputArgumentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalFunctionInputArgumentAST) ;
    return (cPtr_lexicalFunctionInputArgumentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalFunctionInputArgumentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalFunctionInputArgumentAST * ptr = dynamic_cast <const cPtr_lexicalFunctionInputArgumentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFunctionActualArgumentList.operator_isEqual (ptr->mFunctionActualArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFunctionInputArgumentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalFunctionInputArgumentAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFunctionActualArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionInputArgumentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionInputArgumentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalFunctionInputArgumentAST (& typeid (cPtr_lexicalFunctionInputArgumentAST), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgumentAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalFunctionInputArgumentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalFunctionInputArgumentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalFunctionInputArgumentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalFunctionInputArgumentAST (mFunctionName, mFunctionActualArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalFunctionInputArgumentAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalFunctionInputArgumentAST ("lexicalFunctionInputArgumentAST", true, & kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgumentAST::
GGS_lexicalFunctionInputArgumentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgumentAST::
GGS_lexicalFunctionInputArgumentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalFunctionInputArgumentAST GGS_lexicalFunctionInputArgumentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionInputArgumentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalFunctionInputArgumentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalFunctionInputArgumentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalFunctionInputArgumentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalFunctionInputArgumentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgumentAST GGS_lexicalFunctionInputArgumentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalFunctionCallActualArgumentListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionInputArgumentAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalFunctionInputArgumentAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalFunctionInputArgumentAST::
reader_mFunctionName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionInputArgumentAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentListAST  GGS_lexicalFunctionInputArgumentAST::
reader_mFunctionActualArgumentList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalFunctionCallActualArgumentListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionInputArgumentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionInputArgumentAST *) mPointer)->mFunctionActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFunctionInputArgumentAST::actualTypeName (void) const {
  return "lexicalFunctionInputArgumentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalFunctionInputArgumentAST ("lexicalFunctionInputArgumentAST", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgumentAST, & kTypeDescriptor_GGS_lexicalFunctionInputArgumentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalFunctionInputArgumentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalFunctionInputArgumentAST * p = NULL ;
    macroMyNew (p, GGS_lexicalFunctionInputArgumentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgumentAST GGS_lexicalFunctionInputArgumentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionInputArgumentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalFunctionInputArgumentAST * p = dynamic_cast <const GGS_lexicalFunctionInputArgumentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalFunctionInputArgumentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalFunctionInputArgumentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalFunctionInputArgumentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalDropInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalDropInstructionAST::
cPtr_lexicalDropInstructionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mTerminalName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalDropInstructionAST * GGS_lexicalDropInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalDropInstructionAST) ;
    return (cPtr_lexicalDropInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalDropInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalDropInstructionAST * ptr = dynamic_cast <const cPtr_lexicalDropInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTerminalName.operator_isEqual (ptr->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalDropInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalDropInstructionAST:"
           << mTerminalName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalDropInstructionAST (& typeid (cPtr_lexicalDropInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalDropInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalDropInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalDropInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalDropInstructionAST (mTerminalName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalDropInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalDropInstructionAST ("lexicalDropInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionAST::
GGS_lexicalDropInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionAST::
GGS_lexicalDropInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalDropInstructionAST GGS_lexicalDropInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalDropInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalDropInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalDropInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalDropInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionAST GGS_lexicalDropInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalDropInstructionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalDropInstructionAST::
reader_mTerminalName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalDropInstructionAST *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalDropInstructionAST::actualTypeName (void) const {
  return "lexicalDropInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalDropInstructionAST ("lexicalDropInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalDropInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalDropInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalDropInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalDropInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionAST GGS_lexicalDropInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalDropInstructionAST * p = dynamic_cast <const GGS_lexicalDropInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalDropInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalDropInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalDropInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalErrorInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstructionAST::
cPtr_lexicalErrorInstructionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorInstructionAST * GGS_lexicalErrorInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalErrorInstructionAST) ;
    return (cPtr_lexicalErrorInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalErrorInstructionAST * ptr = dynamic_cast <const cPtr_lexicalErrorInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorMessageName.operator_isEqual (ptr->mErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalErrorInstructionAST:"
           << mErrorMessageName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalErrorInstructionAST (& typeid (cPtr_lexicalErrorInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalErrorInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalErrorInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalErrorInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalErrorInstructionAST (mErrorMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalErrorInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalErrorInstructionAST ("lexicalErrorInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionAST::
GGS_lexicalErrorInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionAST::
GGS_lexicalErrorInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalErrorInstructionAST GGS_lexicalErrorInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalErrorInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalErrorInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalErrorInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalErrorInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionAST GGS_lexicalErrorInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorInstructionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorInstructionAST::
reader_mErrorMessageName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorInstructionAST *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorInstructionAST::actualTypeName (void) const {
  return "lexicalErrorInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalErrorInstructionAST ("lexicalErrorInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalErrorInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalErrorInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalErrorInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalErrorInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionAST GGS_lexicalErrorInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalErrorInstructionAST * p = dynamic_cast <const GGS_lexicalErrorInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalErrorInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalErrorInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalErrorInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalWarningInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalWarningInstructionAST::
cPtr_lexicalWarningInstructionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mWarningMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalWarningInstructionAST * GGS_lexicalWarningInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalWarningInstructionAST) ;
    return (cPtr_lexicalWarningInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalWarningInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalWarningInstructionAST * ptr = dynamic_cast <const cPtr_lexicalWarningInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWarningMessageName.operator_isEqual (ptr->mWarningMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalWarningInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalWarningInstructionAST:"
           << mWarningMessageName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalWarningInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWarningInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalWarningInstructionAST (& typeid (cPtr_lexicalWarningInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalWarningInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalWarningInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalWarningInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalWarningInstructionAST (mWarningMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalWarningInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalWarningInstructionAST ("lexicalWarningInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstructionAST::
GGS_lexicalWarningInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstructionAST::
GGS_lexicalWarningInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalWarningInstructionAST GGS_lexicalWarningInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalWarningInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalWarningInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalWarningInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalWarningInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstructionAST GGS_lexicalWarningInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalWarningInstructionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalWarningInstructionAST::
reader_mWarningMessageName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWarningInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWarningInstructionAST *) mPointer)->mWarningMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalWarningInstructionAST::actualTypeName (void) const {
  return "lexicalWarningInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalWarningInstructionAST ("lexicalWarningInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalWarningInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalWarningInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalWarningInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalWarningInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstructionAST GGS_lexicalWarningInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalWarningInstructionAST * p = dynamic_cast <const GGS_lexicalWarningInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalWarningInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalWarningInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalWarningInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalTagInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalTagInstructionAST::
cPtr_lexicalTagInstructionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mLexicalTagName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalTagInstructionAST * GGS_lexicalTagInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalTagInstructionAST) ;
    return (cPtr_lexicalTagInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalTagInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalTagInstructionAST * ptr = dynamic_cast <const cPtr_lexicalTagInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTagName.operator_isEqual (ptr->mLexicalTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalTagInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalTagInstructionAST:"
           << mLexicalTagName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalTagInstructionAST (& typeid (cPtr_lexicalTagInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalTagInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalTagInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalTagInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalTagInstructionAST (mLexicalTagName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalTagInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalTagInstructionAST ("lexicalTagInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionAST::
GGS_lexicalTagInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionAST::
GGS_lexicalTagInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalTagInstructionAST GGS_lexicalTagInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalTagInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalTagInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalTagInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalTagInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionAST GGS_lexicalTagInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalTagInstructionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalTagInstructionAST::
reader_mLexicalTagName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalTagInstructionAST *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalTagInstructionAST::actualTypeName (void) const {
  return "lexicalTagInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalTagInstructionAST ("lexicalTagInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalTagInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalTagInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalTagInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalTagInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionAST GGS_lexicalTagInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalTagInstructionAST * p = dynamic_cast <const GGS_lexicalTagInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalTagInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalTagInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalTagInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalRewindInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstructionAST::
cPtr_lexicalRewindInstructionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE),
mLexicalTagName (argument_0),
mTerminalName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRewindInstructionAST * GGS_lexicalRewindInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalRewindInstructionAST) ;
    return (cPtr_lexicalRewindInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRewindInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRewindInstructionAST * ptr = dynamic_cast <const cPtr_lexicalRewindInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTagName.operator_isEqual (ptr->mLexicalTagName).boolValue ()
         && mTerminalName.operator_isEqual (ptr->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRewindInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalRewindInstructionAST:"
           << mLexicalTagName.reader_description (inIndentation + 1)
           << mTerminalName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRewindInstructionAST (& typeid (cPtr_lexicalRewindInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalRewindInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRewindInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRewindInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRewindInstructionAST (mLexicalTagName, mTerminalName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalRewindInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalRewindInstructionAST ("lexicalRewindInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionAST::
GGS_lexicalRewindInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionAST::
GGS_lexicalRewindInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRewindInstructionAST GGS_lexicalRewindInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRewindInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRewindInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRewindInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRewindInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionAST GGS_lexicalRewindInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_lexicalRewindInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstructionAST::
reader_mLexicalTagName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstructionAST *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstructionAST::
reader_mTerminalName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstructionAST *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRewindInstructionAST::actualTypeName (void) const {
  return "lexicalRewindInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalRewindInstructionAST ("lexicalRewindInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalRewindInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalRewindInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalRewindInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalRewindInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionAST GGS_lexicalRewindInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalRewindInstructionAST * p = dynamic_cast <const GGS_lexicalRewindInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalRewindInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalRewindInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalRewindInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalLogInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalLogInstructionAST::
cPtr_lexicalLogInstructionAST (LOCATION_ARGS)
:cPtr_lexicalInstructionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalLogInstructionAST * GGS_lexicalLogInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexicalLogInstructionAST) ;
    return (cPtr_lexicalLogInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalLogInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalLogInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalLogInstructionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalLogInstructionAST (& typeid (cPtr_lexicalLogInstructionAST), & typeid (cPtr_lexicalInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexicalLogInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalLogInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalLogInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalLogInstructionAST ("lexicalLogInstructionAST", true, & kTypeDescriptor_GGS_lexicalInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionAST::
GGS_lexicalLogInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionAST::
GGS_lexicalLogInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalLogInstructionAST GGS_lexicalLogInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalLogInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalLogInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalLogInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalLogInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lexicalLogInstructionAST * gSingleton_lexicalLogInstructionAST = NULL ;

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionAST GGS_lexicalLogInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstructionAST result ;
  if (NULL == gSingleton_lexicalLogInstructionAST) {
    macroMyNew (gSingleton_lexicalLogInstructionAST, cPtr_lexicalLogInstructionAST (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_lexicalLogInstructionAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalLogInstructionAST::actualTypeName (void) const {
  return "lexicalLogInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lexicalLogInstructionAST ("lexicalLogInstructionAST", gClassInfoFor__lexicalInstructionAST, & kTypeDescriptor_GGS_lexicalLogInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalLogInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalLogInstructionAST * p = NULL ;
    macroMyNew (p, GGS_lexicalLogInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionAST GGS_lexicalLogInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalLogInstructionAST * p = dynamic_cast <const GGS_lexicalLogInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalLogInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalLogInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalLogInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'lexicalArgumentModeAST' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalArgumentModeAST ("lexicalArgumentModeAST", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_lexicalArgumentModeAST::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentModeAST::
operator_isEqual (const GGS_lexicalArgumentModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentModeAST::
operator_isNotEqual (const GGS_lexicalArgumentModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentModeAST::
operator_infOrEqual (const GGS_lexicalArgumentModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentModeAST::
operator_supOrEqual (const GGS_lexicalArgumentModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentModeAST::
operator_strictInf (const GGS_lexicalArgumentModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentModeAST::
operator_strictSup (const GGS_lexicalArgumentModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentModeAST::
reader_lexicalFormalModeName (C_CompilerEx & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "!",
    "\?!"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentModeAST::
reader_cppConstInFormalArgument (C_CompilerEx & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "const ",
    ""
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentModeAST::
reader_cppReferenceInFormalArgument (C_CompilerEx & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "",
    " &"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentModeAST::
reader_cocoaPointerInFormalArgument (C_CompilerEx & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "",
    " *"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentModeAST::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @lexicalArgumentModeAST" ;
  switch (mValue) {
  case enum_lexicalInputMode:
    s << " lexicalInputMode>" ;
    break ;
  case enum_lexicalInputOutputMode:
    s << " lexicalInputOutputMode>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalArgumentModeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalArgumentModeAST * p = NULL ;
    macroMyNew (p, GGS_lexicalArgumentModeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalArgumentModeAST GGS_lexicalArgumentModeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalArgumentModeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalArgumentModeAST * p = dynamic_cast <const GGS_lexicalArgumentModeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalArgumentModeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalArgumentModeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalArgumentModeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@lexicalExternRoutineFormalArgumentListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalExternRoutineFormalArgumentListAST::
elementOf_GGS_lexicalExternRoutineFormalArgumentListAST (const GGS_lexicalArgumentModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mPassingMode (argument_0),
mLexicalTypeName (argument_1),
mFormalArgumentName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalExternRoutineFormalArgumentListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalExternRoutineFormalArgumentListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalExternRoutineFormalArgumentListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPassingMode.operator_isEqual (ptr->mPassingMode).boolValue ()
         && mLexicalTypeName.operator_isEqual (ptr->mLexicalTypeName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalExternRoutineFormalArgumentListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@lexicalExternRoutineFormalArgumentListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalExternRoutineFormalArgumentListAST ("lexicalExternRoutineFormalArgumentListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
internalAppendValues (const GGS_lexicalArgumentModeAST& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
internalPrependValues (const GGS_lexicalArgumentModeAST& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
addAssign_operation (const GGS_lexicalArgumentModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST GGS_lexicalExternRoutineFormalArgumentListAST::
operator_concat (const GGS_lexicalExternRoutineFormalArgumentListAST & inOperand) const {
  GGS_lexicalExternRoutineFormalArgumentListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
dotAssign_operation (const GGS_lexicalExternRoutineFormalArgumentListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalExternRoutineFormalArgumentListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalArgumentModeAST p_0 = p->mPassingMode ;
          GGS_lstring  p_1 = p->mLexicalTypeName ;
          GGS_lstring  p_2 = p->mFormalArgumentName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lexicalArgumentModeAST& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mPassingMode,
                                ptr->mLexicalTypeName,
                                ptr->mFormalArgumentName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST  GGS_lexicalExternRoutineFormalArgumentListAST::
constructor_emptyList (void) {
  GGS_lexicalExternRoutineFormalArgumentListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST  GGS_lexicalExternRoutineFormalArgumentListAST::
constructor_listWithValue (const GGS_lexicalArgumentModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_lexicalExternRoutineFormalArgumentListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
internalSubListWithRange (GGS_lexicalExternRoutineFormalArgumentListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mPassingMode, ptr->mLexicalTypeName, ptr->mFormalArgumentName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST GGS_lexicalExternRoutineFormalArgumentListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternRoutineFormalArgumentListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST GGS_lexicalExternRoutineFormalArgumentListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternRoutineFormalArgumentListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExternRoutineFormalArgumentListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalExternRoutineFormalArgumentListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lexicalArgumentModeAST& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lexicalArgumentModeAST& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lexicalArgumentModeAST& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lexicalArgumentModeAST& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalArgumentModeAST GGS_lexicalExternRoutineFormalArgumentListAST::
reader_mPassingModeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalArgumentModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternRoutineFormalArgumentListAST::
reader_mLexicalTypeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternRoutineFormalArgumentListAST::
reader_mFormalArgumentNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
modifier_setMPassingModeAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalArgumentModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
modifier_setMLexicalTypeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentListAST::
modifier_setMFormalArgumentNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalArgumentModeAST & GGS_lexicalExternRoutineFormalArgumentListAST::cEnumerator::_mPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternRoutineFormalArgumentListAST::cEnumerator::_mLexicalTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternRoutineFormalArgumentListAST::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalExternRoutineFormalArgumentListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalExternRoutineFormalArgumentListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalExternRoutineFormalArgumentListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST GGS_lexicalExternRoutineFormalArgumentListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalExternRoutineFormalArgumentListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalExternRoutineFormalArgumentListAST * p = dynamic_cast <const GGS_lexicalExternRoutineFormalArgumentListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalExternRoutineFormalArgumentListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalExternRoutineFormalArgumentListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalExternRoutineFormalArgumentListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@externRoutineListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_externRoutineListAST::
elementOf_GGS_externRoutineListAST (const GGS_lstring & argument_0,
                                const GGS_lexicalExternRoutineFormalArgumentListAST & argument_1,
                                const GGS_stringlist & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mRoutineName (argument_0),
mLexicalRoutineFormalArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externRoutineListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_externRoutineListAST * ptr = dynamic_cast <const elementOf_GGS_externRoutineListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mLexicalRoutineFormalArgumentList.operator_isEqual (ptr->mLexicalRoutineFormalArgumentList).boolValue ()
         && mErrorMessageList.operator_isEqual (ptr->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externRoutineListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRoutineFormalArgumentList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@externRoutineListAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externRoutineListAST ("externRoutineListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternRoutineFormalArgumentListAST & argument_1,
                    const GGS_stringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternRoutineFormalArgumentListAST & argument_1,
                    const GGS_stringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalExternRoutineFormalArgumentListAST & argument_1,
                                const GGS_stringlist & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST GGS_externRoutineListAST::
operator_concat (const GGS_externRoutineListAST & inOperand) const {
  GGS_externRoutineListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
dotAssign_operation (const GGS_externRoutineListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_externRoutineListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_lexicalExternRoutineFormalArgumentListAST  p_1 = p->mLexicalRoutineFormalArgumentList ;
          GGS_stringlist  p_2 = p->mErrorMessageList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalExternRoutineFormalArgumentListAST & argument_1,
                     const GGS_stringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mRoutineName,
                                ptr->mLexicalRoutineFormalArgumentList,
                                ptr->mErrorMessageList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST  GGS_externRoutineListAST::
constructor_emptyList (void) {
  GGS_externRoutineListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST  GGS_externRoutineListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lexicalExternRoutineFormalArgumentListAST & argument_1,
                                const GGS_stringlist & argument_2) {
  GGS_externRoutineListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
internalSubListWithRange (GGS_externRoutineListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mRoutineName, ptr->mLexicalRoutineFormalArgumentList, ptr->mErrorMessageList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST GGS_externRoutineListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_externRoutineListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST GGS_externRoutineListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_externRoutineListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externRoutineListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@externRoutineListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lexicalExternRoutineFormalArgumentListAST & _out_1,
              GGS_stringlist & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lexicalExternRoutineFormalArgumentListAST & _out_1,
             GGS_stringlist & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lexicalExternRoutineFormalArgumentListAST & _out_1,
                 GGS_stringlist & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lexicalExternRoutineFormalArgumentListAST & _out_1,
                GGS_stringlist & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineListAST::
reader_mRoutineNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentListAST  GGS_externRoutineListAST::
reader_mLexicalRoutineFormalArgumentListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternRoutineFormalArgumentListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRoutineFormalArgumentList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_externRoutineListAST::
reader_mErrorMessageListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_stringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessageList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
modifier_setMRoutineNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
modifier_setMLexicalRoutineFormalArgumentListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalExternRoutineFormalArgumentListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRoutineFormalArgumentList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineListAST::
modifier_setMErrorMessageListAtIndex (C_CompilerEx & inLexique,
                              const GGS_stringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessageList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_externRoutineListAST::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExternRoutineFormalArgumentListAST  & GGS_externRoutineListAST::cEnumerator::_mLexicalRoutineFormalArgumentList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalRoutineFormalArgumentList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringlist  & GGS_externRoutineListAST::cEnumerator::_mErrorMessageList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessageList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_externRoutineListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externRoutineListAST * p = NULL ;
    macroMyNew (p, GGS_externRoutineListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST GGS_externRoutineListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externRoutineListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externRoutineListAST * p = dynamic_cast <const GGS_externRoutineListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externRoutineListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externRoutineListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externRoutineListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@lexicalExternFunctionFormalArgumentListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalExternFunctionFormalArgumentListAST::
elementOf_GGS_lexicalExternFunctionFormalArgumentListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLexicalTypeName (argument_0),
mFormalArgumentName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalExternFunctionFormalArgumentListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalExternFunctionFormalArgumentListAST * ptr = dynamic_cast <const elementOf_GGS_lexicalExternFunctionFormalArgumentListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTypeName.operator_isEqual (ptr->mLexicalTypeName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalExternFunctionFormalArgumentListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@lexicalExternFunctionFormalArgumentListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexicalExternFunctionFormalArgumentListAST ("lexicalExternFunctionFormalArgumentListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST GGS_lexicalExternFunctionFormalArgumentListAST::
operator_concat (const GGS_lexicalExternFunctionFormalArgumentListAST & inOperand) const {
  GGS_lexicalExternFunctionFormalArgumentListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
dotAssign_operation (const GGS_lexicalExternFunctionFormalArgumentListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalExternFunctionFormalArgumentListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLexicalTypeName ;
          GGS_lstring  p_1 = p->mFormalArgumentName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalTypeName,
                                ptr->mFormalArgumentName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST  GGS_lexicalExternFunctionFormalArgumentListAST::
constructor_emptyList (void) {
  GGS_lexicalExternFunctionFormalArgumentListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST  GGS_lexicalExternFunctionFormalArgumentListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalExternFunctionFormalArgumentListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
internalSubListWithRange (GGS_lexicalExternFunctionFormalArgumentListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalTypeName, ptr->mFormalArgumentName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST GGS_lexicalExternFunctionFormalArgumentListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternFunctionFormalArgumentListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST GGS_lexicalExternFunctionFormalArgumentListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternFunctionFormalArgumentListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExternFunctionFormalArgumentListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalExternFunctionFormalArgumentListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternFunctionFormalArgumentListAST::
reader_mLexicalTypeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternFunctionFormalArgumentListAST::
reader_mFormalArgumentNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
modifier_setMLexicalTypeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentListAST::
modifier_setMFormalArgumentNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternFunctionFormalArgumentListAST::cEnumerator::_mLexicalTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternFunctionFormalArgumentListAST::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lexicalExternFunctionFormalArgumentListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexicalExternFunctionFormalArgumentListAST * p = NULL ;
    macroMyNew (p, GGS_lexicalExternFunctionFormalArgumentListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST GGS_lexicalExternFunctionFormalArgumentListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexicalExternFunctionFormalArgumentListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexicalExternFunctionFormalArgumentListAST * p = dynamic_cast <const GGS_lexicalExternFunctionFormalArgumentListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexicalExternFunctionFormalArgumentListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexicalExternFunctionFormalArgumentListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexicalExternFunctionFormalArgumentListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@externFunctionListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_externFunctionListAST::
elementOf_GGS_externFunctionListAST (const GGS_lstring & argument_0,
                                const GGS_lexicalExternFunctionFormalArgumentListAST & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFunctionName (argument_0),
mLexicalFunctionFormalArgumentList (argument_1),
mReturnedTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externFunctionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_externFunctionListAST * ptr = dynamic_cast <const elementOf_GGS_externFunctionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mLexicalFunctionFormalArgumentList.operator_isEqual (ptr->mLexicalFunctionFormalArgumentList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externFunctionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFunctionName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalFunctionFormalArgumentList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@externFunctionListAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externFunctionListAST ("externFunctionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternFunctionFormalArgumentListAST & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternFunctionFormalArgumentListAST & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalExternFunctionFormalArgumentListAST & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST GGS_externFunctionListAST::
operator_concat (const GGS_externFunctionListAST & inOperand) const {
  GGS_externFunctionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
dotAssign_operation (const GGS_externFunctionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_externFunctionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFunctionName ;
          GGS_lexicalExternFunctionFormalArgumentListAST  p_1 = p->mLexicalFunctionFormalArgumentList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalExternFunctionFormalArgumentListAST & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFunctionName,
                                ptr->mLexicalFunctionFormalArgumentList,
                                ptr->mReturnedTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST  GGS_externFunctionListAST::
constructor_emptyList (void) {
  GGS_externFunctionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST  GGS_externFunctionListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lexicalExternFunctionFormalArgumentListAST & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_externFunctionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
internalSubListWithRange (GGS_externFunctionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFunctionName, ptr->mLexicalFunctionFormalArgumentList, ptr->mReturnedTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST GGS_externFunctionListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_externFunctionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST GGS_externFunctionListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_externFunctionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externFunctionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@externFunctionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lexicalExternFunctionFormalArgumentListAST & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lexicalExternFunctionFormalArgumentListAST & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lexicalExternFunctionFormalArgumentListAST & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lexicalExternFunctionFormalArgumentListAST & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionListAST::
reader_mFunctionNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFunctionName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentListAST  GGS_externFunctionListAST::
reader_mLexicalFunctionFormalArgumentListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternFunctionFormalArgumentListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalFunctionFormalArgumentList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionListAST::
reader_mReturnedTypeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
modifier_setMFunctionNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFunctionName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
modifier_setMLexicalFunctionFormalArgumentListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lexicalExternFunctionFormalArgumentListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalFunctionFormalArgumentList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionListAST::
modifier_setMReturnedTypeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_externFunctionListAST::cEnumerator::_mFunctionName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFunctionName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExternFunctionFormalArgumentListAST  & GGS_externFunctionListAST::cEnumerator::_mLexicalFunctionFormalArgumentList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalFunctionFormalArgumentList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_externFunctionListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_externFunctionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externFunctionListAST * p = NULL ;
    macroMyNew (p, GGS_externFunctionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST GGS_externFunctionListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externFunctionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externFunctionListAST * p = dynamic_cast <const GGS_externFunctionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externFunctionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externFunctionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externFunctionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexiqueComponentAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexiqueComponentAST::
cPtr_lexiqueComponentAST (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_metamodelTemplateDelimitorListAST & argument_2,
                                const GGS_templateReplacementListAST & argument_3,
                                const GGS_lexicalAttributeListAST & argument_4,
                                const GGS_lexicalStyleListAST & argument_5,
                                const GGS_terminalDeclarationListAST & argument_6,
                                const GGS_lexicalMessageDeclarationListAST & argument_7,
                                const GGS_lexicalListDeclarationListAST & argument_8,
                                const GGS_lexicalRuleListAST & argument_9,
                                const GGS_externRoutineListAST & argument_10,
                                const GGS_externFunctionListAST & argument_11
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mLexiqueComponentName (argument_0),
mIsTemplate (argument_1),
mTemplateDelimitorList (argument_2),
mTemplateReplacementList (argument_3),
mLexicalAttributeList (argument_4),
mLexicalStyleList (argument_5),
mTerminalDeclarationList (argument_6),
mLexicalMessageDeclarationList (argument_7),
mLexicalListDeclarationList (argument_8),
mLexicalRuleList (argument_9),
mExternRoutineList (argument_10),
mExternFunctionList (argument_11) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexiqueComponentAST * GGS_lexiqueComponentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lexiqueComponentAST) ;
    return (cPtr_lexiqueComponentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexiqueComponentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexiqueComponentAST * ptr = dynamic_cast <const cPtr_lexiqueComponentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexiqueComponentName.operator_isEqual (ptr->mLexiqueComponentName).boolValue ()
         && mIsTemplate.operator_isEqual (ptr->mIsTemplate).boolValue ()
         && mTemplateDelimitorList.operator_isEqual (ptr->mTemplateDelimitorList).boolValue ()
         && mTemplateReplacementList.operator_isEqual (ptr->mTemplateReplacementList).boolValue ()
         && mLexicalAttributeList.operator_isEqual (ptr->mLexicalAttributeList).boolValue ()
         && mLexicalStyleList.operator_isEqual (ptr->mLexicalStyleList).boolValue ()
         && mTerminalDeclarationList.operator_isEqual (ptr->mTerminalDeclarationList).boolValue ()
         && mLexicalMessageDeclarationList.operator_isEqual (ptr->mLexicalMessageDeclarationList).boolValue ()
         && mLexicalListDeclarationList.operator_isEqual (ptr->mLexicalListDeclarationList).boolValue ()
         && mLexicalRuleList.operator_isEqual (ptr->mLexicalRuleList).boolValue ()
         && mExternRoutineList.operator_isEqual (ptr->mExternRoutineList).boolValue ()
         && mExternFunctionList.operator_isEqual (ptr->mExternFunctionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexiqueComponentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexiqueComponentAST:"
           << mLexiqueComponentName.reader_description (inIndentation + 1)
           << mIsTemplate.reader_description (inIndentation + 1)
           << mTemplateDelimitorList.reader_description (inIndentation + 1)
           << mTemplateReplacementList.reader_description (inIndentation + 1)
           << mLexicalAttributeList.reader_description (inIndentation + 1)
           << mLexicalStyleList.reader_description (inIndentation + 1)
           << mTerminalDeclarationList.reader_description (inIndentation + 1)
           << mLexicalMessageDeclarationList.reader_description (inIndentation + 1)
           << mLexicalListDeclarationList.reader_description (inIndentation + 1)
           << mLexicalRuleList.reader_description (inIndentation + 1)
           << mExternRoutineList.reader_description (inIndentation + 1)
           << mExternFunctionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexiqueComponentAST (& typeid (cPtr_lexiqueComponentAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lexiqueComponentAST::galgasRTTI (void) const {
  return & gClassInfoFor__lexiqueComponentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexiqueComponentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexiqueComponentAST (mLexiqueComponentName, mIsTemplate, mTemplateDelimitorList, mTemplateReplacementList, mLexicalAttributeList, mLexicalStyleList, mTerminalDeclarationList, mLexicalMessageDeclarationList, mLexicalListDeclarationList, mLexicalRuleList, mExternRoutineList, mExternFunctionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexiqueComponentAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lexiqueComponentAST ("lexiqueComponentAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_lexiqueComponentAST::
GGS_lexiqueComponentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentAST::
GGS_lexiqueComponentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexiqueComponentAST GGS_lexiqueComponentAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexiqueComponentAST *> (inPointer) != NULL)
      : (typeid (cPtr_lexiqueComponentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexiqueComponentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexiqueComponentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentAST GGS_lexiqueComponentAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_metamodelTemplateDelimitorListAST & argument_2,
                 const GGS_templateReplacementListAST & argument_3,
                 const GGS_lexicalAttributeListAST & argument_4,
                 const GGS_lexicalStyleListAST & argument_5,
                 const GGS_terminalDeclarationListAST & argument_6,
                 const GGS_lexicalMessageDeclarationListAST & argument_7,
                 const GGS_lexicalListDeclarationListAST & argument_8,
                 const GGS_lexicalRuleListAST & argument_9,
                 const GGS_externRoutineListAST & argument_10,
                 const GGS_externFunctionListAST & argument_11
                                COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentAST result ;
  macroMyNew (result.mPointer, cPtr_lexiqueComponentAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexiqueComponentAST::
reader_mLexiqueComponentName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mLexiqueComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorListAST  GGS_lexiqueComponentAST::
reader_mTemplateDelimitorList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelTemplateDelimitorListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mTemplateDelimitorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementListAST  GGS_lexiqueComponentAST::
reader_mTemplateReplacementList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateReplacementListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mTemplateReplacementList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeListAST  GGS_lexiqueComponentAST::
reader_mLexicalAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalAttributeListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mLexicalAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleListAST  GGS_lexiqueComponentAST::
reader_mLexicalStyleList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalStyleListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mLexicalStyleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationListAST  GGS_lexiqueComponentAST::
reader_mTerminalDeclarationList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_terminalDeclarationListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mTerminalDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationListAST  GGS_lexiqueComponentAST::
reader_mLexicalMessageDeclarationList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalMessageDeclarationListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mLexicalMessageDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationListAST  GGS_lexiqueComponentAST::
reader_mLexicalListDeclarationList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mLexicalListDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleListAST  GGS_lexiqueComponentAST::
reader_mLexicalRuleList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalRuleListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mLexicalRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineListAST  GGS_lexiqueComponentAST::
reader_mExternRoutineList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externRoutineListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mExternRoutineList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionListAST  GGS_lexiqueComponentAST::
reader_mExternFunctionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externFunctionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentAST *) mPointer)->mExternFunctionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexiqueComponentAST::actualTypeName (void) const {
  return "lexiqueComponentAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_lexiqueComponentAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__lexiqueComponentAST ("lexiqueComponentAST", & kTypeDescriptor_GGS_lexiqueComponentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lexiqueComponentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lexiqueComponentAST * p = NULL ;
    macroMyNew (p, GGS_lexiqueComponentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentAST GGS_lexiqueComponentAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lexiqueComponentAST * p = dynamic_cast <const GGS_lexiqueComponentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lexiqueComponentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lexiqueComponentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lexiqueComponentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_lexiqueTypesForAST (void) {
  macroReleaseObject (gSingleton_lexicalLogInstructionAST) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_lexiqueTypesForAST (NULL, epilogueRoutineFor_lexiqueTypesForAST) ;

//---------------------------------------------------------------------------*

