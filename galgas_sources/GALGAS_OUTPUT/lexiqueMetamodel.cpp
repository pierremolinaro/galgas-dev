//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'lexiqueMetamodel.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      june 24th, 2007, at 15h56'10"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "lexiqueMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("lexiqueMetamodel", 37) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_lexiqueMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexiqueComponentRoot::
cPtr_lexiqueComponentRoot (const GGS_lstring & argument_0,
                                const GGS__list_lexicalAttribute & argument_1,
                                const GGS__list_lexicalStyle & argument_2,
                                const GGS__list_terminalDeclaration & argument_3,
                                const GGS__list_lexicalErrorMessageDeclaration & argument_4,
                                const GGS__list_lexicalListDeclaration & argument_5,
                                const GGS__list_lexicalImplicitRule & argument_6,
                                const GGS__list_lexicalExplicitRule & argument_7
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mLexiqueComponentName (argument_0),
mLexicalAttributeList (argument_1),
mLexicalStyleList (argument_2),
mTerminalDeclarationList (argument_3),
mLexicalErrorMessageDeclarationList (argument_4),
mLexicalListDeclarationList (argument_5),
mLexicalImplicitRuleList (argument_6),
mLexicalExplicitRuleList (argument_7) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexiqueComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexiqueComponentRoot * _p = dynamic_cast <const cPtr_lexiqueComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexiqueComponentName._operator_isEqual (_p->mLexiqueComponentName).boolValue ()
         && mLexicalAttributeList._operator_isEqual (_p->mLexicalAttributeList).boolValue ()
         && mLexicalStyleList._operator_isEqual (_p->mLexicalStyleList).boolValue ()
         && mTerminalDeclarationList._operator_isEqual (_p->mTerminalDeclarationList).boolValue ()
         && mLexicalErrorMessageDeclarationList._operator_isEqual (_p->mLexicalErrorMessageDeclarationList).boolValue ()
         && mLexicalListDeclarationList._operator_isEqual (_p->mLexicalListDeclarationList).boolValue ()
         && mLexicalImplicitRuleList._operator_isEqual (_p->mLexicalImplicitRuleList).boolValue ()
         && mLexicalExplicitRuleList._operator_isEqual (_p->mLexicalExplicitRuleList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexiqueComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexiqueComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexiqueComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalStyleList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalErrorMessageDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalListDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalImplicitRuleList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalExplicitRuleList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexiqueComponentRoot::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexiqueComponentRoot::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexiqueComponentRoot" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexiqueComponentRoot * cPtr_lexiqueComponentRoot::
_cloneObject (void) const {
  cPtr_lexiqueComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_lexiqueComponentRoot (mLexiqueComponentName, mLexicalAttributeList, mLexicalStyleList, mTerminalDeclarationList, mLexicalErrorMessageDeclarationList, mLexicalListDeclarationList, mLexicalImplicitRuleList, mLexicalExplicitRuleList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_lexiqueComponentRoot'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexiqueComponentRoot::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_lexicalAttribute & argument_1,
                    const GGS__list_lexicalStyle & argument_2,
                    const GGS__list_terminalDeclaration & argument_3,
                    const GGS__list_lexicalErrorMessageDeclaration & argument_4,
                    const GGS__list_lexicalListDeclaration & argument_5,
                    const GGS__list_lexicalImplicitRule & argument_6,
                    const GGS__list_lexicalExplicitRule & argument_7) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexiqueComponentRoot::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_lexicalAttribute & argument_1,
                    const GGS__list_lexicalStyle & argument_2,
                    const GGS__list_terminalDeclaration & argument_3,
                    const GGS__list_lexicalErrorMessageDeclaration & argument_4,
                    const GGS__list_lexicalListDeclaration & argument_5,
                    const GGS__list_lexicalImplicitRule & argument_6,
                    const GGS__list_lexicalExplicitRule & argument_7) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexiqueComponentRoot::
_addAssign_operation (const GGS_lexiqueComponentRoot & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexiqueComponentName,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalAttributeList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalStyleList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mTerminalDeclarationList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalErrorMessageDeclarationList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalListDeclarationList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalImplicitRuleList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalExplicitRuleList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexiqueComponentRoot GGS__list_lexiqueComponentRoot::
_operator_concat (const GGS__list_lexiqueComponentRoot & inOperand) const {
  GGS__list_lexiqueComponentRoot result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexiqueComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLexiqueComponentName ;
          GGS__list_lexicalAttribute  p_1 = p->mLexicalAttributeList ;
          GGS__list_lexicalStyle  p_2 = p->mLexicalStyleList ;
          GGS__list_terminalDeclaration  p_3 = p->mTerminalDeclarationList ;
          GGS__list_lexicalErrorMessageDeclaration  p_4 = p->mLexicalErrorMessageDeclarationList ;
          GGS__list_lexicalListDeclaration  p_5 = p->mLexicalListDeclarationList ;
          GGS__list_lexicalImplicitRule  p_6 = p->mLexicalImplicitRuleList ;
          GGS__list_lexicalExplicitRule  p_7 = p->mLexicalExplicitRuleList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexiqueComponentRoot::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_lexicalAttribute & argument_1,
                     const GGS__list_lexicalStyle & argument_2,
                     const GGS__list_terminalDeclaration & argument_3,
                     const GGS__list_lexicalErrorMessageDeclaration & argument_4,
                     const GGS__list_lexicalListDeclaration & argument_5,
                     const GGS__list_lexicalImplicitRule & argument_6,
                     const GGS__list_lexicalExplicitRule & argument_7
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexiqueComponentRoot::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexiqueComponentName,
                                _p->mLexicalAttributeList,
                                _p->mLexicalStyleList,
                                _p->mTerminalDeclarationList,
                                _p->mLexicalErrorMessageDeclarationList,
                                _p->mLexicalListDeclarationList,
                                _p->mLexicalImplicitRuleList,
                                _p->mLexicalExplicitRuleList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexiqueComponentRoot  GGS__list_lexiqueComponentRoot::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexiqueComponentRoot result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexiqueComponentRoot  GGS__list_lexiqueComponentRoot::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_lexicalAttribute & argument_1,
                           const GGS__list_lexicalStyle & argument_2,
                           const GGS__list_terminalDeclaration & argument_3,
                           const GGS__list_lexicalErrorMessageDeclaration & argument_4,
                           const GGS__list_lexicalListDeclaration & argument_5,
                           const GGS__list_lexicalImplicitRule & argument_6,
                           const GGS__list_lexicalExplicitRule & argument_7
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexiqueComponentRoot result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexiqueComponentRoot::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexiqueComponentRoot", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexiqueComponentRoot::
_addModel (const GGS_lexiqueComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexiqueComponentRoot::
method_first (C_Compiler & _inLexique,
              GGS_lexiqueComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexiqueComponentRoot::
method_last (C_Compiler & _inLexique,
             GGS_lexiqueComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexiqueComponentRoot::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexiqueComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexiqueComponentRoot::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexiqueComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexiqueComponentRoot'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot GGS_lexiqueComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_lexicalAttribute & argument_1,
                 const GGS__list_lexicalStyle & argument_2,
                 const GGS__list_terminalDeclaration & argument_3,
                 const GGS__list_lexicalErrorMessageDeclaration & argument_4,
                 const GGS__list_lexicalListDeclaration & argument_5,
                 const GGS__list_lexicalImplicitRule & argument_6,
                 const GGS__list_lexicalExplicitRule & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_lexiqueComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexiqueComponentRoot::
reader_mLexiqueComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexiqueComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttribute  GGS_lexiqueComponentRoot::
reader_mLexicalAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalAttribute   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStyle  GGS_lexiqueComponentRoot::
reader_mLexicalStyleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalStyle   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalStyleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_terminalDeclaration  GGS_lexiqueComponentRoot::
reader_mTerminalDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_terminalDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTerminalDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorMessageDeclaration  GGS_lexiqueComponentRoot::
reader_mLexicalErrorMessageDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalErrorMessageDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalErrorMessageDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListDeclaration  GGS_lexiqueComponentRoot::
reader_mLexicalListDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalListDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalListDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalImplicitRule  GGS_lexiqueComponentRoot::
reader_mLexicalImplicitRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalImplicitRule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalImplicitRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExplicitRule  GGS_lexiqueComponentRoot::
reader_mLexicalExplicitRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalExplicitRule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalExplicitRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexiqueComponentRoot::actualTypeName (void) const {
 return "lexiqueComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexiqueComponentRoot * GGS_lexiqueComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexiqueComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalImplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalImplicitRule::
cPtr_lexicalImplicitRule (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mListName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalImplicitRule::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalImplicitRule * _p = dynamic_cast <const cPtr_lexicalImplicitRule *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListName._operator_isEqual (_p->mListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalImplicitRule::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalImplicitRule" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mListName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalImplicitRule::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRule::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalImplicitRule::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRule::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalImplicitRule" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalImplicitRule * cPtr_lexicalImplicitRule::
_cloneObject (void) const {
  cPtr_lexicalImplicitRule * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalImplicitRule (mListName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_lexicalImplicitRule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalImplicitRule::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalImplicitRule::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalImplicitRule::
_addAssign_operation (const GGS_lexicalImplicitRule & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalImplicitRule *) inElement.getPtr ())->mListName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalImplicitRule GGS__list_lexicalImplicitRule::
_operator_concat (const GGS__list_lexicalImplicitRule & inOperand) const {
  GGS__list_lexicalImplicitRule result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalImplicitRule * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mListName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalImplicitRule::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalImplicitRule::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mListName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalImplicitRule  GGS__list_lexicalImplicitRule::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalImplicitRule result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalImplicitRule  GGS__list_lexicalImplicitRule::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalImplicitRule result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalImplicitRule::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalImplicitRule", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalImplicitRule::
_addModel (const GGS_lexicalImplicitRule & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalImplicitRule::
method_first (C_Compiler & _inLexique,
              GGS_lexicalImplicitRule & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalImplicitRule::
method_last (C_Compiler & _inLexique,
             GGS_lexicalImplicitRule & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalImplicitRule::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalImplicitRule & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalImplicitRule::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalImplicitRule & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalImplicitRule'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalImplicitRule GGS_lexicalImplicitRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRule result ;
  macroMyNew (result.mPointer, cPtr_lexicalImplicitRule (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalImplicitRule::
reader_mListName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalImplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalImplicitRule *) mPointer)->mListName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalImplicitRule::actualTypeName (void) const {
 return "lexicalImplicitRule" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalImplicitRule * GGS_lexicalImplicitRule::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalImplicitRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@lexicalErrorMessageDeclaration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorMessageDeclaration::
cPtr_lexicalErrorMessageDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorMessageDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalErrorMessageDeclaration * _p = dynamic_cast <const cPtr_lexicalErrorMessageDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorMessageDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalErrorMessageDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalErrorMessageDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorMessageDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalErrorMessageDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorMessageDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalErrorMessageDeclaration" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalErrorMessageDeclaration * cPtr_lexicalErrorMessageDeclaration::
_cloneObject (void) const {
  cPtr_lexicalErrorMessageDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalErrorMessageDeclaration (mMessageName, mMessageValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@_list_lexicalErrorMessageDeclaration'                *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorMessageDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorMessageDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorMessageDeclaration::
_addAssign_operation (const GGS_lexicalErrorMessageDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalErrorMessageDeclaration *) inElement.getPtr ())->mMessageName,
                                ((cPtr_lexicalErrorMessageDeclaration *) inElement.getPtr ())->mMessageValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorMessageDeclaration GGS__list_lexicalErrorMessageDeclaration::
_operator_concat (const GGS__list_lexicalErrorMessageDeclaration & inOperand) const {
  GGS__list_lexicalErrorMessageDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalErrorMessageDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorMessageDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorMessageDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorMessageDeclaration  GGS__list_lexicalErrorMessageDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalErrorMessageDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorMessageDeclaration  GGS__list_lexicalErrorMessageDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalErrorMessageDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalErrorMessageDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalErrorMessageDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorMessageDeclaration::
_addModel (const GGS_lexicalErrorMessageDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorMessageDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_lexicalErrorMessageDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorMessageDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_lexicalErrorMessageDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorMessageDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalErrorMessageDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorMessageDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalErrorMessageDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS entity '@lexicalErrorMessageDeclaration'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclaration GGS_lexicalErrorMessageDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorMessageDeclaration result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorMessageDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorMessageDeclaration::
reader_mMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorMessageDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorMessageDeclaration *) mPointer)->mMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorMessageDeclaration::
reader_mMessageValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorMessageDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorMessageDeclaration *) mPointer)->mMessageValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorMessageDeclaration::actualTypeName (void) const {
 return "lexicalErrorMessageDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorMessageDeclaration * GGS_lexicalErrorMessageDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalErrorMessageDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalAttribute'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttribute::
cPtr_lexicalAttribute (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mTypeName (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttribute::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalAttribute * _p = dynamic_cast <const cPtr_lexicalAttribute *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttribute::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalAttribute" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalAttribute::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttribute::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalAttribute::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttribute::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalAttribute" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalAttribute * cPtr_lexicalAttribute::
_cloneObject (void) const {
  cPtr_lexicalAttribute * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalAttribute (mTypeName, mName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_lexicalAttribute'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalAttribute::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttribute::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttribute::
_addAssign_operation (const GGS_lexicalAttribute & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalAttribute *) inElement.getPtr ())->mTypeName,
                                ((cPtr_lexicalAttribute *) inElement.getPtr ())->mName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttribute GGS__list_lexicalAttribute::
_operator_concat (const GGS__list_lexicalAttribute & inOperand) const {
  GGS__list_lexicalAttribute result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalAttribute * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttribute::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttribute::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttribute  GGS__list_lexicalAttribute::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalAttribute result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttribute  GGS__list_lexicalAttribute::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalAttribute result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalAttribute::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalAttribute", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttribute::
_addModel (const GGS_lexicalAttribute & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttribute::
method_first (C_Compiler & _inLexique,
              GGS_lexicalAttribute & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttribute::
method_last (C_Compiler & _inLexique,
             GGS_lexicalAttribute & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttribute::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalAttribute & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttribute::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalAttribute & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@lexicalAttribute'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalAttribute GGS_lexicalAttribute::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttribute result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttribute (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttribute::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttribute *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttribute::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttribute *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttribute::actualTypeName (void) const {
 return "lexicalAttribute" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttribute * GGS_lexicalAttribute::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalAttribute *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@lexicalStyle'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStyle::
cPtr_lexicalStyle (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mName (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStyle::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStyle * _p = dynamic_cast <const cPtr_lexicalStyle *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mComment._operator_isEqual (_p->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStyle::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStyle" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStyle::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStyle::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStyle::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStyle::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalStyle" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStyle * cPtr_lexicalStyle::
_cloneObject (void) const {
  cPtr_lexicalStyle * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStyle (mName, mComment COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@_list_lexicalStyle'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalStyle::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStyle::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStyle::
_addAssign_operation (const GGS_lexicalStyle & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStyle *) inElement.getPtr ())->mName,
                                ((cPtr_lexicalStyle *) inElement.getPtr ())->mComment) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStyle GGS__list_lexicalStyle::
_operator_concat (const GGS__list_lexicalStyle & inOperand) const {
  GGS__list_lexicalStyle result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStyle * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mComment ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStyle::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStyle::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mComment) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStyle  GGS__list_lexicalStyle::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStyle result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStyle  GGS__list_lexicalStyle::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStyle result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalStyle::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalStyle", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStyle::
_addModel (const GGS_lexicalStyle & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStyle::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStyle & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStyle::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStyle & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStyle::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStyle & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStyle::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStyle & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@lexicalStyle'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStyle GGS_lexicalStyle::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStyle result ;
  macroMyNew (result.mPointer, cPtr_lexicalStyle (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyle::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStyle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStyle *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyle::
reader_mComment (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStyle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStyle *) mPointer)->mComment ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStyle::actualTypeName (void) const {
 return "lexicalStyle" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStyle * GGS_lexicalStyle::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStyle *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@terminalDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_terminalDeclaration::
cPtr_terminalDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mName (argument_0),
mSentAttributeList (argument_1),
mErrorMessage (argument_2),
mStyle (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_terminalDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_terminalDeclaration * _p = dynamic_cast <const cPtr_terminalDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mSentAttributeList._operator_isEqual (_p->mSentAttributeList).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mStyle._operator_isEqual (_p->mStyle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_terminalDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @terminalDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_terminalDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_terminalDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "terminalDeclaration" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_terminalDeclaration * cPtr_terminalDeclaration::
_cloneObject (void) const {
  cPtr_terminalDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_terminalDeclaration (mName, mSentAttributeList, mErrorMessage, mStyle COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_terminalDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_terminalDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalDeclaration::
_addAssign_operation (const GGS_terminalDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_terminalDeclaration *) inElement.getPtr ())->mName,
                                ((cPtr_terminalDeclaration *) inElement.getPtr ())->mSentAttributeList,
                                ((cPtr_terminalDeclaration *) inElement.getPtr ())->mErrorMessage,
                                ((cPtr_terminalDeclaration *) inElement.getPtr ())->mStyle) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_terminalDeclaration GGS__list_terminalDeclaration::
_operator_concat (const GGS__list_terminalDeclaration & inOperand) const {
  GGS__list_terminalDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_terminalDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstringlist  p_1 = p->mSentAttributeList ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mStyle ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_terminalDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mSentAttributeList,
                                _p->mErrorMessage,
                                _p->mStyle) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_terminalDeclaration  GGS__list_terminalDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_terminalDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_terminalDeclaration  GGS__list_terminalDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_terminalDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_terminalDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_terminalDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalDeclaration::
_addModel (const GGS_terminalDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_terminalDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_terminalDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_terminalDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_terminalDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_terminalDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_terminalDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_terminalDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_terminalDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@terminalDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_terminalDeclaration GGS_terminalDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_terminalDeclaration result ;
  macroMyNew (result.mPointer, cPtr_terminalDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclaration::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclaration::
reader_mSentAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mSentAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclaration::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclaration::
reader_mStyle (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mStyle ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_terminalDeclaration::actualTypeName (void) const {
 return "terminalDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_terminalDeclaration * GGS_terminalDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_terminalDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalListDeclaration::
cPtr_lexicalListDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS__list_lexicalListEntry & argument_4
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mName (argument_0),
mStyle (argument_1),
mErrorMessage (argument_2),
mSentAttributeList (argument_3),
mEntryList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalListDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalListDeclaration * _p = dynamic_cast <const cPtr_lexicalListDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mStyle._operator_isEqual (_p->mStyle).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mSentAttributeList._operator_isEqual (_p->mSentAttributeList).boolValue ()
         && mEntryList._operator_isEqual (_p->mEntryList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalListDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalListDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntryList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalListDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalListDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalListDeclaration" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalListDeclaration * cPtr_lexicalListDeclaration::
_cloneObject (void) const {
  cPtr_lexicalListDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalListDeclaration (mName, mStyle, mErrorMessage, mSentAttributeList, mEntryList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalListDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalListDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS__list_lexicalListEntry & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS__list_lexicalListEntry & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListDeclaration::
_addAssign_operation (const GGS_lexicalListDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mName,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mStyle,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mErrorMessage,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mSentAttributeList,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mEntryList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListDeclaration GGS__list_lexicalListDeclaration::
_operator_concat (const GGS__list_lexicalListDeclaration & inOperand) const {
  GGS__list_lexicalListDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalListDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mStyle ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstringlist  p_3 = p->mSentAttributeList ;
          GGS__list_lexicalListEntry  p_4 = p->mEntryList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS__list_lexicalListEntry & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mStyle,
                                _p->mErrorMessage,
                                _p->mSentAttributeList,
                                _p->mEntryList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListDeclaration  GGS__list_lexicalListDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalListDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListDeclaration  GGS__list_lexicalListDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstringlist & argument_3,
                           const GGS__list_lexicalListEntry & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalListDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalListDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalListDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListDeclaration::
_addModel (const GGS_lexicalListDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_lexicalListDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_lexicalListDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalListDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalListDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@lexicalListDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalListDeclaration GGS_lexicalListDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS__list_lexicalListEntry & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalListDeclaration result ;
  macroMyNew (result.mPointer, cPtr_lexicalListDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclaration::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclaration::
reader_mStyle (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mStyle ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclaration::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListDeclaration::
reader_mSentAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mSentAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListEntry  GGS_lexicalListDeclaration::
reader_mEntryList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalListEntry   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mEntryList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalListDeclaration::actualTypeName (void) const {
 return "lexicalListDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalListDeclaration * GGS_lexicalListDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalListDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalListEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalListEntry::
cPtr_lexicalListEntry (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mEntrySpelling (argument_0),
mTerminalSpelling (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalListEntry::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalListEntry * _p = dynamic_cast <const cPtr_lexicalListEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntrySpelling._operator_isEqual (_p->mEntrySpelling).boolValue ()
         && mTerminalSpelling._operator_isEqual (_p->mTerminalSpelling).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalListEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalListEntry" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntrySpelling.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalSpelling.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalListEntry::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListEntry::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalListEntry::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListEntry::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalListEntry" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalListEntry * cPtr_lexicalListEntry::
_cloneObject (void) const {
  cPtr_lexicalListEntry * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalListEntry (mEntrySpelling, mTerminalSpelling COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_lexicalListEntry'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalListEntry::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListEntry::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListEntry::
_addAssign_operation (const GGS_lexicalListEntry & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalListEntry *) inElement.getPtr ())->mEntrySpelling,
                                ((cPtr_lexicalListEntry *) inElement.getPtr ())->mTerminalSpelling) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListEntry GGS__list_lexicalListEntry::
_operator_concat (const GGS__list_lexicalListEntry & inOperand) const {
  GGS__list_lexicalListEntry result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalListEntry * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEntrySpelling ;
          GGS_lstring  p_1 = p->mTerminalSpelling ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListEntry::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListEntry::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntrySpelling,
                                _p->mTerminalSpelling) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListEntry  GGS__list_lexicalListEntry::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalListEntry result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalListEntry  GGS__list_lexicalListEntry::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalListEntry result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalListEntry::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalListEntry", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalListEntry::
_addModel (const GGS_lexicalListEntry & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListEntry::
method_first (C_Compiler & _inLexique,
              GGS_lexicalListEntry & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListEntry::
method_last (C_Compiler & _inLexique,
             GGS_lexicalListEntry & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListEntry::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalListEntry & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalListEntry::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalListEntry & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@lexicalListEntry'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalListEntry GGS_lexicalListEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalListEntry result ;
  macroMyNew (result.mPointer, cPtr_lexicalListEntry (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntry::
reader_mEntrySpelling (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListEntry *) mPointer)->mEntrySpelling ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntry::
reader_mTerminalSpelling (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListEntry *) mPointer)->mTerminalSpelling ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalListEntry::actualTypeName (void) const {
 return "lexicalListEntry" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalListEntry * GGS_lexicalListEntry::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalListEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalExplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExplicitRule::
cPtr_lexicalExplicitRule (const GGS_lexicalExpression & argument_0,
                                const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mLexicalRuleExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalExplicitRule::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalExplicitRule * _p = dynamic_cast <const cPtr_lexicalExplicitRule *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalRuleExpression._operator_isEqual (_p->mLexicalRuleExpression).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalExplicitRule::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalExplicitRule" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRuleExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalExplicitRule::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRule::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalExplicitRule::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRule::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalExplicitRule" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalExplicitRule * cPtr_lexicalExplicitRule::
_cloneObject (void) const {
  cPtr_lexicalExplicitRule * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalExplicitRule (mLexicalRuleExpression, mInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_lexicalExplicitRule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalExplicitRule::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExplicitRule::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExplicitRule::
_addAssign_operation (const GGS_lexicalExplicitRule & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalExplicitRule *) inElement.getPtr ())->mLexicalRuleExpression,
                                ((cPtr_lexicalExplicitRule *) inElement.getPtr ())->mInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExplicitRule GGS__list_lexicalExplicitRule::
_operator_concat (const GGS__list_lexicalExplicitRule & inOperand) const {
  GGS__list_lexicalExplicitRule result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalExplicitRule * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mLexicalRuleExpression ;
          GGS__list_lexicalInstruction  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExplicitRule::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS__list_lexicalInstruction & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExplicitRule::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalRuleExpression,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExplicitRule  GGS__list_lexicalExplicitRule::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalExplicitRule result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExplicitRule  GGS__list_lexicalExplicitRule::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS__list_lexicalInstruction & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalExplicitRule result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalExplicitRule::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalExplicitRule", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExplicitRule::
_addModel (const GGS_lexicalExplicitRule & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExplicitRule::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExplicitRule & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExplicitRule::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExplicitRule & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExplicitRule::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalExplicitRule & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExplicitRule::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalExplicitRule & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalExplicitRule'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalExplicitRule GGS_lexicalExplicitRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRule result ;
  macroMyNew (result.mPointer, cPtr_lexicalExplicitRule (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalExplicitRule::
reader_mLexicalRuleExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRule *) mPointer)->mLexicalRuleExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS_lexicalExplicitRule::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRule *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExplicitRule::actualTypeName (void) const {
 return "lexicalExplicitRule" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExplicitRule * GGS_lexicalExplicitRule::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalExplicitRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExpression::
cPtr_lexicalExpression (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalExpression" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalExpression * cPtr_lexicalExpression::
_cloneObject (void) const {
  cPtr_lexicalExpression * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_lexicalExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalExpression::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExpression::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExpression::
_addAssign_operation (const GGS_lexicalExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExpression GGS__list_lexicalExpression::
_operator_concat (const GGS__list_lexicalExpression & inOperand) const {
  GGS__list_lexicalExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExpression::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExpression::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExpression  GGS__list_lexicalExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalExpression  GGS__list_lexicalExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalExpression result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalExpression::
_addModel (const GGS_lexicalExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExpression::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExpression::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@lexicalExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalExpression::actualTypeName (void) const {
 return "lexicalExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExpression * GGS_lexicalExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalOrExpression::
cPtr_lexicalOrExpression (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalOrExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalOrExpression * _p = dynamic_cast <const cPtr_lexicalOrExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLeftOperand._operator_isEqual (_p->mLeftOperand).boolValue ()
         && mRightOperand._operator_isEqual (_p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalOrExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalOrExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalOrExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalOrExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalOrExpression" ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalOrExpression * cPtr_lexicalOrExpression::
_cloneObject (void) const {
  cPtr_lexicalOrExpression * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalOrExpression (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_lexicalOrExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalOrExpression::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalOrExpression::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalOrExpression::
_addAssign_operation (const GGS_lexicalOrExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalOrExpression *) inElement.getPtr ())->mLeftOperand,
                                ((cPtr_lexicalOrExpression *) inElement.getPtr ())->mRightOperand) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalOrExpression GGS__list_lexicalOrExpression::
_operator_concat (const GGS__list_lexicalOrExpression & inOperand) const {
  GGS__list_lexicalOrExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalOrExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mLeftOperand ;
          GGS_lexicalExpression  p_1 = p->mRightOperand ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalOrExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalOrExpression::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLeftOperand,
                                _p->mRightOperand) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalOrExpression  GGS__list_lexicalOrExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalOrExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalOrExpression  GGS__list_lexicalOrExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS_lexicalExpression & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalOrExpression result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalOrExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalOrExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalOrExpression::
_addModel (const GGS_lexicalOrExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalOrExpression::
method_first (C_Compiler & _inLexique,
              GGS_lexicalOrExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalOrExpression::
method_last (C_Compiler & _inLexique,
             GGS_lexicalOrExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalOrExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalOrExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalOrExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalOrExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalOrExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalOrExpression GGS_lexicalOrExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpression result ;
  macroMyNew (result.mPointer, cPtr_lexicalOrExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalOrExpression::actualTypeName (void) const {
 return "lexicalOrExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalOrExpression * GGS_lexicalOrExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalOrExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatch::
cPtr_lexicalCharacterMatch (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalCharacterMatch * _p = dynamic_cast <const cPtr_lexicalCharacterMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCharacterMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCharacterMatch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCharacterMatch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalCharacterMatch" ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatch * cPtr_lexicalCharacterMatch::
_cloneObject (void) const {
  cPtr_lexicalCharacterMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCharacterMatch (mCharacter COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalCharacterMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterMatch::
_internalAppendValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterMatch::
_internalPrependValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterMatch::
_addAssign_operation (const GGS_lexicalCharacterMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalCharacterMatch *) inElement.getPtr ())->mCharacter) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterMatch GGS__list_lexicalCharacterMatch::
_operator_concat (const GGS__list_lexicalCharacterMatch & inOperand) const {
  GGS__list_lexicalCharacterMatch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCharacterMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mCharacter ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterMatch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterMatch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCharacter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterMatch  GGS__list_lexicalCharacterMatch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCharacterMatch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterMatch  GGS__list_lexicalCharacterMatch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCharacterMatch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalCharacterMatch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalCharacterMatch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterMatch::
_addModel (const GGS_lexicalCharacterMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterMatch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCharacterMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterMatch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCharacterMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterMatch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCharacterMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterMatch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCharacterMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexicalCharacterMatch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch GGS_lexicalCharacterMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterMatch::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterMatch *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterMatch::actualTypeName (void) const {
 return "lexicalCharacterMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterMatch * GGS_lexicalCharacterMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCharacterMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatch::
cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mLowerBound (argument_0),
mUpperBound (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterIntervalMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalCharacterIntervalMatch * _p = dynamic_cast <const cPtr_lexicalCharacterIntervalMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLowerBound._operator_isEqual (_p->mLowerBound).boolValue ()
         && mUpperBound._operator_isEqual (_p->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterIntervalMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCharacterIntervalMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowerBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUpperBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCharacterIntervalMatch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCharacterIntervalMatch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 12 ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalCharacterIntervalMatch" ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatch * cPtr_lexicalCharacterIntervalMatch::
_cloneObject (void) const {
  cPtr_lexicalCharacterIntervalMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCharacterIntervalMatch (mLowerBound, mUpperBound COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@_list_lexicalCharacterIntervalMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterIntervalMatch::
_internalAppendValues (const GGS_lchar & argument_0,
                    const GGS_lchar & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterIntervalMatch::
_internalPrependValues (const GGS_lchar & argument_0,
                    const GGS_lchar & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterIntervalMatch::
_addAssign_operation (const GGS_lexicalCharacterIntervalMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalCharacterIntervalMatch *) inElement.getPtr ())->mLowerBound,
                                ((cPtr_lexicalCharacterIntervalMatch *) inElement.getPtr ())->mUpperBound) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterIntervalMatch GGS__list_lexicalCharacterIntervalMatch::
_operator_concat (const GGS__list_lexicalCharacterIntervalMatch & inOperand) const {
  GGS__list_lexicalCharacterIntervalMatch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCharacterIntervalMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mLowerBound ;
          GGS_lchar  p_1 = p->mUpperBound ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterIntervalMatch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0,
                     const GGS_lchar & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterIntervalMatch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLowerBound,
                                _p->mUpperBound) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterIntervalMatch  GGS__list_lexicalCharacterIntervalMatch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCharacterIntervalMatch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterIntervalMatch  GGS__list_lexicalCharacterIntervalMatch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0,
                           const GGS_lchar & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCharacterIntervalMatch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalCharacterIntervalMatch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalCharacterIntervalMatch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterIntervalMatch::
_addModel (const GGS_lexicalCharacterIntervalMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterIntervalMatch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCharacterIntervalMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterIntervalMatch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCharacterIntervalMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterIntervalMatch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCharacterIntervalMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterIntervalMatch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCharacterIntervalMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS entity '@lexicalCharacterIntervalMatch'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch GGS_lexicalCharacterIntervalMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterIntervalMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mLowerBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mUpperBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterIntervalMatch::actualTypeName (void) const {
 return "lexicalCharacterIntervalMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterIntervalMatch * GGS_lexicalCharacterIntervalMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringMatch::
cPtr_lexicalStringMatch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mString (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStringMatch * _p = dynamic_cast <const cPtr_lexicalStringMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mString._operator_isEqual (_p->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStringMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStringMatch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStringMatch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 13 ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalStringMatch" ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStringMatch * cPtr_lexicalStringMatch::
_cloneObject (void) const {
  cPtr_lexicalStringMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStringMatch (mString COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_lexicalStringMatch'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalStringMatch::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringMatch::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringMatch::
_addAssign_operation (const GGS_lexicalStringMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStringMatch *) inElement.getPtr ())->mString) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStringMatch GGS__list_lexicalStringMatch::
_operator_concat (const GGS__list_lexicalStringMatch & inOperand) const {
  GGS__list_lexicalStringMatch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStringMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mString ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringMatch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringMatch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mString) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStringMatch  GGS__list_lexicalStringMatch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStringMatch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStringMatch  GGS__list_lexicalStringMatch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStringMatch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalStringMatch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalStringMatch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringMatch::
_addModel (const GGS_lexicalStringMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringMatch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStringMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringMatch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStringMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringMatch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStringMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringMatch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStringMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalStringMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStringMatch GGS_lexicalStringMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringMatch::actualTypeName (void) const {
 return "lexicalStringMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringMatch * GGS_lexicalStringMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStringMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatch::
cPtr_lexicalStringNotMatch (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mString (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringNotMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStringNotMatch * _p = dynamic_cast <const cPtr_lexicalStringNotMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mString._operator_isEqual (_p->mString).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringNotMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStringNotMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStringNotMatch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStringNotMatch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 14 ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalStringNotMatch" ;
  if (inLevel > 0) {
    result = cPtr_lexicalExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatch * cPtr_lexicalStringNotMatch::
_cloneObject (void) const {
  cPtr_lexicalStringNotMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStringNotMatch (mString, mErrorMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalStringNotMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalStringNotMatch::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringNotMatch::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringNotMatch::
_addAssign_operation (const GGS_lexicalStringNotMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStringNotMatch *) inElement.getPtr ())->mString,
                                ((cPtr_lexicalStringNotMatch *) inElement.getPtr ())->mErrorMessage) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStringNotMatch GGS__list_lexicalStringNotMatch::
_operator_concat (const GGS__list_lexicalStringNotMatch & inOperand) const {
  GGS__list_lexicalStringNotMatch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStringNotMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mString ;
          GGS_lstring  p_1 = p->mErrorMessage ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringNotMatch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringNotMatch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mString,
                                _p->mErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStringNotMatch  GGS__list_lexicalStringNotMatch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStringNotMatch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStringNotMatch  GGS__list_lexicalStringNotMatch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStringNotMatch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalStringNotMatch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalStringNotMatch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStringNotMatch::
_addModel (const GGS_lexicalStringNotMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringNotMatch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStringNotMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringNotMatch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStringNotMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringNotMatch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStringNotMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStringNotMatch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStringNotMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexicalStringNotMatch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch GGS_lexicalStringNotMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringNotMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringNotMatch::actualTypeName (void) const {
 return "lexicalStringNotMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringNotMatch * GGS_lexicalStringNotMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStringNotMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalInstruction::
cPtr_lexicalInstruction (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalInstruction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 15 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalInstruction" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalInstruction * cPtr_lexicalInstruction::
_cloneObject (void) const {
  cPtr_lexicalInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalInstruction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_lexicalInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalInstruction::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalInstruction::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalInstruction::
_addAssign_operation (const GGS_lexicalInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction GGS__list_lexicalInstruction::
_operator_concat (const GGS__list_lexicalInstruction & inOperand) const {
  GGS__list_lexicalInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalInstruction::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS__list_lexicalInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS__list_lexicalInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalInstruction result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalInstruction::
_addModel (const GGS_lexicalInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalInstruction::actualTypeName (void) const {
 return "lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalInstruction * GGS_lexicalInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstruction::
cPtr_lexicalStructuredSendInstruction (const GGS__list_lexicalSendSearch & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mLexicalSendSearchList (argument_0),
mLexicalSendDefaultAction (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStructuredSendInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStructuredSendInstruction * _p = dynamic_cast <const cPtr_lexicalStructuredSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalSendSearchList._operator_isEqual (_p->mLexicalSendSearchList).boolValue ()
         && mLexicalSendDefaultAction._operator_isEqual (_p->mLexicalSendDefaultAction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStructuredSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStructuredSendInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalSendSearchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalSendDefaultAction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStructuredSendInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalStructuredSendInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 16 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalStructuredSendInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstruction * cPtr_lexicalStructuredSendInstruction::
_cloneObject (void) const {
  cPtr_lexicalStructuredSendInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStructuredSendInstruction (mLexicalSendSearchList, mLexicalSendDefaultAction COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@_list_lexicalStructuredSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalStructuredSendInstruction::
_internalAppendValues (const GGS__list_lexicalSendSearch & argument_0,
                    const GGS_lexicalSendDefaultAction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStructuredSendInstruction::
_internalPrependValues (const GGS__list_lexicalSendSearch & argument_0,
                    const GGS_lexicalSendDefaultAction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStructuredSendInstruction::
_addAssign_operation (const GGS_lexicalStructuredSendInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStructuredSendInstruction *) inElement.getPtr ())->mLexicalSendSearchList,
                                ((cPtr_lexicalStructuredSendInstruction *) inElement.getPtr ())->mLexicalSendDefaultAction) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStructuredSendInstruction GGS__list_lexicalStructuredSendInstruction::
_operator_concat (const GGS__list_lexicalStructuredSendInstruction & inOperand) const {
  GGS__list_lexicalStructuredSendInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStructuredSendInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS__list_lexicalSendSearch  p_0 = p->mLexicalSendSearchList ;
          GGS_lexicalSendDefaultAction  p_1 = p->mLexicalSendDefaultAction ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStructuredSendInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS__list_lexicalSendSearch & argument_0,
                     const GGS_lexicalSendDefaultAction & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStructuredSendInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalSendSearchList,
                                _p->mLexicalSendDefaultAction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStructuredSendInstruction  GGS__list_lexicalStructuredSendInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStructuredSendInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalStructuredSendInstruction  GGS__list_lexicalStructuredSendInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS__list_lexicalSendSearch & argument_0,
                           const GGS_lexicalSendDefaultAction & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalStructuredSendInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalStructuredSendInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalStructuredSendInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalStructuredSendInstruction::
_addModel (const GGS_lexicalStructuredSendInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStructuredSendInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStructuredSendInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStructuredSendInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStructuredSendInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStructuredSendInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStructuredSendInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalStructuredSendInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStructuredSendInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS entity '@lexicalStructuredSendInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction GGS_lexicalStructuredSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_lexicalSendSearch & argument_0,
                 const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalStructuredSendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendSearch  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendSearchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalSendSearch   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendSearchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendDefaultAction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendDefaultAction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendDefaultAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStructuredSendInstruction::actualTypeName (void) const {
 return "lexicalStructuredSendInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStructuredSendInstruction * GGS_lexicalStructuredSendInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstruction::
cPtr_lexicalSimpleSendInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSimpleSendInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSimpleSendInstruction * _p = dynamic_cast <const cPtr_lexicalSimpleSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSentTerminal._operator_isEqual (_p->mSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSimpleSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSimpleSendInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSimpleSendInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSimpleSendInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 17 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalSimpleSendInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstruction * cPtr_lexicalSimpleSendInstruction::
_cloneObject (void) const {
  cPtr_lexicalSimpleSendInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSimpleSendInstruction (mSentTerminal COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@_list_lexicalSimpleSendInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalSimpleSendInstruction::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSimpleSendInstruction::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSimpleSendInstruction::
_addAssign_operation (const GGS_lexicalSimpleSendInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSimpleSendInstruction *) inElement.getPtr ())->mSentTerminal) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSimpleSendInstruction GGS__list_lexicalSimpleSendInstruction::
_operator_concat (const GGS__list_lexicalSimpleSendInstruction & inOperand) const {
  GGS__list_lexicalSimpleSendInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSimpleSendInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSentTerminal ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSimpleSendInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSimpleSendInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSentTerminal) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSimpleSendInstruction  GGS__list_lexicalSimpleSendInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSimpleSendInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSimpleSendInstruction  GGS__list_lexicalSimpleSendInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSimpleSendInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalSimpleSendInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalSimpleSendInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSimpleSendInstruction::
_addModel (const GGS_lexicalSimpleSendInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSimpleSendInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSimpleSendInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSimpleSendInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSimpleSendInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSimpleSendInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSimpleSendInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSimpleSendInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSimpleSendInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS entity '@lexicalSimpleSendInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction GGS_lexicalSimpleSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSimpleSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSimpleSendInstruction::
reader_mSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSimpleSendInstruction *) mPointer)->mSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSimpleSendInstruction::actualTypeName (void) const {
 return "lexicalSimpleSendInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSimpleSendInstruction * GGS_lexicalSimpleSendInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultAction::
cPtr_lexicalSendDefaultAction (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendDefaultAction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendDefaultAction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSendDefaultAction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSendDefaultAction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 18 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalSendDefaultAction" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultAction * cPtr_lexicalSendDefaultAction::
_cloneObject (void) const {
  cPtr_lexicalSendDefaultAction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSendDefaultAction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalSendDefaultAction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalSendDefaultAction::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendDefaultAction::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendDefaultAction::
_addAssign_operation (const GGS_lexicalSendDefaultAction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendDefaultAction GGS__list_lexicalSendDefaultAction::
_operator_concat (const GGS__list_lexicalSendDefaultAction & inOperand) const {
  GGS__list_lexicalSendDefaultAction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSendDefaultAction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendDefaultAction::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendDefaultAction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendDefaultAction  GGS__list_lexicalSendDefaultAction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSendDefaultAction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendDefaultAction  GGS__list_lexicalSendDefaultAction::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSendDefaultAction result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalSendDefaultAction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalSendDefaultAction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendDefaultAction::
_addModel (const GGS_lexicalSendDefaultAction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendDefaultAction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSendDefaultAction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendDefaultAction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSendDefaultAction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendDefaultAction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSendDefaultAction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendDefaultAction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSendDefaultAction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalSendDefaultAction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalSendDefaultAction::actualTypeName (void) const {
 return "lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendDefaultAction * GGS_lexicalSendDefaultAction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSendDefaultAction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefault::
cPtr_lexicalSendTerminalByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalSendDefaultAction (THERE),
mDefaultSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendTerminalByDefault::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSendTerminalByDefault * _p = dynamic_cast <const cPtr_lexicalSendTerminalByDefault *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDefaultSentTerminal._operator_isEqual (_p->mDefaultSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendTerminalByDefault::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSendTerminalByDefault" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefaultSentTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSendTerminalByDefault::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSendTerminalByDefault::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 19 ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalSendTerminalByDefault" ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefault * cPtr_lexicalSendTerminalByDefault::
_cloneObject (void) const {
  cPtr_lexicalSendTerminalByDefault * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSendTerminalByDefault (mDefaultSentTerminal COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@_list_lexicalSendTerminalByDefault'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalSendTerminalByDefault::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendTerminalByDefault::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendTerminalByDefault::
_addAssign_operation (const GGS_lexicalSendTerminalByDefault & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSendTerminalByDefault *) inElement.getPtr ())->mDefaultSentTerminal) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendTerminalByDefault GGS__list_lexicalSendTerminalByDefault::
_operator_concat (const GGS__list_lexicalSendTerminalByDefault & inOperand) const {
  GGS__list_lexicalSendTerminalByDefault result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSendTerminalByDefault * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mDefaultSentTerminal ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendTerminalByDefault::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendTerminalByDefault::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mDefaultSentTerminal) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendTerminalByDefault  GGS__list_lexicalSendTerminalByDefault::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSendTerminalByDefault result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendTerminalByDefault  GGS__list_lexicalSendTerminalByDefault::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSendTerminalByDefault result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalSendTerminalByDefault::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalSendTerminalByDefault", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendTerminalByDefault::
_addModel (const GGS_lexicalSendTerminalByDefault & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendTerminalByDefault::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSendTerminalByDefault & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendTerminalByDefault::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSendTerminalByDefault & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendTerminalByDefault::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSendTerminalByDefault & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendTerminalByDefault::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSendTerminalByDefault & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS entity '@lexicalSendTerminalByDefault'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault GGS_lexicalSendTerminalByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendTerminalByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendTerminalByDefault::
reader_mDefaultSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendTerminalByDefault *) mPointer)->mDefaultSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendTerminalByDefault::actualTypeName (void) const {
 return "lexicalSendTerminalByDefault" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendTerminalByDefault * GGS_lexicalSendTerminalByDefault::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefault::
cPtr_lexicalErrorByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalSendDefaultAction (THERE),
mDefaultErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorByDefault::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalErrorByDefault * _p = dynamic_cast <const cPtr_lexicalErrorByDefault *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDefaultErrorMessageName._operator_isEqual (_p->mDefaultErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorByDefault::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalErrorByDefault" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefaultErrorMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalErrorByDefault::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalErrorByDefault::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 20 ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalErrorByDefault" ;
  if (inLevel > 0) {
    result = cPtr_lexicalSendDefaultAction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefault * cPtr_lexicalErrorByDefault::
_cloneObject (void) const {
  cPtr_lexicalErrorByDefault * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalErrorByDefault (mDefaultErrorMessageName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalErrorByDefault'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorByDefault::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorByDefault::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorByDefault::
_addAssign_operation (const GGS_lexicalErrorByDefault & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalErrorByDefault *) inElement.getPtr ())->mDefaultErrorMessageName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorByDefault GGS__list_lexicalErrorByDefault::
_operator_concat (const GGS__list_lexicalErrorByDefault & inOperand) const {
  GGS__list_lexicalErrorByDefault result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalErrorByDefault * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mDefaultErrorMessageName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorByDefault::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorByDefault::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mDefaultErrorMessageName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorByDefault  GGS__list_lexicalErrorByDefault::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalErrorByDefault result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorByDefault  GGS__list_lexicalErrorByDefault::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalErrorByDefault result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalErrorByDefault::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalErrorByDefault", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorByDefault::
_addModel (const GGS_lexicalErrorByDefault & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorByDefault::
method_first (C_Compiler & _inLexique,
              GGS_lexicalErrorByDefault & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorByDefault::
method_last (C_Compiler & _inLexique,
             GGS_lexicalErrorByDefault & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorByDefault::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalErrorByDefault & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorByDefault::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalErrorByDefault & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexicalErrorByDefault'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault GGS_lexicalErrorByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorByDefault::
reader_mDefaultErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorByDefault *) mPointer)->mDefaultErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorByDefault::actualTypeName (void) const {
 return "lexicalErrorByDefault" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorByDefault * GGS_lexicalErrorByDefault::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalErrorByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalSendSearch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendSearch::
cPtr_lexicalSendSearch (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mAttributeName (argument_0),
mSearchListName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendSearch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSendSearch * _p = dynamic_cast <const cPtr_lexicalSendSearch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue ()
         && mSearchListName._operator_isEqual (_p->mSearchListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendSearch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSendSearch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchListName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSendSearch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendSearch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSendSearch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 21 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendSearch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalSendSearch" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSendSearch * cPtr_lexicalSendSearch::
_cloneObject (void) const {
  cPtr_lexicalSendSearch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSendSearch (mAttributeName, mSearchListName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_lexicalSendSearch'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalSendSearch::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendSearch::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendSearch::
_addAssign_operation (const GGS_lexicalSendSearch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSendSearch *) inElement.getPtr ())->mAttributeName,
                                ((cPtr_lexicalSendSearch *) inElement.getPtr ())->mSearchListName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendSearch GGS__list_lexicalSendSearch::
_operator_concat (const GGS__list_lexicalSendSearch & inOperand) const {
  GGS__list_lexicalSendSearch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSendSearch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_lstring  p_1 = p->mSearchListName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendSearch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendSearch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeName,
                                _p->mSearchListName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendSearch  GGS__list_lexicalSendSearch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSendSearch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSendSearch  GGS__list_lexicalSendSearch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSendSearch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalSendSearch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalSendSearch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSendSearch::
_addModel (const GGS_lexicalSendSearch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendSearch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSendSearch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendSearch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSendSearch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendSearch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSendSearch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSendSearch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSendSearch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@lexicalSendSearch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSendSearch GGS_lexicalSendSearch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendSearch result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendSearch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearch::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendSearch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendSearch *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearch::
reader_mSearchListName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendSearch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendSearch *) mPointer)->mSearchListName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendSearch::actualTypeName (void) const {
 return "lexicalSendSearch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendSearch * GGS_lexicalSendSearch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSendSearch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstruction::
cPtr_lexicalRepeatInstruction (const GGS__list_lexicalInstruction & argument_0,
                                const GGS__list_lexicalWhileBranch & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mRepeatedInstructionList (argument_0),
mLexicalWhileBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalRepeatInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalRepeatInstruction * _p = dynamic_cast <const cPtr_lexicalRepeatInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRepeatedInstructionList._operator_isEqual (_p->mRepeatedInstructionList).boolValue ()
         && mLexicalWhileBranchList._operator_isEqual (_p->mLexicalWhileBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRepeatInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalRepeatInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRepeatedInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalWhileBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalRepeatInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalRepeatInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 22 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalRepeatInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstruction * cPtr_lexicalRepeatInstruction::
_cloneObject (void) const {
  cPtr_lexicalRepeatInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalRepeatInstruction (mRepeatedInstructionList, mLexicalWhileBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalRepeatInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalRepeatInstruction::
_internalAppendValues (const GGS__list_lexicalInstruction & argument_0,
                    const GGS__list_lexicalWhileBranch & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRepeatInstruction::
_internalPrependValues (const GGS__list_lexicalInstruction & argument_0,
                    const GGS__list_lexicalWhileBranch & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRepeatInstruction::
_addAssign_operation (const GGS_lexicalRepeatInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalRepeatInstruction *) inElement.getPtr ())->mRepeatedInstructionList,
                                ((cPtr_lexicalRepeatInstruction *) inElement.getPtr ())->mLexicalWhileBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalRepeatInstruction GGS__list_lexicalRepeatInstruction::
_operator_concat (const GGS__list_lexicalRepeatInstruction & inOperand) const {
  GGS__list_lexicalRepeatInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalRepeatInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS__list_lexicalInstruction  p_0 = p->mRepeatedInstructionList ;
          GGS__list_lexicalWhileBranch  p_1 = p->mLexicalWhileBranchList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRepeatInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS__list_lexicalInstruction & argument_0,
                     const GGS__list_lexicalWhileBranch & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRepeatInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRepeatedInstructionList,
                                _p->mLexicalWhileBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalRepeatInstruction  GGS__list_lexicalRepeatInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalRepeatInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalRepeatInstruction  GGS__list_lexicalRepeatInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS__list_lexicalInstruction & argument_0,
                           const GGS__list_lexicalWhileBranch & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalRepeatInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalRepeatInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalRepeatInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRepeatInstruction::
_addModel (const GGS_lexicalRepeatInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRepeatInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalRepeatInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRepeatInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalRepeatInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRepeatInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalRepeatInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRepeatInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalRepeatInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalRepeatInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction GGS_lexicalRepeatInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_lexicalInstruction & argument_0,
                 const GGS__list_lexicalWhileBranch & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRepeatInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS_lexicalRepeatInstruction::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalWhileBranch  GGS_lexicalRepeatInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalWhileBranch   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRepeatInstruction::actualTypeName (void) const {
 return "lexicalRepeatInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRepeatInstruction * GGS_lexicalRepeatInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalRepeatInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalWhileBranch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalWhileBranch::
cPtr_lexicalWhileBranch (const GGS_lexicalExpression & argument_0,
                                const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mWhileExpression (argument_0),
mWhileInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalWhileBranch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalWhileBranch * _p = dynamic_cast <const cPtr_lexicalWhileBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mWhileInstructionList._operator_isEqual (_p->mWhileInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalWhileBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalWhileBranch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalWhileBranch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWhileBranch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalWhileBranch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 23 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWhileBranch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalWhileBranch" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalWhileBranch * cPtr_lexicalWhileBranch::
_cloneObject (void) const {
  cPtr_lexicalWhileBranch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalWhileBranch (mWhileExpression, mWhileInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_lexicalWhileBranch'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalWhileBranch::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalWhileBranch::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalWhileBranch::
_addAssign_operation (const GGS_lexicalWhileBranch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalWhileBranch *) inElement.getPtr ())->mWhileExpression,
                                ((cPtr_lexicalWhileBranch *) inElement.getPtr ())->mWhileInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalWhileBranch GGS__list_lexicalWhileBranch::
_operator_concat (const GGS__list_lexicalWhileBranch & inOperand) const {
  GGS__list_lexicalWhileBranch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalWhileBranch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mWhileExpression ;
          GGS__list_lexicalInstruction  p_1 = p->mWhileInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalWhileBranch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS__list_lexicalInstruction & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalWhileBranch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mWhileExpression,
                                _p->mWhileInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalWhileBranch  GGS__list_lexicalWhileBranch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalWhileBranch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalWhileBranch  GGS__list_lexicalWhileBranch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS__list_lexicalInstruction & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalWhileBranch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalWhileBranch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalWhileBranch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalWhileBranch::
_addModel (const GGS_lexicalWhileBranch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalWhileBranch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalWhileBranch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalWhileBranch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalWhileBranch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalWhileBranch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalWhileBranch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalWhileBranch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalWhileBranch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalWhileBranch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalWhileBranch GGS_lexicalWhileBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalWhileBranch result ;
  macroMyNew (result.mPointer, cPtr_lexicalWhileBranch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalWhileBranch::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWhileBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWhileBranch *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS_lexicalWhileBranch::
reader_mWhileInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWhileBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWhileBranch *) mPointer)->mWhileInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalWhileBranch::actualTypeName (void) const {
 return "lexicalWhileBranch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalWhileBranch * GGS_lexicalWhileBranch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalWhileBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstruction::
cPtr_lexicalSelectInstruction (const GGS__list_lexicalSelectBranch & argument_0,
                                const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mLexicalWhileBranchList (argument_0),
mDefaultInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSelectInstruction * _p = dynamic_cast <const cPtr_lexicalSelectInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalWhileBranchList._operator_isEqual (_p->mLexicalWhileBranchList).boolValue ()
         && mDefaultInstructionList._operator_isEqual (_p->mDefaultInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSelectInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalWhileBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefaultInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSelectInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSelectInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 24 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalSelectInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstruction * cPtr_lexicalSelectInstruction::
_cloneObject (void) const {
  cPtr_lexicalSelectInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSelectInstruction (mLexicalWhileBranchList, mDefaultInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalSelectInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectInstruction::
_internalAppendValues (const GGS__list_lexicalSelectBranch & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectInstruction::
_internalPrependValues (const GGS__list_lexicalSelectBranch & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectInstruction::
_addAssign_operation (const GGS_lexicalSelectInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSelectInstruction *) inElement.getPtr ())->mLexicalWhileBranchList,
                                ((cPtr_lexicalSelectInstruction *) inElement.getPtr ())->mDefaultInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectInstruction GGS__list_lexicalSelectInstruction::
_operator_concat (const GGS__list_lexicalSelectInstruction & inOperand) const {
  GGS__list_lexicalSelectInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSelectInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS__list_lexicalSelectBranch  p_0 = p->mLexicalWhileBranchList ;
          GGS__list_lexicalInstruction  p_1 = p->mDefaultInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS__list_lexicalSelectBranch & argument_0,
                     const GGS__list_lexicalInstruction & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalWhileBranchList,
                                _p->mDefaultInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectInstruction  GGS__list_lexicalSelectInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSelectInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectInstruction  GGS__list_lexicalSelectInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS__list_lexicalSelectBranch & argument_0,
                           const GGS__list_lexicalInstruction & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSelectInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalSelectInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalSelectInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectInstruction::
_addModel (const GGS_lexicalSelectInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSelectInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSelectInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSelectInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSelectInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalSelectInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction GGS_lexicalSelectInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_lexicalSelectBranch & argument_0,
                 const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectBranch  GGS_lexicalSelectInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalSelectBranch   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS_lexicalSelectInstruction::
reader_mDefaultInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mDefaultInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectInstruction::actualTypeName (void) const {
 return "lexicalSelectInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectInstruction * GGS_lexicalSelectInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSelectInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@lexicalSelectBranch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectBranch::
cPtr_lexicalSelectBranch (const GGS_lexicalExpression & argument_0,
                                const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mSelectExpression (argument_0),
mSelectInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectBranch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSelectBranch * _p = dynamic_cast <const cPtr_lexicalSelectBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSelectExpression._operator_isEqual (_p->mSelectExpression).boolValue ()
         && mSelectInstructionList._operator_isEqual (_p->mSelectInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSelectBranch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSelectBranch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectBranch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalSelectBranch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 25 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectBranch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalSelectBranch" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSelectBranch * cPtr_lexicalSelectBranch::
_cloneObject (void) const {
  cPtr_lexicalSelectBranch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSelectBranch (mSelectExpression, mSelectInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_lexicalSelectBranch'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectBranch::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectBranch::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS__list_lexicalInstruction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectBranch::
_addAssign_operation (const GGS_lexicalSelectBranch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSelectBranch *) inElement.getPtr ())->mSelectExpression,
                                ((cPtr_lexicalSelectBranch *) inElement.getPtr ())->mSelectInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectBranch GGS__list_lexicalSelectBranch::
_operator_concat (const GGS__list_lexicalSelectBranch & inOperand) const {
  GGS__list_lexicalSelectBranch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSelectBranch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mSelectExpression ;
          GGS__list_lexicalInstruction  p_1 = p->mSelectInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectBranch::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS__list_lexicalInstruction & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectBranch::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSelectExpression,
                                _p->mSelectInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectBranch  GGS__list_lexicalSelectBranch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSelectBranch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalSelectBranch  GGS__list_lexicalSelectBranch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS__list_lexicalInstruction & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalSelectBranch result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalSelectBranch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalSelectBranch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalSelectBranch::
_addModel (const GGS_lexicalSelectBranch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectBranch::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSelectBranch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectBranch::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSelectBranch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectBranch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSelectBranch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalSelectBranch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSelectBranch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@lexicalSelectBranch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSelectBranch GGS_lexicalSelectBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS__list_lexicalInstruction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectBranch result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectBranch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalSelectBranch::
reader_mSelectExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectBranch *) mPointer)->mSelectExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalInstruction  GGS_lexicalSelectBranch::
reader_mSelectInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectBranch *) mPointer)->mSelectInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectBranch::actualTypeName (void) const {
 return "lexicalSelectBranch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectBranch * GGS_lexicalSelectBranch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSelectBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalActionInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalActionInstruction::
cPtr_lexicalActionInstruction (const GGS_lstring & argument_0,
                                const GGS__list_lexicalActualArgument & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mActionName (argument_0),
mActualArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalActionInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalActionInstruction * _p = dynamic_cast <const cPtr_lexicalActionInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mActionName._operator_isEqual (_p->mActionName).boolValue ()
         && mActualArgumentList._operator_isEqual (_p->mActualArgumentList).boolValue ()
         && mErrorMessageList._operator_isEqual (_p->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalActionInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalActionInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalActionInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActionInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalActionInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 26 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActionInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalActionInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalActionInstruction * cPtr_lexicalActionInstruction::
_cloneObject (void) const {
  cPtr_lexicalActionInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalActionInstruction (mActionName, mActualArgumentList, mErrorMessageList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalActionInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalActionInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_lexicalActualArgument & argument_1,
                    const GGS_lstringlist & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActionInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_lexicalActualArgument & argument_1,
                    const GGS_lstringlist & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActionInstruction::
_addAssign_operation (const GGS_lexicalActionInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalActionInstruction *) inElement.getPtr ())->mActionName,
                                ((cPtr_lexicalActionInstruction *) inElement.getPtr ())->mActualArgumentList,
                                ((cPtr_lexicalActionInstruction *) inElement.getPtr ())->mErrorMessageList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActionInstruction GGS__list_lexicalActionInstruction::
_operator_concat (const GGS__list_lexicalActionInstruction & inOperand) const {
  GGS__list_lexicalActionInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalActionInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mActionName ;
          GGS__list_lexicalActualArgument  p_1 = p->mActualArgumentList ;
          GGS_lstringlist  p_2 = p->mErrorMessageList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActionInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_lexicalActualArgument & argument_1,
                     const GGS_lstringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActionInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mActionName,
                                _p->mActualArgumentList,
                                _p->mErrorMessageList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActionInstruction  GGS__list_lexicalActionInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalActionInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActionInstruction  GGS__list_lexicalActionInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_lexicalActualArgument & argument_1,
                           const GGS_lstringlist & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalActionInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalActionInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalActionInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActionInstruction::
_addModel (const GGS_lexicalActionInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActionInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalActionInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActionInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalActionInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActionInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalActionInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActionInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalActionInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalActionInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalActionInstruction GGS_lexicalActionInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_lexicalActualArgument & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalActionInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalActionInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalActionInstruction::
reader_mActionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mActionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActualArgument  GGS_lexicalActionInstruction::
reader_mActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalActualArgument   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalActionInstruction::
reader_mErrorMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mErrorMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalActionInstruction::actualTypeName (void) const {
 return "lexicalActionInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalActionInstruction * GGS_lexicalActionInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalActionInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalActualArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalActualArgument::
cPtr_lexicalActualArgument (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalActualArgument::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalActualArgument::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalActualArgument" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalActualArgument::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActualArgument::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalActualArgument::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 27 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActualArgument::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalActualArgument" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalActualArgument * cPtr_lexicalActualArgument::
_cloneObject (void) const {
  cPtr_lexicalActualArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalActualArgument (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalActualArgument'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalActualArgument::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActualArgument::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActualArgument::
_addAssign_operation (const GGS_lexicalActualArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActualArgument GGS__list_lexicalActualArgument::
_operator_concat (const GGS__list_lexicalActualArgument & inOperand) const {
  GGS__list_lexicalActualArgument result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalActualArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActualArgument::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActualArgument::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActualArgument  GGS__list_lexicalActualArgument::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalActualArgument result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActualArgument  GGS__list_lexicalActualArgument::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalActualArgument result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalActualArgument::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalActualArgument", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalActualArgument::
_addModel (const GGS_lexicalActualArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActualArgument::
method_first (C_Compiler & _inLexique,
              GGS_lexicalActualArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActualArgument::
method_last (C_Compiler & _inLexique,
             GGS_lexicalActualArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActualArgument::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalActualArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalActualArgument::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalActualArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexicalActualArgument'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalActualArgument::actualTypeName (void) const {
 return "lexicalActualArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalActualArgument * GGS_lexicalActualArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalActualArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalAttributeArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeArgument::
cPtr_lexicalAttributeArgument (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE),
mAttributeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeArgument::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalAttributeArgument * _p = dynamic_cast <const cPtr_lexicalAttributeArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalAttributeArgument" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalAttributeArgument::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeArgument::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalAttributeArgument::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 28 ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeArgument::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalAttributeArgument" ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalAttributeArgument * cPtr_lexicalAttributeArgument::
_cloneObject (void) const {
  cPtr_lexicalAttributeArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalAttributeArgument (mAttributeName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalAttributeArgument'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalAttributeArgument::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttributeArgument::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttributeArgument::
_addAssign_operation (const GGS_lexicalAttributeArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalAttributeArgument *) inElement.getPtr ())->mAttributeName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttributeArgument GGS__list_lexicalAttributeArgument::
_operator_concat (const GGS__list_lexicalAttributeArgument & inOperand) const {
  GGS__list_lexicalAttributeArgument result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalAttributeArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttributeArgument::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttributeArgument::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttributeArgument  GGS__list_lexicalAttributeArgument::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalAttributeArgument result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalAttributeArgument  GGS__list_lexicalAttributeArgument::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalAttributeArgument result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalAttributeArgument::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalAttributeArgument", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalAttributeArgument::
_addModel (const GGS_lexicalAttributeArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttributeArgument::
method_first (C_Compiler & _inLexique,
              GGS_lexicalAttributeArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttributeArgument::
method_last (C_Compiler & _inLexique,
             GGS_lexicalAttributeArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttributeArgument::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalAttributeArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalAttributeArgument::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalAttributeArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalAttributeArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgument GGS_lexicalAttributeArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeArgument::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeArgument *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeArgument::actualTypeName (void) const {
 return "lexicalAttributeArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeArgument * GGS_lexicalAttributeArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalAttributeArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalCharacterArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterArgument::
cPtr_lexicalCharacterArgument (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterArgument::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalCharacterArgument * _p = dynamic_cast <const cPtr_lexicalCharacterArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCharacterArgument" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCharacterArgument::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterArgument::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCharacterArgument::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 29 ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterArgument::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalCharacterArgument" ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCharacterArgument * cPtr_lexicalCharacterArgument::
_cloneObject (void) const {
  cPtr_lexicalCharacterArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCharacterArgument (mCharacter COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalCharacterArgument'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterArgument::
_internalAppendValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterArgument::
_internalPrependValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterArgument::
_addAssign_operation (const GGS_lexicalCharacterArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalCharacterArgument *) inElement.getPtr ())->mCharacter) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterArgument GGS__list_lexicalCharacterArgument::
_operator_concat (const GGS__list_lexicalCharacterArgument & inOperand) const {
  GGS__list_lexicalCharacterArgument result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCharacterArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mCharacter ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterArgument::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterArgument::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCharacter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterArgument  GGS__list_lexicalCharacterArgument::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCharacterArgument result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCharacterArgument  GGS__list_lexicalCharacterArgument::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCharacterArgument result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalCharacterArgument::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalCharacterArgument", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCharacterArgument::
_addModel (const GGS_lexicalCharacterArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterArgument::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCharacterArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterArgument::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCharacterArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterArgument::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCharacterArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCharacterArgument::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCharacterArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalCharacterArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgument GGS_lexicalCharacterArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterArgument::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterArgument *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterArgument::actualTypeName (void) const {
 return "lexicalCharacterArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterArgument * GGS_lexicalCharacterArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCharacterArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@lexicalCurrentCharacterArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterArgument::
cPtr_lexicalCurrentCharacterArgument (LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCurrentCharacterArgument::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCurrentCharacterArgument::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCurrentCharacterArgument" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCurrentCharacterArgument::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterArgument::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalCurrentCharacterArgument::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 30 ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterArgument::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalCurrentCharacterArgument" ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterArgument * cPtr_lexicalCurrentCharacterArgument::
_cloneObject (void) const {
  cPtr_lexicalCurrentCharacterArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCurrentCharacterArgument (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@_list_lexicalCurrentCharacterArgument'                *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalCurrentCharacterArgument::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCurrentCharacterArgument::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCurrentCharacterArgument::
_addAssign_operation (const GGS_lexicalCurrentCharacterArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCurrentCharacterArgument GGS__list_lexicalCurrentCharacterArgument::
_operator_concat (const GGS__list_lexicalCurrentCharacterArgument & inOperand) const {
  GGS__list_lexicalCurrentCharacterArgument result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCurrentCharacterArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCurrentCharacterArgument::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCurrentCharacterArgument::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCurrentCharacterArgument  GGS__list_lexicalCurrentCharacterArgument::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCurrentCharacterArgument result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalCurrentCharacterArgument  GGS__list_lexicalCurrentCharacterArgument::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalCurrentCharacterArgument result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalCurrentCharacterArgument::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalCurrentCharacterArgument", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalCurrentCharacterArgument::
_addModel (const GGS_lexicalCurrentCharacterArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCurrentCharacterArgument::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCurrentCharacterArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCurrentCharacterArgument::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCurrentCharacterArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCurrentCharacterArgument::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCurrentCharacterArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalCurrentCharacterArgument::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCurrentCharacterArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS entity '@lexicalCurrentCharacterArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgument GGS_lexicalCurrentCharacterArgument::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCurrentCharacterArgument (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCurrentCharacterArgument::actualTypeName (void) const {
 return "lexicalCurrentCharacterArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCurrentCharacterArgument * GGS_lexicalCurrentCharacterArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCurrentCharacterArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalFunctionArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFunctionArgument::
cPtr_lexicalFunctionArgument (const GGS_lstring & argument_0,
                                const GGS__list_lexicalActualArgument & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE),
mFunctionName (argument_0),
mFunctionActualArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalFunctionArgument::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalFunctionArgument * _p = dynamic_cast <const cPtr_lexicalFunctionArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFunctionName._operator_isEqual (_p->mFunctionName).boolValue ()
         && mFunctionActualArgumentList._operator_isEqual (_p->mFunctionActualArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFunctionArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalFunctionArgument" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFunctionName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFunctionActualArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalFunctionArgument::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionArgument::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalFunctionArgument::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 31 ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionArgument::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalFunctionArgument" ;
  if (inLevel > 0) {
    result = cPtr_lexicalActualArgument::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalFunctionArgument * cPtr_lexicalFunctionArgument::
_cloneObject (void) const {
  cPtr_lexicalFunctionArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalFunctionArgument (mFunctionName, mFunctionActualArgumentList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalFunctionArgument'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalFunctionArgument::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_lexicalActualArgument & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalFunctionArgument::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_lexicalActualArgument & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalFunctionArgument::
_addAssign_operation (const GGS_lexicalFunctionArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalFunctionArgument *) inElement.getPtr ())->mFunctionName,
                                ((cPtr_lexicalFunctionArgument *) inElement.getPtr ())->mFunctionActualArgumentList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalFunctionArgument GGS__list_lexicalFunctionArgument::
_operator_concat (const GGS__list_lexicalFunctionArgument & inOperand) const {
  GGS__list_lexicalFunctionArgument result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalFunctionArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFunctionName ;
          GGS__list_lexicalActualArgument  p_1 = p->mFunctionActualArgumentList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalFunctionArgument::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_lexicalActualArgument & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalFunctionArgument::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFunctionName,
                                _p->mFunctionActualArgumentList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalFunctionArgument  GGS__list_lexicalFunctionArgument::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalFunctionArgument result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalFunctionArgument  GGS__list_lexicalFunctionArgument::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_lexicalActualArgument & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalFunctionArgument result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalFunctionArgument::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalFunctionArgument", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalFunctionArgument::
_addModel (const GGS_lexicalFunctionArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalFunctionArgument::
method_first (C_Compiler & _inLexique,
              GGS_lexicalFunctionArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalFunctionArgument::
method_last (C_Compiler & _inLexique,
             GGS_lexicalFunctionArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalFunctionArgument::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalFunctionArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalFunctionArgument::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalFunctionArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@lexicalFunctionArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgument GGS_lexicalFunctionArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_lexicalActualArgument & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalFunctionArgument (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalFunctionArgument::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionArgument *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalActualArgument  GGS_lexicalFunctionArgument::
reader_mFunctionActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_lexicalActualArgument   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionArgument *) mPointer)->mFunctionActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFunctionArgument::actualTypeName (void) const {
 return "lexicalFunctionArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFunctionArgument * GGS_lexicalFunctionArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalFunctionArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalDropInstruction::
cPtr_lexicalDropInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mTerminalName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalDropInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalDropInstruction * _p = dynamic_cast <const cPtr_lexicalDropInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTerminalName._operator_isEqual (_p->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalDropInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalDropInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalDropInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalDropInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 32 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalDropInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalDropInstruction * cPtr_lexicalDropInstruction::
_cloneObject (void) const {
  cPtr_lexicalDropInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalDropInstruction (mTerminalName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalDropInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalDropInstruction::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalDropInstruction::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalDropInstruction::
_addAssign_operation (const GGS_lexicalDropInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalDropInstruction *) inElement.getPtr ())->mTerminalName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalDropInstruction GGS__list_lexicalDropInstruction::
_operator_concat (const GGS__list_lexicalDropInstruction & inOperand) const {
  GGS__list_lexicalDropInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalDropInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTerminalName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalDropInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalDropInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTerminalName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalDropInstruction  GGS__list_lexicalDropInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalDropInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalDropInstruction  GGS__list_lexicalDropInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalDropInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalDropInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalDropInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalDropInstruction::
_addModel (const GGS_lexicalDropInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalDropInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalDropInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalDropInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalDropInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalDropInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalDropInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalDropInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalDropInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@lexicalDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction GGS_lexicalDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalDropInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalDropInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalDropInstruction::actualTypeName (void) const {
 return "lexicalDropInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalDropInstruction * GGS_lexicalDropInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstruction::
cPtr_lexicalErrorInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalErrorInstruction * _p = dynamic_cast <const cPtr_lexicalErrorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorMessageName._operator_isEqual (_p->mErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalErrorInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalErrorInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalErrorInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 33 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalErrorInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstruction * cPtr_lexicalErrorInstruction::
_cloneObject (void) const {
  cPtr_lexicalErrorInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalErrorInstruction (mErrorMessageName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalErrorInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorInstruction::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorInstruction::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorInstruction::
_addAssign_operation (const GGS_lexicalErrorInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalErrorInstruction *) inElement.getPtr ())->mErrorMessageName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorInstruction GGS__list_lexicalErrorInstruction::
_operator_concat (const GGS__list_lexicalErrorInstruction & inOperand) const {
  GGS__list_lexicalErrorInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalErrorInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mErrorMessageName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mErrorMessageName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorInstruction  GGS__list_lexicalErrorInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalErrorInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalErrorInstruction  GGS__list_lexicalErrorInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalErrorInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalErrorInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalErrorInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalErrorInstruction::
_addModel (const GGS_lexicalErrorInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalErrorInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalErrorInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalErrorInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalErrorInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalErrorInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@lexicalErrorInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction GGS_lexicalErrorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorInstruction::
reader_mErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorInstruction *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorInstruction::actualTypeName (void) const {
 return "lexicalErrorInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorInstruction * GGS_lexicalErrorInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalTagInstruction::
cPtr_lexicalTagInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mTagName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalTagInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalTagInstruction * _p = dynamic_cast <const cPtr_lexicalTagInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTagName._operator_isEqual (_p->mTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalTagInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalTagInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTagName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalTagInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalTagInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 34 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalTagInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalTagInstruction * cPtr_lexicalTagInstruction::
_cloneObject (void) const {
  cPtr_lexicalTagInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalTagInstruction (mTagName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalTagInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalTagInstruction::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalTagInstruction::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalTagInstruction::
_addAssign_operation (const GGS_lexicalTagInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalTagInstruction *) inElement.getPtr ())->mTagName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalTagInstruction GGS__list_lexicalTagInstruction::
_operator_concat (const GGS__list_lexicalTagInstruction & inOperand) const {
  GGS__list_lexicalTagInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalTagInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTagName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalTagInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalTagInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTagName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalTagInstruction  GGS__list_lexicalTagInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalTagInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalTagInstruction  GGS__list_lexicalTagInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalTagInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalTagInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalTagInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalTagInstruction::
_addModel (const GGS_lexicalTagInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalTagInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalTagInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalTagInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalTagInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalTagInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalTagInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalTagInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalTagInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexicalTagInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction GGS_lexicalTagInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalTagInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalTagInstruction::
reader_mTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalTagInstruction *) mPointer)->mTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalTagInstruction::actualTypeName (void) const {
 return "lexicalTagInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalTagInstruction * GGS_lexicalTagInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalTagInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstruction::
cPtr_lexicalRewindInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mTagName (argument_0),
mTerminalName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalRewindInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalRewindInstruction * _p = dynamic_cast <const cPtr_lexicalRewindInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTagName._operator_isEqual (_p->mTagName).boolValue ()
         && mTerminalName._operator_isEqual (_p->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRewindInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalRewindInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTagName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalRewindInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalRewindInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 35 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalRewindInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstruction * cPtr_lexicalRewindInstruction::
_cloneObject (void) const {
  cPtr_lexicalRewindInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalRewindInstruction (mTagName, mTerminalName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_lexicalRewindInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalRewindInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRewindInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRewindInstruction::
_addAssign_operation (const GGS_lexicalRewindInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalRewindInstruction *) inElement.getPtr ())->mTagName,
                                ((cPtr_lexicalRewindInstruction *) inElement.getPtr ())->mTerminalName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalRewindInstruction GGS__list_lexicalRewindInstruction::
_operator_concat (const GGS__list_lexicalRewindInstruction & inOperand) const {
  GGS__list_lexicalRewindInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalRewindInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTagName ;
          GGS_lstring  p_1 = p->mTerminalName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRewindInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRewindInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTagName,
                                _p->mTerminalName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalRewindInstruction  GGS__list_lexicalRewindInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalRewindInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalRewindInstruction  GGS__list_lexicalRewindInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalRewindInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalRewindInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalRewindInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalRewindInstruction::
_addModel (const GGS_lexicalRewindInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRewindInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalRewindInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRewindInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalRewindInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRewindInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalRewindInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalRewindInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalRewindInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@lexicalRewindInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction GGS_lexicalRewindInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRewindInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRewindInstruction::actualTypeName (void) const {
 return "lexicalRewindInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRewindInstruction * GGS_lexicalRewindInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalRewindInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalLogInstruction::
cPtr_lexicalLogInstruction (LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalLogInstruction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalLogInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalLogInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lexicalLogInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 36 ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lexicalLogInstruction" ;
  if (inLevel > 0) {
    result = cPtr_lexicalInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalLogInstruction * cPtr_lexicalLogInstruction::
_cloneObject (void) const {
  cPtr_lexicalLogInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalLogInstruction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lexicalLogInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_lexicalLogInstruction::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalLogInstruction::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalLogInstruction::
_addAssign_operation (const GGS_lexicalLogInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalLogInstruction GGS__list_lexicalLogInstruction::
_operator_concat (const GGS__list_lexicalLogInstruction & inOperand) const {
  GGS__list_lexicalLogInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalLogInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalLogInstruction::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalLogInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_lexicalLogInstruction  GGS__list_lexicalLogInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalLogInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lexicalLogInstruction  GGS__list_lexicalLogInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lexicalLogInstruction result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lexicalLogInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lexicalLogInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_lexicalLogInstruction::
_addModel (const GGS_lexicalLogInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalLogInstruction::
method_first (C_Compiler & _inLexique,
              GGS_lexicalLogInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalLogInstruction::
method_last (C_Compiler & _inLexique,
             GGS_lexicalLogInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalLogInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalLogInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lexicalLogInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalLogInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@lexicalLogInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction GGS_lexicalLogInstruction::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalLogInstruction (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalLogInstruction::actualTypeName (void) const {
 return "lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalLogInstruction * GGS_lexicalLogInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalLogInstruction *) mPointer ;
  }
#endif

