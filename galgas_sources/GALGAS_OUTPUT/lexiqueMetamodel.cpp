//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'lexiqueMetamodel.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 6th, 2007, at 17h13'50"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "lexiqueMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("lexiqueMetamodel") ;

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_lexiqueMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexiqueComponentRootList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexiqueComponentRoot::
cPtr_lexiqueComponentRoot (const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mLexiqueComponentName (argument_0),
mLexicalAttributeList (argument_1),
mLexicalStyleList (argument_2),
mTerminalDeclarationList (argument_3),
mLexicalErrorMessageDeclarationList (argument_4),
mLexicalListDeclarationList (argument_5),
mLexicalImplicitRuleList (argument_6),
mLexicalExplicitRuleList (argument_7) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexiqueComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexiqueComponentRoot * _p = dynamic_cast <const cPtr_lexiqueComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexiqueComponentName._operator_isEqual (_p->mLexiqueComponentName).boolValue ()
         && mLexicalAttributeList._operator_isEqual (_p->mLexicalAttributeList).boolValue ()
         && mLexicalStyleList._operator_isEqual (_p->mLexicalStyleList).boolValue ()
         && mTerminalDeclarationList._operator_isEqual (_p->mTerminalDeclarationList).boolValue ()
         && mLexicalErrorMessageDeclarationList._operator_isEqual (_p->mLexicalErrorMessageDeclarationList).boolValue ()
         && mLexicalListDeclarationList._operator_isEqual (_p->mLexicalListDeclarationList).boolValue ()
         && mLexicalImplicitRuleList._operator_isEqual (_p->mLexicalImplicitRuleList).boolValue ()
         && mLexicalExplicitRuleList._operator_isEqual (_p->mLexicalExplicitRuleList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexiqueComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexiqueComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexiqueComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalStyleList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalErrorMessageDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalListDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalImplicitRuleList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalExplicitRuleList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexiqueComponentRoot::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexiqueComponentRoot::_metamodelClassID (void) const {
  return 0 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::_metamodelClassName (void) const {
  return "lexiqueComponentRoot" ;
}

//---------------------------------------------------------------------------*

cPtr_lexiqueComponentRoot * cPtr_lexiqueComponentRoot::
_cloneObject (void) const {
  cPtr_lexiqueComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_lexiqueComponentRoot (mLexiqueComponentName, mLexicalAttributeList, mLexicalStyleList, mTerminalDeclarationList, mLexicalErrorMessageDeclarationList, mLexicalListDeclarationList, mLexicalImplicitRuleList, mLexicalExplicitRuleList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexiqueComponentRootList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexiqueComponentRootList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalAttributeList & argument_1,
                    const GGS_lexicalStyleList & argument_2,
                    const GGS_terminalDeclarationList & argument_3,
                    const GGS_lexicalErrorMessageDeclarationList & argument_4,
                    const GGS_lexicalListDeclarationList & argument_5,
                    const GGS_lexicalImplicitRuleList & argument_6,
                    const GGS_lexicalExplicitRuleList & argument_7) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexiqueComponentRootList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalAttributeList & argument_1,
                    const GGS_lexicalStyleList & argument_2,
                    const GGS_terminalDeclarationList & argument_3,
                    const GGS_lexicalErrorMessageDeclarationList & argument_4,
                    const GGS_lexicalListDeclarationList & argument_5,
                    const GGS_lexicalImplicitRuleList & argument_6,
                    const GGS_lexicalExplicitRuleList & argument_7) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexiqueComponentRootList::
_addAssign_operation (const GGS_lexiqueComponentRoot & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexiqueComponentName,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalAttributeList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalStyleList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mTerminalDeclarationList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalErrorMessageDeclarationList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalListDeclarationList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalImplicitRuleList,
                                ((cPtr_lexiqueComponentRoot *) inElement.getPtr ())->mLexicalExplicitRuleList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRootList GGS_lexiqueComponentRootList::
_operator_concat (const GGS_lexiqueComponentRootList & inOperand) const {
  GGS_lexiqueComponentRootList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexiqueComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLexiqueComponentName ;
          GGS_lexicalAttributeList  p_1 = p->mLexicalAttributeList ;
          GGS_lexicalStyleList  p_2 = p->mLexicalStyleList ;
          GGS_terminalDeclarationList  p_3 = p->mTerminalDeclarationList ;
          GGS_lexicalErrorMessageDeclarationList  p_4 = p->mLexicalErrorMessageDeclarationList ;
          GGS_lexicalListDeclarationList  p_5 = p->mLexicalListDeclarationList ;
          GGS_lexicalImplicitRuleList  p_6 = p->mLexicalImplicitRuleList ;
          GGS_lexicalExplicitRuleList  p_7 = p->mLexicalExplicitRuleList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexiqueComponentRootList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalAttributeList & argument_1,
                     const GGS_lexicalStyleList & argument_2,
                     const GGS_terminalDeclarationList & argument_3,
                     const GGS_lexicalErrorMessageDeclarationList & argument_4,
                     const GGS_lexicalListDeclarationList & argument_5,
                     const GGS_lexicalImplicitRuleList & argument_6,
                     const GGS_lexicalExplicitRuleList & argument_7
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexiqueComponentRootList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexiqueComponentName,
                                _p->mLexicalAttributeList,
                                _p->mLexicalStyleList,
                                _p->mTerminalDeclarationList,
                                _p->mLexicalErrorMessageDeclarationList,
                                _p->mLexicalListDeclarationList,
                                _p->mLexicalImplicitRuleList,
                                _p->mLexicalExplicitRuleList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRootList  GGS_lexiqueComponentRootList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexiqueComponentRootList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRootList  GGS_lexiqueComponentRootList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lexicalAttributeList & argument_1,
                           const GGS_lexicalStyleList & argument_2,
                           const GGS_terminalDeclarationList & argument_3,
                           const GGS_lexicalErrorMessageDeclarationList & argument_4,
                           const GGS_lexicalListDeclarationList & argument_5,
                           const GGS_lexicalImplicitRuleList & argument_6,
                           const GGS_lexicalExplicitRuleList & argument_7
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexiqueComponentRootList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexiqueComponentRootList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexiqueComponentRootList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexiqueComponentRootList::
_addModel (const GGS_lexiqueComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexiqueComponentRootList::
method_first (C_Compiler & _inLexique,
              GGS_lexiqueComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexiqueComponentRootList::
method_last (C_Compiler & _inLexique,
             GGS_lexiqueComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexiqueComponentRootList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexiqueComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexiqueComponentRootList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexiqueComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexiqueComponentRoot::constructor_new (_inLexique,
       _p->mLexiqueComponentName,
       _p->mLexicalAttributeList,
       _p->mLexicalStyleList,
       _p->mTerminalDeclarationList,
       _p->mLexicalErrorMessageDeclarationList,
       _p->mLexicalListDeclarationList,
       _p->mLexicalImplicitRuleList,
       _p->mLexicalExplicitRuleList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot GGS_lexiqueComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalAttributeList & argument_1,
                 const GGS_lexicalStyleList & argument_2,
                 const GGS_terminalDeclarationList & argument_3,
                 const GGS_lexicalErrorMessageDeclarationList & argument_4,
                 const GGS_lexicalListDeclarationList & argument_5,
                 const GGS_lexicalImplicitRuleList & argument_6,
                 const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_lexiqueComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexiqueComponentRoot::
reader_mLexiqueComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexiqueComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexiqueComponentRoot::
reader_mLexicalAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexiqueComponentRoot::
reader_mLexicalStyleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalStyleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalStyleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_lexiqueComponentRoot::
reader_mTerminalDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_terminalDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTerminalDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList  GGS_lexiqueComponentRoot::
reader_mLexicalErrorMessageDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalErrorMessageDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalErrorMessageDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexiqueComponentRoot::
reader_mLexicalListDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalListDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList  GGS_lexiqueComponentRoot::
reader_mLexicalImplicitRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalImplicitRuleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalImplicitRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList  GGS_lexiqueComponentRoot::
reader_mLexicalExplicitRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExplicitRuleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalExplicitRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexiqueComponentRoot::actualTypeName (void) const {
 return "lexiqueComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexiqueComponentRoot * GGS_lexiqueComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexiqueComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalImplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalImplicitRule::
cPtr_lexicalImplicitRule (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mListName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalImplicitRule::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalImplicitRule * _p = dynamic_cast <const cPtr_lexicalImplicitRule *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListName._operator_isEqual (_p->mListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalImplicitRule::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalImplicitRule" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mListName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalImplicitRule::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRule::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalImplicitRule::_metamodelClassID (void) const {
  return 1 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRule::_metamodelClassName (void) const {
  return "lexicalImplicitRule" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalImplicitRule * cPtr_lexicalImplicitRule::
_cloneObject (void) const {
  cPtr_lexicalImplicitRule * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalImplicitRule (mListName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalImplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_addAssign_operation (const GGS_lexicalImplicitRule & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalImplicitRule *) inElement.getPtr ())->mListName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList GGS_lexicalImplicitRuleList::
_operator_concat (const GGS_lexicalImplicitRuleList & inOperand) const {
  GGS_lexicalImplicitRuleList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalImplicitRule * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mListName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mListName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList  GGS_lexicalImplicitRuleList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalImplicitRuleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList  GGS_lexicalImplicitRuleList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalImplicitRuleList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalImplicitRuleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalImplicitRuleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_addModel (const GGS_lexicalImplicitRule & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalImplicitRuleList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalImplicitRule & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalImplicitRuleList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalImplicitRule & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalImplicitRuleList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalImplicitRule & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalImplicitRuleList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalImplicitRule & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalImplicitRule::constructor_new (_inLexique,
       _p->mListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalImplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalImplicitRule GGS_lexicalImplicitRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRule result ;
  macroMyNew (result.mPointer, cPtr_lexicalImplicitRule (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalImplicitRule::
reader_mListName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalImplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalImplicitRule *) mPointer)->mListName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalImplicitRule::actualTypeName (void) const {
 return "lexicalImplicitRule" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalImplicitRule * GGS_lexicalImplicitRule::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalImplicitRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalErrorMessageDeclarationList'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorMessageDeclaration::
cPtr_lexicalErrorMessageDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorMessageDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalErrorMessageDeclaration * _p = dynamic_cast <const cPtr_lexicalErrorMessageDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorMessageDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalErrorMessageDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalErrorMessageDeclaration::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorMessageDeclaration::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalErrorMessageDeclaration::_metamodelClassID (void) const {
  return 2 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorMessageDeclaration::_metamodelClassName (void) const {
  return "lexicalErrorMessageDeclaration" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalErrorMessageDeclaration * cPtr_lexicalErrorMessageDeclaration::
_cloneObject (void) const {
  cPtr_lexicalErrorMessageDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalErrorMessageDeclaration (mMessageName, mMessageValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@lexicalErrorMessageDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_addAssign_operation (const GGS_lexicalErrorMessageDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalErrorMessageDeclaration *) inElement.getPtr ())->mMessageName,
                                ((cPtr_lexicalErrorMessageDeclaration *) inElement.getPtr ())->mMessageValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList GGS_lexicalErrorMessageDeclarationList::
_operator_concat (const GGS_lexicalErrorMessageDeclarationList & inOperand) const {
  GGS_lexicalErrorMessageDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalErrorMessageDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList  GGS_lexicalErrorMessageDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalErrorMessageDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList  GGS_lexicalErrorMessageDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalErrorMessageDeclarationList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalErrorMessageDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalErrorMessageDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_addModel (const GGS_lexicalErrorMessageDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorMessageDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalErrorMessageDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorMessageDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalErrorMessageDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorMessageDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalErrorMessageDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorMessageDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalErrorMessageDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorMessageDeclaration::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalErrorMessageDeclaration'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclaration GGS_lexicalErrorMessageDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorMessageDeclaration result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorMessageDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorMessageDeclaration::
reader_mMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorMessageDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorMessageDeclaration *) mPointer)->mMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorMessageDeclaration::
reader_mMessageValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorMessageDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorMessageDeclaration *) mPointer)->mMessageValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorMessageDeclaration::actualTypeName (void) const {
 return "lexicalErrorMessageDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorMessageDeclaration * GGS_lexicalErrorMessageDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalErrorMessageDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttribute::
cPtr_lexicalAttribute (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mTypeName (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttribute::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalAttribute * _p = dynamic_cast <const cPtr_lexicalAttribute *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttribute::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalAttribute" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalAttribute::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttribute::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalAttribute::_metamodelClassID (void) const {
  return 3 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttribute::_metamodelClassName (void) const {
  return "lexicalAttribute" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalAttribute * cPtr_lexicalAttribute::
_cloneObject (void) const {
  cPtr_lexicalAttribute * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalAttribute (mTypeName, mName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalAttributeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_addAssign_operation (const GGS_lexicalAttribute & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalAttribute *) inElement.getPtr ())->mTypeName,
                                ((cPtr_lexicalAttribute *) inElement.getPtr ())->mName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
_operator_concat (const GGS_lexicalAttributeList & inOperand) const {
  GGS_lexicalAttributeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalAttribute * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexicalAttributeList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalAttributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexicalAttributeList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalAttributeList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalAttributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalAttributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_addModel (const GGS_lexicalAttribute & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalAttribute & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalAttribute & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalAttribute & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalAttribute & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttribute::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalAttribute'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalAttribute GGS_lexicalAttribute::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttribute result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttribute (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttribute::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttribute *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttribute::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttribute *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttribute::actualTypeName (void) const {
 return "lexicalAttribute" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttribute * GGS_lexicalAttribute::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalAttribute *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalStyleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStyle::
cPtr_lexicalStyle (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mName (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStyle::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStyle * _p = dynamic_cast <const cPtr_lexicalStyle *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mComment._operator_isEqual (_p->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStyle::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStyle" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStyle::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStyle::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStyle::_metamodelClassID (void) const {
  return 4 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStyle::_metamodelClassName (void) const {
  return "lexicalStyle" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStyle * cPtr_lexicalStyle::
_cloneObject (void) const {
  cPtr_lexicalStyle * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStyle (mName, mComment COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@lexicalStyleList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_addAssign_operation (const GGS_lexicalStyle & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStyle *) inElement.getPtr ())->mName,
                                ((cPtr_lexicalStyle *) inElement.getPtr ())->mComment) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
_operator_concat (const GGS_lexicalStyleList & inOperand) const {
  GGS_lexicalStyleList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStyle * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mComment ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mComment) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexicalStyleList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStyleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexicalStyleList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStyleList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStyleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalStyleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_addModel (const GGS_lexicalStyle & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalStyleList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStyle & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStyleList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStyle & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStyleList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStyle & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStyleList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStyle & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStyle::constructor_new (_inLexique,
       _p->mName,
       _p->mComment) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_lexicalStyle'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStyle GGS_lexicalStyle::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStyle result ;
  macroMyNew (result.mPointer, cPtr_lexicalStyle (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyle::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStyle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStyle *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyle::
reader_mComment (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStyle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStyle *) mPointer)->mComment ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStyle::actualTypeName (void) const {
 return "lexicalStyle" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStyle * GGS_lexicalStyle::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStyle *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@terminalDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_terminalDeclaration::
cPtr_terminalDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mName (argument_0),
mSentAttributeList (argument_1),
mErrorMessage (argument_2),
mStyle (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_terminalDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_terminalDeclaration * _p = dynamic_cast <const cPtr_terminalDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mSentAttributeList._operator_isEqual (_p->mSentAttributeList).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mStyle._operator_isEqual (_p->mStyle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_terminalDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @terminalDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_terminalDeclaration::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalDeclaration::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_terminalDeclaration::_metamodelClassID (void) const {
  return 5 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalDeclaration::_metamodelClassName (void) const {
  return "terminalDeclaration" ;
}

//---------------------------------------------------------------------------*

cPtr_terminalDeclaration * cPtr_terminalDeclaration::
_cloneObject (void) const {
  cPtr_terminalDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_terminalDeclaration (mName, mSentAttributeList, mErrorMessage, mStyle COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@terminalDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_addAssign_operation (const GGS_terminalDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_terminalDeclaration *) inElement.getPtr ())->mName,
                                ((cPtr_terminalDeclaration *) inElement.getPtr ())->mSentAttributeList,
                                ((cPtr_terminalDeclaration *) inElement.getPtr ())->mErrorMessage,
                                ((cPtr_terminalDeclaration *) inElement.getPtr ())->mStyle) ;
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
_operator_concat (const GGS_terminalDeclarationList & inOperand) const {
  GGS_terminalDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_terminalDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstringlist  p_1 = p->mSentAttributeList ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mStyle ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mSentAttributeList,
                                _p->mErrorMessage,
                                _p->mStyle) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_terminalDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_terminalDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_terminalDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_terminalDeclarationList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@terminalDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_addModel (const GGS_terminalDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_terminalDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_terminalDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_terminalDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_terminalDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_terminalDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_terminalDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_terminalDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_terminalDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mSentAttributeList,
       _p->mErrorMessage,
       _p->mStyle) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_terminalDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_terminalDeclaration GGS_terminalDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_terminalDeclaration result ;
  macroMyNew (result.mPointer, cPtr_terminalDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclaration::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclaration::
reader_mSentAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mSentAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclaration::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclaration::
reader_mStyle (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalDeclaration *) mPointer)->mStyle ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_terminalDeclaration::actualTypeName (void) const {
 return "terminalDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_terminalDeclaration * GGS_terminalDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_terminalDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalListDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalListDeclaration::
cPtr_lexicalListDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mName (argument_0),
mStyle (argument_1),
mErrorMessage (argument_2),
mSentAttributeList (argument_3),
mEntryList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalListDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalListDeclaration * _p = dynamic_cast <const cPtr_lexicalListDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mStyle._operator_isEqual (_p->mStyle).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mSentAttributeList._operator_isEqual (_p->mSentAttributeList).boolValue ()
         && mEntryList._operator_isEqual (_p->mEntryList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalListDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalListDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntryList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalListDeclaration::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListDeclaration::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalListDeclaration::_metamodelClassID (void) const {
  return 6 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListDeclaration::_metamodelClassName (void) const {
  return "lexicalListDeclaration" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalListDeclaration * cPtr_lexicalListDeclaration::
_cloneObject (void) const {
  cPtr_lexicalListDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalListDeclaration (mName, mStyle, mErrorMessage, mSentAttributeList, mEntryList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalListDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_addAssign_operation (const GGS_lexicalListDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mName,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mStyle,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mErrorMessage,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mSentAttributeList,
                                ((cPtr_lexicalListDeclaration *) inElement.getPtr ())->mEntryList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
_operator_concat (const GGS_lexicalListDeclarationList & inOperand) const {
  GGS_lexicalListDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalListDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mStyle ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstringlist  p_3 = p->mSentAttributeList ;
          GGS_lexicalListEntryList  p_4 = p->mEntryList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS_lexicalListEntryList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mStyle,
                                _p->mErrorMessage,
                                _p->mSentAttributeList,
                                _p->mEntryList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexicalListDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalListDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexicalListDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstringlist & argument_3,
                           const GGS_lexicalListEntryList & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalListDeclarationList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalListDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_addModel (const GGS_lexicalListDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalListDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalListDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalListDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalListDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalListDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalListDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalListDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalListDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListDeclaration::constructor_new (_inLexique,
       _p->mName,
       _p->mStyle,
       _p->mErrorMessage,
       _p->mSentAttributeList,
       _p->mEntryList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalListDeclaration GGS_lexicalListDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalListDeclaration result ;
  macroMyNew (result.mPointer, cPtr_lexicalListDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclaration::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclaration::
reader_mStyle (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mStyle ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclaration::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListDeclaration::
reader_mSentAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mSentAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListDeclaration::
reader_mEntryList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalListEntryList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListDeclaration *) mPointer)->mEntryList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalListDeclaration::actualTypeName (void) const {
 return "lexicalListDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalListDeclaration * GGS_lexicalListDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalListDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalListEntryList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalListEntry::
cPtr_lexicalListEntry (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mEntrySpelling (argument_0),
mTerminalSpelling (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalListEntry::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalListEntry * _p = dynamic_cast <const cPtr_lexicalListEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntrySpelling._operator_isEqual (_p->mEntrySpelling).boolValue ()
         && mTerminalSpelling._operator_isEqual (_p->mTerminalSpelling).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalListEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalListEntry" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntrySpelling.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalSpelling.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalListEntry::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListEntry::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalListEntry::_metamodelClassID (void) const {
  return 7 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalListEntry::_metamodelClassName (void) const {
  return "lexicalListEntry" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalListEntry * cPtr_lexicalListEntry::
_cloneObject (void) const {
  cPtr_lexicalListEntry * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalListEntry (mEntrySpelling, mTerminalSpelling COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalListEntryList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_addAssign_operation (const GGS_lexicalListEntry & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalListEntry *) inElement.getPtr ())->mEntrySpelling,
                                ((cPtr_lexicalListEntry *) inElement.getPtr ())->mTerminalSpelling) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
_operator_concat (const GGS_lexicalListEntryList & inOperand) const {
  GGS_lexicalListEntryList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalListEntry * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEntrySpelling ;
          GGS_lstring  p_1 = p->mTerminalSpelling ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntrySpelling,
                                _p->mTerminalSpelling) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListEntryList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalListEntryList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListEntryList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalListEntryList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListEntryList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalListEntryList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_addModel (const GGS_lexicalListEntry & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalListEntryList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalListEntry & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalListEntryList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalListEntry & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalListEntryList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalListEntry & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalListEntryList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalListEntry & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalListEntry::constructor_new (_inLexique,
       _p->mEntrySpelling,
       _p->mTerminalSpelling) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalListEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalListEntry GGS_lexicalListEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalListEntry result ;
  macroMyNew (result.mPointer, cPtr_lexicalListEntry (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntry::
reader_mEntrySpelling (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListEntry *) mPointer)->mEntrySpelling ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntry::
reader_mTerminalSpelling (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalListEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalListEntry *) mPointer)->mTerminalSpelling ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalListEntry::actualTypeName (void) const {
 return "lexicalListEntry" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalListEntry * GGS_lexicalListEntry::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalListEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalExplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExplicitRule::
cPtr_lexicalExplicitRule (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mLexicalRuleExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalExplicitRule::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalExplicitRule * _p = dynamic_cast <const cPtr_lexicalExplicitRule *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalRuleExpression._operator_isEqual (_p->mLexicalRuleExpression).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalExplicitRule::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalExplicitRule" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRuleExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalExplicitRule::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRule::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalExplicitRule::_metamodelClassID (void) const {
  return 8 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRule::_metamodelClassName (void) const {
  return "lexicalExplicitRule" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalExplicitRule * cPtr_lexicalExplicitRule::
_cloneObject (void) const {
  cPtr_lexicalExplicitRule * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalExplicitRule (mLexicalRuleExpression, mInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalExplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_addAssign_operation (const GGS_lexicalExplicitRule & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalExplicitRule *) inElement.getPtr ())->mLexicalRuleExpression,
                                ((cPtr_lexicalExplicitRule *) inElement.getPtr ())->mInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList GGS_lexicalExplicitRuleList::
_operator_concat (const GGS_lexicalExplicitRuleList & inOperand) const {
  GGS_lexicalExplicitRuleList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalExplicitRule * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mLexicalRuleExpression ;
          GGS_lexicalInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalRuleExpression,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList  GGS_lexicalExplicitRuleList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalExplicitRuleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList  GGS_lexicalExplicitRuleList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS_lexicalInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalExplicitRuleList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExplicitRuleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalExplicitRuleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_addModel (const GGS_lexicalExplicitRule & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalExplicitRuleList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExplicitRule & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalExplicitRuleList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExplicitRule & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalExplicitRuleList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalExplicitRule & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalExplicitRuleList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalExplicitRule & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExplicitRule::constructor_new (_inLexique,
       _p->mLexicalRuleExpression,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalExplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalExplicitRule GGS_lexicalExplicitRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRule result ;
  macroMyNew (result.mPointer, cPtr_lexicalExplicitRule (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalExplicitRule::
reader_mLexicalRuleExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRule *) mPointer)->mLexicalRuleExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalExplicitRule::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRule *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExplicitRule::actualTypeName (void) const {
 return "lexicalExplicitRule" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExplicitRule * GGS_lexicalExplicitRule::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalExplicitRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExpression::
cPtr_lexicalExpression (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalExpression" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalExpression::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalExpression::_metamodelClassID (void) const {
  return 9 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::_metamodelClassName (void) const {
  return "lexicalExpression" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalExpression * cPtr_lexicalExpression::
_cloneObject (void) const {
  cPtr_lexicalExpression * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalExpressionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExpressionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExpressionList::
_addAssign_operation (const GGS_lexicalExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionList GGS_lexicalExpressionList::
_operator_concat (const GGS_lexicalExpressionList & inOperand) const {
  GGS_lexicalExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionList  GGS_lexicalExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpressionList  GGS_lexicalExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalExpressionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExpressionList::
_addModel (const GGS_lexicalExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalExpression::actualTypeName (void) const {
 return "lexicalExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExpression * GGS_lexicalExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalOrExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalOrExpression::
cPtr_lexicalOrExpression (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalOrExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalOrExpression * _p = dynamic_cast <const cPtr_lexicalOrExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLeftOperand._operator_isEqual (_p->mLeftOperand).boolValue ()
         && mRightOperand._operator_isEqual (_p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalOrExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalOrExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalOrExpression::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalOrExpression::_metamodelClassID (void) const {
  return 10 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::_metamodelClassName (void) const {
  return "lexicalOrExpression" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalOrExpression * cPtr_lexicalOrExpression::
_cloneObject (void) const {
  cPtr_lexicalOrExpression * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalOrExpression (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalOrExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalOrExpressionList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalOrExpressionList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalOrExpressionList::
_addAssign_operation (const GGS_lexicalOrExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalOrExpression *) inElement.getPtr ())->mLeftOperand,
                                ((cPtr_lexicalOrExpression *) inElement.getPtr ())->mRightOperand) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionList GGS_lexicalOrExpressionList::
_operator_concat (const GGS_lexicalOrExpressionList & inOperand) const {
  GGS_lexicalOrExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalOrExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mLeftOperand ;
          GGS_lexicalExpression  p_1 = p->mRightOperand ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalOrExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalOrExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLeftOperand,
                                _p->mRightOperand) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionList  GGS_lexicalOrExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalOrExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpressionList  GGS_lexicalOrExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS_lexicalExpression & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalOrExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalOrExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalOrExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalOrExpressionList::
_addModel (const GGS_lexicalOrExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalOrExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalOrExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalOrExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalOrExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalOrExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalOrExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalOrExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalOrExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalOrExpression::constructor_new (_inLexique,
       _p->mLeftOperand,
       _p->mRightOperand) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalOrExpression GGS_lexicalOrExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpression result ;
  macroMyNew (result.mPointer, cPtr_lexicalOrExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalOrExpression::actualTypeName (void) const {
 return "lexicalOrExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalOrExpression * GGS_lexicalOrExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalOrExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalCharacterMatchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatch::
cPtr_lexicalCharacterMatch (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalCharacterMatch * _p = dynamic_cast <const cPtr_lexicalCharacterMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCharacterMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCharacterMatch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCharacterMatch::_metamodelClassID (void) const {
  return 11 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::_metamodelClassName (void) const {
  return "lexicalCharacterMatch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatch * cPtr_lexicalCharacterMatch::
_cloneObject (void) const {
  cPtr_lexicalCharacterMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCharacterMatch (mCharacter COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalCharacterMatchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalCharacterMatchList::
_internalAppendValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterMatchList::
_internalPrependValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterMatchList::
_addAssign_operation (const GGS_lexicalCharacterMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalCharacterMatch *) inElement.getPtr ())->mCharacter) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchList GGS_lexicalCharacterMatchList::
_operator_concat (const GGS_lexicalCharacterMatchList & inOperand) const {
  GGS_lexicalCharacterMatchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCharacterMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mCharacter ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterMatchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterMatchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCharacter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchList  GGS_lexicalCharacterMatchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCharacterMatchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatchList  GGS_lexicalCharacterMatchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCharacterMatchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalCharacterMatchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalCharacterMatchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterMatchList::
_addModel (const GGS_lexicalCharacterMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterMatchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCharacterMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterMatchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCharacterMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterMatchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCharacterMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterMatchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCharacterMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterMatch::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch GGS_lexicalCharacterMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterMatch::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterMatch *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterMatch::actualTypeName (void) const {
 return "lexicalCharacterMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterMatch * GGS_lexicalCharacterMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCharacterMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalCharacterIntervalMatchList'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatch::
cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mLowerBound (argument_0),
mUpperBound (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterIntervalMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalCharacterIntervalMatch * _p = dynamic_cast <const cPtr_lexicalCharacterIntervalMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLowerBound._operator_isEqual (_p->mLowerBound).boolValue ()
         && mUpperBound._operator_isEqual (_p->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterIntervalMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCharacterIntervalMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowerBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUpperBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCharacterIntervalMatch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCharacterIntervalMatch::_metamodelClassID (void) const {
  return 12 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::_metamodelClassName (void) const {
  return "lexicalCharacterIntervalMatch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatch * cPtr_lexicalCharacterIntervalMatch::
_cloneObject (void) const {
  cPtr_lexicalCharacterIntervalMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCharacterIntervalMatch (mLowerBound, mUpperBound COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@lexicalCharacterIntervalMatchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalCharacterIntervalMatchList::
_internalAppendValues (const GGS_lchar & argument_0,
                    const GGS_lchar & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterIntervalMatchList::
_internalPrependValues (const GGS_lchar & argument_0,
                    const GGS_lchar & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterIntervalMatchList::
_addAssign_operation (const GGS_lexicalCharacterIntervalMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalCharacterIntervalMatch *) inElement.getPtr ())->mLowerBound,
                                ((cPtr_lexicalCharacterIntervalMatch *) inElement.getPtr ())->mUpperBound) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchList GGS_lexicalCharacterIntervalMatchList::
_operator_concat (const GGS_lexicalCharacterIntervalMatchList & inOperand) const {
  GGS_lexicalCharacterIntervalMatchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCharacterIntervalMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mLowerBound ;
          GGS_lchar  p_1 = p->mUpperBound ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterIntervalMatchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0,
                     const GGS_lchar & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterIntervalMatchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLowerBound,
                                _p->mUpperBound) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchList  GGS_lexicalCharacterIntervalMatchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatchList  GGS_lexicalCharacterIntervalMatchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0,
                           const GGS_lchar & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalCharacterIntervalMatchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalCharacterIntervalMatchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterIntervalMatchList::
_addModel (const GGS_lexicalCharacterIntervalMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterIntervalMatchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCharacterIntervalMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterIntervalMatchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCharacterIntervalMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterIntervalMatchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCharacterIntervalMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterIntervalMatchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCharacterIntervalMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterIntervalMatch::constructor_new (_inLexique,
       _p->mLowerBound,
       _p->mUpperBound) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch GGS_lexicalCharacterIntervalMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterIntervalMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mLowerBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mUpperBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterIntervalMatch::actualTypeName (void) const {
 return "lexicalCharacterIntervalMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterIntervalMatch * GGS_lexicalCharacterIntervalMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalStringMatchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringMatch::
cPtr_lexicalStringMatch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mString (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStringMatch * _p = dynamic_cast <const cPtr_lexicalStringMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mString._operator_isEqual (_p->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStringMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStringMatch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStringMatch::_metamodelClassID (void) const {
  return 13 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::_metamodelClassName (void) const {
  return "lexicalStringMatch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStringMatch * cPtr_lexicalStringMatch::
_cloneObject (void) const {
  cPtr_lexicalStringMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStringMatch (mString COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalStringMatchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalStringMatchList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringMatchList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringMatchList::
_addAssign_operation (const GGS_lexicalStringMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStringMatch *) inElement.getPtr ())->mString) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchList GGS_lexicalStringMatchList::
_operator_concat (const GGS_lexicalStringMatchList & inOperand) const {
  GGS_lexicalStringMatchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStringMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mString ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringMatchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringMatchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mString) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchList  GGS_lexicalStringMatchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStringMatchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatchList  GGS_lexicalStringMatchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStringMatchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStringMatchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalStringMatchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringMatchList::
_addModel (const GGS_lexicalStringMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringMatchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStringMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringMatchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStringMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringMatchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStringMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringMatchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStringMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringMatch::constructor_new (_inLexique,
       _p->mString) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStringMatch GGS_lexicalStringMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringMatch::actualTypeName (void) const {
 return "lexicalStringMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringMatch * GGS_lexicalStringMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStringMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalStringNotMatchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatch::
cPtr_lexicalStringNotMatch (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalExpression (THERE),
mString (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringNotMatch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStringNotMatch * _p = dynamic_cast <const cPtr_lexicalStringNotMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mString._operator_isEqual (_p->mString).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringNotMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStringNotMatch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStringNotMatch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStringNotMatch::_metamodelClassID (void) const {
  return 14 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::_metamodelClassName (void) const {
  return "lexicalStringNotMatch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatch * cPtr_lexicalStringNotMatch::
_cloneObject (void) const {
  cPtr_lexicalStringNotMatch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStringNotMatch (mString, mErrorMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalStringNotMatchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalStringNotMatchList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringNotMatchList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringNotMatchList::
_addAssign_operation (const GGS_lexicalStringNotMatch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStringNotMatch *) inElement.getPtr ())->mString,
                                ((cPtr_lexicalStringNotMatch *) inElement.getPtr ())->mErrorMessage) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchList GGS_lexicalStringNotMatchList::
_operator_concat (const GGS_lexicalStringNotMatchList & inOperand) const {
  GGS_lexicalStringNotMatchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStringNotMatch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mString ;
          GGS_lstring  p_1 = p->mErrorMessage ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringNotMatchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringNotMatchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mString,
                                _p->mErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchList  GGS_lexicalStringNotMatchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStringNotMatchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatchList  GGS_lexicalStringNotMatchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStringNotMatchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStringNotMatchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalStringNotMatchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStringNotMatchList::
_addModel (const GGS_lexicalStringNotMatch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringNotMatchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStringNotMatch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringNotMatchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStringNotMatch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringNotMatchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStringNotMatch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStringNotMatchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStringNotMatch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStringNotMatch::constructor_new (_inLexique,
       _p->mString,
       _p->mErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch GGS_lexicalStringNotMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringNotMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringNotMatch::actualTypeName (void) const {
 return "lexicalStringNotMatch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringNotMatch * GGS_lexicalStringNotMatch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStringNotMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalInstruction::
cPtr_lexicalInstruction (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalInstruction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalInstruction::_metamodelClassID (void) const {
  return 15 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::_metamodelClassName (void) const {
  return "lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalInstruction * cPtr_lexicalInstruction::
_cloneObject (void) const {
  cPtr_lexicalInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalInstruction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_addAssign_operation (const GGS_lexicalInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
_operator_concat (const GGS_lexicalInstructionList & inOperand) const {
  GGS_lexicalInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalInstructionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_addModel (const GGS_lexicalInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalInstruction::actualTypeName (void) const {
 return "lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalInstruction * GGS_lexicalInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalStructuredSendInstructionList'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstruction::
cPtr_lexicalStructuredSendInstruction (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mLexicalSendSearchList (argument_0),
mLexicalSendDefaultAction (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalStructuredSendInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalStructuredSendInstruction * _p = dynamic_cast <const cPtr_lexicalStructuredSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalSendSearchList._operator_isEqual (_p->mLexicalSendSearchList).boolValue ()
         && mLexicalSendDefaultAction._operator_isEqual (_p->mLexicalSendDefaultAction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStructuredSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalStructuredSendInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalSendSearchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalSendDefaultAction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStructuredSendInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalStructuredSendInstruction::_metamodelClassID (void) const {
  return 16 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::_metamodelClassName (void) const {
  return "lexicalStructuredSendInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstruction * cPtr_lexicalStructuredSendInstruction::
_cloneObject (void) const {
  cPtr_lexicalStructuredSendInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalStructuredSendInstruction (mLexicalSendSearchList, mLexicalSendDefaultAction COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@lexicalStructuredSendInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalStructuredSendInstructionList::
_internalAppendValues (const GGS_lexicalSendSearchList & argument_0,
                    const GGS_lexicalSendDefaultAction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStructuredSendInstructionList::
_internalPrependValues (const GGS_lexicalSendSearchList & argument_0,
                    const GGS_lexicalSendDefaultAction & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStructuredSendInstructionList::
_addAssign_operation (const GGS_lexicalStructuredSendInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalStructuredSendInstruction *) inElement.getPtr ())->mLexicalSendSearchList,
                                ((cPtr_lexicalStructuredSendInstruction *) inElement.getPtr ())->mLexicalSendDefaultAction) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionList GGS_lexicalStructuredSendInstructionList::
_operator_concat (const GGS_lexicalStructuredSendInstructionList & inOperand) const {
  GGS_lexicalStructuredSendInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalStructuredSendInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalSendSearchList  p_0 = p->mLexicalSendSearchList ;
          GGS_lexicalSendDefaultAction  p_1 = p->mLexicalSendDefaultAction ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStructuredSendInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalSendSearchList & argument_0,
                     const GGS_lexicalSendDefaultAction & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStructuredSendInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalSendSearchList,
                                _p->mLexicalSendDefaultAction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionList  GGS_lexicalStructuredSendInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstructionList  GGS_lexicalStructuredSendInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalSendSearchList & argument_0,
                           const GGS_lexicalSendDefaultAction & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStructuredSendInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalStructuredSendInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStructuredSendInstructionList::
_addModel (const GGS_lexicalStructuredSendInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalStructuredSendInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalStructuredSendInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStructuredSendInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalStructuredSendInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStructuredSendInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalStructuredSendInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalStructuredSendInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalStructuredSendInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalStructuredSendInstruction::constructor_new (_inLexique,
       _p->mLexicalSendSearchList,
       _p->mLexicalSendDefaultAction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction GGS_lexicalStructuredSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalSendSearchList & argument_0,
                 const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalStructuredSendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendSearchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendSearchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendDefaultAction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendDefaultAction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendDefaultAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStructuredSendInstruction::actualTypeName (void) const {
 return "lexicalStructuredSendInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStructuredSendInstruction * GGS_lexicalStructuredSendInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalSimpleSendInstructionList'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstruction::
cPtr_lexicalSimpleSendInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSimpleSendInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSimpleSendInstruction * _p = dynamic_cast <const cPtr_lexicalSimpleSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSentTerminal._operator_isEqual (_p->mSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSimpleSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSimpleSendInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSimpleSendInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSimpleSendInstruction::_metamodelClassID (void) const {
  return 17 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::_metamodelClassName (void) const {
  return "lexicalSimpleSendInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstruction * cPtr_lexicalSimpleSendInstruction::
_cloneObject (void) const {
  cPtr_lexicalSimpleSendInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSimpleSendInstruction (mSentTerminal COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@lexicalSimpleSendInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSimpleSendInstructionList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSimpleSendInstructionList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSimpleSendInstructionList::
_addAssign_operation (const GGS_lexicalSimpleSendInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSimpleSendInstruction *) inElement.getPtr ())->mSentTerminal) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionList GGS_lexicalSimpleSendInstructionList::
_operator_concat (const GGS_lexicalSimpleSendInstructionList & inOperand) const {
  GGS_lexicalSimpleSendInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSimpleSendInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSentTerminal ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSimpleSendInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSimpleSendInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSentTerminal) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionList  GGS_lexicalSimpleSendInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstructionList  GGS_lexicalSimpleSendInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSimpleSendInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSimpleSendInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSimpleSendInstructionList::
_addModel (const GGS_lexicalSimpleSendInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalSimpleSendInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSimpleSendInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSimpleSendInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSimpleSendInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSimpleSendInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSimpleSendInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSimpleSendInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSimpleSendInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSimpleSendInstruction::constructor_new (_inLexique,
       _p->mSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction GGS_lexicalSimpleSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSimpleSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSimpleSendInstruction::
reader_mSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSimpleSendInstruction *) mPointer)->mSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSimpleSendInstruction::actualTypeName (void) const {
 return "lexicalSimpleSendInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSimpleSendInstruction * GGS_lexicalSimpleSendInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSendDefaultActionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultAction::
cPtr_lexicalSendDefaultAction (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendDefaultAction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendDefaultAction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSendDefaultAction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSendDefaultAction::_metamodelClassID (void) const {
  return 18 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::_metamodelClassName (void) const {
  return "lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultAction * cPtr_lexicalSendDefaultAction::
_cloneObject (void) const {
  cPtr_lexicalSendDefaultAction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSendDefaultAction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalSendDefaultActionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSendDefaultActionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendDefaultActionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendDefaultActionList::
_addAssign_operation (const GGS_lexicalSendDefaultAction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionList GGS_lexicalSendDefaultActionList::
_operator_concat (const GGS_lexicalSendDefaultActionList & inOperand) const {
  GGS_lexicalSendDefaultActionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSendDefaultAction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendDefaultActionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendDefaultActionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionList  GGS_lexicalSendDefaultActionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSendDefaultActionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultActionList  GGS_lexicalSendDefaultActionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSendDefaultActionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSendDefaultActionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSendDefaultActionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendDefaultActionList::
_addModel (const GGS_lexicalSendDefaultAction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendDefaultActionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSendDefaultAction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendDefaultActionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSendDefaultAction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendDefaultActionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSendDefaultAction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendDefaultActionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSendDefaultAction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendDefaultAction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalSendDefaultAction::actualTypeName (void) const {
 return "lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendDefaultAction * GGS_lexicalSendDefaultAction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSendDefaultAction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalSendTerminalByDefaultList'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefault::
cPtr_lexicalSendTerminalByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalSendDefaultAction (THERE),
mDefaultSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendTerminalByDefault::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSendTerminalByDefault * _p = dynamic_cast <const cPtr_lexicalSendTerminalByDefault *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDefaultSentTerminal._operator_isEqual (_p->mDefaultSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendTerminalByDefault::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSendTerminalByDefault" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefaultSentTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSendTerminalByDefault::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSendTerminalByDefault::_metamodelClassID (void) const {
  return 19 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::_metamodelClassName (void) const {
  return "lexicalSendTerminalByDefault" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefault * cPtr_lexicalSendTerminalByDefault::
_cloneObject (void) const {
  cPtr_lexicalSendTerminalByDefault * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSendTerminalByDefault (mDefaultSentTerminal COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@lexicalSendTerminalByDefaultList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSendTerminalByDefaultList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendTerminalByDefaultList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendTerminalByDefaultList::
_addAssign_operation (const GGS_lexicalSendTerminalByDefault & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSendTerminalByDefault *) inElement.getPtr ())->mDefaultSentTerminal) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultList GGS_lexicalSendTerminalByDefaultList::
_operator_concat (const GGS_lexicalSendTerminalByDefaultList & inOperand) const {
  GGS_lexicalSendTerminalByDefaultList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSendTerminalByDefault * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mDefaultSentTerminal ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendTerminalByDefaultList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendTerminalByDefaultList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mDefaultSentTerminal) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultList  GGS_lexicalSendTerminalByDefaultList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefaultList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefaultList  GGS_lexicalSendTerminalByDefaultList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefaultList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSendTerminalByDefaultList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSendTerminalByDefaultList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendTerminalByDefaultList::
_addModel (const GGS_lexicalSendTerminalByDefault & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendTerminalByDefaultList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSendTerminalByDefault & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendTerminalByDefaultList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSendTerminalByDefault & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendTerminalByDefaultList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSendTerminalByDefault & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendTerminalByDefaultList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSendTerminalByDefault & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendTerminalByDefault::constructor_new (_inLexique,
       _p->mDefaultSentTerminal) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault GGS_lexicalSendTerminalByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendTerminalByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendTerminalByDefault::
reader_mDefaultSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendTerminalByDefault *) mPointer)->mDefaultSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendTerminalByDefault::actualTypeName (void) const {
 return "lexicalSendTerminalByDefault" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendTerminalByDefault * GGS_lexicalSendTerminalByDefault::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalErrorByDefaultList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefault::
cPtr_lexicalErrorByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalSendDefaultAction (THERE),
mDefaultErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorByDefault::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalErrorByDefault * _p = dynamic_cast <const cPtr_lexicalErrorByDefault *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDefaultErrorMessageName._operator_isEqual (_p->mDefaultErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorByDefault::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalErrorByDefault" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefaultErrorMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalErrorByDefault::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalErrorByDefault::_metamodelClassID (void) const {
  return 20 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::_metamodelClassName (void) const {
  return "lexicalErrorByDefault" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefault * cPtr_lexicalErrorByDefault::
_cloneObject (void) const {
  cPtr_lexicalErrorByDefault * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalErrorByDefault (mDefaultErrorMessageName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalErrorByDefaultList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalErrorByDefaultList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorByDefaultList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorByDefaultList::
_addAssign_operation (const GGS_lexicalErrorByDefault & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalErrorByDefault *) inElement.getPtr ())->mDefaultErrorMessageName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultList GGS_lexicalErrorByDefaultList::
_operator_concat (const GGS_lexicalErrorByDefaultList & inOperand) const {
  GGS_lexicalErrorByDefaultList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalErrorByDefault * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mDefaultErrorMessageName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorByDefaultList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorByDefaultList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mDefaultErrorMessageName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultList  GGS_lexicalErrorByDefaultList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalErrorByDefaultList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefaultList  GGS_lexicalErrorByDefaultList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalErrorByDefaultList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalErrorByDefaultList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalErrorByDefaultList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorByDefaultList::
_addModel (const GGS_lexicalErrorByDefault & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorByDefaultList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalErrorByDefault & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorByDefaultList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalErrorByDefault & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorByDefaultList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalErrorByDefault & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorByDefaultList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalErrorByDefault & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorByDefault::constructor_new (_inLexique,
       _p->mDefaultErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault GGS_lexicalErrorByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorByDefault::
reader_mDefaultErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorByDefault *) mPointer)->mDefaultErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorByDefault::actualTypeName (void) const {
 return "lexicalErrorByDefault" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorByDefault * GGS_lexicalErrorByDefault::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalErrorByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalSendSearchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendSearch::
cPtr_lexicalSendSearch (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mAttributeName (argument_0),
mSearchListName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendSearch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSendSearch * _p = dynamic_cast <const cPtr_lexicalSendSearch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue ()
         && mSearchListName._operator_isEqual (_p->mSearchListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendSearch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSendSearch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchListName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSendSearch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendSearch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSendSearch::_metamodelClassID (void) const {
  return 21 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendSearch::_metamodelClassName (void) const {
  return "lexicalSendSearch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSendSearch * cPtr_lexicalSendSearch::
_cloneObject (void) const {
  cPtr_lexicalSendSearch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSendSearch (mAttributeName, mSearchListName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalSendSearchList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_addAssign_operation (const GGS_lexicalSendSearch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSendSearch *) inElement.getPtr ())->mAttributeName,
                                ((cPtr_lexicalSendSearch *) inElement.getPtr ())->mSearchListName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
_operator_concat (const GGS_lexicalSendSearchList & inOperand) const {
  GGS_lexicalSendSearchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSendSearch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_lstring  p_1 = p->mSearchListName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeName,
                                _p->mSearchListName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalSendSearchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSendSearchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalSendSearchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSendSearchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSendSearchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSendSearchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_addModel (const GGS_lexicalSendSearch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendSearchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSendSearch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendSearchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSendSearch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendSearchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSendSearch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSendSearchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSendSearch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSendSearch::constructor_new (_inLexique,
       _p->mAttributeName,
       _p->mSearchListName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalSendSearch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSendSearch GGS_lexicalSendSearch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendSearch result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendSearch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearch::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendSearch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendSearch *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearch::
reader_mSearchListName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendSearch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendSearch *) mPointer)->mSearchListName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendSearch::actualTypeName (void) const {
 return "lexicalSendSearch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendSearch * GGS_lexicalSendSearch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSendSearch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalRepeatInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstruction::
cPtr_lexicalRepeatInstruction (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mRepeatedInstructionList (argument_0),
mLexicalWhileBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalRepeatInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalRepeatInstruction * _p = dynamic_cast <const cPtr_lexicalRepeatInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRepeatedInstructionList._operator_isEqual (_p->mRepeatedInstructionList).boolValue ()
         && mLexicalWhileBranchList._operator_isEqual (_p->mLexicalWhileBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRepeatInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalRepeatInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRepeatedInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalWhileBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalRepeatInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalRepeatInstruction::_metamodelClassID (void) const {
  return 22 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::_metamodelClassName (void) const {
  return "lexicalRepeatInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstruction * cPtr_lexicalRepeatInstruction::
_cloneObject (void) const {
  cPtr_lexicalRepeatInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalRepeatInstruction (mRepeatedInstructionList, mLexicalWhileBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalRepeatInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalRepeatInstructionList::
_internalAppendValues (const GGS_lexicalInstructionList & argument_0,
                    const GGS_lexicalWhileBranchList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRepeatInstructionList::
_internalPrependValues (const GGS_lexicalInstructionList & argument_0,
                    const GGS_lexicalWhileBranchList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRepeatInstructionList::
_addAssign_operation (const GGS_lexicalRepeatInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalRepeatInstruction *) inElement.getPtr ())->mRepeatedInstructionList,
                                ((cPtr_lexicalRepeatInstruction *) inElement.getPtr ())->mLexicalWhileBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionList GGS_lexicalRepeatInstructionList::
_operator_concat (const GGS_lexicalRepeatInstructionList & inOperand) const {
  GGS_lexicalRepeatInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalRepeatInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalInstructionList  p_0 = p->mRepeatedInstructionList ;
          GGS_lexicalWhileBranchList  p_1 = p->mLexicalWhileBranchList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRepeatInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalInstructionList & argument_0,
                     const GGS_lexicalWhileBranchList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRepeatInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRepeatedInstructionList,
                                _p->mLexicalWhileBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionList  GGS_lexicalRepeatInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalRepeatInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstructionList  GGS_lexicalRepeatInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalInstructionList & argument_0,
                           const GGS_lexicalWhileBranchList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalRepeatInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalRepeatInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalRepeatInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRepeatInstructionList::
_addModel (const GGS_lexicalRepeatInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalRepeatInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalRepeatInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalRepeatInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalRepeatInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalRepeatInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalRepeatInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalRepeatInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalRepeatInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRepeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mLexicalWhileBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction GGS_lexicalRepeatInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalInstructionList & argument_0,
                 const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRepeatInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalRepeatInstruction::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalRepeatInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRepeatInstruction::actualTypeName (void) const {
 return "lexicalRepeatInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRepeatInstruction * GGS_lexicalRepeatInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalRepeatInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalWhileBranchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalWhileBranch::
cPtr_lexicalWhileBranch (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mWhileExpression (argument_0),
mWhileInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalWhileBranch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalWhileBranch * _p = dynamic_cast <const cPtr_lexicalWhileBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mWhileInstructionList._operator_isEqual (_p->mWhileInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalWhileBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalWhileBranch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalWhileBranch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWhileBranch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalWhileBranch::_metamodelClassID (void) const {
  return 23 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWhileBranch::_metamodelClassName (void) const {
  return "lexicalWhileBranch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalWhileBranch * cPtr_lexicalWhileBranch::
_cloneObject (void) const {
  cPtr_lexicalWhileBranch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalWhileBranch (mWhileExpression, mWhileInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalWhileBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_addAssign_operation (const GGS_lexicalWhileBranch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalWhileBranch *) inElement.getPtr ())->mWhileExpression,
                                ((cPtr_lexicalWhileBranch *) inElement.getPtr ())->mWhileInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
_operator_concat (const GGS_lexicalWhileBranchList & inOperand) const {
  GGS_lexicalWhileBranchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalWhileBranch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mWhileExpression ;
          GGS_lexicalInstructionList  p_1 = p->mWhileInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mWhileExpression,
                                _p->mWhileInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalWhileBranchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalWhileBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalWhileBranchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS_lexicalInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalWhileBranchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalWhileBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalWhileBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_addModel (const GGS_lexicalWhileBranch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalWhileBranchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalWhileBranch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalWhileBranchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalWhileBranch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalWhileBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalWhileBranch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalWhileBranchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalWhileBranch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalWhileBranch::constructor_new (_inLexique,
       _p->mWhileExpression,
       _p->mWhileInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalWhileBranch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalWhileBranch GGS_lexicalWhileBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalWhileBranch result ;
  macroMyNew (result.mPointer, cPtr_lexicalWhileBranch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalWhileBranch::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWhileBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWhileBranch *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalWhileBranch::
reader_mWhileInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWhileBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWhileBranch *) mPointer)->mWhileInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalWhileBranch::actualTypeName (void) const {
 return "lexicalWhileBranch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalWhileBranch * GGS_lexicalWhileBranch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalWhileBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSelectInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstruction::
cPtr_lexicalSelectInstruction (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mLexicalWhileBranchList (argument_0),
mDefaultInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSelectInstruction * _p = dynamic_cast <const cPtr_lexicalSelectInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalWhileBranchList._operator_isEqual (_p->mLexicalWhileBranchList).boolValue ()
         && mDefaultInstructionList._operator_isEqual (_p->mDefaultInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSelectInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalWhileBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDefaultInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSelectInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSelectInstruction::_metamodelClassID (void) const {
  return 24 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::_metamodelClassName (void) const {
  return "lexicalSelectInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstruction * cPtr_lexicalSelectInstruction::
_cloneObject (void) const {
  cPtr_lexicalSelectInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSelectInstruction (mLexicalWhileBranchList, mDefaultInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalSelectInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSelectInstructionList::
_internalAppendValues (const GGS_lexicalSelectBranchList & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectInstructionList::
_internalPrependValues (const GGS_lexicalSelectBranchList & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectInstructionList::
_addAssign_operation (const GGS_lexicalSelectInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSelectInstruction *) inElement.getPtr ())->mLexicalWhileBranchList,
                                ((cPtr_lexicalSelectInstruction *) inElement.getPtr ())->mDefaultInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionList GGS_lexicalSelectInstructionList::
_operator_concat (const GGS_lexicalSelectInstructionList & inOperand) const {
  GGS_lexicalSelectInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSelectInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalSelectBranchList  p_0 = p->mLexicalWhileBranchList ;
          GGS_lexicalInstructionList  p_1 = p->mDefaultInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalSelectBranchList & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalWhileBranchList,
                                _p->mDefaultInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionList  GGS_lexicalSelectInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSelectInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstructionList  GGS_lexicalSelectInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalSelectBranchList & argument_0,
                           const GGS_lexicalInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSelectInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSelectInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSelectInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectInstructionList::
_addModel (const GGS_lexicalSelectInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSelectInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSelectInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSelectInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSelectInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectInstruction::constructor_new (_inLexique,
       _p->mLexicalWhileBranchList,
       _p->mDefaultInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction GGS_lexicalSelectInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalSelectBranchList & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalSelectInstruction::
reader_mDefaultInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mDefaultInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectInstruction::actualTypeName (void) const {
 return "lexicalSelectInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectInstruction * GGS_lexicalSelectInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSelectInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalSelectBranchList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectBranch::
cPtr_lexicalSelectBranch (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mSelectExpression (argument_0),
mSelectInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectBranch::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalSelectBranch * _p = dynamic_cast <const cPtr_lexicalSelectBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSelectExpression._operator_isEqual (_p->mSelectExpression).boolValue ()
         && mSelectInstructionList._operator_isEqual (_p->mSelectInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalSelectBranch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSelectBranch::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectBranch::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalSelectBranch::_metamodelClassID (void) const {
  return 25 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectBranch::_metamodelClassName (void) const {
  return "lexicalSelectBranch" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalSelectBranch * cPtr_lexicalSelectBranch::
_cloneObject (void) const {
  cPtr_lexicalSelectBranch * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalSelectBranch (mSelectExpression, mSelectInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalSelectBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_addAssign_operation (const GGS_lexicalSelectBranch & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalSelectBranch *) inElement.getPtr ())->mSelectExpression,
                                ((cPtr_lexicalSelectBranch *) inElement.getPtr ())->mSelectInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
_operator_concat (const GGS_lexicalSelectBranchList & inOperand) const {
  GGS_lexicalSelectBranchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalSelectBranch * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mSelectExpression ;
          GGS_lexicalInstructionList  p_1 = p->mSelectInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSelectExpression,
                                _p->mSelectInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectBranchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSelectBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectBranchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lexicalExpression & argument_0,
                           const GGS_lexicalInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalSelectBranchList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSelectBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSelectBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_addModel (const GGS_lexicalSelectBranch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectBranchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalSelectBranch & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectBranchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalSelectBranch & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalSelectBranch & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalSelectBranchList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalSelectBranch & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalSelectBranch::constructor_new (_inLexique,
       _p->mSelectExpression,
       _p->mSelectInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalSelectBranch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSelectBranch GGS_lexicalSelectBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectBranch result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectBranch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalSelectBranch::
reader_mSelectExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectBranch *) mPointer)->mSelectExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalSelectBranch::
reader_mSelectInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectBranch *) mPointer)->mSelectInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectBranch::actualTypeName (void) const {
 return "lexicalSelectBranch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectBranch * GGS_lexicalSelectBranch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalSelectBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalActionInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalActionInstruction::
cPtr_lexicalActionInstruction (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mActionName (argument_0),
mActualArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalActionInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalActionInstruction * _p = dynamic_cast <const cPtr_lexicalActionInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mActionName._operator_isEqual (_p->mActionName).boolValue ()
         && mActualArgumentList._operator_isEqual (_p->mActualArgumentList).boolValue ()
         && mErrorMessageList._operator_isEqual (_p->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalActionInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalActionInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalActionInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActionInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalActionInstruction::_metamodelClassID (void) const {
  return 26 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActionInstruction::_metamodelClassName (void) const {
  return "lexicalActionInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalActionInstruction * cPtr_lexicalActionInstruction::
_cloneObject (void) const {
  cPtr_lexicalActionInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalActionInstruction (mActionName, mActualArgumentList, mErrorMessageList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalActionInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalActionInstructionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalActualArgumentList & argument_1,
                    const GGS_lstringlist & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActionInstructionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalActualArgumentList & argument_1,
                    const GGS_lstringlist & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActionInstructionList::
_addAssign_operation (const GGS_lexicalActionInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalActionInstruction *) inElement.getPtr ())->mActionName,
                                ((cPtr_lexicalActionInstruction *) inElement.getPtr ())->mActualArgumentList,
                                ((cPtr_lexicalActionInstruction *) inElement.getPtr ())->mErrorMessageList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActionInstructionList GGS_lexicalActionInstructionList::
_operator_concat (const GGS_lexicalActionInstructionList & inOperand) const {
  GGS_lexicalActionInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalActionInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mActionName ;
          GGS_lexicalActualArgumentList  p_1 = p->mActualArgumentList ;
          GGS_lstringlist  p_2 = p->mErrorMessageList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActionInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalActualArgumentList & argument_1,
                     const GGS_lstringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActionInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mActionName,
                                _p->mActualArgumentList,
                                _p->mErrorMessageList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActionInstructionList  GGS_lexicalActionInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalActionInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActionInstructionList  GGS_lexicalActionInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lexicalActualArgumentList & argument_1,
                           const GGS_lstringlist & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalActionInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalActionInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalActionInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActionInstructionList::
_addModel (const GGS_lexicalActionInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalActionInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalActionInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalActionInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalActionInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalActionInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalActionInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalActionInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalActionInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActionInstruction::constructor_new (_inLexique,
       _p->mActionName,
       _p->mActualArgumentList,
       _p->mErrorMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalActionInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalActionInstruction GGS_lexicalActionInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalActualArgumentList & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalActionInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalActionInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalActionInstruction::
reader_mActionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mActionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalActionInstruction::
reader_mActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalActualArgumentList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalActionInstruction::
reader_mErrorMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mErrorMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalActionInstruction::actualTypeName (void) const {
 return "lexicalActionInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalActionInstruction * GGS_lexicalActionInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalActionInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalActualArgument::
cPtr_lexicalActualArgument (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalActualArgument::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalActualArgument::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalActualArgument" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalActualArgument::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActualArgument::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalActualArgument::_metamodelClassID (void) const {
  return 27 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActualArgument::_metamodelClassName (void) const {
  return "lexicalActualArgument" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalActualArgument * cPtr_lexicalActualArgument::
_cloneObject (void) const {
  cPtr_lexicalActualArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalActualArgument (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalActualArgumentList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_addAssign_operation (const GGS_lexicalActualArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList GGS_lexicalActualArgumentList::
_operator_concat (const GGS_lexicalActualArgumentList & inOperand) const {
  GGS_lexicalActualArgumentList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalActualArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalActualArgumentList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalActualArgumentList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalActualArgumentList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalActualArgumentList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalActualArgumentList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalActualArgumentList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_addModel (const GGS_lexicalActualArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalActualArgumentList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalActualArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalActualArgumentList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalActualArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalActualArgumentList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalActualArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalActualArgumentList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalActualArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalActualArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalActualArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_lexicalActualArgument::actualTypeName (void) const {
 return "lexicalActualArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalActualArgument * GGS_lexicalActualArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalActualArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalAttributeArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeArgument::
cPtr_lexicalAttributeArgument (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE),
mAttributeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeArgument::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalAttributeArgument * _p = dynamic_cast <const cPtr_lexicalAttributeArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalAttributeArgument" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalAttributeArgument::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeArgument::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalAttributeArgument::_metamodelClassID (void) const {
  return 28 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeArgument::_metamodelClassName (void) const {
  return "lexicalAttributeArgument" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalAttributeArgument * cPtr_lexicalAttributeArgument::
_cloneObject (void) const {
  cPtr_lexicalAttributeArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalAttributeArgument (mAttributeName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalAttributeArgumentList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalAttributeArgumentList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeArgumentList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeArgumentList::
_addAssign_operation (const GGS_lexicalAttributeArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalAttributeArgument *) inElement.getPtr ())->mAttributeName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgumentList GGS_lexicalAttributeArgumentList::
_operator_concat (const GGS_lexicalAttributeArgumentList & inOperand) const {
  GGS_lexicalAttributeArgumentList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalAttributeArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeArgumentList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgumentList  GGS_lexicalAttributeArgumentList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalAttributeArgumentList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgumentList  GGS_lexicalAttributeArgumentList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalAttributeArgumentList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalAttributeArgumentList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalAttributeArgumentList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeArgumentList::
_addModel (const GGS_lexicalAttributeArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeArgumentList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalAttributeArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeArgumentList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalAttributeArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeArgumentList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalAttributeArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalAttributeArgumentList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalAttributeArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalAttributeArgument::constructor_new (_inLexique,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalAttributeArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgument GGS_lexicalAttributeArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeArgument::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeArgument *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeArgument::actualTypeName (void) const {
 return "lexicalAttributeArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeArgument * GGS_lexicalAttributeArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalAttributeArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalCharacterArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterArgument::
cPtr_lexicalCharacterArgument (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterArgument::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalCharacterArgument * _p = dynamic_cast <const cPtr_lexicalCharacterArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCharacterArgument" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCharacterArgument::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterArgument::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCharacterArgument::_metamodelClassID (void) const {
  return 29 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterArgument::_metamodelClassName (void) const {
  return "lexicalCharacterArgument" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCharacterArgument * cPtr_lexicalCharacterArgument::
_cloneObject (void) const {
  cPtr_lexicalCharacterArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCharacterArgument (mCharacter COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalCharacterArgumentList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalCharacterArgumentList::
_internalAppendValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterArgumentList::
_internalPrependValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterArgumentList::
_addAssign_operation (const GGS_lexicalCharacterArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalCharacterArgument *) inElement.getPtr ())->mCharacter) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgumentList GGS_lexicalCharacterArgumentList::
_operator_concat (const GGS_lexicalCharacterArgumentList & inOperand) const {
  GGS_lexicalCharacterArgumentList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCharacterArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mCharacter ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterArgumentList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCharacter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgumentList  GGS_lexicalCharacterArgumentList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCharacterArgumentList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgumentList  GGS_lexicalCharacterArgumentList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCharacterArgumentList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalCharacterArgumentList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalCharacterArgumentList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCharacterArgumentList::
_addModel (const GGS_lexicalCharacterArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterArgumentList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCharacterArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterArgumentList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCharacterArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterArgumentList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCharacterArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCharacterArgumentList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCharacterArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCharacterArgument::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgument GGS_lexicalCharacterArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterArgument::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterArgument *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterArgument::actualTypeName (void) const {
 return "lexicalCharacterArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterArgument * GGS_lexicalCharacterArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCharacterArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalCurrentCharacterArgumentList'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterArgument::
cPtr_lexicalCurrentCharacterArgument (LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalCurrentCharacterArgument::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCurrentCharacterArgument::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalCurrentCharacterArgument" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCurrentCharacterArgument::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterArgument::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalCurrentCharacterArgument::_metamodelClassID (void) const {
  return 30 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterArgument::_metamodelClassName (void) const {
  return "lexicalCurrentCharacterArgument" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterArgument * cPtr_lexicalCurrentCharacterArgument::
_cloneObject (void) const {
  cPtr_lexicalCurrentCharacterArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalCurrentCharacterArgument (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@lexicalCurrentCharacterArgumentList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalCurrentCharacterArgumentList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCurrentCharacterArgumentList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCurrentCharacterArgumentList::
_addAssign_operation (const GGS_lexicalCurrentCharacterArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgumentList GGS_lexicalCurrentCharacterArgumentList::
_operator_concat (const GGS_lexicalCurrentCharacterArgumentList & inOperand) const {
  GGS_lexicalCurrentCharacterArgumentList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalCurrentCharacterArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCurrentCharacterArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalCurrentCharacterArgumentList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgumentList  GGS_lexicalCurrentCharacterArgumentList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterArgumentList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgumentList  GGS_lexicalCurrentCharacterArgumentList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterArgumentList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalCurrentCharacterArgumentList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalCurrentCharacterArgumentList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalCurrentCharacterArgumentList::
_addModel (const GGS_lexicalCurrentCharacterArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalCurrentCharacterArgumentList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalCurrentCharacterArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCurrentCharacterArgumentList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalCurrentCharacterArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCurrentCharacterArgumentList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalCurrentCharacterArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalCurrentCharacterArgumentList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalCurrentCharacterArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalCurrentCharacterArgument::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalCurrentCharacterArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgument GGS_lexicalCurrentCharacterArgument::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCurrentCharacterArgument (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCurrentCharacterArgument::actualTypeName (void) const {
 return "lexicalCurrentCharacterArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCurrentCharacterArgument * GGS_lexicalCurrentCharacterArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalCurrentCharacterArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalFunctionArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFunctionArgument::
cPtr_lexicalFunctionArgument (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalActualArgument (THERE),
mFunctionName (argument_0),
mFunctionActualArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalFunctionArgument::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalFunctionArgument * _p = dynamic_cast <const cPtr_lexicalFunctionArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFunctionName._operator_isEqual (_p->mFunctionName).boolValue ()
         && mFunctionActualArgumentList._operator_isEqual (_p->mFunctionActualArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFunctionArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalFunctionArgument" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFunctionName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFunctionActualArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalFunctionArgument::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionArgument::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalFunctionArgument::_metamodelClassID (void) const {
  return 31 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionArgument::_metamodelClassName (void) const {
  return "lexicalFunctionArgument" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalFunctionArgument * cPtr_lexicalFunctionArgument::
_cloneObject (void) const {
  cPtr_lexicalFunctionArgument * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalFunctionArgument (mFunctionName, mFunctionActualArgumentList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalFunctionArgumentList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalFunctionArgumentList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalActualArgumentList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionArgumentList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalActualArgumentList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionArgumentList::
_addAssign_operation (const GGS_lexicalFunctionArgument & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalFunctionArgument *) inElement.getPtr ())->mFunctionName,
                                ((cPtr_lexicalFunctionArgument *) inElement.getPtr ())->mFunctionActualArgumentList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgumentList GGS_lexicalFunctionArgumentList::
_operator_concat (const GGS_lexicalFunctionArgumentList & inOperand) const {
  GGS_lexicalFunctionArgumentList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalFunctionArgument * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFunctionName ;
          GGS_lexicalActualArgumentList  p_1 = p->mFunctionActualArgumentList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalActualArgumentList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionArgumentList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFunctionName,
                                _p->mFunctionActualArgumentList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgumentList  GGS_lexicalFunctionArgumentList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalFunctionArgumentList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgumentList  GGS_lexicalFunctionArgumentList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lexicalActualArgumentList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalFunctionArgumentList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalFunctionArgumentList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalFunctionArgumentList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionArgumentList::
_addModel (const GGS_lexicalFunctionArgument & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalFunctionArgumentList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalFunctionArgument & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalFunctionArgumentList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalFunctionArgument & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalFunctionArgumentList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalFunctionArgument & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalFunctionArgumentList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalFunctionArgument & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalFunctionArgument::constructor_new (_inLexique,
       _p->mFunctionName,
       _p->mFunctionActualArgumentList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalFunctionArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgument GGS_lexicalFunctionArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalFunctionArgument (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalFunctionArgument::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionArgument *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalFunctionArgument::
reader_mFunctionActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalActualArgumentList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionArgument *) mPointer)->mFunctionActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFunctionArgument::actualTypeName (void) const {
 return "lexicalFunctionArgument" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFunctionArgument * GGS_lexicalFunctionArgument::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalFunctionArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalDropInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalDropInstruction::
cPtr_lexicalDropInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mTerminalName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalDropInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalDropInstruction * _p = dynamic_cast <const cPtr_lexicalDropInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTerminalName._operator_isEqual (_p->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalDropInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalDropInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalDropInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalDropInstruction::_metamodelClassID (void) const {
  return 32 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::_metamodelClassName (void) const {
  return "lexicalDropInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalDropInstruction * cPtr_lexicalDropInstruction::
_cloneObject (void) const {
  cPtr_lexicalDropInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalDropInstruction (mTerminalName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalDropInstructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalDropInstructionList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalDropInstructionList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalDropInstructionList::
_addAssign_operation (const GGS_lexicalDropInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalDropInstruction *) inElement.getPtr ())->mTerminalName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionList GGS_lexicalDropInstructionList::
_operator_concat (const GGS_lexicalDropInstructionList & inOperand) const {
  GGS_lexicalDropInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalDropInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTerminalName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalDropInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalDropInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTerminalName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionList  GGS_lexicalDropInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalDropInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstructionList  GGS_lexicalDropInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalDropInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalDropInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalDropInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalDropInstructionList::
_addModel (const GGS_lexicalDropInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalDropInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalDropInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalDropInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalDropInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalDropInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalDropInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalDropInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalDropInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalDropInstruction::constructor_new (_inLexique,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction GGS_lexicalDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalDropInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalDropInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalDropInstruction::actualTypeName (void) const {
 return "lexicalDropInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalDropInstruction * GGS_lexicalDropInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalErrorInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstruction::
cPtr_lexicalErrorInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalErrorInstruction * _p = dynamic_cast <const cPtr_lexicalErrorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorMessageName._operator_isEqual (_p->mErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalErrorInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalErrorInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalErrorInstruction::_metamodelClassID (void) const {
  return 33 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::_metamodelClassName (void) const {
  return "lexicalErrorInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstruction * cPtr_lexicalErrorInstruction::
_cloneObject (void) const {
  cPtr_lexicalErrorInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalErrorInstruction (mErrorMessageName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalErrorInstructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalErrorInstructionList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorInstructionList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorInstructionList::
_addAssign_operation (const GGS_lexicalErrorInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalErrorInstruction *) inElement.getPtr ())->mErrorMessageName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionList GGS_lexicalErrorInstructionList::
_operator_concat (const GGS_lexicalErrorInstructionList & inOperand) const {
  GGS_lexicalErrorInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalErrorInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mErrorMessageName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mErrorMessageName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionList  GGS_lexicalErrorInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalErrorInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstructionList  GGS_lexicalErrorInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalErrorInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalErrorInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalErrorInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorInstructionList::
_addModel (const GGS_lexicalErrorInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalErrorInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalErrorInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalErrorInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalErrorInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalErrorInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalErrorInstruction::constructor_new (_inLexique,
       _p->mErrorMessageName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction GGS_lexicalErrorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorInstruction::
reader_mErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorInstruction *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorInstruction::actualTypeName (void) const {
 return "lexicalErrorInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorInstruction * GGS_lexicalErrorInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalTagInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalTagInstruction::
cPtr_lexicalTagInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mTagName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalTagInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalTagInstruction * _p = dynamic_cast <const cPtr_lexicalTagInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTagName._operator_isEqual (_p->mTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalTagInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalTagInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTagName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalTagInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalTagInstruction::_metamodelClassID (void) const {
  return 34 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::_metamodelClassName (void) const {
  return "lexicalTagInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalTagInstruction * cPtr_lexicalTagInstruction::
_cloneObject (void) const {
  cPtr_lexicalTagInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalTagInstruction (mTagName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalTagInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalTagInstructionList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTagInstructionList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTagInstructionList::
_addAssign_operation (const GGS_lexicalTagInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalTagInstruction *) inElement.getPtr ())->mTagName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionList GGS_lexicalTagInstructionList::
_operator_concat (const GGS_lexicalTagInstructionList & inOperand) const {
  GGS_lexicalTagInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalTagInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTagName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTagInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalTagInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTagName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionList  GGS_lexicalTagInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalTagInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstructionList  GGS_lexicalTagInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalTagInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalTagInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalTagInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTagInstructionList::
_addModel (const GGS_lexicalTagInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalTagInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalTagInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalTagInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalTagInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalTagInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalTagInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalTagInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalTagInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalTagInstruction::constructor_new (_inLexique,
       _p->mTagName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction GGS_lexicalTagInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalTagInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalTagInstruction::
reader_mTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalTagInstruction *) mPointer)->mTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalTagInstruction::actualTypeName (void) const {
 return "lexicalTagInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalTagInstruction * GGS_lexicalTagInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalTagInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalRewindInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstruction::
cPtr_lexicalRewindInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE),
mTagName (argument_0),
mTerminalName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalRewindInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lexicalRewindInstruction * _p = dynamic_cast <const cPtr_lexicalRewindInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTagName._operator_isEqual (_p->mTagName).boolValue ()
         && mTerminalName._operator_isEqual (_p->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRewindInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalRewindInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTagName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalRewindInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalRewindInstruction::_metamodelClassID (void) const {
  return 35 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::_metamodelClassName (void) const {
  return "lexicalRewindInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstruction * cPtr_lexicalRewindInstruction::
_cloneObject (void) const {
  cPtr_lexicalRewindInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalRewindInstruction (mTagName, mTerminalName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@lexicalRewindInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalRewindInstructionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRewindInstructionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRewindInstructionList::
_addAssign_operation (const GGS_lexicalRewindInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lexicalRewindInstruction *) inElement.getPtr ())->mTagName,
                                ((cPtr_lexicalRewindInstruction *) inElement.getPtr ())->mTerminalName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionList GGS_lexicalRewindInstructionList::
_operator_concat (const GGS_lexicalRewindInstructionList & inOperand) const {
  GGS_lexicalRewindInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalRewindInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTagName ;
          GGS_lstring  p_1 = p->mTerminalName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRewindInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRewindInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTagName,
                                _p->mTerminalName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionList  GGS_lexicalRewindInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalRewindInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstructionList  GGS_lexicalRewindInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalRewindInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalRewindInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalRewindInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRewindInstructionList::
_addModel (const GGS_lexicalRewindInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalRewindInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalRewindInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalRewindInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalRewindInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalRewindInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalRewindInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalRewindInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalRewindInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalRewindInstruction::constructor_new (_inLexique,
       _p->mTagName,
       _p->mTerminalName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction GGS_lexicalRewindInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRewindInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRewindInstruction::actualTypeName (void) const {
 return "lexicalRewindInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRewindInstruction * GGS_lexicalRewindInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalRewindInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalLogInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalLogInstruction::
cPtr_lexicalLogInstruction (LOCATION_ARGS) :
cPtr_lexicalInstruction (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_lexicalLogInstruction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalLogInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalLogInstruction::_metamodelComponentIndex (void) const {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::_metamodelComponentName (void) const {
  return gMetamodelManager.mMetamodelComponentName ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_lexicalLogInstruction::_metamodelClassID (void) const {
  return 36 ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::_metamodelClassName (void) const {
  return "lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

cPtr_lexicalLogInstruction * cPtr_lexicalLogInstruction::
_cloneObject (void) const {
  cPtr_lexicalLogInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_lexicalLogInstruction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalLogInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalLogInstructionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalLogInstructionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalLogInstructionList::
_addAssign_operation (const GGS_lexicalLogInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionList GGS_lexicalLogInstructionList::
_operator_concat (const GGS_lexicalLogInstructionList & inOperand) const {
  GGS_lexicalLogInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lexicalLogInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalLogInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalLogInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionList  GGS_lexicalLogInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalLogInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstructionList  GGS_lexicalLogInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalLogInstructionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalLogInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalLogInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalLogInstructionList::
_addModel (const GGS_lexicalLogInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lexicalLogInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalLogInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalLogInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalLogInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalLogInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lexicalLogInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lexicalLogInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lexicalLogInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lexicalLogInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction GGS_lexicalLogInstruction::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalLogInstruction (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalLogInstruction::actualTypeName (void) const {
 return "lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalLogInstruction * GGS_lexicalLogInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lexicalLogInstruction *) mPointer ;
  }
#endif

