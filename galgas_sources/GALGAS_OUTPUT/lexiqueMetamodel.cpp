//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'lexiqueMetamodel.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 21th, 2009, at 15h9'39"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "lexiqueMetamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueMetamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@templateDelimitorList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateDelimitorList::
elementOf_GGS_templateDelimitorList (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mStartString (argument_0),
mOptionList (argument_1),
mEndString (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateDelimitorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateDelimitorList * _p = dynamic_cast <const elementOf_GGS_templateDelimitorList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStartString._operator_isEqual (_p->mStartString).boolValue ()
         && mOptionList._operator_isEqual (_p->mOptionList).boolValue ()
         && mEndString._operator_isEqual (_p->mEndString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateDelimitorList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@templateDelimitorList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateDelimitorList GGS_templateDelimitorList::
_operator_concat (const GGS_templateDelimitorList & inOperand) const {
  GGS_templateDelimitorList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
_dotAssign_operation (const GGS_templateDelimitorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_templateDelimitorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mStartString ;
          GGS_lstringlist  p_1 = p->mOptionList ;
          GGS_lstring  p_2 = p->mEndString ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mStartString,
                                _p->mOptionList,
                                _p->mEndString
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateDelimitorList  GGS_templateDelimitorList::
constructor_emptyList (void) {
  GGS_templateDelimitorList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimitorList  GGS_templateDelimitorList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_templateDelimitorList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
internalSubListWithRange (GGS_templateDelimitorList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mStartString, _p->mOptionList, _p->mEndString) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateDelimitorList GGS_templateDelimitorList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateDelimitorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimitorList GGS_templateDelimitorList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateDelimitorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateDelimitorList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@templateDelimitorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStartString ;
    _out_1 = _p->mOptionList ;
    _out_2 = _p->mEndString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStartString ;
    _out_1 = _p->mOptionList ;
    _out_2 = _p->mEndString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStartString ;
    _out_1 = _p->mOptionList ;
    _out_2 = _p->mEndString ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStartString ;
    _out_1 = _p->mOptionList ;
    _out_2 = _p->mEndString ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateDelimitorList::
reader_mStartStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStartString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_templateDelimitorList::
reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateDelimitorList::
reader_mEndStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
modifier_setMStartStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStartString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimitorList::
modifier_setMEndStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateDelimitorList::cEnumerator::_mStartString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mStartString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_templateDelimitorList::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateDelimitorList::cEnumerator::_mEndString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEndString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@templateReplacementList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateReplacementList::
elementOf_GGS_templateReplacementList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMatchString (argument_0),
mReplacementString (argument_1),
mReplacementFunction (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateReplacementList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateReplacementList * _p = dynamic_cast <const elementOf_GGS_templateReplacementList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchString._operator_isEqual (_p->mMatchString).boolValue ()
         && mReplacementString._operator_isEqual (_p->mReplacementString).boolValue ()
         && mReplacementFunction._operator_isEqual (_p->mReplacementFunction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateReplacementList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReplacementString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReplacementFunction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@templateReplacementList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList GGS_templateReplacementList::
_operator_concat (const GGS_templateReplacementList & inOperand) const {
  GGS_templateReplacementList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
_dotAssign_operation (const GGS_templateReplacementList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_templateReplacementList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMatchString ;
          GGS_lstring  p_1 = p->mReplacementString ;
          GGS_lstring  p_2 = p->mReplacementFunction ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMatchString,
                                _p->mReplacementString,
                                _p->mReplacementFunction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList  GGS_templateReplacementList::
constructor_emptyList (void) {
  GGS_templateReplacementList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList  GGS_templateReplacementList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_templateReplacementList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
internalSubListWithRange (GGS_templateReplacementList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMatchString, _p->mReplacementString, _p->mReplacementFunction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList GGS_templateReplacementList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateReplacementList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList GGS_templateReplacementList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateReplacementList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateReplacementList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@templateReplacementList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchString ;
    _out_1 = _p->mReplacementString ;
    _out_2 = _p->mReplacementFunction ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchString ;
    _out_1 = _p->mReplacementString ;
    _out_2 = _p->mReplacementFunction ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchString ;
    _out_1 = _p->mReplacementString ;
    _out_2 = _p->mReplacementFunction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchString ;
    _out_1 = _p->mReplacementString ;
    _out_2 = _p->mReplacementFunction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementList::
reader_mMatchStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementList::
reader_mReplacementStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReplacementString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementList::
reader_mReplacementFunctionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReplacementFunction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_setMMatchStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_setMReplacementStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReplacementString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_setMReplacementFunctionAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReplacementFunction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementList::cEnumerator::_mMatchString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mMatchString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementList::cEnumerator::_mReplacementString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mReplacementString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementList::cEnumerator::_mReplacementFunction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mReplacementFunction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalImplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalImplicitRuleList::
elementOf_GGS_lexicalImplicitRuleList (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mListName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalImplicitRuleList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalImplicitRuleList * _p = dynamic_cast <const elementOf_GGS_lexicalImplicitRuleList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListName._operator_isEqual (_p->mListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalImplicitRuleList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mListName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalImplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_internalAppendValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_internalPrependValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList GGS_lexicalImplicitRuleList::
_operator_concat (const GGS_lexicalImplicitRuleList & inOperand) const {
  GGS_lexicalImplicitRuleList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_dotAssign_operation (const GGS_lexicalImplicitRuleList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalImplicitRuleList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mListName ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mListName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList  GGS_lexicalImplicitRuleList::
constructor_emptyList (void) {
  GGS_lexicalImplicitRuleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList  GGS_lexicalImplicitRuleList::
constructor_listWithValue (const GGS_lstring & argument_0) {
  GGS_lexicalImplicitRuleList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
internalSubListWithRange (GGS_lexicalImplicitRuleList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mListName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList GGS_lexicalImplicitRuleList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalImplicitRuleList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList GGS_lexicalImplicitRuleList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalImplicitRuleList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalImplicitRuleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalImplicitRuleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalImplicitRuleList::
reader_mListNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mListName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalImplicitRuleList::
modifier_setMListNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mListName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalImplicitRuleList::cEnumerator::_mListName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mListName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalErrorMessageDeclarationList'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalErrorMessageDeclarationList::
elementOf_GGS_lexicalErrorMessageDeclarationList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalErrorMessageDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalErrorMessageDeclarationList * _p = dynamic_cast <const elementOf_GGS_lexicalErrorMessageDeclarationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalErrorMessageDeclarationList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@lexicalErrorMessageDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList GGS_lexicalErrorMessageDeclarationList::
_operator_concat (const GGS_lexicalErrorMessageDeclarationList & inOperand) const {
  GGS_lexicalErrorMessageDeclarationList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_dotAssign_operation (const GGS_lexicalErrorMessageDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalErrorMessageDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList  GGS_lexicalErrorMessageDeclarationList::
constructor_emptyList (void) {
  GGS_lexicalErrorMessageDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList  GGS_lexicalErrorMessageDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalErrorMessageDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
internalSubListWithRange (GGS_lexicalErrorMessageDeclarationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMessageName, _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList GGS_lexicalErrorMessageDeclarationList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalErrorMessageDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList GGS_lexicalErrorMessageDeclarationList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalErrorMessageDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalErrorMessageDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalErrorMessageDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorMessageDeclarationList::
reader_mMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorMessageDeclarationList::
reader_mMessageValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
modifier_setMMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalErrorMessageDeclarationList::
modifier_setMMessageValueAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalErrorMessageDeclarationList::cEnumerator::_mMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalErrorMessageDeclarationList::cEnumerator::_mMessageValue (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mMessageValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalAttributeList::
elementOf_GGS_lexicalAttributeList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTypeName (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalAttributeList * _p = dynamic_cast <const elementOf_GGS_lexicalAttributeList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalAttributeList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalAttributeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
_operator_concat (const GGS_lexicalAttributeList & inOperand) const {
  GGS_lexicalAttributeList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_dotAssign_operation (const GGS_lexicalAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexicalAttributeList::
constructor_emptyList (void) {
  GGS_lexicalAttributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexicalAttributeList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalAttributeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
internalSubListWithRange (GGS_lexicalAttributeList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mTypeName, _p->mName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalAttributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalAttributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeList::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalAttributeList::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalAttributeList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalStyleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalStyleList::
elementOf_GGS_lexicalStyleList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalStyleList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalStyleList * _p = dynamic_cast <const elementOf_GGS_lexicalStyleList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mComment._operator_isEqual (_p->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalStyleList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@lexicalStyleList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
_operator_concat (const GGS_lexicalStyleList & inOperand) const {
  GGS_lexicalStyleList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_dotAssign_operation (const GGS_lexicalStyleList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalStyleList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mComment ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mComment
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexicalStyleList::
constructor_emptyList (void) {
  GGS_lexicalStyleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexicalStyleList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalStyleList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
internalSubListWithRange (GGS_lexicalStyleList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mName, _p->mComment) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalStyleList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalStyleList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStyleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalStyleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mComment ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mComment ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyleList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyleList::
reader_mCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_setMCommentAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalStyleList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalStyleList::cEnumerator::_mComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mComment ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@terminalDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_terminalDeclarationList::
elementOf_GGS_terminalDeclarationList (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mSentAttributeList (argument_1),
mErrorMessage (argument_2),
mStyle (argument_3),
mOptionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_terminalDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_terminalDeclarationList * _p = dynamic_cast <const elementOf_GGS_terminalDeclarationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mSentAttributeList._operator_isEqual (_p->mSentAttributeList).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mStyle._operator_isEqual (_p->mStyle).boolValue ()
         && mOptionList._operator_isEqual (_p->mOptionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_terminalDeclarationList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@terminalDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_lstringlist & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_lstringlist & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
_operator_concat (const GGS_terminalDeclarationList & inOperand) const {
  GGS_terminalDeclarationList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_dotAssign_operation (const GGS_terminalDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_terminalDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstringlist  p_1 = p->mSentAttributeList ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mStyle ;
          GGS_lstringlist  p_4 = p->mOptionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_lstringlist & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mSentAttributeList,
                                _p->mErrorMessage,
                                _p->mStyle,
                                _p->mOptionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_terminalDeclarationList::
constructor_emptyList (void) {
  GGS_terminalDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_terminalDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) {
  GGS_terminalDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
internalSubListWithRange (GGS_terminalDeclarationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mName, _p->mSentAttributeList, _p->mErrorMessage, _p->mStyle, _p->mOptionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@terminalDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_lstringlist & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSentAttributeList ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mStyle ;
    _out_4 = _p->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_lstringlist & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSentAttributeList ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mStyle ;
    _out_4 = _p->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_lstringlist & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSentAttributeList ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mStyle ;
    _out_4 = _p->mOptionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_lstringlist & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mSentAttributeList ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mStyle ;
    _out_4 = _p->mOptionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclarationList::
reader_mSentAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSentAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationList::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationList::
reader_mStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclarationList::
reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMSentAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSentAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMStyleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_terminalDeclarationList::cEnumerator::_mSentAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSentAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationList::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationList::cEnumerator::_mStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_terminalDeclarationList::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalListEntryList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalListEntryList::
elementOf_GGS_lexicalListEntryList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntrySpelling (argument_0),
mTerminalSpelling (argument_1),
mOptionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalListEntryList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalListEntryList * _p = dynamic_cast <const elementOf_GGS_lexicalListEntryList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntrySpelling._operator_isEqual (_p->mEntrySpelling).boolValue ()
         && mTerminalSpelling._operator_isEqual (_p->mTerminalSpelling).boolValue ()
         && mOptionList._operator_isEqual (_p->mOptionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalListEntryList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntrySpelling.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalSpelling.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalListEntryList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
_operator_concat (const GGS_lexicalListEntryList & inOperand) const {
  GGS_lexicalListEntryList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_dotAssign_operation (const GGS_lexicalListEntryList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalListEntryList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEntrySpelling ;
          GGS_lstring  p_1 = p->mTerminalSpelling ;
          GGS_lstringlist  p_2 = p->mOptionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntrySpelling,
                                _p->mTerminalSpelling,
                                _p->mOptionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListEntryList::
constructor_emptyList (void) {
  GGS_lexicalListEntryList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListEntryList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  GGS_lexicalListEntryList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
internalSubListWithRange (GGS_lexicalListEntryList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEntrySpelling, _p->mTerminalSpelling, _p->mOptionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListEntryList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalListEntryList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstringlist & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntrySpelling ;
    _out_1 = _p->mTerminalSpelling ;
    _out_2 = _p->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstringlist & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntrySpelling ;
    _out_1 = _p->mTerminalSpelling ;
    _out_2 = _p->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstringlist & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntrySpelling ;
    _out_1 = _p->mTerminalSpelling ;
    _out_2 = _p->mOptionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstringlist & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntrySpelling ;
    _out_1 = _p->mTerminalSpelling ;
    _out_2 = _p->mOptionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntryList::
reader_mEntrySpellingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntrySpelling ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntryList::
reader_mTerminalSpellingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminalSpelling ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListEntryList::
reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_setMEntrySpellingAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntrySpelling = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_setMTerminalSpellingAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminalSpelling = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListEntryList::cEnumerator::_mEntrySpelling (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEntrySpelling ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListEntryList::cEnumerator::_mTerminalSpelling (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTerminalSpelling ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_lexicalListEntryList::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalListDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalListDeclarationList::
elementOf_GGS_lexicalListDeclarationList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mStyle (argument_1),
mErrorMessage (argument_2),
mSentAttributeList (argument_3),
mEntryList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalListDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalListDeclarationList * _p = dynamic_cast <const elementOf_GGS_lexicalListDeclarationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mName._operator_isEqual (_p->mName).boolValue ()
         && mStyle._operator_isEqual (_p->mStyle).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mSentAttributeList._operator_isEqual (_p->mSentAttributeList).boolValue ()
         && mEntryList._operator_isEqual (_p->mEntryList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalListDeclarationList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntryList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalListDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
_operator_concat (const GGS_lexicalListDeclarationList & inOperand) const {
  GGS_lexicalListDeclarationList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_dotAssign_operation (const GGS_lexicalListDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalListDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mStyle ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstringlist  p_3 = p->mSentAttributeList ;
          GGS_lexicalListEntryList  p_4 = p->mEntryList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS_lexicalListEntryList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mName,
                                _p->mStyle,
                                _p->mErrorMessage,
                                _p->mSentAttributeList,
                                _p->mEntryList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexicalListDeclarationList::
constructor_emptyList (void) {
  GGS_lexicalListDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexicalListDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) {
  GGS_lexicalListDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
internalSubListWithRange (GGS_lexicalListDeclarationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mName, _p->mStyle, _p->mErrorMessage, _p->mSentAttributeList, _p->mEntryList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalListDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstringlist & _out_3,
              GGS_lexicalListEntryList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mStyle ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mSentAttributeList ;
    _out_4 = _p->mEntryList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstringlist & _out_3,
             GGS_lexicalListEntryList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mStyle ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mSentAttributeList ;
    _out_4 = _p->mEntryList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstringlist & _out_3,
                 GGS_lexicalListEntryList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mStyle ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mSentAttributeList ;
    _out_4 = _p->mEntryList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstringlist & _out_3,
                GGS_lexicalListEntryList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mName ;
    _out_1 = _p->mStyle ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mSentAttributeList ;
    _out_4 = _p->mEntryList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationList::
reader_mStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationList::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListDeclarationList::
reader_mSentAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSentAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListDeclarationList::
reader_mEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMStyleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMSentAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSentAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalListEntryList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationList::cEnumerator::_mStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationList::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_lexicalListDeclarationList::cEnumerator::_mSentAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSentAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalListEntryList  & GGS_lexicalListDeclarationList::cEnumerator::_mEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEntryList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_lexicalExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExpression::
cPtr_lexicalExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExpression * GGS_lexicalExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lexicalExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalExpression (& typeid (cPtr_lexicalExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalExpression::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalExpression::
GGS_lexicalExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression::
GGS_lexicalExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalExpression GGS_lexicalExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalExpression *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExpression::actualTypeName (void) const {
  return "lexicalExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalExpression::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalExpression ("lexicalExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalExplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalExplicitRuleList::
elementOf_GGS_lexicalExplicitRuleList (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexicalRuleExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalExplicitRuleList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalExplicitRuleList * _p = dynamic_cast <const elementOf_GGS_lexicalExplicitRuleList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalRuleExpression._operator_isEqual (_p->mLexicalRuleExpression).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalExplicitRuleList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRuleExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalExplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList GGS_lexicalExplicitRuleList::
_operator_concat (const GGS_lexicalExplicitRuleList & inOperand) const {
  GGS_lexicalExplicitRuleList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_dotAssign_operation (const GGS_lexicalExplicitRuleList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalExplicitRuleList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mLexicalRuleExpression ;
          GGS_lexicalInstructionList  p_1 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalRuleExpression,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList  GGS_lexicalExplicitRuleList::
constructor_emptyList (void) {
  GGS_lexicalExplicitRuleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList  GGS_lexicalExplicitRuleList::
constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  GGS_lexicalExplicitRuleList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
internalSubListWithRange (GGS_lexicalExplicitRuleList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mLexicalRuleExpression, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList GGS_lexicalExplicitRuleList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExplicitRuleList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList GGS_lexicalExplicitRuleList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExplicitRuleList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExplicitRuleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalExplicitRuleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExpression & _out_0,
              GGS_lexicalInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalRuleExpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExpression & _out_0,
             GGS_lexicalInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalRuleExpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lexicalExpression & _out_0,
                 GGS_lexicalInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalRuleExpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lexicalExpression & _out_0,
                GGS_lexicalInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalRuleExpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalExplicitRuleList::
reader_mLexicalRuleExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRuleExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalExplicitRuleList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
modifier_setMLexicalRuleExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRuleExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExplicitRuleList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpression  & GGS_lexicalExplicitRuleList::cEnumerator::_mLexicalRuleExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLexicalRuleExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionList  & GGS_lexicalExplicitRuleList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalOrExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalOrExpression::
cPtr_lexicalOrExpression (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalOrExpression * GGS_lexicalOrExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalOrExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalOrExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalOrExpression * _p = dynamic_cast <const cPtr_lexicalOrExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLeftOperand._operator_isEqual (_p->mLeftOperand).boolValue ()
         && mRightOperand._operator_isEqual (_p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalOrExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalOrExpression:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalOrExpression (& typeid (cPtr_lexicalOrExpression), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalOrExpression::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalOrExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalOrExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalOrExpression (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalOrExpression::
GGS_lexicalOrExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpression::
GGS_lexicalOrExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalOrExpression GGS_lexicalOrExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalOrExpression *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalOrExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalOrExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalOrExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpression GGS_lexicalOrExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpression result ;
  macroMyNew (result.mPointer, cPtr_lexicalOrExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalOrExpression::actualTypeName (void) const {
  return "lexicalOrExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalOrExpression ("lexicalOrExpression", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalCharacterSetMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterSetMatch::
cPtr_lexicalCharacterSetMatch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mCharacterSetName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterSetMatch * GGS_lexicalCharacterSetMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterSetMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterSetMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterSetMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterSetMatch * _p = dynamic_cast <const cPtr_lexicalCharacterSetMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacterSetName._operator_isEqual (_p->mCharacterSetName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterSetMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalCharacterSetMatch:"
           << mCharacterSetName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterSetMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterSetMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterSetMatch (& typeid (cPtr_lexicalCharacterSetMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterSetMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterSetMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterSetMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterSetMatch (mCharacterSetName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterSetMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatch::
GGS_lexicalCharacterSetMatch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatch::
GGS_lexicalCharacterSetMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalCharacterSetMatch GGS_lexicalCharacterSetMatch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterSetMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterSetMatch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalCharacterSetMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterSetMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatch GGS_lexicalCharacterSetMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterSetMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalCharacterSetMatch::
reader_mCharacterSetName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterSetMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterSetMatch *) mPointer)->mCharacterSetName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterSetMatch::actualTypeName (void) const {
  return "lexicalCharacterSetMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterSetMatch ("lexicalCharacterSetMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalCharacterMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatch::
cPtr_lexicalCharacterMatch (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterMatch * GGS_lexicalCharacterMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterMatch * _p = dynamic_cast <const cPtr_lexicalCharacterMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalCharacterMatch:"
           << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterMatch (& typeid (cPtr_lexicalCharacterMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterMatch (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch::
GGS_lexicalCharacterMatch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch::
GGS_lexicalCharacterMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalCharacterMatch GGS_lexicalCharacterMatch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterMatch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalCharacterMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch GGS_lexicalCharacterMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterMatch::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterMatch *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterMatch::actualTypeName (void) const {
  return "lexicalCharacterMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterMatch ("lexicalCharacterMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalCharacterIntervalMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatch::
cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mLowerBound (argument_0),
mUpperBound (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterIntervalMatch * GGS_lexicalCharacterIntervalMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterIntervalMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterIntervalMatch * _p = dynamic_cast <const cPtr_lexicalCharacterIntervalMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLowerBound._operator_isEqual (_p->mLowerBound).boolValue ()
         && mUpperBound._operator_isEqual (_p->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterIntervalMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalCharacterIntervalMatch:"
           << mLowerBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mUpperBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterIntervalMatch (& typeid (cPtr_lexicalCharacterIntervalMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterIntervalMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterIntervalMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterIntervalMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterIntervalMatch (mLowerBound, mUpperBound COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch::
GGS_lexicalCharacterIntervalMatch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch::
GGS_lexicalCharacterIntervalMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalCharacterIntervalMatch GGS_lexicalCharacterIntervalMatch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterIntervalMatch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalCharacterIntervalMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterIntervalMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch GGS_lexicalCharacterIntervalMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterIntervalMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mLowerBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mUpperBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterIntervalMatch::actualTypeName (void) const {
  return "lexicalCharacterIntervalMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterIntervalMatch ("lexicalCharacterIntervalMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalStringMatch'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringMatch::
cPtr_lexicalStringMatch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringMatch * GGS_lexicalStringMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalStringMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStringMatch * _p = dynamic_cast <const cPtr_lexicalStringMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mString._operator_isEqual (_p->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalStringMatch:"
           << mString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStringMatch (& typeid (cPtr_lexicalStringMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalStringMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStringMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStringMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStringMatch (mString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStringMatch::
GGS_lexicalStringMatch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatch::
GGS_lexicalStringMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalStringMatch GGS_lexicalStringMatch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStringMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStringMatch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalStringMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStringMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatch GGS_lexicalStringMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringMatch::actualTypeName (void) const {
  return "lexicalStringMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalStringMatch ("lexicalStringMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalStringNotMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatch::
cPtr_lexicalStringNotMatch (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mString (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringNotMatch * GGS_lexicalStringNotMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalStringNotMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringNotMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStringNotMatch * _p = dynamic_cast <const cPtr_lexicalStringNotMatch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mString._operator_isEqual (_p->mString).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringNotMatch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalStringNotMatch:"
           << mString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStringNotMatch (& typeid (cPtr_lexicalStringNotMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalStringNotMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStringNotMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStringNotMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStringNotMatch (mString, mErrorMessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch::
GGS_lexicalStringNotMatch (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch::
GGS_lexicalStringNotMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalStringNotMatch GGS_lexicalStringNotMatch::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatch _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStringNotMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStringNotMatch) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalStringNotMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStringNotMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch GGS_lexicalStringNotMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringNotMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringNotMatch::actualTypeName (void) const {
  return "lexicalStringNotMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalStringNotMatch ("lexicalStringNotMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalInstruction::
cPtr_lexicalInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalInstruction * GGS_lexicalInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lexicalInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalInstruction (& typeid (cPtr_lexicalInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalInstruction::
GGS_lexicalInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstruction::
GGS_lexicalInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalInstruction GGS_lexicalInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalInstruction::actualTypeName (void) const {
  return "lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalInstruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalInstruction ("lexicalInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalSendDefaultAction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultAction::
cPtr_lexicalSendDefaultAction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendDefaultAction * GGS_lexicalSendDefaultAction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendDefaultAction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSendDefaultAction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalSendDefaultAction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lexicalSendDefaultAction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSendDefaultAction (& typeid (cPtr_lexicalSendDefaultAction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSendDefaultAction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSendDefaultAction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction::
GGS_lexicalSendDefaultAction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction::
GGS_lexicalSendDefaultAction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalSendDefaultAction GGS_lexicalSendDefaultAction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSendDefaultAction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSendDefaultAction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSendDefaultAction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalSendDefaultAction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSendDefaultAction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendDefaultAction::actualTypeName (void) const {
  return "lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalSendDefaultAction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalSendDefaultAction ("lexicalSendDefaultAction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_lexicalStructuredSendInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstruction::
cPtr_lexicalStructuredSendInstruction (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mLexicalSendSearchList (argument_0),
mLexicalSendDefaultAction (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStructuredSendInstruction * GGS_lexicalStructuredSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStructuredSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStructuredSendInstruction * _p = dynamic_cast <const cPtr_lexicalStructuredSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalSendSearchList._operator_isEqual (_p->mLexicalSendSearchList).boolValue ()
         && mLexicalSendDefaultAction._operator_isEqual (_p->mLexicalSendDefaultAction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStructuredSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalStructuredSendInstruction:"
           << mLexicalSendSearchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalSendDefaultAction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStructuredSendInstruction (& typeid (cPtr_lexicalStructuredSendInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalStructuredSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStructuredSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStructuredSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStructuredSendInstruction (mLexicalSendSearchList, mLexicalSendDefaultAction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction::
GGS_lexicalStructuredSendInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction::
GGS_lexicalStructuredSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalStructuredSendInstruction GGS_lexicalStructuredSendInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStructuredSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalStructuredSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStructuredSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction GGS_lexicalStructuredSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalSendSearchList & argument_0,
                 const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalStructuredSendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendSearchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendSearchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendDefaultAction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendDefaultAction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendDefaultAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStructuredSendInstruction::actualTypeName (void) const {
  return "lexicalStructuredSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalStructuredSendInstruction ("lexicalStructuredSendInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalSimpleSendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstruction::
cPtr_lexicalSimpleSendInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSimpleSendInstruction * GGS_lexicalSimpleSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSimpleSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSimpleSendInstruction * _p = dynamic_cast <const cPtr_lexicalSimpleSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSentTerminal._operator_isEqual (_p->mSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSimpleSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalSimpleSendInstruction:"
           << mSentTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSimpleSendInstruction (& typeid (cPtr_lexicalSimpleSendInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSimpleSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSimpleSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSimpleSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSimpleSendInstruction (mSentTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction::
GGS_lexicalSimpleSendInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction::
GGS_lexicalSimpleSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalSimpleSendInstruction GGS_lexicalSimpleSendInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSimpleSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalSimpleSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSimpleSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction GGS_lexicalSimpleSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSimpleSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSimpleSendInstruction::
reader_mSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSimpleSendInstruction *) mPointer)->mSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSimpleSendInstruction::actualTypeName (void) const {
  return "lexicalSimpleSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalSimpleSendInstruction ("lexicalSimpleSendInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalSendTerminalByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefault::
cPtr_lexicalSendTerminalByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalSendDefaultAction (THERE),
mDefaultSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendTerminalByDefault * GGS_lexicalSendTerminalByDefault::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendTerminalByDefault::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSendTerminalByDefault * _p = dynamic_cast <const cPtr_lexicalSendTerminalByDefault *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDefaultSentTerminal._operator_isEqual (_p->mDefaultSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendTerminalByDefault::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalSendTerminalByDefault:"
           << mDefaultSentTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSendTerminalByDefault (& typeid (cPtr_lexicalSendTerminalByDefault), & typeid (cPtr_lexicalSendDefaultAction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSendTerminalByDefault::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSendTerminalByDefault ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSendTerminalByDefault::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSendTerminalByDefault (mDefaultSentTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault::
GGS_lexicalSendTerminalByDefault (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault::
GGS_lexicalSendTerminalByDefault (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalSendTerminalByDefault GGS_lexicalSendTerminalByDefault::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefault _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSendTerminalByDefault) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalSendTerminalByDefault (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSendTerminalByDefault),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault GGS_lexicalSendTerminalByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendTerminalByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendTerminalByDefault::
reader_mDefaultSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendTerminalByDefault *) mPointer)->mDefaultSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendTerminalByDefault::actualTypeName (void) const {
  return "lexicalSendTerminalByDefault" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalSendTerminalByDefault ("lexicalSendTerminalByDefault", gClassInfoFor__lexicalSendDefaultAction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalErrorByDefault'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefault::
cPtr_lexicalErrorByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalSendDefaultAction (THERE),
mDefaultErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorByDefault * GGS_lexicalErrorByDefault::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalErrorByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorByDefault::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalErrorByDefault * _p = dynamic_cast <const cPtr_lexicalErrorByDefault *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDefaultErrorMessageName._operator_isEqual (_p->mDefaultErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorByDefault::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalErrorByDefault:"
           << mDefaultErrorMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalErrorByDefault (& typeid (cPtr_lexicalErrorByDefault), & typeid (cPtr_lexicalSendDefaultAction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalErrorByDefault::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalErrorByDefault ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalErrorByDefault::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalErrorByDefault (mDefaultErrorMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault::
GGS_lexicalErrorByDefault (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault::
GGS_lexicalErrorByDefault (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalErrorByDefault GGS_lexicalErrorByDefault::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefault _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalErrorByDefault *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalErrorByDefault) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalErrorByDefault (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalErrorByDefault),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault GGS_lexicalErrorByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorByDefault::
reader_mDefaultErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorByDefault *) mPointer)->mDefaultErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorByDefault::actualTypeName (void) const {
  return "lexicalErrorByDefault" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalErrorByDefault ("lexicalErrorByDefault", gClassInfoFor__lexicalSendDefaultAction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalSendSearchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalSendSearchList::
elementOf_GGS_lexicalSendSearchList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeName (argument_0),
mSearchListName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalSendSearchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalSendSearchList * _p = dynamic_cast <const elementOf_GGS_lexicalSendSearchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue ()
         && mSearchListName._operator_isEqual (_p->mSearchListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalSendSearchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchListName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalSendSearchList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
_operator_concat (const GGS_lexicalSendSearchList & inOperand) const {
  GGS_lexicalSendSearchList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_dotAssign_operation (const GGS_lexicalSendSearchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalSendSearchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_lstring  p_1 = p->mSearchListName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeName,
                                _p->mSearchListName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalSendSearchList::
constructor_emptyList (void) {
  GGS_lexicalSendSearchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalSendSearchList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalSendSearchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
internalSubListWithRange (GGS_lexicalSendSearchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributeName, _p->mSearchListName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSendSearchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSendSearchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mSearchListName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mSearchListName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mSearchListName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeName ;
    _out_1 = _p->mSearchListName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearchList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearchList::
reader_mSearchListNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSearchListName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_setMSearchListNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSearchListName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalSendSearchList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalSendSearchList::cEnumerator::_mSearchListName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSearchListName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalRepeatInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstruction::
cPtr_lexicalRepeatInstruction (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mRepeatedInstructionList (argument_0),
mLexicalWhileBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRepeatInstruction * GGS_lexicalRepeatInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalRepeatInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRepeatInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRepeatInstruction * _p = dynamic_cast <const cPtr_lexicalRepeatInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRepeatedInstructionList._operator_isEqual (_p->mRepeatedInstructionList).boolValue ()
         && mLexicalWhileBranchList._operator_isEqual (_p->mLexicalWhileBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRepeatInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalRepeatInstruction:"
           << mRepeatedInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalWhileBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRepeatInstruction (& typeid (cPtr_lexicalRepeatInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalRepeatInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRepeatInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRepeatInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRepeatInstruction (mRepeatedInstructionList, mLexicalWhileBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction::
GGS_lexicalRepeatInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction::
GGS_lexicalRepeatInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalRepeatInstruction GGS_lexicalRepeatInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRepeatInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRepeatInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalRepeatInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRepeatInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction GGS_lexicalRepeatInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalInstructionList & argument_0,
                 const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRepeatInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalRepeatInstruction::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalRepeatInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRepeatInstruction::actualTypeName (void) const {
  return "lexicalRepeatInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalRepeatInstruction ("lexicalRepeatInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalWhileBranchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalWhileBranchList::
elementOf_GGS_lexicalWhileBranchList (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mWhileExpression (argument_0),
mWhileInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalWhileBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalWhileBranchList * _p = dynamic_cast <const elementOf_GGS_lexicalWhileBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mWhileInstructionList._operator_isEqual (_p->mWhileInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalWhileBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalWhileBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
_operator_concat (const GGS_lexicalWhileBranchList & inOperand) const {
  GGS_lexicalWhileBranchList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_dotAssign_operation (const GGS_lexicalWhileBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalWhileBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mWhileExpression ;
          GGS_lexicalInstructionList  p_1 = p->mWhileInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mWhileExpression,
                                _p->mWhileInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalWhileBranchList::
constructor_emptyList (void) {
  GGS_lexicalWhileBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalWhileBranchList::
constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  GGS_lexicalWhileBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
internalSubListWithRange (GGS_lexicalWhileBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mWhileExpression, _p->mWhileInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalWhileBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalWhileBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExpression & _out_0,
              GGS_lexicalInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mWhileExpression ;
    _out_1 = _p->mWhileInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExpression & _out_0,
             GGS_lexicalInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mWhileExpression ;
    _out_1 = _p->mWhileInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lexicalExpression & _out_0,
                 GGS_lexicalInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mWhileExpression ;
    _out_1 = _p->mWhileInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lexicalExpression & _out_0,
                GGS_lexicalInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mWhileExpression ;
    _out_1 = _p->mWhileInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalWhileBranchList::
reader_mWhileExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mWhileExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalWhileBranchList::
reader_mWhileInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mWhileInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_setMWhileExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mWhileExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_setMWhileInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mWhileInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpression  & GGS_lexicalWhileBranchList::cEnumerator::_mWhileExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mWhileExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionList  & GGS_lexicalWhileBranchList::cEnumerator::_mWhileInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mWhileInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalSelectInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstruction::
cPtr_lexicalSelectInstruction (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mLexicalWhileBranchList (argument_0),
mDefaultInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectInstruction * GGS_lexicalSelectInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSelectInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSelectInstruction * _p = dynamic_cast <const cPtr_lexicalSelectInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalWhileBranchList._operator_isEqual (_p->mLexicalWhileBranchList).boolValue ()
         && mDefaultInstructionList._operator_isEqual (_p->mDefaultInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalSelectInstruction:"
           << mLexicalWhileBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDefaultInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSelectInstruction (& typeid (cPtr_lexicalSelectInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSelectInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSelectInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSelectInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSelectInstruction (mLexicalWhileBranchList, mDefaultInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction::
GGS_lexicalSelectInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction::
GGS_lexicalSelectInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalSelectInstruction GGS_lexicalSelectInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSelectInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSelectInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalSelectInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSelectInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction GGS_lexicalSelectInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalSelectBranchList & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalSelectInstruction::
reader_mDefaultInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mDefaultInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectInstruction::actualTypeName (void) const {
  return "lexicalSelectInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalSelectInstruction ("lexicalSelectInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalInstructionList::
elementOf_GGS_lexicalInstructionList (const GGS_lexicalInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalInstructionList * _p = dynamic_cast <const elementOf_GGS_lexicalInstructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalInstructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_internalAppendValues (const GGS_lexicalInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_internalPrependValues (const GGS_lexicalInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_addAssign_operation (const GGS_lexicalInstruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
_operator_concat (const GGS_lexicalInstructionList & inOperand) const {
  GGS_lexicalInstructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_dotAssign_operation (const GGS_lexicalInstructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalInstruction  p_0 = p->mInstructionList ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalInstructionList::
constructor_emptyList (void) {
  GGS_lexicalInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalInstructionList::
constructor_listWithValue (const GGS_lexicalInstruction & argument_0) {
  GGS_lexicalInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
internalSubListWithRange (GGS_lexicalInstructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lexicalInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lexicalInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstruction  GGS_lexicalInstructionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstruction  & GGS_lexicalInstructionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalSelectBranchList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalSelectBranchList::
elementOf_GGS_lexicalSelectBranchList (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSelectExpression (argument_0),
mSelectInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalSelectBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalSelectBranchList * _p = dynamic_cast <const elementOf_GGS_lexicalSelectBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSelectExpression._operator_isEqual (_p->mSelectExpression).boolValue ()
         && mSelectInstructionList._operator_isEqual (_p->mSelectInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalSelectBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalSelectBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
_operator_concat (const GGS_lexicalSelectBranchList & inOperand) const {
  GGS_lexicalSelectBranchList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_dotAssign_operation (const GGS_lexicalSelectBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalSelectBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mSelectExpression ;
          GGS_lexicalInstructionList  p_1 = p->mSelectInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSelectExpression,
                                _p->mSelectInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectBranchList::
constructor_emptyList (void) {
  GGS_lexicalSelectBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectBranchList::
constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  GGS_lexicalSelectBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
internalSubListWithRange (GGS_lexicalSelectBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSelectExpression, _p->mSelectInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSelectBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalSelectBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalExpression & _out_0,
              GGS_lexicalInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSelectExpression ;
    _out_1 = _p->mSelectInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalExpression & _out_0,
             GGS_lexicalInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSelectExpression ;
    _out_1 = _p->mSelectInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lexicalExpression & _out_0,
                 GGS_lexicalInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSelectExpression ;
    _out_1 = _p->mSelectInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lexicalExpression & _out_0,
                GGS_lexicalInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSelectExpression ;
    _out_1 = _p->mSelectInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalSelectBranchList::
reader_mSelectExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSelectExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalSelectBranchList::
reader_mSelectInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSelectInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_setMSelectExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSelectExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_setMSelectInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSelectInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpression  & GGS_lexicalSelectBranchList::cEnumerator::_mSelectExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSelectExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionList  & GGS_lexicalSelectBranchList::cEnumerator::_mSelectInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSelectInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalActionInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalActionInstruction::
cPtr_lexicalActionInstruction (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mActionName (argument_0),
mActualArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalActionInstruction * GGS_lexicalActionInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalActionInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalActionInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalActionInstruction * _p = dynamic_cast <const cPtr_lexicalActionInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mActionName._operator_isEqual (_p->mActionName).boolValue ()
         && mActualArgumentList._operator_isEqual (_p->mActualArgumentList).boolValue ()
         && mErrorMessageList._operator_isEqual (_p->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalActionInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalActionInstruction:"
           << mActionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalActionInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActionInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalActionInstruction (& typeid (cPtr_lexicalActionInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalActionInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalActionInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalActionInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalActionInstruction (mActionName, mActualArgumentList, mErrorMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalActionInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalActionInstruction::
GGS_lexicalActionInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActionInstruction::
GGS_lexicalActionInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalActionInstruction GGS_lexicalActionInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalActionInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalActionInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalActionInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalActionInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalActionInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActionInstruction GGS_lexicalActionInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalActualArgumentList & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalActionInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalActionInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalActionInstruction::
reader_mActionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mActionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalActionInstruction::
reader_mActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalActualArgumentList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalActionInstruction::
reader_mErrorMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActionInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalActionInstruction *) mPointer)->mErrorMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalActionInstruction::actualTypeName (void) const {
  return "lexicalActionInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalActionInstruction ("lexicalActionInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalActualArgument'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalActualArgument::
cPtr_lexicalActualArgument (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalActualArgument * GGS_lexicalActualArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalActualArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalActualArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalActualArgument::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lexicalActualArgument:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalActualArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalActualArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalActualArgument (& typeid (cPtr_lexicalActualArgument), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalActualArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalActualArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalActualArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalActualArgument::
GGS_lexicalActualArgument (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgument::
GGS_lexicalActualArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalActualArgument GGS_lexicalActualArgument::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalActualArgument _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalActualArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalActualArgument) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalActualArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalActualArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalActualArgument::actualTypeName (void) const {
  return "lexicalActualArgument" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalActualArgument::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalActualArgument ("lexicalActualArgument") ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalActualArgumentList::
elementOf_GGS_lexicalActualArgumentList (const GGS_lexicalActualArgument & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexicalActualArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalActualArgumentList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalActualArgumentList * _p = dynamic_cast <const elementOf_GGS_lexicalActualArgumentList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexicalActualArgument._operator_isEqual (_p->mLexicalActualArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalActualArgumentList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalActualArgument.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalActualArgumentList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_internalAppendValues (const GGS_lexicalActualArgument & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_internalPrependValues (const GGS_lexicalActualArgument & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_addAssign_operation (const GGS_lexicalActualArgument & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList GGS_lexicalActualArgumentList::
_operator_concat (const GGS_lexicalActualArgumentList & inOperand) const {
  GGS_lexicalActualArgumentList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_dotAssign_operation (const GGS_lexicalActualArgumentList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_lexicalActualArgumentList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalActualArgument  p_0 = p->mLexicalActualArgument ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalActualArgument & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLexicalActualArgument
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalActualArgumentList::
constructor_emptyList (void) {
  GGS_lexicalActualArgumentList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalActualArgumentList::
constructor_listWithValue (const GGS_lexicalActualArgument & argument_0) {
  GGS_lexicalActualArgumentList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
internalSubListWithRange (GGS_lexicalActualArgumentList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mLexicalActualArgument) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList GGS_lexicalActualArgumentList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalActualArgumentList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList GGS_lexicalActualArgumentList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalActualArgumentList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalActualArgumentList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lexicalActualArgumentList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
method_first (C_Compiler & _inLexique,
              GGS_lexicalActualArgument & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalActualArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
method_last (C_Compiler & _inLexique,
             GGS_lexicalActualArgument & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalActualArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lexicalActualArgument & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalActualArgument ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lexicalActualArgument & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLexicalActualArgument ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgument  GGS_lexicalActualArgumentList::
reader_mLexicalActualArgumentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalActualArgument  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalActualArgument ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalActualArgumentList::
modifier_setMLexicalActualArgumentAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalActualArgument  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalActualArgument = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalActualArgument  & GGS_lexicalActualArgumentList::cEnumerator::_mLexicalActualArgument (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLexicalActualArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalAttributeArgument'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeArgument::
cPtr_lexicalAttributeArgument (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalActualArgument (THERE),
mAttributeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeArgument * GGS_lexicalAttributeArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalAttributeArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalAttributeArgument * _p = dynamic_cast <const cPtr_lexicalAttributeArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalAttributeArgument:"
           << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalAttributeArgument (& typeid (cPtr_lexicalAttributeArgument), & typeid (cPtr_lexicalActualArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalAttributeArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalAttributeArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalAttributeArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalAttributeArgument (mAttributeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalAttributeArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgument::
GGS_lexicalAttributeArgument (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgument::
GGS_lexicalAttributeArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalAttributeArgument GGS_lexicalAttributeArgument::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeArgument _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalAttributeArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalAttributeArgument) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalAttributeArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalAttributeArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeArgument GGS_lexicalAttributeArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeArgument::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeArgument *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeArgument::actualTypeName (void) const {
  return "lexicalAttributeArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalAttributeArgument ("lexicalAttributeArgument", gClassInfoFor__lexicalActualArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalCharacterArgument'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterArgument::
cPtr_lexicalCharacterArgument (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalActualArgument (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterArgument * GGS_lexicalCharacterArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterArgument * _p = dynamic_cast <const cPtr_lexicalCharacterArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalCharacterArgument:"
           << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterArgument (& typeid (cPtr_lexicalCharacterArgument), & typeid (cPtr_lexicalActualArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterArgument (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgument::
GGS_lexicalCharacterArgument (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgument::
GGS_lexicalCharacterArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalCharacterArgument GGS_lexicalCharacterArgument::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterArgument _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterArgument) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalCharacterArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterArgument GGS_lexicalCharacterArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterArgument::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterArgument *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterArgument::actualTypeName (void) const {
  return "lexicalCharacterArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterArgument ("lexicalCharacterArgument", gClassInfoFor__lexicalActualArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_lexicalCurrentCharacterArgument'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterArgument::
cPtr_lexicalCurrentCharacterArgument (LOCATION_ARGS)
:cPtr_lexicalActualArgument (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCurrentCharacterArgument * GGS_lexicalCurrentCharacterArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCurrentCharacterArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCurrentCharacterArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCurrentCharacterArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCurrentCharacterArgument::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lexicalCurrentCharacterArgument:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCurrentCharacterArgument (& typeid (cPtr_lexicalCurrentCharacterArgument), & typeid (cPtr_lexicalActualArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCurrentCharacterArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCurrentCharacterArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalCurrentCharacterArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgument::
GGS_lexicalCurrentCharacterArgument (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgument::
GGS_lexicalCurrentCharacterArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalCurrentCharacterArgument GGS_lexicalCurrentCharacterArgument::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterArgument _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCurrentCharacterArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCurrentCharacterArgument) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalCurrentCharacterArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCurrentCharacterArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lexicalCurrentCharacterArgument * gSingleton_lexicalCurrentCharacterArgument = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lexicalCurrentCharacterArgument (void) {
  macroDetachPointer (gSingleton_lexicalCurrentCharacterArgument, cPtr_lexicalCurrentCharacterArgument) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterArgument GGS_lexicalCurrentCharacterArgument::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterArgument result ;
  if (NULL == gSingleton_lexicalCurrentCharacterArgument) {
    macroMyNew (gSingleton_lexicalCurrentCharacterArgument, cPtr_lexicalCurrentCharacterArgument (THERE)) ;
    registerReleaseRoutine (cleanUp_lexicalCurrentCharacterArgument) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lexicalCurrentCharacterArgument) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCurrentCharacterArgument::actualTypeName (void) const {
  return "lexicalCurrentCharacterArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCurrentCharacterArgument ("lexicalCurrentCharacterArgument", gClassInfoFor__lexicalActualArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalFunctionArgument'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFunctionArgument::
cPtr_lexicalFunctionArgument (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalActualArgument (THERE),
mFunctionName (argument_0),
mFunctionActualArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFunctionArgument * GGS_lexicalFunctionArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalFunctionArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalFunctionArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalFunctionArgument * _p = dynamic_cast <const cPtr_lexicalFunctionArgument *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFunctionName._operator_isEqual (_p->mFunctionName).boolValue ()
         && mFunctionActualArgumentList._operator_isEqual (_p->mFunctionActualArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFunctionArgument::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalFunctionArgument:"
           << mFunctionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFunctionActualArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalFunctionArgument (& typeid (cPtr_lexicalFunctionArgument), & typeid (cPtr_lexicalActualArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalFunctionArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalFunctionArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalFunctionArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalFunctionArgument (mFunctionName, mFunctionActualArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalFunctionArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgument::
GGS_lexicalFunctionArgument (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgument::
GGS_lexicalFunctionArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalFunctionArgument GGS_lexicalFunctionArgument::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionArgument _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalFunctionArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalFunctionArgument) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalFunctionArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalFunctionArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionArgument GGS_lexicalFunctionArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalFunctionArgument (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalFunctionArgument::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionArgument *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalActualArgumentList  GGS_lexicalFunctionArgument::
reader_mFunctionActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalActualArgumentList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionArgument *) mPointer)->mFunctionActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFunctionArgument::actualTypeName (void) const {
  return "lexicalFunctionArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalFunctionArgument ("lexicalFunctionArgument", gClassInfoFor__lexicalActualArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalDropInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalDropInstruction::
cPtr_lexicalDropInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mTerminalName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalDropInstruction * GGS_lexicalDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalDropInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalDropInstruction * _p = dynamic_cast <const cPtr_lexicalDropInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTerminalName._operator_isEqual (_p->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalDropInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalDropInstruction:"
           << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalDropInstruction (& typeid (cPtr_lexicalDropInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalDropInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalDropInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalDropInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalDropInstruction (mTerminalName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction::
GGS_lexicalDropInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction::
GGS_lexicalDropInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalDropInstruction GGS_lexicalDropInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalDropInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalDropInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalDropInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalDropInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction GGS_lexicalDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalDropInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalDropInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalDropInstruction::actualTypeName (void) const {
  return "lexicalDropInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalDropInstruction ("lexicalDropInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalErrorInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstruction::
cPtr_lexicalErrorInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorInstruction * GGS_lexicalErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalErrorInstruction * _p = dynamic_cast <const cPtr_lexicalErrorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorMessageName._operator_isEqual (_p->mErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalErrorInstruction:"
           << mErrorMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalErrorInstruction (& typeid (cPtr_lexicalErrorInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalErrorInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalErrorInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalErrorInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalErrorInstruction (mErrorMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction::
GGS_lexicalErrorInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction::
GGS_lexicalErrorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalErrorInstruction GGS_lexicalErrorInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalErrorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalErrorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalErrorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalErrorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction GGS_lexicalErrorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorInstruction::
reader_mErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorInstruction *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorInstruction::actualTypeName (void) const {
  return "lexicalErrorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalErrorInstruction ("lexicalErrorInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalWarningInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalWarningInstruction::
cPtr_lexicalWarningInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mWarningMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalWarningInstruction * GGS_lexicalWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalWarningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalWarningInstruction * _p = dynamic_cast <const cPtr_lexicalWarningInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mWarningMessageName._operator_isEqual (_p->mWarningMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalWarningInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalWarningInstruction:"
           << mWarningMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalWarningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWarningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalWarningInstruction (& typeid (cPtr_lexicalWarningInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalWarningInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalWarningInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalWarningInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalWarningInstruction (mWarningMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalWarningInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalWarningInstruction::
GGS_lexicalWarningInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstruction::
GGS_lexicalWarningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalWarningInstruction GGS_lexicalWarningInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalWarningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalWarningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalWarningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalWarningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstruction GGS_lexicalWarningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalWarningInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalWarningInstruction::
reader_mWarningMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWarningInstruction *) mPointer)->mWarningMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalWarningInstruction::actualTypeName (void) const {
  return "lexicalWarningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalWarningInstruction ("lexicalWarningInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalTagInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalTagInstruction::
cPtr_lexicalTagInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mTagName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalTagInstruction * GGS_lexicalTagInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalTagInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalTagInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalTagInstruction * _p = dynamic_cast <const cPtr_lexicalTagInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTagName._operator_isEqual (_p->mTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalTagInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalTagInstruction:"
           << mTagName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalTagInstruction (& typeid (cPtr_lexicalTagInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalTagInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalTagInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalTagInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalTagInstruction (mTagName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction::
GGS_lexicalTagInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction::
GGS_lexicalTagInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalTagInstruction GGS_lexicalTagInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalTagInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalTagInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalTagInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalTagInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction GGS_lexicalTagInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalTagInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalTagInstruction::
reader_mTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalTagInstruction *) mPointer)->mTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalTagInstruction::actualTypeName (void) const {
  return "lexicalTagInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalTagInstruction ("lexicalTagInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalRewindInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstruction::
cPtr_lexicalRewindInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mTagName (argument_0),
mTerminalName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRewindInstruction * GGS_lexicalRewindInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalRewindInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRewindInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRewindInstruction * _p = dynamic_cast <const cPtr_lexicalRewindInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTagName._operator_isEqual (_p->mTagName).boolValue ()
         && mTerminalName._operator_isEqual (_p->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRewindInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexicalRewindInstruction:"
           << mTagName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRewindInstruction (& typeid (cPtr_lexicalRewindInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalRewindInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRewindInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRewindInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRewindInstruction (mTagName, mTerminalName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction::
GGS_lexicalRewindInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction::
GGS_lexicalRewindInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalRewindInstruction GGS_lexicalRewindInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRewindInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRewindInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalRewindInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRewindInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction GGS_lexicalRewindInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRewindInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRewindInstruction::actualTypeName (void) const {
  return "lexicalRewindInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalRewindInstruction ("lexicalRewindInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalLogInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalLogInstruction::
cPtr_lexicalLogInstruction (LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalLogInstruction * GGS_lexicalLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalLogInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalLogInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@lexicalLogInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalLogInstruction (& typeid (cPtr_lexicalLogInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalLogInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalLogInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction::
GGS_lexicalLogInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction::
GGS_lexicalLogInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexicalLogInstruction GGS_lexicalLogInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalLogInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalLogInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexicalLogInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalLogInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_lexicalLogInstruction * gSingleton_lexicalLogInstruction = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lexicalLogInstruction (void) {
  macroDetachPointer (gSingleton_lexicalLogInstruction, cPtr_lexicalLogInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction GGS_lexicalLogInstruction::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstruction result ;
  if (NULL == gSingleton_lexicalLogInstruction) {
    macroMyNew (gSingleton_lexicalLogInstruction, cPtr_lexicalLogInstruction (THERE)) ;
    registerReleaseRoutine (cleanUp_lexicalLogInstruction) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lexicalLogInstruction) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalLogInstruction::actualTypeName (void) const {
  return "lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalLogInstruction ("lexicalLogInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexiqueComponentRoot'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexiqueComponentRoot::
cPtr_lexiqueComponentRoot (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_templateDelimitorList & argument_2,
                                const GGS_templateReplacementList & argument_3,
                                const GGS_lexicalAttributeList & argument_4,
                                const GGS_lexicalStyleList & argument_5,
                                const GGS_terminalDeclarationList & argument_6,
                                const GGS_lexicalErrorMessageDeclarationList & argument_7,
                                const GGS_lexicalListDeclarationList & argument_8,
                                const GGS_lexicalImplicitRuleList & argument_9,
                                const GGS_lexicalExplicitRuleList & argument_10
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mLexiqueComponentName (argument_0),
mIsTemplate (argument_1),
mTemplateDelimitorList (argument_2),
mTemplateReplacementList (argument_3),
mLexicalAttributeList (argument_4),
mLexicalStyleList (argument_5),
mTerminalDeclarationList (argument_6),
mLexicalErrorMessageDeclarationList (argument_7),
mLexicalListDeclarationList (argument_8),
mLexicalImplicitRuleList (argument_9),
mLexicalExplicitRuleList (argument_10) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexiqueComponentRoot * GGS_lexiqueComponentRoot::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexiqueComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexiqueComponentRoot::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexiqueComponentRoot * _p = dynamic_cast <const cPtr_lexiqueComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLexiqueComponentName._operator_isEqual (_p->mLexiqueComponentName).boolValue ()
         && mIsTemplate._operator_isEqual (_p->mIsTemplate).boolValue ()
         && mTemplateDelimitorList._operator_isEqual (_p->mTemplateDelimitorList).boolValue ()
         && mTemplateReplacementList._operator_isEqual (_p->mTemplateReplacementList).boolValue ()
         && mLexicalAttributeList._operator_isEqual (_p->mLexicalAttributeList).boolValue ()
         && mLexicalStyleList._operator_isEqual (_p->mLexicalStyleList).boolValue ()
         && mTerminalDeclarationList._operator_isEqual (_p->mTerminalDeclarationList).boolValue ()
         && mLexicalErrorMessageDeclarationList._operator_isEqual (_p->mLexicalErrorMessageDeclarationList).boolValue ()
         && mLexicalListDeclarationList._operator_isEqual (_p->mLexicalListDeclarationList).boolValue ()
         && mLexicalImplicitRuleList._operator_isEqual (_p->mLexicalImplicitRuleList).boolValue ()
         && mLexicalExplicitRuleList._operator_isEqual (_p->mLexicalExplicitRuleList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexiqueComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@lexiqueComponentRoot:"
           << mLexiqueComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIsTemplate.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateDelimitorList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateReplacementList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalStyleList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalErrorMessageDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalListDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalImplicitRuleList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexicalExplicitRuleList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexiqueComponentRoot (& typeid (cPtr_lexiqueComponentRoot), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexiqueComponentRoot::galgasRTTI (void) const {
  return & gClassInfoFor__lexiqueComponentRoot ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexiqueComponentRoot::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexiqueComponentRoot (mLexiqueComponentName, mIsTemplate, mTemplateDelimitorList, mTemplateReplacementList, mLexicalAttributeList, mLexicalStyleList, mTerminalDeclarationList, mLexicalErrorMessageDeclarationList, mLexicalListDeclarationList, mLexicalImplicitRuleList, mLexicalExplicitRuleList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot::
GGS_lexiqueComponentRoot (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot::
GGS_lexiqueComponentRoot (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_lexiqueComponentRoot GGS_lexiqueComponentRoot::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentRoot _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexiqueComponentRoot *> (inPointer) != NULL)
      : (typeid (cPtr_lexiqueComponentRoot) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_lexiqueComponentRoot (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexiqueComponentRoot),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot GGS_lexiqueComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_templateDelimitorList & argument_2,
                 const GGS_templateReplacementList & argument_3,
                 const GGS_lexicalAttributeList & argument_4,
                 const GGS_lexicalStyleList & argument_5,
                 const GGS_terminalDeclarationList & argument_6,
                 const GGS_lexicalErrorMessageDeclarationList & argument_7,
                 const GGS_lexicalListDeclarationList & argument_8,
                 const GGS_lexicalImplicitRuleList & argument_9,
                 const GGS_lexicalExplicitRuleList & argument_10
                                COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_lexiqueComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexiqueComponentRoot::
reader_mLexiqueComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexiqueComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexiqueComponentRoot::
reader_mIsTemplate (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mIsTemplate ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimitorList  GGS_lexiqueComponentRoot::
reader_mTemplateDelimitorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateDelimitorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTemplateDelimitorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList  GGS_lexiqueComponentRoot::
reader_mTemplateReplacementList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateReplacementList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTemplateReplacementList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexiqueComponentRoot::
reader_mLexicalAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexiqueComponentRoot::
reader_mLexicalStyleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalStyleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalStyleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_lexiqueComponentRoot::
reader_mTerminalDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_terminalDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTerminalDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorMessageDeclarationList  GGS_lexiqueComponentRoot::
reader_mLexicalErrorMessageDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalErrorMessageDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalErrorMessageDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexiqueComponentRoot::
reader_mLexicalListDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalListDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRuleList  GGS_lexiqueComponentRoot::
reader_mLexicalImplicitRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalImplicitRuleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalImplicitRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRuleList  GGS_lexiqueComponentRoot::
reader_mLexicalExplicitRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExplicitRuleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalExplicitRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexiqueComponentRoot::actualTypeName (void) const {
  return "lexiqueComponentRoot" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexiqueComponentRoot::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexiqueComponentRoot ("lexiqueComponentRoot") ;

//---------------------------------------------------------------------------*

