//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'lexiqueMetamodel.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    november 14th, 2009, at 15h49'10"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "lexiqueMetamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueMetamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_lexicalExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExpression::
cPtr_lexicalExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExpression * GGS_lexicalExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalExpression (& typeid (cPtr_lexicalExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalExpression::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalExpression ("lexicalExpression") ;

//---------------------------------------------------------------------------*

GGS_lexicalExpression::
GGS_lexicalExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression::
GGS_lexicalExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalExpression GGS_lexicalExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalExpression *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExpression::actualTypeName (void) const {
  return "lexicalExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalExpression ("lexicalExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalInstruction::
cPtr_lexicalInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalInstruction * GGS_lexicalInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalInstruction (& typeid (cPtr_lexicalInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalInstruction ("lexicalInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalInstruction::
GGS_lexicalInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstruction::
GGS_lexicalInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalInstruction GGS_lexicalInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalInstruction::actualTypeName (void) const {
  return "lexicalInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalInstruction ("lexicalInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalInstructionList::
elementOf_GGS_lexicalInstructionList (const GGS_lexicalInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalInstructionList * ptr = dynamic_cast <const elementOf_GGS_lexicalInstructionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalInstructionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalInstructionList ("lexicalInstructionList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
internalAppendValues (const GGS_lexicalInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
internalPrependValues (const GGS_lexicalInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
addAssign_operation (const GGS_lexicalInstruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
operator_concat (const GGS_lexicalInstructionList & inOperand) const {
  GGS_lexicalInstructionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
dotAssign_operation (const GGS_lexicalInstructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalInstruction  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalInstructionList::
constructor_emptyList (void) {
  GGS_lexicalInstructionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalInstructionList::
constructor_listWithValue (const GGS_lexicalInstruction & argument_0) {
  GGS_lexicalInstructionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
internalSubListWithRange (GGS_lexicalInstructionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList GGS_lexicalInstructionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalInstructionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalInstructionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
method_first (C_Compiler & inLexique,
              GGS_lexicalInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
method_last (C_Compiler & inLexique,
             GGS_lexicalInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lexicalInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lexicalInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalInstruction  GGS_lexicalInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstruction  & GGS_lexicalInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@metamodelTemplateDelimitorList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_metamodelTemplateDelimitorList::
elementOf_GGS_metamodelTemplateDelimitorList (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mStartString (argument_0),
mOptionList (argument_1),
mEndString (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_metamodelTemplateDelimitorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_metamodelTemplateDelimitorList * ptr = dynamic_cast <const elementOf_GGS_metamodelTemplateDelimitorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartString.operator_isEqual (ptr->mStartString).boolValue ()
         && mOptionList.operator_isEqual (ptr->mOptionList).boolValue ()
         && mEndString.operator_isEqual (ptr->mEndString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_metamodelTemplateDelimitorList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndString.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@metamodelTemplateDelimitorList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_metamodelTemplateDelimitorList ("metamodelTemplateDelimitorList") ;

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorList GGS_metamodelTemplateDelimitorList::
operator_concat (const GGS_metamodelTemplateDelimitorList & inOperand) const {
  GGS_metamodelTemplateDelimitorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
dotAssign_operation (const GGS_metamodelTemplateDelimitorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_metamodelTemplateDelimitorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mStartString ;
          GGS_lstringlist  p_1 = p->mOptionList ;
          GGS_lstring  p_2 = p->mEndString ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStartString,
                                ptr->mOptionList,
                                ptr->mEndString
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorList  GGS_metamodelTemplateDelimitorList::
constructor_emptyList (void) {
  GGS_metamodelTemplateDelimitorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorList  GGS_metamodelTemplateDelimitorList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_metamodelTemplateDelimitorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
internalSubListWithRange (GGS_metamodelTemplateDelimitorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mStartString, ptr->mOptionList, ptr->mEndString) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorList GGS_metamodelTemplateDelimitorList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_metamodelTemplateDelimitorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorList GGS_metamodelTemplateDelimitorList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_metamodelTemplateDelimitorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelTemplateDelimitorList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@metamodelTemplateDelimitorList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartString ;
    _out_1 = ptr->mOptionList ;
    _out_2 = ptr->mEndString ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelTemplateDelimitorList::
reader_mStartStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStartString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelTemplateDelimitorList::
reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelTemplateDelimitorList::
reader_mEndStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
modifier_setMStartStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStartString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelTemplateDelimitorList::
modifier_setMEndStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_metamodelTemplateDelimitorList::cEnumerator::_mStartString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStartString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_metamodelTemplateDelimitorList::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_metamodelTemplateDelimitorList::cEnumerator::_mEndString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@templateReplacementList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateReplacementList::
elementOf_GGS_templateReplacementList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMatchString (argument_0),
mReplacementString (argument_1),
mReplacementFunction (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateReplacementList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateReplacementList * ptr = dynamic_cast <const elementOf_GGS_templateReplacementList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchString.operator_isEqual (ptr->mMatchString).boolValue ()
         && mReplacementString.operator_isEqual (ptr->mReplacementString).boolValue ()
         && mReplacementFunction.operator_isEqual (ptr->mReplacementFunction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateReplacementList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReplacementString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReplacementFunction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@templateReplacementList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_templateReplacementList ("templateReplacementList") ;

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList GGS_templateReplacementList::
operator_concat (const GGS_templateReplacementList & inOperand) const {
  GGS_templateReplacementList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
dotAssign_operation (const GGS_templateReplacementList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateReplacementList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMatchString ;
          GGS_lstring  p_1 = p->mReplacementString ;
          GGS_lstring  p_2 = p->mReplacementFunction ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMatchString,
                                ptr->mReplacementString,
                                ptr->mReplacementFunction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList  GGS_templateReplacementList::
constructor_emptyList (void) {
  GGS_templateReplacementList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList  GGS_templateReplacementList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_templateReplacementList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
internalSubListWithRange (GGS_templateReplacementList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchString, ptr->mReplacementString, ptr->mReplacementFunction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList GGS_templateReplacementList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateReplacementList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList GGS_templateReplacementList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateReplacementList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateReplacementList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateReplacementList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchString ;
    _out_1 = ptr->mReplacementString ;
    _out_2 = ptr->mReplacementFunction ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementList::
reader_mMatchStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementList::
reader_mReplacementStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReplacementString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReplacementList::
reader_mReplacementFunctionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReplacementFunction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_setMMatchStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_setMReplacementStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReplacementString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementList::
modifier_setMReplacementFunctionAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReplacementFunction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementList::cEnumerator::_mMatchString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementList::cEnumerator::_mReplacementString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReplacementString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementList::cEnumerator::_mReplacementFunction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReplacementFunction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_abstractLexicalRule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractLexicalRule::
cPtr_abstractLexicalRule (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractLexicalRule * GGS_abstractLexicalRule::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractLexicalRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_abstractLexicalRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_abstractLexicalRule::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@abstractLexicalRule:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRule::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRule::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractLexicalRule (& typeid (cPtr_abstractLexicalRule), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_abstractLexicalRule::galgasRTTI (void) const {
  return & gClassInfoFor__abstractLexicalRule ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_abstractLexicalRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_abstractLexicalRule ("abstractLexicalRule") ;

//---------------------------------------------------------------------------*

GGS_abstractLexicalRule::
GGS_abstractLexicalRule (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRule::
GGS_abstractLexicalRule (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractLexicalRule GGS_abstractLexicalRule::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractLexicalRule result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractLexicalRule *> (inPointer) != NULL)
      : (typeid (cPtr_abstractLexicalRule) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractLexicalRule (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractLexicalRule),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractLexicalRule::actualTypeName (void) const {
  return "abstractLexicalRule" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_abstractLexicalRule::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__abstractLexicalRule ("abstractLexicalRule") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@lexicalRuleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalRuleList::
elementOf_GGS_lexicalRuleList (const GGS_abstractLexicalRule & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexicalRule (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalRuleList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalRuleList * ptr = dynamic_cast <const elementOf_GGS_lexicalRuleList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalRule.operator_isEqual (ptr->mLexicalRule).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalRuleList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRule.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@lexicalRuleList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalRuleList ("lexicalRuleList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
internalAppendValues (const GGS_abstractLexicalRule & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
internalPrependValues (const GGS_abstractLexicalRule & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
addAssign_operation (const GGS_abstractLexicalRule & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleList GGS_lexicalRuleList::
operator_concat (const GGS_lexicalRuleList & inOperand) const {
  GGS_lexicalRuleList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
dotAssign_operation (const GGS_lexicalRuleList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalRuleList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_abstractLexicalRule  p_0 = p->mLexicalRule ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_abstractLexicalRule & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalRule
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleList  GGS_lexicalRuleList::
constructor_emptyList (void) {
  GGS_lexicalRuleList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleList  GGS_lexicalRuleList::
constructor_listWithValue (const GGS_abstractLexicalRule & argument_0) {
  GGS_lexicalRuleList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
internalSubListWithRange (GGS_lexicalRuleList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalRule) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleList GGS_lexicalRuleList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRuleList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleList GGS_lexicalRuleList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRuleList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalRuleList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalRuleList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
method_first (C_Compiler & inLexique,
              GGS_abstractLexicalRule & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
method_last (C_Compiler & inLexique,
             GGS_abstractLexicalRule & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_abstractLexicalRule & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
modifier_popLast (C_Compiler & inLexique,
                GGS_abstractLexicalRule & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRule ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRule  GGS_lexicalRuleList::
reader_mLexicalRuleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_abstractLexicalRule  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRule ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRuleList::
modifier_setMLexicalRuleAtIndex (C_Compiler & inLexique,
                              const GGS_abstractLexicalRule  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRule = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_abstractLexicalRule  & GGS_lexicalRuleList::cEnumerator::_mLexicalRule (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalRule ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalImplicitRule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalImplicitRule::
cPtr_lexicalImplicitRule (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRule (THERE),
mListName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalImplicitRule * GGS_lexicalImplicitRule::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalImplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalImplicitRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalImplicitRule::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalImplicitRule * ptr = dynamic_cast <const cPtr_lexicalImplicitRule *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListName.operator_isEqual (ptr->mListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalImplicitRule::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalImplicitRule:"
           << mListName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRule::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalImplicitRule::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalImplicitRule (& typeid (cPtr_lexicalImplicitRule), & typeid (cPtr_abstractLexicalRule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalImplicitRule::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalImplicitRule ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalImplicitRule::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalImplicitRule (mListName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalImplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalImplicitRule ("lexicalImplicitRule") ;

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRule::
GGS_lexicalImplicitRule (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRule::
GGS_lexicalImplicitRule (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalImplicitRule GGS_lexicalImplicitRule::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRule result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalImplicitRule *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalImplicitRule) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalImplicitRule (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalImplicitRule),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalImplicitRule GGS_lexicalImplicitRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalImplicitRule result ;
  macroMyNew (result.mPointer, cPtr_lexicalImplicitRule (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalImplicitRule::
reader_mListName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalImplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalImplicitRule *) mPointer)->mListName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalImplicitRule::actualTypeName (void) const {
  return "lexicalImplicitRule" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalImplicitRule ("lexicalImplicitRule", gClassInfoFor__abstractLexicalRule) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalExplicitRule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalExplicitRule::
cPtr_lexicalExplicitRule (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRule (THERE),
mLexicalRuleExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalExplicitRule * GGS_lexicalExplicitRule::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalExplicitRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalExplicitRule::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalExplicitRule * ptr = dynamic_cast <const cPtr_lexicalExplicitRule *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalRuleExpression.operator_isEqual (ptr->mLexicalRuleExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalExplicitRule::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalExplicitRule:"
           << mLexicalRuleExpression.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRule::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalExplicitRule::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalExplicitRule (& typeid (cPtr_lexicalExplicitRule), & typeid (cPtr_abstractLexicalRule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalExplicitRule::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalExplicitRule ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalExplicitRule::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalExplicitRule (mLexicalRuleExpression, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalExplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalExplicitRule ("lexicalExplicitRule") ;

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRule::
GGS_lexicalExplicitRule (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRule::
GGS_lexicalExplicitRule (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalExplicitRule GGS_lexicalExplicitRule::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRule result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalExplicitRule *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalExplicitRule) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalExplicitRule (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalExplicitRule),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExplicitRule GGS_lexicalExplicitRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalExplicitRule result ;
  macroMyNew (result.mPointer, cPtr_lexicalExplicitRule (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalExplicitRule::
reader_mLexicalRuleExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRule *) mPointer)->mLexicalRuleExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalExplicitRule::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalExplicitRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalExplicitRule *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalExplicitRule::actualTypeName (void) const {
  return "lexicalExplicitRule" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalExplicitRule ("lexicalExplicitRule", gClassInfoFor__abstractLexicalRule) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalMessageDeclarationList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalMessageDeclarationList::
elementOf_GGS_lexicalMessageDeclarationList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalMessageDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalMessageDeclarationList * ptr = dynamic_cast <const elementOf_GGS_lexicalMessageDeclarationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessageName.operator_isEqual (ptr->mMessageName).boolValue ()
         && mMessageValue.operator_isEqual (ptr->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalMessageDeclarationList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@lexicalMessageDeclarationList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalMessageDeclarationList ("lexicalMessageDeclarationList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationList GGS_lexicalMessageDeclarationList::
operator_concat (const GGS_lexicalMessageDeclarationList & inOperand) const {
  GGS_lexicalMessageDeclarationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
dotAssign_operation (const GGS_lexicalMessageDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalMessageDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMessageName,
                                ptr->mMessageValue
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationList  GGS_lexicalMessageDeclarationList::
constructor_emptyList (void) {
  GGS_lexicalMessageDeclarationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationList  GGS_lexicalMessageDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalMessageDeclarationList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
internalSubListWithRange (GGS_lexicalMessageDeclarationList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMessageName, ptr->mMessageValue) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationList GGS_lexicalMessageDeclarationList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalMessageDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationList GGS_lexicalMessageDeclarationList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalMessageDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalMessageDeclarationList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalMessageDeclarationList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalMessageDeclarationList::
reader_mMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalMessageDeclarationList::
reader_mMessageValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
modifier_setMMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalMessageDeclarationList::
modifier_setMMessageValueAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalMessageDeclarationList::cEnumerator::_mMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalMessageDeclarationList::cEnumerator::_mMessageValue (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalAttributeList::
elementOf_GGS_lexicalAttributeList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTypeName (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalAttributeList * ptr = dynamic_cast <const elementOf_GGS_lexicalAttributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalAttributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalAttributeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalAttributeList ("lexicalAttributeList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
operator_concat (const GGS_lexicalAttributeList & inOperand) const {
  GGS_lexicalAttributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
dotAssign_operation (const GGS_lexicalAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTypeName,
                                ptr->mName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexicalAttributeList::
constructor_emptyList (void) {
  GGS_lexicalAttributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexicalAttributeList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalAttributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
internalSubListWithRange (GGS_lexicalAttributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTypeName, ptr->mName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList GGS_lexicalAttributeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalAttributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalAttributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeList::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalAttributeList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalAttributeList::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalAttributeList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalStyleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalStyleList::
elementOf_GGS_lexicalStyleList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalStyleList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalStyleList * ptr = dynamic_cast <const elementOf_GGS_lexicalStyleList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mComment.operator_isEqual (ptr->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalStyleList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@lexicalStyleList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalStyleList ("lexicalStyleList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
operator_concat (const GGS_lexicalStyleList & inOperand) const {
  GGS_lexicalStyleList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
dotAssign_operation (const GGS_lexicalStyleList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalStyleList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mComment ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mName,
                                ptr->mComment
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexicalStyleList::
constructor_emptyList (void) {
  GGS_lexicalStyleList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexicalStyleList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalStyleList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
internalSubListWithRange (GGS_lexicalStyleList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mName, ptr->mComment) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalStyleList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList GGS_lexicalStyleList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalStyleList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalStyleList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalStyleList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mComment ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyleList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStyleList::
reader_mCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalStyleList::
modifier_setMCommentAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalStyleList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalStyleList::cEnumerator::_mComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mComment ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@terminalDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_terminalDeclarationList::
elementOf_GGS_terminalDeclarationList (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mSentAttributeList (argument_1),
mSyntaxErrorMessage (argument_2),
mStyle (argument_3),
mOptionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_terminalDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_terminalDeclarationList * ptr = dynamic_cast <const elementOf_GGS_terminalDeclarationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mSentAttributeList.operator_isEqual (ptr->mSentAttributeList).boolValue ()
         && mSyntaxErrorMessage.operator_isEqual (ptr->mSyntaxErrorMessage).boolValue ()
         && mStyle.operator_isEqual (ptr->mStyle).boolValue ()
         && mOptionList.operator_isEqual (ptr->mOptionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_terminalDeclarationList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@terminalDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_terminalDeclarationList ("terminalDeclarationList") ;

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_lstringlist & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_lstringlist & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
operator_concat (const GGS_terminalDeclarationList & inOperand) const {
  GGS_terminalDeclarationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
dotAssign_operation (const GGS_terminalDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_terminalDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstringlist  p_1 = p->mSentAttributeList ;
          GGS_lstring  p_2 = p->mSyntaxErrorMessage ;
          GGS_lstring  p_3 = p->mStyle ;
          GGS_lstringlist  p_4 = p->mOptionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_lstringlist & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mName,
                                ptr->mSentAttributeList,
                                ptr->mSyntaxErrorMessage,
                                ptr->mStyle,
                                ptr->mOptionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_terminalDeclarationList::
constructor_emptyList (void) {
  GGS_terminalDeclarationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_terminalDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) {
  GGS_terminalDeclarationList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
internalSubListWithRange (GGS_terminalDeclarationList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mName, ptr->mSentAttributeList, ptr->mSyntaxErrorMessage, ptr->mStyle, ptr->mOptionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList GGS_terminalDeclarationList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalDeclarationList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@terminalDeclarationList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_lstringlist & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_lstringlist & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_lstringlist & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_lstringlist & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mSentAttributeList ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mStyle ;
    _out_4 = ptr->mOptionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclarationList::
reader_mSentAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSentAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationList::
reader_mSyntaxErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalDeclarationList::
reader_mStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalDeclarationList::
reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMSentAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSentAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMSyntaxErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMStyleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalDeclarationList::
modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_terminalDeclarationList::cEnumerator::_mSentAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSentAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationList::cEnumerator::_mSyntaxErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_terminalDeclarationList::cEnumerator::_mStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_terminalDeclarationList::cEnumerator::_mOptionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalListEntryList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalListEntryList::
elementOf_GGS_lexicalListEntryList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntrySpelling (argument_0),
mTerminalSpelling (argument_1),
mFeatureList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalListEntryList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalListEntryList * ptr = dynamic_cast <const elementOf_GGS_lexicalListEntryList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntrySpelling.operator_isEqual (ptr->mEntrySpelling).boolValue ()
         && mTerminalSpelling.operator_isEqual (ptr->mTerminalSpelling).boolValue ()
         && mFeatureList.operator_isEqual (ptr->mFeatureList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalListEntryList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntrySpelling.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalSpelling.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFeatureList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lexicalListEntryList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalListEntryList ("lexicalListEntryList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
operator_concat (const GGS_lexicalListEntryList & inOperand) const {
  GGS_lexicalListEntryList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
dotAssign_operation (const GGS_lexicalListEntryList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalListEntryList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEntrySpelling ;
          GGS_lstring  p_1 = p->mTerminalSpelling ;
          GGS_lstringlist  p_2 = p->mFeatureList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEntrySpelling,
                                ptr->mTerminalSpelling,
                                ptr->mFeatureList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListEntryList::
constructor_emptyList (void) {
  GGS_lexicalListEntryList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListEntryList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  GGS_lexicalListEntryList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
internalSubListWithRange (GGS_lexicalListEntryList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntrySpelling, ptr->mTerminalSpelling, ptr->mFeatureList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList GGS_lexicalListEntryList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListEntryList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalListEntryList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstringlist & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstringlist & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstringlist & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstringlist & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntrySpelling ;
    _out_1 = ptr->mTerminalSpelling ;
    _out_2 = ptr->mFeatureList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntryList::
reader_mEntrySpellingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntrySpelling ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListEntryList::
reader_mTerminalSpellingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminalSpelling ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListEntryList::
reader_mFeatureListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFeatureList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_setMEntrySpellingAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntrySpelling = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_setMTerminalSpellingAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminalSpelling = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListEntryList::
modifier_setMFeatureListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFeatureList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListEntryList::cEnumerator::_mEntrySpelling (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntrySpelling ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListEntryList::cEnumerator::_mTerminalSpelling (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTerminalSpelling ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_lexicalListEntryList::cEnumerator::_mFeatureList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFeatureList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalListDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalListDeclarationList::
elementOf_GGS_lexicalListDeclarationList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mName (argument_0),
mStyle (argument_1),
mSyntaxErrorMessage (argument_2),
mSentAttributeList (argument_3),
mEntryList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalListDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalListDeclarationList * ptr = dynamic_cast <const elementOf_GGS_lexicalListDeclarationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mName.operator_isEqual (ptr->mName).boolValue ()
         && mStyle.operator_isEqual (ptr->mStyle).boolValue ()
         && mSyntaxErrorMessage.operator_isEqual (ptr->mSyntaxErrorMessage).boolValue ()
         && mSentAttributeList.operator_isEqual (ptr->mSentAttributeList).boolValue ()
         && mEntryList.operator_isEqual (ptr->mEntryList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalListDeclarationList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSentAttributeList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntryList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lexicalListDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalListDeclarationList ("lexicalListDeclarationList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_lexicalListEntryList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
operator_concat (const GGS_lexicalListDeclarationList & inOperand) const {
  GGS_lexicalListDeclarationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
dotAssign_operation (const GGS_lexicalListDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalListDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mName ;
          GGS_lstring  p_1 = p->mStyle ;
          GGS_lstring  p_2 = p->mSyntaxErrorMessage ;
          GGS_lstringlist  p_3 = p->mSentAttributeList ;
          GGS_lexicalListEntryList  p_4 = p->mEntryList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS_lexicalListEntryList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mName,
                                ptr->mStyle,
                                ptr->mSyntaxErrorMessage,
                                ptr->mSentAttributeList,
                                ptr->mEntryList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexicalListDeclarationList::
constructor_emptyList (void) {
  GGS_lexicalListDeclarationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexicalListDeclarationList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) {
  GGS_lexicalListDeclarationList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
internalSubListWithRange (GGS_lexicalListDeclarationList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mName, ptr->mStyle, ptr->mSyntaxErrorMessage, ptr->mSentAttributeList, ptr->mEntryList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList GGS_lexicalListDeclarationList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalListDeclarationList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalListDeclarationList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstringlist & _out_3,
              GGS_lexicalListEntryList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstringlist & _out_3,
             GGS_lexicalListEntryList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstringlist & _out_3,
                 GGS_lexicalListEntryList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstringlist & _out_3,
                GGS_lexicalListEntryList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mName ;
    _out_1 = ptr->mStyle ;
    _out_2 = ptr->mSyntaxErrorMessage ;
    _out_3 = ptr->mSentAttributeList ;
    _out_4 = ptr->mEntryList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationList::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationList::
reader_mStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalListDeclarationList::
reader_mSyntaxErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalListDeclarationList::
reader_mSentAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSentAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListEntryList  GGS_lexicalListDeclarationList::
reader_mEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalListEntryList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMStyleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMSyntaxErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMSentAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSentAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalListDeclarationList::
modifier_setMEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalListEntryList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationList::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationList::cEnumerator::_mStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalListDeclarationList::cEnumerator::_mSyntaxErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_lexicalListDeclarationList::cEnumerator::_mSentAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSentAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalListEntryList  & GGS_lexicalListDeclarationList::cEnumerator::_mEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntryList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalOrExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalOrExpression::
cPtr_lexicalOrExpression (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalOrExpression * GGS_lexicalOrExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalOrExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalOrExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalOrExpression * ptr = dynamic_cast <const cPtr_lexicalOrExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftOperand.operator_isEqual (ptr->mLeftOperand).boolValue ()
         && mRightOperand.operator_isEqual (ptr->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalOrExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalOrExpression:"
           << mLeftOperand.reader_description (inIndentation + 1)
           << mRightOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalOrExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalOrExpression (& typeid (cPtr_lexicalOrExpression), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalOrExpression::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalOrExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalOrExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalOrExpression (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalOrExpression ("lexicalOrExpression") ;

//---------------------------------------------------------------------------*

GGS_lexicalOrExpression::
GGS_lexicalOrExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpression::
GGS_lexicalOrExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalOrExpression GGS_lexicalOrExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalOrExpression *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalOrExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalOrExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalOrExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalOrExpression GGS_lexicalOrExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalExpression & argument_0,
                 const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalOrExpression result ;
  macroMyNew (result.mPointer, cPtr_lexicalOrExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalOrExpression::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalOrExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalOrExpression *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalOrExpression::actualTypeName (void) const {
  return "lexicalOrExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalOrExpression ("lexicalOrExpression", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalCharacterSetMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterSetMatch::
cPtr_lexicalCharacterSetMatch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mCharacterSetName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterSetMatch * GGS_lexicalCharacterSetMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterSetMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterSetMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterSetMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterSetMatch * ptr = dynamic_cast <const cPtr_lexicalCharacterSetMatch *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacterSetName.operator_isEqual (ptr->mCharacterSetName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterSetMatch::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterSetMatch:"
           << mCharacterSetName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterSetMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterSetMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterSetMatch (& typeid (cPtr_lexicalCharacterSetMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterSetMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterSetMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterSetMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterSetMatch (mCharacterSetName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterSetMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalCharacterSetMatch ("lexicalCharacterSetMatch") ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatch::
GGS_lexicalCharacterSetMatch (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatch::
GGS_lexicalCharacterSetMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterSetMatch GGS_lexicalCharacterSetMatch::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatch result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterSetMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterSetMatch) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterSetMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterSetMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterSetMatch GGS_lexicalCharacterSetMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterSetMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterSetMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalCharacterSetMatch::
reader_mCharacterSetName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterSetMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterSetMatch *) mPointer)->mCharacterSetName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterSetMatch::actualTypeName (void) const {
  return "lexicalCharacterSetMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterSetMatch ("lexicalCharacterSetMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalCharacterMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterMatch::
cPtr_lexicalCharacterMatch (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterMatch * GGS_lexicalCharacterMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterMatch * ptr = dynamic_cast <const cPtr_lexicalCharacterMatch *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterMatch::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterMatch:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterMatch (& typeid (cPtr_lexicalCharacterMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterMatch (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalCharacterMatch ("lexicalCharacterMatch") ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch::
GGS_lexicalCharacterMatch (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch::
GGS_lexicalCharacterMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterMatch GGS_lexicalCharacterMatch::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatch result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterMatch) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterMatch GGS_lexicalCharacterMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterMatch::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterMatch *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterMatch::actualTypeName (void) const {
  return "lexicalCharacterMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterMatch ("lexicalCharacterMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalCharacterIntervalMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterIntervalMatch::
cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mLowerBound (argument_0),
mUpperBound (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterIntervalMatch * GGS_lexicalCharacterIntervalMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterIntervalMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterIntervalMatch * ptr = dynamic_cast <const cPtr_lexicalCharacterIntervalMatch *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLowerBound.operator_isEqual (ptr->mLowerBound).boolValue ()
         && mUpperBound.operator_isEqual (ptr->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterIntervalMatch::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterIntervalMatch:"
           << mLowerBound.reader_description (inIndentation + 1)
           << mUpperBound.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterIntervalMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterIntervalMatch (& typeid (cPtr_lexicalCharacterIntervalMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterIntervalMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterIntervalMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterIntervalMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterIntervalMatch (mLowerBound, mUpperBound COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalCharacterIntervalMatch ("lexicalCharacterIntervalMatch") ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch::
GGS_lexicalCharacterIntervalMatch (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch::
GGS_lexicalCharacterIntervalMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterIntervalMatch GGS_lexicalCharacterIntervalMatch::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatch result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterIntervalMatch) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterIntervalMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterIntervalMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterIntervalMatch GGS_lexicalCharacterIntervalMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterIntervalMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterIntervalMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mLowerBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterIntervalMatch::
reader_mUpperBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterIntervalMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterIntervalMatch *) mPointer)->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterIntervalMatch::actualTypeName (void) const {
  return "lexicalCharacterIntervalMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterIntervalMatch ("lexicalCharacterIntervalMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_lexicalStringMatch'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringMatch::
cPtr_lexicalStringMatch (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringMatch * GGS_lexicalStringMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalStringMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStringMatch * ptr = dynamic_cast <const cPtr_lexicalStringMatch *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mString.operator_isEqual (ptr->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringMatch::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalStringMatch:"
           << mString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStringMatch (& typeid (cPtr_lexicalStringMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalStringMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStringMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStringMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStringMatch (mString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalStringMatch ("lexicalStringMatch") ;

//---------------------------------------------------------------------------*

GGS_lexicalStringMatch::
GGS_lexicalStringMatch (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatch::
GGS_lexicalStringMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalStringMatch GGS_lexicalStringMatch::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatch result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStringMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStringMatch) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalStringMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStringMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringMatch GGS_lexicalStringMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringMatch (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringMatch::actualTypeName (void) const {
  return "lexicalStringMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalStringMatch ("lexicalStringMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalStringNotMatch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStringNotMatch::
cPtr_lexicalStringNotMatch (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalExpression (THERE),
mString (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStringNotMatch * GGS_lexicalStringNotMatch::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalStringNotMatch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStringNotMatch::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStringNotMatch * ptr = dynamic_cast <const cPtr_lexicalStringNotMatch *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mString.operator_isEqual (ptr->mString).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStringNotMatch::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalStringNotMatch:"
           << mString.reader_description (inIndentation + 1)
           << mErrorMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStringNotMatch::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStringNotMatch (& typeid (cPtr_lexicalStringNotMatch), & typeid (cPtr_lexicalExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalStringNotMatch::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStringNotMatch ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStringNotMatch::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStringNotMatch (mString, mErrorMessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalStringNotMatch ("lexicalStringNotMatch") ;

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch::
GGS_lexicalStringNotMatch (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch::
GGS_lexicalStringNotMatch (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalStringNotMatch GGS_lexicalStringNotMatch::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatch result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStringNotMatch *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStringNotMatch) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalStringNotMatch (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStringNotMatch),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStringNotMatch GGS_lexicalStringNotMatch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStringNotMatch result ;
  macroMyNew (result.mPointer, cPtr_lexicalStringNotMatch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalStringNotMatch::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStringNotMatch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStringNotMatch *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStringNotMatch::actualTypeName (void) const {
  return "lexicalStringNotMatch" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalStringNotMatch ("lexicalStringNotMatch", gClassInfoFor__lexicalExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalSendSearchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalSendSearchList::
elementOf_GGS_lexicalSendSearchList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeName (argument_0),
mSearchListName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalSendSearchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalSendSearchList * ptr = dynamic_cast <const elementOf_GGS_lexicalSendSearchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mSearchListName.operator_isEqual (ptr->mSearchListName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalSendSearchList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchListName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalSendSearchList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalSendSearchList ("lexicalSendSearchList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
operator_concat (const GGS_lexicalSendSearchList & inOperand) const {
  GGS_lexicalSendSearchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
dotAssign_operation (const GGS_lexicalSendSearchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalSendSearchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_lstring  p_1 = p->mSearchListName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeName,
                                ptr->mSearchListName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalSendSearchList::
constructor_emptyList (void) {
  GGS_lexicalSendSearchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalSendSearchList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalSendSearchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
internalSubListWithRange (GGS_lexicalSendSearchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeName, ptr->mSearchListName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList GGS_lexicalSendSearchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSendSearchList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalSendSearchList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mSearchListName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearchList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendSearchList::
reader_mSearchListNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSearchListName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSendSearchList::
modifier_setMSearchListNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSearchListName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalSendSearchList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalSendSearchList::cEnumerator::_mSearchListName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSearchListName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalSendDefaultAction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendDefaultAction::
cPtr_lexicalSendDefaultAction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendDefaultAction * GGS_lexicalSendDefaultAction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendDefaultAction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSendDefaultAction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalSendDefaultAction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalSendDefaultAction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendDefaultAction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSendDefaultAction (& typeid (cPtr_lexicalSendDefaultAction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSendDefaultAction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSendDefaultAction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalSendDefaultAction ("lexicalSendDefaultAction") ;

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction::
GGS_lexicalSendDefaultAction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction::
GGS_lexicalSendDefaultAction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSendDefaultAction GGS_lexicalSendDefaultAction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSendDefaultAction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSendDefaultAction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSendDefaultAction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSendDefaultAction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSendDefaultAction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendDefaultAction::actualTypeName (void) const {
  return "lexicalSendDefaultAction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalSendDefaultAction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalSendDefaultAction ("lexicalSendDefaultAction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_lexicalStructuredSendInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalStructuredSendInstruction::
cPtr_lexicalStructuredSendInstruction (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mLexicalSendSearchList (argument_0),
mLexicalSendDefaultAction (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalStructuredSendInstruction * GGS_lexicalStructuredSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalStructuredSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalStructuredSendInstruction * ptr = dynamic_cast <const cPtr_lexicalStructuredSendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalSendSearchList.operator_isEqual (ptr->mLexicalSendSearchList).boolValue ()
         && mLexicalSendDefaultAction.operator_isEqual (ptr->mLexicalSendDefaultAction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalStructuredSendInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalStructuredSendInstruction:"
           << mLexicalSendSearchList.reader_description (inIndentation + 1)
           << mLexicalSendDefaultAction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalStructuredSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalStructuredSendInstruction (& typeid (cPtr_lexicalStructuredSendInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalStructuredSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalStructuredSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalStructuredSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalStructuredSendInstruction (mLexicalSendSearchList, mLexicalSendDefaultAction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalStructuredSendInstruction ("lexicalStructuredSendInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction::
GGS_lexicalStructuredSendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction::
GGS_lexicalStructuredSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalStructuredSendInstruction GGS_lexicalStructuredSendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalStructuredSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalStructuredSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalStructuredSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStructuredSendInstruction GGS_lexicalStructuredSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalSendSearchList & argument_0,
                 const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalStructuredSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalStructuredSendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendSearchList  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendSearchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendSearchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendSearchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendDefaultAction  GGS_lexicalStructuredSendInstruction::
reader_mLexicalSendDefaultAction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSendDefaultAction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalStructuredSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalStructuredSendInstruction *) mPointer)->mLexicalSendDefaultAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalStructuredSendInstruction::actualTypeName (void) const {
  return "lexicalStructuredSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalStructuredSendInstruction ("lexicalStructuredSendInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalSimpleSendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSimpleSendInstruction::
cPtr_lexicalSimpleSendInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSimpleSendInstruction * GGS_lexicalSimpleSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSimpleSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSimpleSendInstruction * ptr = dynamic_cast <const cPtr_lexicalSimpleSendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSentTerminal.operator_isEqual (ptr->mSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSimpleSendInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalSimpleSendInstruction:"
           << mSentTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSimpleSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSimpleSendInstruction (& typeid (cPtr_lexicalSimpleSendInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSimpleSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSimpleSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSimpleSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSimpleSendInstruction (mSentTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalSimpleSendInstruction ("lexicalSimpleSendInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction::
GGS_lexicalSimpleSendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction::
GGS_lexicalSimpleSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSimpleSendInstruction GGS_lexicalSimpleSendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSimpleSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSimpleSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSimpleSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSimpleSendInstruction GGS_lexicalSimpleSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSimpleSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSimpleSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSimpleSendInstruction::
reader_mSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSimpleSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSimpleSendInstruction *) mPointer)->mSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSimpleSendInstruction::actualTypeName (void) const {
  return "lexicalSimpleSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalSimpleSendInstruction ("lexicalSimpleSendInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalSendTerminalByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSendTerminalByDefault::
cPtr_lexicalSendTerminalByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalSendDefaultAction (THERE),
mDefaultSentTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSendTerminalByDefault * GGS_lexicalSendTerminalByDefault::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSendTerminalByDefault::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSendTerminalByDefault * ptr = dynamic_cast <const cPtr_lexicalSendTerminalByDefault *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDefaultSentTerminal.operator_isEqual (ptr->mDefaultSentTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSendTerminalByDefault::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalSendTerminalByDefault:"
           << mDefaultSentTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSendTerminalByDefault::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSendTerminalByDefault (& typeid (cPtr_lexicalSendTerminalByDefault), & typeid (cPtr_lexicalSendDefaultAction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSendTerminalByDefault::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSendTerminalByDefault ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSendTerminalByDefault::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSendTerminalByDefault (mDefaultSentTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalSendTerminalByDefault ("lexicalSendTerminalByDefault") ;

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault::
GGS_lexicalSendTerminalByDefault (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault::
GGS_lexicalSendTerminalByDefault (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSendTerminalByDefault GGS_lexicalSendTerminalByDefault::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefault result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSendTerminalByDefault) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSendTerminalByDefault (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSendTerminalByDefault),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSendTerminalByDefault GGS_lexicalSendTerminalByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSendTerminalByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalSendTerminalByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalSendTerminalByDefault::
reader_mDefaultSentTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSendTerminalByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSendTerminalByDefault *) mPointer)->mDefaultSentTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSendTerminalByDefault::actualTypeName (void) const {
  return "lexicalSendTerminalByDefault" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalSendTerminalByDefault ("lexicalSendTerminalByDefault", gClassInfoFor__lexicalSendDefaultAction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalErrorByDefault'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorByDefault::
cPtr_lexicalErrorByDefault (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalSendDefaultAction (THERE),
mDefaultErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorByDefault * GGS_lexicalErrorByDefault::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalErrorByDefault *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorByDefault::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalErrorByDefault * ptr = dynamic_cast <const cPtr_lexicalErrorByDefault *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDefaultErrorMessageName.operator_isEqual (ptr->mDefaultErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorByDefault::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalErrorByDefault:"
           << mDefaultErrorMessageName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorByDefault::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalErrorByDefault (& typeid (cPtr_lexicalErrorByDefault), & typeid (cPtr_lexicalSendDefaultAction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalErrorByDefault::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalErrorByDefault ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalErrorByDefault::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalErrorByDefault (mDefaultErrorMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalErrorByDefault ("lexicalErrorByDefault") ;

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault::
GGS_lexicalErrorByDefault (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault::
GGS_lexicalErrorByDefault (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalErrorByDefault GGS_lexicalErrorByDefault::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefault result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalErrorByDefault *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalErrorByDefault) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalErrorByDefault (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalErrorByDefault),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorByDefault GGS_lexicalErrorByDefault::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorByDefault result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorByDefault (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorByDefault::
reader_mDefaultErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorByDefault *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorByDefault *) mPointer)->mDefaultErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorByDefault::actualTypeName (void) const {
  return "lexicalErrorByDefault" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalErrorByDefault ("lexicalErrorByDefault", gClassInfoFor__lexicalSendDefaultAction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalWhileBranchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalWhileBranchList::
elementOf_GGS_lexicalWhileBranchList (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mWhileExpression (argument_0),
mWhileInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalWhileBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalWhileBranchList * ptr = dynamic_cast <const elementOf_GGS_lexicalWhileBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mWhileInstructionList.operator_isEqual (ptr->mWhileInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalWhileBranchList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@lexicalWhileBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalWhileBranchList ("lexicalWhileBranchList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
operator_concat (const GGS_lexicalWhileBranchList & inOperand) const {
  GGS_lexicalWhileBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
dotAssign_operation (const GGS_lexicalWhileBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalWhileBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mWhileExpression ;
          GGS_lexicalInstructionList  p_1 = p->mWhileInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mWhileExpression,
                                ptr->mWhileInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalWhileBranchList::
constructor_emptyList (void) {
  GGS_lexicalWhileBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalWhileBranchList::
constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  GGS_lexicalWhileBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
internalSubListWithRange (GGS_lexicalWhileBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mWhileExpression, ptr->mWhileInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList GGS_lexicalWhileBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalWhileBranchList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalWhileBranchList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
method_first (C_Compiler & inLexique,
              GGS_lexicalExpression & _out_0,
              GGS_lexicalInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
method_last (C_Compiler & inLexique,
             GGS_lexicalExpression & _out_0,
             GGS_lexicalInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lexicalExpression & _out_0,
                 GGS_lexicalInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lexicalExpression & _out_0,
                GGS_lexicalInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mWhileExpression ;
    _out_1 = ptr->mWhileInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalWhileBranchList::
reader_mWhileExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mWhileExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalWhileBranchList::
reader_mWhileInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mWhileInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_setMWhileExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mWhileExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalWhileBranchList::
modifier_setMWhileInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mWhileInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpression  & GGS_lexicalWhileBranchList::cEnumerator::_mWhileExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWhileExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionList  & GGS_lexicalWhileBranchList::cEnumerator::_mWhileInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWhileInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalRepeatInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRepeatInstruction::
cPtr_lexicalRepeatInstruction (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mRepeatedInstructionList (argument_0),
mLexicalWhileBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRepeatInstruction * GGS_lexicalRepeatInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalRepeatInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRepeatInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRepeatInstruction * ptr = dynamic_cast <const cPtr_lexicalRepeatInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRepeatedInstructionList.operator_isEqual (ptr->mRepeatedInstructionList).boolValue ()
         && mLexicalWhileBranchList.operator_isEqual (ptr->mLexicalWhileBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRepeatInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalRepeatInstruction:"
           << mRepeatedInstructionList.reader_description (inIndentation + 1)
           << mLexicalWhileBranchList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRepeatInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRepeatInstruction (& typeid (cPtr_lexicalRepeatInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalRepeatInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRepeatInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRepeatInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRepeatInstruction (mRepeatedInstructionList, mLexicalWhileBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalRepeatInstruction ("lexicalRepeatInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction::
GGS_lexicalRepeatInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction::
GGS_lexicalRepeatInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRepeatInstruction GGS_lexicalRepeatInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRepeatInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRepeatInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRepeatInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRepeatInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRepeatInstruction GGS_lexicalRepeatInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalInstructionList & argument_0,
                 const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRepeatInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRepeatInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalRepeatInstruction::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWhileBranchList  GGS_lexicalRepeatInstruction::
reader_mLexicalWhileBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalWhileBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRepeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRepeatInstruction *) mPointer)->mLexicalWhileBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRepeatInstruction::actualTypeName (void) const {
  return "lexicalRepeatInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalRepeatInstruction ("lexicalRepeatInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalSelectBranchList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalSelectBranchList::
elementOf_GGS_lexicalSelectBranchList (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSelectExpression (argument_0),
mSelectInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalSelectBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalSelectBranchList * ptr = dynamic_cast <const elementOf_GGS_lexicalSelectBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSelectExpression.operator_isEqual (ptr->mSelectExpression).boolValue ()
         && mSelectInstructionList.operator_isEqual (ptr->mSelectInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalSelectBranchList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@lexicalSelectBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalSelectBranchList ("lexicalSelectBranchList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
internalAppendValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
internalPrependValues (const GGS_lexicalExpression & argument_0,
                    const GGS_lexicalInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
operator_concat (const GGS_lexicalSelectBranchList & inOperand) const {
  GGS_lexicalSelectBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
dotAssign_operation (const GGS_lexicalSelectBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalSelectBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalExpression  p_0 = p->mSelectExpression ;
          GGS_lexicalInstructionList  p_1 = p->mSelectInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalExpression & argument_0,
                     const GGS_lexicalInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSelectExpression,
                                ptr->mSelectInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectBranchList::
constructor_emptyList (void) {
  GGS_lexicalSelectBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectBranchList::
constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) {
  GGS_lexicalSelectBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
internalSubListWithRange (GGS_lexicalSelectBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSelectExpression, ptr->mSelectInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList GGS_lexicalSelectBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalSelectBranchList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalSelectBranchList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
method_first (C_Compiler & inLexique,
              GGS_lexicalExpression & _out_0,
              GGS_lexicalInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
method_last (C_Compiler & inLexique,
             GGS_lexicalExpression & _out_0,
             GGS_lexicalInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lexicalExpression & _out_0,
                 GGS_lexicalInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lexicalExpression & _out_0,
                GGS_lexicalInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSelectExpression ;
    _out_1 = ptr->mSelectInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExpression  GGS_lexicalSelectBranchList::
reader_mSelectExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSelectExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalSelectBranchList::
reader_mSelectInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSelectInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_setMSelectExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSelectExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalSelectBranchList::
modifier_setMSelectInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSelectInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExpression  & GGS_lexicalSelectBranchList::cEnumerator::_mSelectExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSelectExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalInstructionList  & GGS_lexicalSelectBranchList::cEnumerator::_mSelectInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSelectInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalSelectInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalSelectInstruction::
cPtr_lexicalSelectInstruction (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mLexicalSelectBranchList (argument_0),
mDefaultInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalSelectInstruction * GGS_lexicalSelectInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalSelectInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalSelectInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalSelectInstruction * ptr = dynamic_cast <const cPtr_lexicalSelectInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalSelectBranchList.operator_isEqual (ptr->mLexicalSelectBranchList).boolValue ()
         && mDefaultInstructionList.operator_isEqual (ptr->mDefaultInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalSelectInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalSelectInstruction:"
           << mLexicalSelectBranchList.reader_description (inIndentation + 1)
           << mDefaultInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalSelectInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalSelectInstruction (& typeid (cPtr_lexicalSelectInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalSelectInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalSelectInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalSelectInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalSelectInstruction (mLexicalSelectBranchList, mDefaultInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalSelectInstruction ("lexicalSelectInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction::
GGS_lexicalSelectInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction::
GGS_lexicalSelectInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalSelectInstruction GGS_lexicalSelectInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalSelectInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalSelectInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalSelectInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalSelectInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectInstruction GGS_lexicalSelectInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lexicalSelectBranchList & argument_0,
                 const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalSelectInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalSelectInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalSelectBranchList  GGS_lexicalSelectInstruction::
reader_mLexicalSelectBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalSelectBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mLexicalSelectBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalInstructionList  GGS_lexicalSelectInstruction::
reader_mDefaultInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalSelectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalSelectInstruction *) mPointer)->mDefaultInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalSelectInstruction::actualTypeName (void) const {
  return "lexicalSelectInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalSelectInstruction ("lexicalSelectInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_abstractLexicalRoutineActualArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractLexicalRoutineActualArgument::
cPtr_abstractLexicalRoutineActualArgument (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mActualPassingModeLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractLexicalRoutineActualArgument * GGS_abstractLexicalRoutineActualArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractLexicalRoutineActualArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_abstractLexicalRoutineActualArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_abstractLexicalRoutineActualArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@abstractLexicalRoutineActualArgument:"
           << mActualPassingModeLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRoutineActualArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractLexicalRoutineActualArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractLexicalRoutineActualArgument (& typeid (cPtr_abstractLexicalRoutineActualArgument), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_abstractLexicalRoutineActualArgument::galgasRTTI (void) const {
  return & gClassInfoFor__abstractLexicalRoutineActualArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_abstractLexicalRoutineActualArgument'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_abstractLexicalRoutineActualArgument ("abstractLexicalRoutineActualArgument") ;

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgument::
GGS_abstractLexicalRoutineActualArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgument::
GGS_abstractLexicalRoutineActualArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractLexicalRoutineActualArgument GGS_abstractLexicalRoutineActualArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractLexicalRoutineActualArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractLexicalRoutineActualArgument *> (inPointer) != NULL)
      : (typeid (cPtr_abstractLexicalRoutineActualArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractLexicalRoutineActualArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractLexicalRoutineActualArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_abstractLexicalRoutineActualArgument::
reader_mActualPassingModeLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractLexicalRoutineActualArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractLexicalRoutineActualArgument *) mPointer)->mActualPassingModeLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractLexicalRoutineActualArgument::actualTypeName (void) const {
  return "abstractLexicalRoutineActualArgument" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_abstractLexicalRoutineActualArgument::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__abstractLexicalRoutineActualArgument ("abstractLexicalRoutineActualArgument") ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalRoutineCallActualArgumentList'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalRoutineCallActualArgumentList::
elementOf_GGS_lexicalRoutineCallActualArgumentList (const GGS_abstractLexicalRoutineActualArgument & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexicalRoutineActualArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalRoutineCallActualArgumentList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalRoutineCallActualArgumentList * ptr = dynamic_cast <const elementOf_GGS_lexicalRoutineCallActualArgumentList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalRoutineActualArgument.operator_isEqual (ptr->mLexicalRoutineActualArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalRoutineCallActualArgumentList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRoutineActualArgument.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@lexicalRoutineCallActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalRoutineCallActualArgumentList ("lexicalRoutineCallActualArgumentList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
internalAppendValues (const GGS_abstractLexicalRoutineActualArgument & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
internalPrependValues (const GGS_abstractLexicalRoutineActualArgument & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
addAssign_operation (const GGS_abstractLexicalRoutineActualArgument & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentList GGS_lexicalRoutineCallActualArgumentList::
operator_concat (const GGS_lexicalRoutineCallActualArgumentList & inOperand) const {
  GGS_lexicalRoutineCallActualArgumentList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
dotAssign_operation (const GGS_lexicalRoutineCallActualArgumentList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalRoutineCallActualArgumentList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_abstractLexicalRoutineActualArgument  p_0 = p->mLexicalRoutineActualArgument ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_abstractLexicalRoutineActualArgument & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalRoutineActualArgument
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentList  GGS_lexicalRoutineCallActualArgumentList::
constructor_emptyList (void) {
  GGS_lexicalRoutineCallActualArgumentList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentList  GGS_lexicalRoutineCallActualArgumentList::
constructor_listWithValue (const GGS_abstractLexicalRoutineActualArgument & argument_0) {
  GGS_lexicalRoutineCallActualArgumentList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
internalSubListWithRange (GGS_lexicalRoutineCallActualArgumentList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalRoutineActualArgument) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentList GGS_lexicalRoutineCallActualArgumentList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRoutineCallActualArgumentList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentList GGS_lexicalRoutineCallActualArgumentList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalRoutineCallActualArgumentList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalRoutineCallActualArgumentList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalRoutineCallActualArgumentList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
method_first (C_Compiler & inLexique,
              GGS_abstractLexicalRoutineActualArgument & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
method_last (C_Compiler & inLexique,
             GGS_abstractLexicalRoutineActualArgument & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_abstractLexicalRoutineActualArgument & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
modifier_popLast (C_Compiler & inLexique,
                GGS_abstractLexicalRoutineActualArgument & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalRoutineActualArgument ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractLexicalRoutineActualArgument  GGS_lexicalRoutineCallActualArgumentList::
reader_mLexicalRoutineActualArgumentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_abstractLexicalRoutineActualArgument  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRoutineActualArgument ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalRoutineCallActualArgumentList::
modifier_setMLexicalRoutineActualArgumentAtIndex (C_Compiler & inLexique,
                              const GGS_abstractLexicalRoutineActualArgument  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRoutineActualArgument = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_abstractLexicalRoutineActualArgument  & GGS_lexicalRoutineCallActualArgumentList::cEnumerator::_mLexicalRoutineActualArgument (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalRoutineActualArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalRoutineInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRoutineInstruction::
cPtr_lexicalRoutineInstruction (const GGS_lstring & argument_0,
                                const GGS_lexicalRoutineCallActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mRoutineName (argument_0),
mActualArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRoutineInstruction * GGS_lexicalRoutineInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalRoutineInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRoutineInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRoutineInstruction * ptr = dynamic_cast <const cPtr_lexicalRoutineInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualArgumentList.operator_isEqual (ptr->mActualArgumentList).boolValue ()
         && mErrorMessageList.operator_isEqual (ptr->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRoutineInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalRoutineInstruction:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualArgumentList.reader_description (inIndentation + 1)
           << mErrorMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRoutineInstruction (& typeid (cPtr_lexicalRoutineInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalRoutineInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRoutineInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRoutineInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRoutineInstruction (mRoutineName, mActualArgumentList, mErrorMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRoutineInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalRoutineInstruction ("lexicalRoutineInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstruction::
GGS_lexicalRoutineInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstruction::
GGS_lexicalRoutineInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRoutineInstruction GGS_lexicalRoutineInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRoutineInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRoutineInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRoutineInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRoutineInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineInstruction GGS_lexicalRoutineInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalRoutineCallActualArgumentList & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRoutineInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRoutineInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRoutineInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineCallActualArgumentList  GGS_lexicalRoutineInstruction::
reader_mActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalRoutineCallActualArgumentList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRoutineInstruction *) mPointer)->mActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_lexicalRoutineInstruction::
reader_mErrorMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRoutineInstruction *) mPointer)->mErrorMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRoutineInstruction::actualTypeName (void) const {
  return "lexicalRoutineInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalRoutineInstruction ("lexicalRoutineInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_lexicalAttributeInputOutputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeInputOutputArgument::
cPtr_lexicalAttributeInputOutputArgument (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRoutineActualArgument (argument_0 COMMA_THERE),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeInputOutputArgument * GGS_lexicalAttributeInputOutputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeInputOutputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalAttributeInputOutputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeInputOutputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalAttributeInputOutputArgument * ptr = dynamic_cast <const cPtr_lexicalAttributeInputOutputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualPassingModeLocation.operator_isEqual (ptr->mActualPassingModeLocation).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeInputOutputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalAttributeInputOutputArgument:"
           << mActualPassingModeLocation.reader_description (inIndentation + 1)
           << mAttributeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputOutputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputOutputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalAttributeInputOutputArgument (& typeid (cPtr_lexicalAttributeInputOutputArgument), & typeid (cPtr_abstractLexicalRoutineActualArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalAttributeInputOutputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalAttributeInputOutputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalAttributeInputOutputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalAttributeInputOutputArgument (mActualPassingModeLocation, mAttributeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_lexicalAttributeInputOutputArgument'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalAttributeInputOutputArgument ("lexicalAttributeInputOutputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgument::
GGS_lexicalAttributeInputOutputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgument::
GGS_lexicalAttributeInputOutputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalAttributeInputOutputArgument GGS_lexicalAttributeInputOutputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputOutputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalAttributeInputOutputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalAttributeInputOutputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalAttributeInputOutputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalAttributeInputOutputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputOutputArgument GGS_lexicalAttributeInputOutputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputOutputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeInputOutputArgument (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeInputOutputArgument::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeInputOutputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeInputOutputArgument *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeInputOutputArgument::actualTypeName (void) const {
  return "lexicalAttributeInputOutputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalAttributeInputOutputArgument ("lexicalAttributeInputOutputArgument", gClassInfoFor__abstractLexicalRoutineActualArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         class 'cPtr_lexicalRoutineOrFunctionFormalInputArgument'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRoutineOrFunctionFormalInputArgument::
cPtr_lexicalRoutineOrFunctionFormalInputArgument (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRoutineOrFunctionFormalInputArgument * GGS_lexicalRoutineOrFunctionFormalInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRoutineOrFunctionFormalInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalRoutineOrFunctionFormalInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_lexicalRoutineOrFunctionFormalInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalRoutineOrFunctionFormalInputArgument:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineOrFunctionFormalInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRoutineOrFunctionFormalInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRoutineOrFunctionFormalInputArgument (& typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalRoutineOrFunctionFormalInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_lexicalRoutineOrFunctionFormalInputArgument'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalRoutineOrFunctionFormalInputArgument ("lexicalRoutineOrFunctionFormalInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgument::
GGS_lexicalRoutineOrFunctionFormalInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgument::
GGS_lexicalRoutineOrFunctionFormalInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRoutineOrFunctionFormalInputArgument GGS_lexicalRoutineOrFunctionFormalInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRoutineOrFunctionFormalInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRoutineOrFunctionFormalInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRoutineOrFunctionFormalInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRoutineOrFunctionFormalInputArgument::actualTypeName (void) const {
  return "lexicalRoutineOrFunctionFormalInputArgument" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexicalRoutineOrFunctionFormalInputArgument::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument ("lexicalRoutineOrFunctionFormalInputArgument") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lexicalFormalInputArgument'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFormalInputArgument::
cPtr_lexicalFormalInputArgument (const GGS_location & argument_0,
                                const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_abstractLexicalRoutineActualArgument (argument_0 COMMA_THERE),
mRoutineOrFunctionFormalInputArgument (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFormalInputArgument * GGS_lexicalFormalInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFormalInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalFormalInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalFormalInputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalFormalInputArgument * ptr = dynamic_cast <const cPtr_lexicalFormalInputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualPassingModeLocation.operator_isEqual (ptr->mActualPassingModeLocation).boolValue ()
         && mRoutineOrFunctionFormalInputArgument.operator_isEqual (ptr->mRoutineOrFunctionFormalInputArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFormalInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalFormalInputArgument:"
           << mActualPassingModeLocation.reader_description (inIndentation + 1)
           << mRoutineOrFunctionFormalInputArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalFormalInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFormalInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalFormalInputArgument (& typeid (cPtr_lexicalFormalInputArgument), & typeid (cPtr_abstractLexicalRoutineActualArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalFormalInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalFormalInputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalFormalInputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalFormalInputArgument (mActualPassingModeLocation, mRoutineOrFunctionFormalInputArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalFormalInputArgument'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalFormalInputArgument ("lexicalFormalInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgument::
GGS_lexicalFormalInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgument::
GGS_lexicalFormalInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalFormalInputArgument GGS_lexicalFormalInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalFormalInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalFormalInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalFormalInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalFormalInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalFormalInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFormalInputArgument GGS_lexicalFormalInputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFormalInputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalFormalInputArgument (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgument  GGS_lexicalFormalInputArgument::
reader_mRoutineOrFunctionFormalInputArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalRoutineOrFunctionFormalInputArgument   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFormalInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFormalInputArgument *) mPointer)->mRoutineOrFunctionFormalInputArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFormalInputArgument::actualTypeName (void) const {
  return "lexicalFormalInputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalFormalInputArgument ("lexicalFormalInputArgument", gClassInfoFor__abstractLexicalRoutineActualArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalFunctionCallActualArgumentList'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalFunctionCallActualArgumentList::
elementOf_GGS_lexicalFunctionCallActualArgumentList (const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexicalActualInputArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalFunctionCallActualArgumentList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalFunctionCallActualArgumentList * ptr = dynamic_cast <const elementOf_GGS_lexicalFunctionCallActualArgumentList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalActualInputArgument.operator_isEqual (ptr->mLexicalActualInputArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalFunctionCallActualArgumentList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalActualInputArgument.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@lexicalFunctionCallActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalFunctionCallActualArgumentList ("lexicalFunctionCallActualArgumentList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
internalAppendValues (const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
internalPrependValues (const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
addAssign_operation (const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentList GGS_lexicalFunctionCallActualArgumentList::
operator_concat (const GGS_lexicalFunctionCallActualArgumentList & inOperand) const {
  GGS_lexicalFunctionCallActualArgumentList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
dotAssign_operation (const GGS_lexicalFunctionCallActualArgumentList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalFunctionCallActualArgumentList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalRoutineOrFunctionFormalInputArgument  p_0 = p->mLexicalActualInputArgument ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalActualInputArgument
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentList  GGS_lexicalFunctionCallActualArgumentList::
constructor_emptyList (void) {
  GGS_lexicalFunctionCallActualArgumentList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentList  GGS_lexicalFunctionCallActualArgumentList::
constructor_listWithValue (const GGS_lexicalRoutineOrFunctionFormalInputArgument & argument_0) {
  GGS_lexicalFunctionCallActualArgumentList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
internalSubListWithRange (GGS_lexicalFunctionCallActualArgumentList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalActualInputArgument) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentList GGS_lexicalFunctionCallActualArgumentList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalFunctionCallActualArgumentList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentList GGS_lexicalFunctionCallActualArgumentList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalFunctionCallActualArgumentList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalFunctionCallActualArgumentList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalFunctionCallActualArgumentList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
method_first (C_Compiler & inLexique,
              GGS_lexicalRoutineOrFunctionFormalInputArgument & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
method_last (C_Compiler & inLexique,
             GGS_lexicalRoutineOrFunctionFormalInputArgument & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lexicalRoutineOrFunctionFormalInputArgument & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lexicalRoutineOrFunctionFormalInputArgument & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalActualInputArgument ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalRoutineOrFunctionFormalInputArgument  GGS_lexicalFunctionCallActualArgumentList::
reader_mLexicalActualInputArgumentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalRoutineOrFunctionFormalInputArgument  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalActualInputArgument ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalFunctionCallActualArgumentList::
modifier_setMLexicalActualInputArgumentAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalRoutineOrFunctionFormalInputArgument  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalActualInputArgument = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalRoutineOrFunctionFormalInputArgument  & GGS_lexicalFunctionCallActualArgumentList::cEnumerator::_mLexicalActualInputArgument (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalActualInputArgument ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalAttributeInputArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalAttributeInputArgument::
cPtr_lexicalAttributeInputArgument (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgument (THERE),
mAttributeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalAttributeInputArgument * GGS_lexicalAttributeInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalAttributeInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalAttributeInputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalAttributeInputArgument * ptr = dynamic_cast <const cPtr_lexicalAttributeInputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalAttributeInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalAttributeInputArgument:"
           << mAttributeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalAttributeInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalAttributeInputArgument (& typeid (cPtr_lexicalAttributeInputArgument), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalAttributeInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalAttributeInputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalAttributeInputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalAttributeInputArgument (mAttributeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalAttributeInputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalAttributeInputArgument ("lexicalAttributeInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgument::
GGS_lexicalAttributeInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgument::
GGS_lexicalAttributeInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalAttributeInputArgument GGS_lexicalAttributeInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalAttributeInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalAttributeInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalAttributeInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalAttributeInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeInputArgument GGS_lexicalAttributeInputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalAttributeInputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalAttributeInputArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalAttributeInputArgument::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalAttributeInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalAttributeInputArgument *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalAttributeInputArgument::actualTypeName (void) const {
  return "lexicalAttributeInputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalAttributeInputArgument ("lexicalAttributeInputArgument", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalCharacterInputArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCharacterInputArgument::
cPtr_lexicalCharacterInputArgument (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgument (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCharacterInputArgument * GGS_lexicalCharacterInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCharacterInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCharacterInputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCharacterInputArgument * ptr = dynamic_cast <const cPtr_lexicalCharacterInputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCharacterInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCharacterInputArgument:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCharacterInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCharacterInputArgument (& typeid (cPtr_lexicalCharacterInputArgument), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCharacterInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCharacterInputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCharacterInputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCharacterInputArgument (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterInputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalCharacterInputArgument ("lexicalCharacterInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgument::
GGS_lexicalCharacterInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgument::
GGS_lexicalCharacterInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCharacterInputArgument GGS_lexicalCharacterInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCharacterInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCharacterInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCharacterInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCharacterInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCharacterInputArgument GGS_lexicalCharacterInputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCharacterInputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCharacterInputArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_lexicalCharacterInputArgument::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCharacterInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCharacterInputArgument *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCharacterInputArgument::actualTypeName (void) const {
  return "lexicalCharacterInputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterInputArgument ("lexicalCharacterInputArgument", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalUnsignedInputArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalUnsignedInputArgument::
cPtr_lexicalUnsignedInputArgument (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgument (THERE),
mUnsigned (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalUnsignedInputArgument * GGS_lexicalUnsignedInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalUnsignedInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalUnsignedInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalUnsignedInputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalUnsignedInputArgument * ptr = dynamic_cast <const cPtr_lexicalUnsignedInputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUnsigned.operator_isEqual (ptr->mUnsigned).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalUnsignedInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalUnsignedInputArgument:"
           << mUnsigned.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalUnsignedInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalUnsignedInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalUnsignedInputArgument (& typeid (cPtr_lexicalUnsignedInputArgument), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalUnsignedInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalUnsignedInputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalUnsignedInputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalUnsignedInputArgument (mUnsigned COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalUnsignedInputArgument'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalUnsignedInputArgument ("lexicalUnsignedInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgument::
GGS_lexicalUnsignedInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgument::
GGS_lexicalUnsignedInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalUnsignedInputArgument GGS_lexicalUnsignedInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalUnsignedInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalUnsignedInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalUnsignedInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalUnsignedInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalUnsignedInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalUnsignedInputArgument GGS_lexicalUnsignedInputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalUnsignedInputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalUnsignedInputArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_lexicalUnsignedInputArgument::
reader_mUnsigned (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalUnsignedInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalUnsignedInputArgument *) mPointer)->mUnsigned ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalUnsignedInputArgument::actualTypeName (void) const {
  return "lexicalUnsignedInputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalUnsignedInputArgument ("lexicalUnsignedInputArgument", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_lexicalCurrentCharacterInputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalCurrentCharacterInputArgument::
cPtr_lexicalCurrentCharacterInputArgument (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgument (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalCurrentCharacterInputArgument * GGS_lexicalCurrentCharacterInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCurrentCharacterInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalCurrentCharacterInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalCurrentCharacterInputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalCurrentCharacterInputArgument * ptr = dynamic_cast <const cPtr_lexicalCurrentCharacterInputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalCurrentCharacterInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalCurrentCharacterInputArgument:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalCurrentCharacterInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalCurrentCharacterInputArgument (& typeid (cPtr_lexicalCurrentCharacterInputArgument), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalCurrentCharacterInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalCurrentCharacterInputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalCurrentCharacterInputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalCurrentCharacterInputArgument (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_lexicalCurrentCharacterInputArgument'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalCurrentCharacterInputArgument ("lexicalCurrentCharacterInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgument::
GGS_lexicalCurrentCharacterInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgument::
GGS_lexicalCurrentCharacterInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalCurrentCharacterInputArgument GGS_lexicalCurrentCharacterInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalCurrentCharacterInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalCurrentCharacterInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalCurrentCharacterInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalCurrentCharacterInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalCurrentCharacterInputArgument GGS_lexicalCurrentCharacterInputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalCurrentCharacterInputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalCurrentCharacterInputArgument (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lexicalCurrentCharacterInputArgument::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalCurrentCharacterInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalCurrentCharacterInputArgument *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalCurrentCharacterInputArgument::actualTypeName (void) const {
  return "lexicalCurrentCharacterInputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalCurrentCharacterInputArgument ("lexicalCurrentCharacterInputArgument", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_lexicalFunctionInputArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalFunctionInputArgument::
cPtr_lexicalFunctionInputArgument (const GGS_lstring & argument_0,
                                const GGS_lexicalFunctionCallActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalRoutineOrFunctionFormalInputArgument (THERE),
mFunctionName (argument_0),
mFunctionActualArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalFunctionInputArgument * GGS_lexicalFunctionInputArgument::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalFunctionInputArgument *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalFunctionInputArgument::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalFunctionInputArgument * ptr = dynamic_cast <const cPtr_lexicalFunctionInputArgument *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFunctionActualArgumentList.operator_isEqual (ptr->mFunctionActualArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalFunctionInputArgument::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalFunctionInputArgument:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFunctionActualArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionInputArgument::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalFunctionInputArgument::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalFunctionInputArgument (& typeid (cPtr_lexicalFunctionInputArgument), & typeid (cPtr_lexicalRoutineOrFunctionFormalInputArgument), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalFunctionInputArgument::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalFunctionInputArgument ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalFunctionInputArgument::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalFunctionInputArgument (mFunctionName, mFunctionActualArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalFunctionInputArgument'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalFunctionInputArgument ("lexicalFunctionInputArgument") ;

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgument::
GGS_lexicalFunctionInputArgument (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgument::
GGS_lexicalFunctionInputArgument (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalFunctionInputArgument GGS_lexicalFunctionInputArgument::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionInputArgument result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalFunctionInputArgument *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalFunctionInputArgument) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalFunctionInputArgument (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalFunctionInputArgument),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionInputArgument GGS_lexicalFunctionInputArgument::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lexicalFunctionCallActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalFunctionInputArgument result ;
  macroMyNew (result.mPointer, cPtr_lexicalFunctionInputArgument (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalFunctionInputArgument::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionInputArgument *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalFunctionCallActualArgumentList  GGS_lexicalFunctionInputArgument::
reader_mFunctionActualArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalFunctionCallActualArgumentList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalFunctionInputArgument *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalFunctionInputArgument *) mPointer)->mFunctionActualArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalFunctionInputArgument::actualTypeName (void) const {
  return "lexicalFunctionInputArgument" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalFunctionInputArgument ("lexicalFunctionInputArgument", gClassInfoFor__lexicalRoutineOrFunctionFormalInputArgument) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalDropInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalDropInstruction::
cPtr_lexicalDropInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mTerminalName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalDropInstruction * GGS_lexicalDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalDropInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalDropInstruction * ptr = dynamic_cast <const cPtr_lexicalDropInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTerminalName.operator_isEqual (ptr->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalDropInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalDropInstruction:"
           << mTerminalName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalDropInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalDropInstruction (& typeid (cPtr_lexicalDropInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalDropInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalDropInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalDropInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalDropInstruction (mTerminalName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalDropInstruction ("lexicalDropInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction::
GGS_lexicalDropInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction::
GGS_lexicalDropInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalDropInstruction GGS_lexicalDropInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalDropInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalDropInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalDropInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalDropInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalDropInstruction GGS_lexicalDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalDropInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalDropInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalDropInstruction::actualTypeName (void) const {
  return "lexicalDropInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalDropInstruction ("lexicalDropInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lexicalErrorInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalErrorInstruction::
cPtr_lexicalErrorInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mErrorMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalErrorInstruction * GGS_lexicalErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalErrorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalErrorInstruction * ptr = dynamic_cast <const cPtr_lexicalErrorInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorMessageName.operator_isEqual (ptr->mErrorMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalErrorInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalErrorInstruction:"
           << mErrorMessageName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalErrorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalErrorInstruction (& typeid (cPtr_lexicalErrorInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalErrorInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalErrorInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalErrorInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalErrorInstruction (mErrorMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalErrorInstruction ("lexicalErrorInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction::
GGS_lexicalErrorInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction::
GGS_lexicalErrorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalErrorInstruction GGS_lexicalErrorInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalErrorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalErrorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalErrorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalErrorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalErrorInstruction GGS_lexicalErrorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalErrorInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalErrorInstruction::
reader_mErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalErrorInstruction *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalErrorInstruction::actualTypeName (void) const {
  return "lexicalErrorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalErrorInstruction ("lexicalErrorInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalWarningInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalWarningInstruction::
cPtr_lexicalWarningInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mWarningMessageName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalWarningInstruction * GGS_lexicalWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalWarningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalWarningInstruction * ptr = dynamic_cast <const cPtr_lexicalWarningInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWarningMessageName.operator_isEqual (ptr->mWarningMessageName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalWarningInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalWarningInstruction:"
           << mWarningMessageName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalWarningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalWarningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalWarningInstruction (& typeid (cPtr_lexicalWarningInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalWarningInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalWarningInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalWarningInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalWarningInstruction (mWarningMessageName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalWarningInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalWarningInstruction ("lexicalWarningInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstruction::
GGS_lexicalWarningInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstruction::
GGS_lexicalWarningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalWarningInstruction GGS_lexicalWarningInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalWarningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalWarningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalWarningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalWarningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalWarningInstruction GGS_lexicalWarningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalWarningInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalWarningInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalWarningInstruction::
reader_mWarningMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalWarningInstruction *) mPointer)->mWarningMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalWarningInstruction::actualTypeName (void) const {
  return "lexicalWarningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalWarningInstruction ("lexicalWarningInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalTagInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalTagInstruction::
cPtr_lexicalTagInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mLexicalTagName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalTagInstruction * GGS_lexicalTagInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalTagInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalTagInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalTagInstruction * ptr = dynamic_cast <const cPtr_lexicalTagInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTagName.operator_isEqual (ptr->mLexicalTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalTagInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalTagInstruction:"
           << mLexicalTagName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalTagInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalTagInstruction (& typeid (cPtr_lexicalTagInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalTagInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalTagInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalTagInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalTagInstruction (mLexicalTagName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalTagInstruction ("lexicalTagInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction::
GGS_lexicalTagInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction::
GGS_lexicalTagInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalTagInstruction GGS_lexicalTagInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalTagInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalTagInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalTagInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalTagInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTagInstruction GGS_lexicalTagInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalTagInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalTagInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalTagInstruction::
reader_mLexicalTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalTagInstruction *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalTagInstruction::actualTypeName (void) const {
  return "lexicalTagInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalTagInstruction ("lexicalTagInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lexicalRewindInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalRewindInstruction::
cPtr_lexicalRewindInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE),
mLexicalTagName (argument_0),
mTerminalName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalRewindInstruction * GGS_lexicalRewindInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalRewindInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalRewindInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexicalRewindInstruction * ptr = dynamic_cast <const cPtr_lexicalRewindInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTagName.operator_isEqual (ptr->mLexicalTagName).boolValue ()
         && mTerminalName.operator_isEqual (ptr->mTerminalName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalRewindInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexicalRewindInstruction:"
           << mLexicalTagName.reader_description (inIndentation + 1)
           << mTerminalName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalRewindInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalRewindInstruction (& typeid (cPtr_lexicalRewindInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalRewindInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalRewindInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexicalRewindInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexicalRewindInstruction (mLexicalTagName, mTerminalName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalRewindInstruction ("lexicalRewindInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction::
GGS_lexicalRewindInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction::
GGS_lexicalRewindInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalRewindInstruction GGS_lexicalRewindInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalRewindInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalRewindInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalRewindInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalRewindInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRewindInstruction GGS_lexicalRewindInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalRewindInstruction result ;
  macroMyNew (result.mPointer, cPtr_lexicalRewindInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mLexicalTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalRewindInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalRewindInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexicalRewindInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalRewindInstruction::actualTypeName (void) const {
  return "lexicalRewindInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalRewindInstruction ("lexicalRewindInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexicalLogInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexicalLogInstruction::
cPtr_lexicalLogInstruction (LOCATION_ARGS)
:cPtr_lexicalInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexicalLogInstruction * GGS_lexicalLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexicalLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexicalLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexicalLogInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lexicalLogInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lexicalLogInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexicalLogInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexicalLogInstruction (& typeid (cPtr_lexicalLogInstruction), & typeid (cPtr_lexicalInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexicalLogInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__lexicalLogInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalLogInstruction ("lexicalLogInstruction") ;

//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction::
GGS_lexicalLogInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction::
GGS_lexicalLogInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexicalLogInstruction GGS_lexicalLogInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexicalLogInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_lexicalLogInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexicalLogInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexicalLogInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lexicalLogInstruction * gSingleton_lexicalLogInstruction = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lexicalLogInstruction (void) {
  macroDetachPointer (gSingleton_lexicalLogInstruction, cPtr_lexicalLogInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalLogInstruction GGS_lexicalLogInstruction::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lexicalLogInstruction result ;
  if (NULL == gSingleton_lexicalLogInstruction) {
    macroMyNew (gSingleton_lexicalLogInstruction, cPtr_lexicalLogInstruction (THERE)) ;
    registerReleaseRoutine (cleanUp_lexicalLogInstruction) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lexicalLogInstruction) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexicalLogInstruction::actualTypeName (void) const {
  return "lexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__lexicalLogInstruction ("lexicalLogInstruction", gClassInfoFor__lexicalInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'lexicalArgumentMode' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalArgumentMode ("lexicalArgumentMode") ;

//---------------------------------------------------------------------------*

bool GGS_lexicalArgumentMode::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentMode::
operator_isEqual (const GGS_lexicalArgumentMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentMode::
operator_isNotEqual (const GGS_lexicalArgumentMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentMode::
operator_infOrEqual (const GGS_lexicalArgumentMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentMode::
operator_supOrEqual (const GGS_lexicalArgumentMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentMode::
operator_strictInf (const GGS_lexicalArgumentMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalArgumentMode::
operator_strictSup (const GGS_lexicalArgumentMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentMode::
reader_lexicalFormalModeName (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "!",
    "\?!"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentMode::
reader_cppConstInFormalArgument (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "const ",
    ""
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentMode::
reader_cppReferenceInFormalArgument (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "",
    " &"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentMode::
reader_cocoaPointerInFormalArgument (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [3] = {"",
    "",
    " *"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalArgumentMode::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @lexicalArgumentMode" ;
  switch (mValue) {
  case enum_lexicalInputMode:
    s << " lexicalInputMode>" ;
    break ;
  case enum_lexicalInputOutputMode:
    s << " lexicalInputOutputMode>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@lexicalExternRoutineFormalArgumentList'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalExternRoutineFormalArgumentList::
elementOf_GGS_lexicalExternRoutineFormalArgumentList (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mPassingMode (argument_0),
mLexicalTypeName (argument_1),
mFormalArgumentName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalExternRoutineFormalArgumentList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalExternRoutineFormalArgumentList * ptr = dynamic_cast <const elementOf_GGS_lexicalExternRoutineFormalArgumentList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPassingMode.operator_isEqual (ptr->mPassingMode).boolValue ()
         && mLexicalTypeName.operator_isEqual (ptr->mLexicalTypeName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalExternRoutineFormalArgumentList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@lexicalExternRoutineFormalArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalExternRoutineFormalArgumentList ("lexicalExternRoutineFormalArgumentList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
internalAppendValues (const GGS_lexicalArgumentMode& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
internalPrependValues (const GGS_lexicalArgumentMode& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
addAssign_operation (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentList GGS_lexicalExternRoutineFormalArgumentList::
operator_concat (const GGS_lexicalExternRoutineFormalArgumentList & inOperand) const {
  GGS_lexicalExternRoutineFormalArgumentList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
dotAssign_operation (const GGS_lexicalExternRoutineFormalArgumentList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalExternRoutineFormalArgumentList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lexicalArgumentMode p_0 = p->mPassingMode ;
          GGS_lstring  p_1 = p->mLexicalTypeName ;
          GGS_lstring  p_2 = p->mFormalArgumentName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lexicalArgumentMode& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mPassingMode,
                                ptr->mLexicalTypeName,
                                ptr->mFormalArgumentName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentList  GGS_lexicalExternRoutineFormalArgumentList::
constructor_emptyList (void) {
  GGS_lexicalExternRoutineFormalArgumentList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentList  GGS_lexicalExternRoutineFormalArgumentList::
constructor_listWithValue (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_lexicalExternRoutineFormalArgumentList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
internalSubListWithRange (GGS_lexicalExternRoutineFormalArgumentList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mPassingMode, ptr->mLexicalTypeName, ptr->mFormalArgumentName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentList GGS_lexicalExternRoutineFormalArgumentList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternRoutineFormalArgumentList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentList GGS_lexicalExternRoutineFormalArgumentList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternRoutineFormalArgumentList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExternRoutineFormalArgumentList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalExternRoutineFormalArgumentList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
method_first (C_Compiler & inLexique,
              GGS_lexicalArgumentMode& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
method_last (C_Compiler & inLexique,
             GGS_lexicalArgumentMode& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lexicalArgumentMode& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lexicalArgumentMode& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mPassingMode ;
    _out_1 = ptr->mLexicalTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalArgumentMode GGS_lexicalExternRoutineFormalArgumentList::
reader_mPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalArgumentMode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternRoutineFormalArgumentList::
reader_mLexicalTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternRoutineFormalArgumentList::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
modifier_setMPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalArgumentMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
modifier_setMLexicalTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternRoutineFormalArgumentList::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalArgumentMode & GGS_lexicalExternRoutineFormalArgumentList::cEnumerator::_mPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternRoutineFormalArgumentList::cEnumerator::_mLexicalTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternRoutineFormalArgumentList::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@externRoutineList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_externRoutineList::
elementOf_GGS_externRoutineList (const GGS_lstring & argument_0,
                                const GGS_lexicalExternRoutineFormalArgumentList & argument_1,
                                const GGS_stringlist & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mRoutineName (argument_0),
mLexicalRoutineFormalArgumentList (argument_1),
mErrorMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externRoutineList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_externRoutineList * ptr = dynamic_cast <const elementOf_GGS_externRoutineList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mLexicalRoutineFormalArgumentList.operator_isEqual (ptr->mLexicalRoutineFormalArgumentList).boolValue ()
         && mErrorMessageList.operator_isEqual (ptr->mErrorMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externRoutineList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalRoutineFormalArgumentList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@externRoutineList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_externRoutineList ("externRoutineList") ;

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternRoutineFormalArgumentList & argument_1,
                    const GGS_stringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternRoutineFormalArgumentList & argument_1,
                    const GGS_stringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalExternRoutineFormalArgumentList & argument_1,
                                const GGS_stringlist & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_externRoutineList GGS_externRoutineList::
operator_concat (const GGS_externRoutineList & inOperand) const {
  GGS_externRoutineList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
dotAssign_operation (const GGS_externRoutineList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_externRoutineList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_lexicalExternRoutineFormalArgumentList  p_1 = p->mLexicalRoutineFormalArgumentList ;
          GGS_stringlist  p_2 = p->mErrorMessageList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalExternRoutineFormalArgumentList & argument_1,
                     const GGS_stringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mRoutineName,
                                ptr->mLexicalRoutineFormalArgumentList,
                                ptr->mErrorMessageList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externRoutineList  GGS_externRoutineList::
constructor_emptyList (void) {
  GGS_externRoutineList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineList  GGS_externRoutineList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lexicalExternRoutineFormalArgumentList & argument_1,
                                const GGS_stringlist & argument_2) {
  GGS_externRoutineList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
internalSubListWithRange (GGS_externRoutineList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mRoutineName, ptr->mLexicalRoutineFormalArgumentList, ptr->mErrorMessageList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externRoutineList GGS_externRoutineList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_externRoutineList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineList GGS_externRoutineList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_externRoutineList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externRoutineList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@externRoutineList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lexicalExternRoutineFormalArgumentList & _out_1,
              GGS_stringlist & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lexicalExternRoutineFormalArgumentList & _out_1,
             GGS_stringlist & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lexicalExternRoutineFormalArgumentList & _out_1,
                 GGS_stringlist & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lexicalExternRoutineFormalArgumentList & _out_1,
                GGS_stringlist & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRoutineName ;
    _out_1 = ptr->mLexicalRoutineFormalArgumentList ;
    _out_2 = ptr->mErrorMessageList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineList::
reader_mRoutineNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternRoutineFormalArgumentList  GGS_externRoutineList::
reader_mLexicalRoutineFormalArgumentListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternRoutineFormalArgumentList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalRoutineFormalArgumentList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_externRoutineList::
reader_mErrorMessageListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_stringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessageList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
modifier_setMRoutineNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
modifier_setMLexicalRoutineFormalArgumentListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExternRoutineFormalArgumentList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalRoutineFormalArgumentList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externRoutineList::
modifier_setMErrorMessageListAtIndex (C_Compiler & inLexique,
                              const GGS_stringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessageList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_externRoutineList::cEnumerator::_mRoutineName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExternRoutineFormalArgumentList  & GGS_externRoutineList::cEnumerator::_mLexicalRoutineFormalArgumentList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalRoutineFormalArgumentList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringlist  & GGS_externRoutineList::cEnumerator::_mErrorMessageList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessageList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@lexicalExternFunctionFormalArgumentList'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalExternFunctionFormalArgumentList::
elementOf_GGS_lexicalExternFunctionFormalArgumentList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexicalTypeName (argument_0),
mFormalArgumentName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalExternFunctionFormalArgumentList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lexicalExternFunctionFormalArgumentList * ptr = dynamic_cast <const elementOf_GGS_lexicalExternFunctionFormalArgumentList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTypeName.operator_isEqual (ptr->mLexicalTypeName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalExternFunctionFormalArgumentList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@lexicalExternFunctionFormalArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexicalExternFunctionFormalArgumentList ("lexicalExternFunctionFormalArgumentList") ;

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentList GGS_lexicalExternFunctionFormalArgumentList::
operator_concat (const GGS_lexicalExternFunctionFormalArgumentList & inOperand) const {
  GGS_lexicalExternFunctionFormalArgumentList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
dotAssign_operation (const GGS_lexicalExternFunctionFormalArgumentList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lexicalExternFunctionFormalArgumentList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLexicalTypeName ;
          GGS_lstring  p_1 = p->mFormalArgumentName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexicalTypeName,
                                ptr->mFormalArgumentName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentList  GGS_lexicalExternFunctionFormalArgumentList::
constructor_emptyList (void) {
  GGS_lexicalExternFunctionFormalArgumentList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentList  GGS_lexicalExternFunctionFormalArgumentList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_lexicalExternFunctionFormalArgumentList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
internalSubListWithRange (GGS_lexicalExternFunctionFormalArgumentList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexicalTypeName, ptr->mFormalArgumentName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentList GGS_lexicalExternFunctionFormalArgumentList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternFunctionFormalArgumentList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentList GGS_lexicalExternFunctionFormalArgumentList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternFunctionFormalArgumentList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalExternFunctionFormalArgumentList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lexicalExternFunctionFormalArgumentList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexicalTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternFunctionFormalArgumentList::
reader_mLexicalTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexicalExternFunctionFormalArgumentList::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
modifier_setMLexicalTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalExternFunctionFormalArgumentList::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternFunctionFormalArgumentList::cEnumerator::_mLexicalTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lexicalExternFunctionFormalArgumentList::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@externFunctionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_externFunctionList::
elementOf_GGS_externFunctionList (const GGS_lstring & argument_0,
                                const GGS_lexicalExternFunctionFormalArgumentList & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mFunctionName (argument_0),
mLexicalFunctionFormalArgumentList (argument_1),
mReturnedTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externFunctionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_externFunctionList * ptr = dynamic_cast <const elementOf_GGS_externFunctionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mLexicalFunctionFormalArgumentList.operator_isEqual (ptr->mLexicalFunctionFormalArgumentList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externFunctionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFunctionName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexicalFunctionFormalArgumentList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@externFunctionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_externFunctionList ("externFunctionList") ;

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternFunctionFormalArgumentList & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lexicalExternFunctionFormalArgumentList & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalExternFunctionFormalArgumentList & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_externFunctionList GGS_externFunctionList::
operator_concat (const GGS_externFunctionList & inOperand) const {
  GGS_externFunctionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
dotAssign_operation (const GGS_externFunctionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_externFunctionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFunctionName ;
          GGS_lexicalExternFunctionFormalArgumentList  p_1 = p->mLexicalFunctionFormalArgumentList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lexicalExternFunctionFormalArgumentList & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFunctionName,
                                ptr->mLexicalFunctionFormalArgumentList,
                                ptr->mReturnedTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externFunctionList  GGS_externFunctionList::
constructor_emptyList (void) {
  GGS_externFunctionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionList  GGS_externFunctionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lexicalExternFunctionFormalArgumentList & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_externFunctionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
internalSubListWithRange (GGS_externFunctionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFunctionName, ptr->mLexicalFunctionFormalArgumentList, ptr->mReturnedTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_externFunctionList GGS_externFunctionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_externFunctionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionList GGS_externFunctionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_externFunctionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externFunctionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@externFunctionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lexicalExternFunctionFormalArgumentList & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lexicalExternFunctionFormalArgumentList & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lexicalExternFunctionFormalArgumentList & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lexicalExternFunctionFormalArgumentList & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFunctionName ;
    _out_1 = ptr->mLexicalFunctionFormalArgumentList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionList::
reader_mFunctionNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFunctionName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalExternFunctionFormalArgumentList  GGS_externFunctionList::
reader_mLexicalFunctionFormalArgumentListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lexicalExternFunctionFormalArgumentList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexicalFunctionFormalArgumentList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionList::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
modifier_setMFunctionNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFunctionName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
modifier_setMLexicalFunctionFormalArgumentListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExternFunctionFormalArgumentList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexicalFunctionFormalArgumentList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_externFunctionList::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_externFunctionList::cEnumerator::_mFunctionName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFunctionName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lexicalExternFunctionFormalArgumentList  & GGS_externFunctionList::cEnumerator::_mLexicalFunctionFormalArgumentList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexicalFunctionFormalArgumentList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_externFunctionList::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_lexiqueComponentRoot'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lexiqueComponentRoot::
cPtr_lexiqueComponentRoot (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_metamodelTemplateDelimitorList & argument_2,
                                const GGS_templateReplacementList & argument_3,
                                const GGS_lexicalAttributeList & argument_4,
                                const GGS_lexicalStyleList & argument_5,
                                const GGS_terminalDeclarationList & argument_6,
                                const GGS_lexicalMessageDeclarationList & argument_7,
                                const GGS_lexicalListDeclarationList & argument_8,
                                const GGS_lexicalRuleList & argument_9,
                                const GGS_externRoutineList & argument_10,
                                const GGS_externFunctionList & argument_11
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mLexiqueComponentName (argument_0),
mIsTemplate (argument_1),
mTemplateDelimitorList (argument_2),
mTemplateReplacementList (argument_3),
mLexicalAttributeList (argument_4),
mLexicalStyleList (argument_5),
mTerminalDeclarationList (argument_6),
mLexicalMessageDeclarationList (argument_7),
mLexicalListDeclarationList (argument_8),
mLexicalRuleList (argument_9),
mExternRoutineList (argument_10),
mExternFunctionList (argument_11) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lexiqueComponentRoot * GGS_lexiqueComponentRoot::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lexiqueComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lexiqueComponentRoot::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lexiqueComponentRoot * ptr = dynamic_cast <const cPtr_lexiqueComponentRoot *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexiqueComponentName.operator_isEqual (ptr->mLexiqueComponentName).boolValue ()
         && mIsTemplate.operator_isEqual (ptr->mIsTemplate).boolValue ()
         && mTemplateDelimitorList.operator_isEqual (ptr->mTemplateDelimitorList).boolValue ()
         && mTemplateReplacementList.operator_isEqual (ptr->mTemplateReplacementList).boolValue ()
         && mLexicalAttributeList.operator_isEqual (ptr->mLexicalAttributeList).boolValue ()
         && mLexicalStyleList.operator_isEqual (ptr->mLexicalStyleList).boolValue ()
         && mTerminalDeclarationList.operator_isEqual (ptr->mTerminalDeclarationList).boolValue ()
         && mLexicalMessageDeclarationList.operator_isEqual (ptr->mLexicalMessageDeclarationList).boolValue ()
         && mLexicalListDeclarationList.operator_isEqual (ptr->mLexicalListDeclarationList).boolValue ()
         && mLexicalRuleList.operator_isEqual (ptr->mLexicalRuleList).boolValue ()
         && mExternRoutineList.operator_isEqual (ptr->mExternRoutineList).boolValue ()
         && mExternFunctionList.operator_isEqual (ptr->mExternFunctionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lexiqueComponentRoot::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lexiqueComponentRoot:"
           << mLexiqueComponentName.reader_description (inIndentation + 1)
           << mIsTemplate.reader_description (inIndentation + 1)
           << mTemplateDelimitorList.reader_description (inIndentation + 1)
           << mTemplateReplacementList.reader_description (inIndentation + 1)
           << mLexicalAttributeList.reader_description (inIndentation + 1)
           << mLexicalStyleList.reader_description (inIndentation + 1)
           << mTerminalDeclarationList.reader_description (inIndentation + 1)
           << mLexicalMessageDeclarationList.reader_description (inIndentation + 1)
           << mLexicalListDeclarationList.reader_description (inIndentation + 1)
           << mLexicalRuleList.reader_description (inIndentation + 1)
           << mExternRoutineList.reader_description (inIndentation + 1)
           << mExternFunctionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lexiqueComponentRoot::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lexiqueComponentRoot (& typeid (cPtr_lexiqueComponentRoot), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_lexiqueComponentRoot::galgasRTTI (void) const {
  return & gClassInfoFor__lexiqueComponentRoot ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lexiqueComponentRoot::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lexiqueComponentRoot (mLexiqueComponentName, mIsTemplate, mTemplateDelimitorList, mTemplateReplacementList, mLexicalAttributeList, mLexicalStyleList, mTerminalDeclarationList, mLexicalMessageDeclarationList, mLexicalListDeclarationList, mLexicalRuleList, mExternRoutineList, mExternFunctionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_lexiqueComponentRoot ("lexiqueComponentRoot") ;

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot::
GGS_lexiqueComponentRoot (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot::
GGS_lexiqueComponentRoot (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lexiqueComponentRoot GGS_lexiqueComponentRoot::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentRoot result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lexiqueComponentRoot *> (inPointer) != NULL)
      : (typeid (cPtr_lexiqueComponentRoot) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lexiqueComponentRoot (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lexiqueComponentRoot),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexiqueComponentRoot GGS_lexiqueComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_metamodelTemplateDelimitorList & argument_2,
                 const GGS_templateReplacementList & argument_3,
                 const GGS_lexicalAttributeList & argument_4,
                 const GGS_lexicalStyleList & argument_5,
                 const GGS_terminalDeclarationList & argument_6,
                 const GGS_lexicalMessageDeclarationList & argument_7,
                 const GGS_lexicalListDeclarationList & argument_8,
                 const GGS_lexicalRuleList & argument_9,
                 const GGS_externRoutineList & argument_10,
                 const GGS_externFunctionList & argument_11
                                COMMA_LOCATION_ARGS) {
  GGS_lexiqueComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_lexiqueComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lexiqueComponentRoot::
reader_mLexiqueComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexiqueComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelTemplateDelimitorList  GGS_lexiqueComponentRoot::
reader_mTemplateDelimitorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelTemplateDelimitorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTemplateDelimitorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementList  GGS_lexiqueComponentRoot::
reader_mTemplateReplacementList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateReplacementList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTemplateReplacementList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalAttributeList  GGS_lexiqueComponentRoot::
reader_mLexicalAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalStyleList  GGS_lexiqueComponentRoot::
reader_mLexicalStyleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalStyleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalStyleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalDeclarationList  GGS_lexiqueComponentRoot::
reader_mTerminalDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_terminalDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mTerminalDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalMessageDeclarationList  GGS_lexiqueComponentRoot::
reader_mLexicalMessageDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalMessageDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalMessageDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalListDeclarationList  GGS_lexiqueComponentRoot::
reader_mLexicalListDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalListDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalListDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalRuleList  GGS_lexiqueComponentRoot::
reader_mLexicalRuleList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalRuleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mLexicalRuleList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineList  GGS_lexiqueComponentRoot::
reader_mExternRoutineList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externRoutineList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mExternRoutineList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionList  GGS_lexiqueComponentRoot::
reader_mExternFunctionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externFunctionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lexiqueComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lexiqueComponentRoot *) mPointer)->mExternFunctionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lexiqueComponentRoot::actualTypeName (void) const {
  return "lexiqueComponentRoot" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_lexiqueComponentRoot::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__lexiqueComponentRoot ("lexiqueComponentRoot") ;

//---------------------------------------------------------------------------*

