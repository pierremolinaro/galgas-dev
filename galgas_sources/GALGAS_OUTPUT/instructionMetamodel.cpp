//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'instructionMetamodel.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       may 16th, 2007, at 11h29'18"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "instructionMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "instructionMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ;

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_instructionMetamodel (void) {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticInstructionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstruction::
cPtr_semanticInstruction (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticInstruction::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticInstruction" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticInstruction::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticInstruction::_metamodelClassID (void) const {
  return 0 ;
}

//---------------------------------------------------------------------------*

cPtr_semanticInstruction * cPtr_semanticInstruction::
_cloneObject (void) const {
  cPtr_semanticInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_semanticInstruction (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_addAssign_operation () {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
_operator_concat (const GGS_semanticInstructionList & inOperand) const {
  GGS_semanticInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_semanticInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticInstructionList result ;
  result._alloc () ;
  result._addAssign_operation () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_addModel (const GGS_semanticInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_first (C_Compiler & _inLexique
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
  }else{
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_last (C_Compiler & _inLexique
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
  }else{
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popFirst (C_Compiler & _inLexique
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popLast (C_Compiler & _inLexique
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_semanticInstruction::actualTypeName (void) const {
 return "semanticInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstruction * GGS_semanticInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@semanticInstructionsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructions::
cPtr_semanticInstructions (const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_semanticInstructions * _p = dynamic_cast <const cPtr_semanticInstructions *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticInstructions::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticInstructions" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticInstructions::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticInstructions::_metamodelClassID (void) const {
  return 1 ;
}

//---------------------------------------------------------------------------*

cPtr_semanticInstructions * cPtr_semanticInstructions::
_cloneObject (void) const {
  cPtr_semanticInstructions * _p = NULL ;
  macroMyNew (_p, cPtr_semanticInstructions (mInstruction COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticInstructionsList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
_internalAppendValues (const GGS_semanticInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
_internalPrependValues (const GGS_semanticInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
_addAssign_operation (const GGS_semanticInstructionList & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionsList GGS_semanticInstructionsList::
_operator_concat (const GGS_semanticInstructionsList & inOperand) const {
  GGS_semanticInstructionsList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_semanticInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionList  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionsList  GGS_semanticInstructionsList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticInstructionsList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionsList  GGS_semanticInstructionsList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticInstructionList & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticInstructionsList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionsList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticInstructionsList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
_addModel (const GGS_semanticInstructions & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
method_first (C_Compiler & _inLexique,
              GGS_semanticInstructionList & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
method_last (C_Compiler & _inLexique,
             GGS_semanticInstructionList & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticInstructionList & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionsList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticInstructionList & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_semanticInstructions'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticInstructions GGS_semanticInstructions::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_semanticInstructions result ;
  macroMyNew (result.mPointer, cPtr_semanticInstructions (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructions::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticInstructions *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticInstructions *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructions::actualTypeName (void) const {
 return "semanticInstructions" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructions * GGS_semanticInstructions::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticInstructions *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@localVariableDeclarationList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclaration::
cPtr_localVariableDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_localVariableDeclaration * _p = dynamic_cast <const cPtr_localVariableDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @localVariableDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_localVariableDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_localVariableDeclaration::_metamodelClassID (void) const {
  return 2 ;
}

//---------------------------------------------------------------------------*

cPtr_localVariableDeclaration * cPtr_localVariableDeclaration::
_cloneObject (void) const {
  cPtr_localVariableDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_localVariableDeclaration (mTypeName, mVariableName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@localVariableDeclarationList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationList GGS_localVariableDeclarationList::
_operator_concat (const GGS_localVariableDeclarationList & inOperand) const {
  GGS_localVariableDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_localVariableDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mVariableName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mVariableName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationList  GGS_localVariableDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_localVariableDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationList  GGS_localVariableDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_localVariableDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@localVariableDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
_addModel (const GGS_localVariableDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_localVariableDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclaration GGS_localVariableDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclaration::actualTypeName (void) const {
 return "localVariableDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclaration * GGS_localVariableDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_localVariableDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//    Element of list '@localVariableDeclarationWithInitializationList'      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitialization::
cPtr_localVariableDeclarationWithInitialization (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitialization::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_localVariableDeclarationWithInitialization * _p = dynamic_cast <const cPtr_localVariableDeclarationWithInitialization *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitialization::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @localVariableDeclarationWithInitialization" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_localVariableDeclarationWithInitialization::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_localVariableDeclarationWithInitialization::_metamodelClassID (void) const {
  return 3 ;
}

//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitialization * cPtr_localVariableDeclarationWithInitialization::
_cloneObject (void) const {
  cPtr_localVariableDeclarationWithInitialization * _p = NULL ;
  macroMyNew (_p, cPtr_localVariableDeclarationWithInitialization (mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          List '@localVariableDeclarationWithInitializationList'           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationList GGS_localVariableDeclarationWithInitializationList::
_operator_concat (const GGS_localVariableDeclarationWithInitializationList & inOperand) const {
  GGS_localVariableDeclarationWithInitializationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_localVariableDeclarationWithInitialization * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mVariableName ;
          GGS_semanticExpression  p_2 = p->mSourceExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mVariableName,
                                _p->mSourceExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationList  GGS_localVariableDeclarationWithInitializationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationList  GGS_localVariableDeclarationWithInitializationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableDeclarationWithInitializationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@localVariableDeclarationWithInitializationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
_addModel (const GGS_localVariableDeclarationWithInitialization & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_semanticExpression & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
    _out_2 = _p->mSourceExpression ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_semanticExpression & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
    _out_2 = _p->mSourceExpression ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_semanticExpression & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
    _out_2 = _p->mSourceExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableDeclarationWithInitializationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_semanticExpression & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _out_1 = _p->mVariableName ;
    _out_2 = _p->mSourceExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_localVariableDeclarationWithInitialization'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitialization (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_localVariableDeclarationWithInitialization::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitialization::actualTypeName (void) const {
 return "localVariableDeclarationWithInitialization" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitialization * GGS_localVariableDeclarationWithInitialization::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_localVariableDeclarationWithInitialization *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@assignmentInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstruction::
cPtr_assignmentInstruction (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_assignmentInstruction * _p = dynamic_cast <const cPtr_assignmentInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @assignmentInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_assignmentInstruction::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_assignmentInstruction::_metamodelClassID (void) const {
  return 4 ;
}

//---------------------------------------------------------------------------*

cPtr_assignmentInstruction * cPtr_assignmentInstruction::
_cloneObject (void) const {
  cPtr_assignmentInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_assignmentInstruction (mTargetVariableName, mSourceExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@assignmentInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionList GGS_assignmentInstructionList::
_operator_concat (const GGS_assignmentInstructionList & inOperand) const {
  GGS_assignmentInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_assignmentInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTargetVariableName ;
          GGS_semanticExpression  p_1 = p->mSourceExpression ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_semanticExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTargetVariableName,
                                _p->mSourceExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionList  GGS_assignmentInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_assignmentInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionList  GGS_assignmentInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_semanticExpression & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_assignmentInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_assignmentInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@assignmentInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
_addModel (const GGS_assignmentInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_semanticExpression & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetVariableName ;
    _out_1 = _p->mSourceExpression ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_semanticExpression & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetVariableName ;
    _out_1 = _p->mSourceExpression ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_semanticExpression & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetVariableName ;
    _out_1 = _p->mSourceExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_assignmentInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_semanticExpression & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetVariableName ;
    _out_1 = _p->mSourceExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_assignmentInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_assignmentInstruction GGS_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstruction::actualTypeName (void) const {
 return "assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstruction * GGS_assignmentInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_assignmentInstruction *) mPointer ;
  }
#endif

