//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'instructionMetamodel.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       june 8th, 2008, at 15h3'43"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "instructionMetamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "instructionMetamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_syntaxInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstruction::
cPtr_syntaxInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstruction * GGS_syntaxInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_syntaxInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@syntaxInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstruction (& typeid (cPtr_syntaxInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_syntaxInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxInstruction::
GGS_syntaxInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstruction::
GGS_syntaxInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_syntaxInstruction GGS_syntaxInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_syntaxInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstruction::actualTypeName (void) const {
  return "syntaxInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_semanticInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstruction::
cPtr_semanticInstruction (LOCATION_ARGS)
:cPtr_syntaxInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstruction * GGS_semanticInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@semanticInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstruction (& typeid (cPtr_semanticInstruction), & typeid (cPtr_syntaxInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticInstruction::
GGS_semanticInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstruction::
GGS_semanticInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_semanticInstruction GGS_semanticInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_semanticInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstruction::actualTypeName (void) const {
  return "semanticInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticInstructionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionList::
elementOf_GGS_semanticInstructionList (const GGS_semanticInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionList * _p = dynamic_cast <const elementOf_GGS_semanticInstructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalAppendValues (const GGS_semanticInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalPrependValues (const GGS_semanticInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_addAssign_operation (const GGS_semanticInstruction & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
_operator_concat (const GGS_semanticInstructionList & inOperand) const {
  GGS_semanticInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_semanticInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstruction  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticInstruction & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
internalSubListWithRange (GGS_semanticInstructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_semanticInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_semanticInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_semanticDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclaration::
cPtr_semanticDeclaration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclaration * GGS_semanticDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclaration::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@semanticDeclaration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclaration (& typeid (cPtr_semanticDeclaration), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticDeclaration::
GGS_semanticDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclaration::
GGS_semanticDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_semanticDeclaration GGS_semanticDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_semanticDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclaration::actualTypeName (void) const {
  return "semanticDeclaration" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_routineDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclaration::
cPtr_routineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mRoutineName (argument_0),
mFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclaration * GGS_routineDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineDeclaration * _p = dynamic_cast <const cPtr_routineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue ()
         && mRoutineInstructionList._operator_isEqual (_p->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routineDeclaration:"
           << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRoutineInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineDeclaration (& typeid (cPtr_routineDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_routineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDeclaration::
GGS_routineDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclaration::
GGS_routineDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_routineDeclaration GGS_routineDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_routineDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_routineDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclaration GGS_routineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_routineDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDeclaration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_routineDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_routineDeclaration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclaration::actualTypeName (void) const {
  return "routineDeclaration" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_externRoutineDeclaration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclaration::
cPtr_externRoutineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mActionName (argument_0),
mFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclaration * GGS_externRoutineDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_externRoutineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externRoutineDeclaration * _p = dynamic_cast <const cPtr_externRoutineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mActionName._operator_isEqual (_p->mActionName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@externRoutineDeclaration:"
           << mActionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externRoutineDeclaration (& typeid (cPtr_externRoutineDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_externRoutineDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration::
GGS_externRoutineDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration::
GGS_externRoutineDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externRoutineDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_externRoutineDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_externRoutineDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externRoutineDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclaration::
reader_mActionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mActionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_externRoutineDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclaration::actualTypeName (void) const {
  return "externRoutineDeclaration" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_localVariableDeclaration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclaration::
cPtr_localVariableDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclaration * GGS_localVariableDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclaration * _p = dynamic_cast <const cPtr_localVariableDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclaration:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclaration (& typeid (cPtr_localVariableDeclaration), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_localVariableDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclaration::
GGS_localVariableDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclaration::
GGS_localVariableDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_localVariableDeclaration GGS_localVariableDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_localVariableDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclaration GGS_localVariableDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclaration::actualTypeName (void) const {
  return "localVariableDeclaration" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     abstract class 'cPtr_localVariableDeclarationWithInitialization'      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitialization::
cPtr_localVariableDeclarationWithInitialization (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mConstructorName (argument_2),
mConstructorArguments (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitialization * GGS_localVariableDeclarationWithInitialization::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclarationWithInitialization *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitialization::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithInitialization * _p = dynamic_cast <const cPtr_localVariableDeclarationWithInitialization *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mConstructorName._operator_isEqual (_p->mConstructorName).boolValue ()
         && mConstructorArguments._operator_isEqual (_p->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitialization::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclarationWithInitialization:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithInitialization (& typeid (cPtr_localVariableDeclarationWithInitialization), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_localVariableDeclarationWithInitialization'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization::
GGS_localVariableDeclarationWithInitialization (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization::
GGS_localVariableDeclarationWithInitialization (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithInitialization) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_localVariableDeclarationWithInitialization (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithInitialization),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitialization (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitialization::actualTypeName (void) const {
  return "localVariableDeclarationWithInitialization" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       abstract class 'cPtr_localVariableDeclarationWithAssignment'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithAssignment::
cPtr_localVariableDeclarationWithAssignment (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithAssignment * GGS_localVariableDeclarationWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclarationWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithAssignment::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithAssignment * _p = dynamic_cast <const cPtr_localVariableDeclarationWithAssignment *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithAssignment::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclarationWithAssignment:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithAssignment (& typeid (cPtr_localVariableDeclarationWithAssignment), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_localVariableDeclarationWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment::
GGS_localVariableDeclarationWithAssignment (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment::
GGS_localVariableDeclarationWithAssignment (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithAssignment) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_localVariableDeclarationWithAssignment (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithAssignment),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_localVariableDeclarationWithAssignment::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithAssignment::actualTypeName (void) const {
  return "localVariableDeclarationWithAssignment" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstruction::
cPtr_assignmentInstruction (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstruction * GGS_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstruction * _p = dynamic_cast <const cPtr_assignmentInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@assignmentInstruction:"
           << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstruction (& typeid (cPtr_assignmentInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_assignmentInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_assignmentInstruction::
GGS_assignmentInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstruction::
GGS_assignmentInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_assignmentInstruction GGS_assignmentInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_assignmentInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstruction GGS_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstruction::actualTypeName (void) const {
  return "assignmentInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_appendInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstruction::
cPtr_appendInstruction (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstruction * GGS_appendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_appendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstruction * _p = dynamic_cast <const cPtr_appendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@appendInstruction:"
           << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstruction (& typeid (cPtr_appendInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_appendInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_appendInstruction::
GGS_appendInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstruction::
GGS_appendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_appendInstruction GGS_appendInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_appendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstruction GGS_appendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstruction result ;
  macroMyNew (result.mPointer, cPtr_appendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_appendInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstruction::actualTypeName (void) const {
  return "appendInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     abstract class 'cPtr_foreachInstructionEnumeratedObjectElement'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObjectElement::
cPtr_foreachInstructionEnumeratedObjectElement (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObjectElement * GGS_foreachInstructionEnumeratedObjectElement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionEnumeratedObjectElement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObjectElement::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionEnumeratedObjectElement:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedObjectElement (& typeid (cPtr_foreachInstructionEnumeratedObjectElement), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_foreachInstructionEnumeratedObjectElement'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement::
GGS_foreachInstructionEnumeratedObjectElement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement::
GGS_foreachInstructionEnumeratedObjectElement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedObjectElement GGS_foreachInstructionEnumeratedObjectElement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElement *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedObjectElement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstructionEnumeratedObjectElement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedObjectElement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObjectElement::actualTypeName (void) const {
  return "foreachInstructionEnumeratedObjectElement" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_foreachInstructionJoker'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionJoker::
cPtr_foreachInstructionJoker (LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElement (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionJoker * GGS_foreachInstructionJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionJoker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionJoker::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionJoker (& typeid (cPtr_foreachInstructionJoker), & typeid (cPtr_foreachInstructionEnumeratedObjectElement), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_foreachInstructionJoker'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker::
GGS_foreachInstructionJoker (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker::
GGS_foreachInstructionJoker (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionJoker *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionJoker) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstructionJoker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionJoker),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_foreachInstructionJoker * gSingleton_foreachInstructionJoker = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_foreachInstructionJoker (void) {
  macroDetachPointer (gSingleton_foreachInstructionJoker, cPtr_foreachInstructionJoker) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker result ;
  if (NULL == gSingleton_foreachInstructionJoker) {
    macroMyNew (gSingleton_foreachInstructionJoker, cPtr_foreachInstructionJoker (THERE)) ;
    registerReleaseRoutine (cleanUp_foreachInstructionJoker) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_foreachInstructionJoker) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionJoker::actualTypeName (void) const {
  return "foreachInstructionJoker" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_foreachInstructionEnumeratedConstant'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedConstant::
cPtr_foreachInstructionEnumeratedConstant (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElement (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedConstant * GGS_foreachInstructionEnumeratedConstant::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionEnumeratedConstant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedConstant::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionEnumeratedConstant * _p = dynamic_cast <const cPtr_foreachInstructionEnumeratedConstant *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstantName._operator_isEqual (_p->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedConstant::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionEnumeratedConstant:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedConstant (& typeid (cPtr_foreachInstructionEnumeratedConstant), & typeid (cPtr_foreachInstructionEnumeratedObjectElement), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_foreachInstructionEnumeratedConstant'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant::
GGS_foreachInstructionEnumeratedConstant (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant::
GGS_foreachInstructionEnumeratedConstant (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedConstant) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstructionEnumeratedConstant (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedConstant),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedConstant (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedConstant::actualTypeName (void) const {
  return "foreachInstructionEnumeratedConstant" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Element of list '@foreachInstructionEnumeratedObjectElementList'      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
elementOf_GGS_foreachInstructionEnumeratedObjectElementList (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectElementList * _p = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectElementList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mElement._operator_isEqual (_p->mElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElement.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          List '@foreachInstructionEnumeratedObjectElementList'            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_internalAppendValues (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_internalPrependValues (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_addAssign_operation (const GGS_foreachInstructionEnumeratedObjectElement & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
_operator_concat (const GGS_foreachInstructionEnumeratedObjectElementList & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectElementList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_foreachInstructionEnumeratedObjectElement  p_0 = p->mElement ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mElement
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectElementList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectElementList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectElementList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mElement) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectElementList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachInstructionEnumeratedObjectElementList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstructionEnumeratedObjectElement & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstructionEnumeratedObjectElement & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_foreachInstructionEnumeratedObjectElement & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_foreachInstructionEnumeratedObjectElement & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@foreachInstructionEnumeratedObjectList'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectList::
elementOf_GGS_foreachInstructionEnumeratedObjectList (const GGS_semanticExpression & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEnumeratedExpression (argument_0),
mElementList (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectList * _p = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumeratedExpression._operator_isEqual (_p->mEnumeratedExpression).boolValue ()
         && mElementList._operator_isEqual (_p->mElementList).boolValue ()
         && mEndsWithEllipsis._operator_isEqual (_p->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElementList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@foreachInstructionEnumeratedObjectList'               *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_addAssign_operation (const GGS_semanticExpression & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
_operator_concat (const GGS_foreachInstructionEnumeratedObjectList & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mEnumeratedExpression ;
          GGS_foreachInstructionEnumeratedObjectElementList  p_1 = p->mElementList ;
          GGS_bool p_2 = p->mEndsWithEllipsis ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumeratedExpression,
                                _p->mElementList,
                                _p->mEndsWithEllipsis
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstructionEnumeratedObjectList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstructionEnumeratedObjectList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpression & argument_0,
                           const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                           const GGS_bool& argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEnumeratedExpression, _p->mElementList, _p->mEndsWithEllipsis) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachInstructionEnumeratedObjectList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
method_first (C_Compiler & _inLexique,
              GGS_semanticExpression & _out_0,
              GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
              GGS_bool& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
method_last (C_Compiler & _inLexique,
             GGS_semanticExpression & _out_0,
             GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
             GGS_bool& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticExpression & _out_0,
                 GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
                 GGS_bool& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticExpression & _out_0,
                GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
                GGS_bool& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_foreachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstruction::
cPtr_foreachInstruction (const GGS_foreachInstructionEnumeratedObjectList & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_semanticInstructionList & argument_3,
                                const GGS_semanticInstructionList & argument_4,
                                const GGS_semanticInstructionList & argument_5,
                                const GGS_semanticInstructionList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mEnumeratedObjectList (argument_0),
mIndexVariableName (argument_1),
mWhileExpression (argument_2),
mBeforeInstructionList (argument_3),
mBetweenInstructionList (argument_4),
mDoInstructionList (argument_5),
mAfterInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstruction * GGS_foreachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstruction * _p = dynamic_cast <const cPtr_foreachInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumeratedObjectList._operator_isEqual (_p->mEnumeratedObjectList).boolValue ()
         && mIndexVariableName._operator_isEqual (_p->mIndexVariableName).boolValue ()
         && mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mBeforeInstructionList._operator_isEqual (_p->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList._operator_isEqual (_p->mBetweenInstructionList).boolValue ()
         && mDoInstructionList._operator_isEqual (_p->mDoInstructionList).boolValue ()
         && mAfterInstructionList._operator_isEqual (_p->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@foreachInstruction:"
           << mEnumeratedObjectList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIndexVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBeforeInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBetweenInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDoInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfterInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstruction (& typeid (cPtr_foreachInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_foreachInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstruction::
GGS_foreachInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstruction::
GGS_foreachInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstruction GGS_foreachInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstruction GGS_foreachInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_foreachInstructionEnumeratedObjectList & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_semanticInstructionList & argument_3,
                 const GGS_semanticInstructionList & argument_4,
                 const GGS_semanticInstructionList & argument_5,
                 const GGS_semanticInstructionList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction result ;
  macroMyNew (result.mPointer, cPtr_foreachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstruction::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstruction::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstruction::actualTypeName (void) const {
  return "foreachInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ifBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ifBranchList::
elementOf_GGS_ifBranchList (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mIFinstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ifBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ifBranchList * _p = dynamic_cast <const elementOf_GGS_ifBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIFexpression._operator_isEqual (_p->mIFexpression).boolValue ()
         && mIFinstructionList._operator_isEqual (_p->mIFinstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ifBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFinstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@ifBranchList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_addAssign_operation (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
_operator_concat (const GGS_ifBranchList & inOperand) const {
  GGS_ifBranchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_ifBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mIFexpression ;
          GGS_semanticInstructionList  p_1 = p->mIFinstructionList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIFexpression,
                                _p->mIFinstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifBranchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ifBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifBranchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpression & argument_0,
                           const GGS_semanticInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ifBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
internalSubListWithRange (GGS_ifBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mIFexpression, _p->mIFinstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ifBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ifBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
method_first (C_Compiler & _inLexique,
              GGS_semanticExpression & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
method_last (C_Compiler & _inLexique,
             GGS_semanticExpression & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticExpression & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticExpression & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_ifInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstruction::
cPtr_ifInstruction (const GGS_ifBranchList & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mBranchList (argument_0),
mElseInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstruction * GGS_ifInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ifInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstruction * _p = dynamic_cast <const cPtr_ifInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBranchList._operator_isEqual (_p->mBranchList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ifInstruction:"
           << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstruction (& typeid (cPtr_ifInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ifInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ifInstruction::
GGS_ifInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstruction::
GGS_ifInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ifInstruction GGS_ifInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ifInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstruction GGS_ifInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ifBranchList & argument_0,
                 const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstruction result ;
  macroMyNew (result.mPointer, cPtr_ifInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifInstruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ifBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_ifInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstruction::actualTypeName (void) const {
  return "ifInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_methodCallInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstruction::
cPtr_methodCallInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstruction * GGS_methodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_methodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstruction * _p = dynamic_cast <const cPtr_methodCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@methodCallInstruction:"
           << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstruction (& typeid (cPtr_methodCallInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_methodCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_methodCallInstruction::
GGS_methodCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstruction::
GGS_methodCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_methodCallInstruction GGS_methodCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_methodCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstruction GGS_methodCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_methodCallInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_methodCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstruction::actualTypeName (void) const {
  return "methodCallInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_modifierCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstruction::
cPtr_modifierCallInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mModifierName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstruction * GGS_modifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_modifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstruction * _p = dynamic_cast <const cPtr_modifierCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mModifierName._operator_isEqual (_p->mModifierName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@modifierCallInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstruction (& typeid (cPtr_modifierCallInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_modifierCallInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_modifierCallInstruction::
GGS_modifierCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstruction::
GGS_modifierCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_modifierCallInstruction GGS_modifierCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_modifierCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstruction GGS_modifierCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_modifierCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstruction::actualTypeName (void) const {
  return "modifierCallInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_errorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstruction::
cPtr_errorInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mErrorExpression (argument_1),
mBuiltVariableList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstruction * GGS_errorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_errorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstruction * _p = dynamic_cast <const cPtr_errorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mErrorExpression._operator_isEqual (_p->mErrorExpression).boolValue ()
         && mBuiltVariableList._operator_isEqual (_p->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@errorInstruction:"
           << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBuiltVariableList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstruction (& typeid (cPtr_errorInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_errorInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_errorInstruction::
GGS_errorInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstruction::
GGS_errorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_errorInstruction GGS_errorInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_errorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstruction GGS_errorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstruction result ;
  macroMyNew (result.mPointer, cPtr_errorInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstruction::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstruction::actualTypeName (void) const {
  return "errorInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_warningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstruction::
cPtr_warningInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mErrorExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstruction * GGS_warningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_warningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstruction * _p = dynamic_cast <const cPtr_warningInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mErrorExpression._operator_isEqual (_p->mErrorExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@warningInstruction:"
           << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstruction (& typeid (cPtr_warningInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_warningInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_warningInstruction::
GGS_warningInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstruction::
GGS_warningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_warningInstruction GGS_warningInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_warningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstruction GGS_warningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstruction result ;
  macroMyNew (result.mPointer, cPtr_warningInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstruction::actualTypeName (void) const {
  return "warningInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_routineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstruction::
cPtr_routineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_actualParameterList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mRoutineName (argument_0),
mActualParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstruction * GGS_routineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstruction * _p = dynamic_cast <const cPtr_routineCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routineCallInstruction:"
           << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstruction (& typeid (cPtr_routineCallInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_routineCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineCallInstruction::
GGS_routineCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstruction::
GGS_routineCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_routineCallInstruction GGS_routineCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_routineCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstruction GGS_routineCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_actualParameterList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_routineCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstruction::actualTypeName (void) const {
  return "routineCallInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_matchEntry'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchEntry::
cPtr_matchEntry (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchEntry * GGS_matchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_matchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_matchEntry::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@matchEntry:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchEntry (& typeid (cPtr_matchEntry), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_matchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchEntry::
GGS_matchEntry (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchEntry::
GGS_matchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_matchEntry GGS_matchEntry::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchEntry _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_matchEntry) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_matchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchEntry::actualTypeName (void) const {
  return "matchEntry" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@matchEntryList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchEntryList::
elementOf_GGS_matchEntryList (const GGS_matchEntry & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntry (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchEntryList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchEntryList * _p = dynamic_cast <const elementOf_GGS_matchEntryList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntry._operator_isEqual (_p->mEntry).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchEntryList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntry.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@matchEntryList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_internalAppendValues (const GGS_matchEntry & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_internalPrependValues (const GGS_matchEntry & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_addAssign_operation (const GGS_matchEntry & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
_operator_concat (const GGS_matchEntryList & inOperand) const {
  GGS_matchEntryList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_matchEntryList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntry  p_0 = p->mEntry ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntry & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntry
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchEntryList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_matchEntryList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchEntryList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_matchEntry & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_matchEntryList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
internalSubListWithRange (GGS_matchEntryList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEntry) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchEntryList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@matchEntryList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
method_first (C_Compiler & _inLexique,
              GGS_matchEntry & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
method_last (C_Compiler & _inLexique,
             GGS_matchEntry & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_matchEntry & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_matchEntry & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_constantMatchEntry'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constantMatchEntry::
cPtr_constantMatchEntry (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntry (THERE),
mConstantName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constantMatchEntry * GGS_constantMatchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_constantMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constantMatchEntry::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constantMatchEntry * _p = dynamic_cast <const cPtr_constantMatchEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constantMatchEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@constantMatchEntry:"
           << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constantMatchEntry (& typeid (cPtr_constantMatchEntry), & typeid (cPtr_matchEntry), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_constantMatchEntry'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_constantMatchEntry::
GGS_constantMatchEntry (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntry::
GGS_constantMatchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_constantMatchEntry GGS_constantMatchEntry::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constantMatchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_constantMatchEntry) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_constantMatchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constantMatchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntry GGS_constantMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_constantMatchEntry (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantMatchEntry::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constantMatchEntry *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constantMatchEntry::actualTypeName (void) const {
  return "constantMatchEntry" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_classMatchEntry'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMatchEntry::
cPtr_classMatchEntry (const GGS_lstring & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntry (THERE),
mClassName (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMatchEntry * GGS_classMatchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classMatchEntry::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classMatchEntry * _p = dynamic_cast <const cPtr_classMatchEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mElements._operator_isEqual (_p->mElements).boolValue ()
         && mEndsWithEllipsis._operator_isEqual (_p->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMatchEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classMatchEntry:"
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElements.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEndsWithEllipsis.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classMatchEntry (& typeid (cPtr_classMatchEntry), & typeid (cPtr_matchEntry), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classMatchEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMatchEntry::
GGS_classMatchEntry (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntry::
GGS_classMatchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_classMatchEntry GGS_classMatchEntry::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classMatchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_classMatchEntry) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_classMatchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classMatchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntry GGS_classMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_classMatchEntry (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMatchEntry::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_classMatchEntry::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMatchEntry::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMatchEntry::actualTypeName (void) const {
  return "classMatchEntry" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@matchInstructionBranchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchList::
elementOf_GGS_matchInstructionBranchList (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMatchEntryList (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchList * _p = dynamic_cast <const elementOf_GGS_matchInstructionBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchEntryList._operator_isEqual (_p->mMatchEntryList).boolValue ()
         && mMatchBranchInstructionList._operator_isEqual (_p->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchEntryList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@matchInstructionBranchList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_internalAppendValues (const GGS_matchEntryList & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_internalPrependValues (const GGS_matchEntryList & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_addAssign_operation (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
_operator_concat (const GGS_matchInstructionBranchList & inOperand) const {
  GGS_matchInstructionBranchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_matchInstructionBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryList  p_0 = p->mMatchEntryList ;
          GGS_semanticInstructionList  p_1 = p->mMatchBranchInstructionList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryList & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMatchEntryList,
                                _p->mMatchBranchInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstructionBranchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_matchInstructionBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstructionBranchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_matchEntryList & argument_0,
                           const GGS_semanticInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_matchInstructionBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
internalSubListWithRange (GGS_matchInstructionBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMatchEntryList, _p->mMatchBranchInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@matchInstructionBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
method_first (C_Compiler & _inLexique,
              GGS_matchEntryList & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
method_last (C_Compiler & _inLexique,
             GGS_matchEntryList & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_matchEntryList & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_matchEntryList & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_matchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstruction::
cPtr_matchInstruction (const GGS_lstringlist & argument_0,
                                const GGS_matchInstructionBranchList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mMatchedVariableNameList (argument_0),
mMatchInstructionBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstruction * GGS_matchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_matchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstruction * _p = dynamic_cast <const cPtr_matchInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchedVariableNameList._operator_isEqual (_p->mMatchedVariableNameList).boolValue ()
         && mMatchInstructionBranchList._operator_isEqual (_p->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@matchInstruction:"
           << mMatchedVariableNameList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMatchInstructionBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstruction (& typeid (cPtr_matchInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_matchInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchInstruction::
GGS_matchInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstruction::
GGS_matchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_matchInstruction GGS_matchInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_matchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstruction GGS_matchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0,
                 const GGS_matchInstructionBranchList & argument_1,
                 const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstruction result ;
  macroMyNew (result.mPointer, cPtr_matchInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_matchInstruction::
reader_mMatchedVariableNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchedVariableNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstruction::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_matchInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstruction::actualTypeName (void) const {
  return "matchInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@castInstructionBranchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchList::
elementOf_GGS_castInstructionBranchList (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mCastBranchInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchList * _p = dynamic_cast <const elementOf_GGS_castInstructionBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mUseKindOfClass._operator_isEqual (_p->mUseKindOfClass).boolValue ()
         && mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstantVarName._operator_isEqual (_p->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused._operator_isEqual (_p->mConstantVarNameIsUnused).boolValue ()
         && mCastBranchInstructionList._operator_isEqual (_p->mCastBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastBranchInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@castInstructionBranchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
_operator_concat (const GGS_castInstructionBranchList & inOperand) const {
  GGS_castInstructionBranchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_castInstructionBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_lstring  p_1 = p->mTypeName ;
          GGS_lstring  p_2 = p->mConstantVarName ;
          GGS_bool p_3 = p->mConstantVarNameIsUnused ;
          GGS_semanticInstructionList  p_4 = p->mCastBranchInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_semanticInstructionList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mUseKindOfClass,
                                _p->mTypeName,
                                _p->mConstantVarName,
                                _p->mConstantVarNameIsUnused,
                                _p->mCastBranchInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstructionBranchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_castInstructionBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstructionBranchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_bool& argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_bool& argument_3,
                           const GGS_semanticInstructionList & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_castInstructionBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
internalSubListWithRange (GGS_castInstructionBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mUseKindOfClass, _p->mTypeName, _p->mConstantVarName, _p->mConstantVarNameIsUnused, _p->mCastBranchInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@castInstructionBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
method_first (C_Compiler & _inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3,
              GGS_semanticInstructionList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
method_last (C_Compiler & _inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3,
             GGS_semanticInstructionList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3,
                 GGS_semanticInstructionList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3,
                GGS_semanticInstructionList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_elseOrDefaultForCastInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseOrDefaultForCastInstruction::
cPtr_elseOrDefaultForCastInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseOrDefaultForCastInstruction * GGS_elseOrDefaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseOrDefaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_elseOrDefaultForCastInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@elseOrDefaultForCastInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseOrDefaultForCastInstruction (& typeid (cPtr_elseOrDefaultForCastInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_elseOrDefaultForCastInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction::
GGS_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction::
GGS_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_elseOrDefaultForCastInstruction GGS_elseOrDefaultForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseOrDefaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_elseOrDefaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_elseOrDefaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseOrDefaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseOrDefaultForCastInstruction::actualTypeName (void) const {
  return "elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_elseForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseForCastInstruction::
cPtr_elseForCastInstruction (const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseForCastInstruction * GGS_elseForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_elseForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_elseForCastInstruction * _p = dynamic_cast <const cPtr_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_elseForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@elseForCastInstruction:"
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseForCastInstruction (& typeid (cPtr_elseForCastInstruction), & typeid (cPtr_elseOrDefaultForCastInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_elseForCastInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseForCastInstruction::
GGS_elseForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstruction::
GGS_elseForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_elseForCastInstruction GGS_elseForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_elseForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_elseForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstruction GGS_elseForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_elseForCastInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseForCastInstruction::actualTypeName (void) const {
  return "elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_defaultForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_defaultForCastInstruction::
cPtr_defaultForCastInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_defaultForCastInstruction * GGS_defaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_defaultForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_defaultForCastInstruction * _p = dynamic_cast <const cPtr_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_defaultForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@defaultForCastInstruction:"
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_defaultForCastInstruction (& typeid (cPtr_defaultForCastInstruction), & typeid (cPtr_elseOrDefaultForCastInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_defaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction::
GGS_defaultForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction::
GGS_defaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_defaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_defaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_defaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_defaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_defaultForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_defaultForCastInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_defaultForCastInstruction::actualTypeName (void) const {
  return "defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_castInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstruction::
cPtr_castInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_castInstructionBranchList & argument_1,
                                const GGS_elseOrDefaultForCastInstruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mExpression (argument_0),
mCastInstructionBranchList (argument_1),
mElseOrDefault (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstruction * GGS_castInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_castInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInstruction * _p = dynamic_cast <const cPtr_castInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && mCastInstructionBranchList._operator_isEqual (_p->mCastInstructionBranchList).boolValue ()
         && mElseOrDefault._operator_isEqual (_p->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@castInstruction:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCastInstructionBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseOrDefault.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInstruction (& typeid (cPtr_castInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_castInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInstruction::
GGS_castInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInstruction::
GGS_castInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_castInstruction GGS_castInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_castInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_castInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_castInstruction GGS_castInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_castInstructionBranchList & argument_1,
                 const GGS_elseOrDefaultForCastInstruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_castInstruction result ;
  macroMyNew (result.mPointer, cPtr_castInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstruction::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction  GGS_castInstruction::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstruction::actualTypeName (void) const {
  return "castInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_addInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstruction::
cPtr_addInstruction (const GGS_lstring & argument_0,
                                const GGS_outExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mExpressionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstruction * GGS_addInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_addInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addInstruction * _p = dynamic_cast <const cPtr_addInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mExpressionList._operator_isEqual (_p->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@addInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addInstruction (& typeid (cPtr_addInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_addInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_addInstruction::
GGS_addInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addInstruction::
GGS_addInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_addInstruction GGS_addInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_addInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_addInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_addInstruction GGS_addInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_outExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_addInstruction result ;
  macroMyNew (result.mPointer, cPtr_addInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_addInstruction::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstruction::actualTypeName (void) const {
  return "addInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_incrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstruction::
cPtr_incrementInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstruction * GGS_incrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_incrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstruction * _p = dynamic_cast <const cPtr_incrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@incrementInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstruction (& typeid (cPtr_incrementInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_incrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_incrementInstruction::
GGS_incrementInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstruction::
GGS_incrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_incrementInstruction GGS_incrementInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_incrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstruction GGS_incrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_incrementInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstruction::actualTypeName (void) const {
  return "incrementInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_decrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstruction::
cPtr_decrementInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstruction * GGS_decrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_decrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstruction * _p = dynamic_cast <const cPtr_decrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@decrementInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstruction (& typeid (cPtr_decrementInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_decrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_decrementInstruction::
GGS_decrementInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstruction::
GGS_decrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_decrementInstruction GGS_decrementInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_decrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstruction GGS_decrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_decrementInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstruction::actualTypeName (void) const {
  return "decrementInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_loopInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstruction::
cPtr_loopInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_semanticInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mVariantExpression (argument_0),
mFirstInstructions (argument_1),
mLoopExpression (argument_2),
mSecondInstructions (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstruction * GGS_loopInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_loopInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstruction * _p = dynamic_cast <const cPtr_loopInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariantExpression._operator_isEqual (_p->mVariantExpression).boolValue ()
         && mFirstInstructions._operator_isEqual (_p->mFirstInstructions).boolValue ()
         && mLoopExpression._operator_isEqual (_p->mLoopExpression).boolValue ()
         && mSecondInstructions._operator_isEqual (_p->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@loopInstruction:"
           << mVariantExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFirstInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLoopExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSecondInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstruction (& typeid (cPtr_loopInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_loopInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loopInstruction::
GGS_loopInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstruction::
GGS_loopInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_loopInstruction GGS_loopInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_loopInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstruction GGS_loopInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticInstructionList & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_semanticInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstruction result ;
  macroMyNew (result.mPointer, cPtr_loopInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_loopInstruction::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_loopInstruction::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstruction::actualTypeName (void) const {
  return "loopInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_messageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstruction::
cPtr_messageInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstruction * GGS_messageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_messageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstruction * _p = dynamic_cast <const cPtr_messageInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@messageInstruction:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstruction (& typeid (cPtr_messageInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_messageInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_messageInstruction::
GGS_messageInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstruction::
GGS_messageInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_messageInstruction GGS_messageInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_messageInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstruction GGS_messageInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstruction result ;
  macroMyNew (result.mPointer, cPtr_messageInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_messageInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstruction::actualTypeName (void) const {
  return "messageInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_logInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstruction::
cPtr_logInstruction (const GGS_lstringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mLoggedVariableList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstruction * GGS_logInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_logInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstruction * _p = dynamic_cast <const cPtr_logInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLoggedVariableList._operator_isEqual (_p->mLoggedVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@logInstruction:"
           << mLoggedVariableList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstruction (& typeid (cPtr_logInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_logInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_logInstruction::
GGS_logInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstruction::
GGS_logInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_logInstruction GGS_logInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_logInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_logInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_logInstruction GGS_logInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_logInstruction result ;
  macroMyNew (result.mPointer, cPtr_logInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_logInstruction::
reader_mLoggedVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstruction *) mPointer)->mLoggedVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstruction::actualTypeName (void) const {
  return "logInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_grammarInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstruction::
cPtr_grammarInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_actualParameterList & argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mGrammarComponentName (argument_0),
mLabelName (argument_1),
mSourceFileExpression (argument_2),
mActualParameterList (argument_3),
mReturnedModelName (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstruction * GGS_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstruction * _p = dynamic_cast <const cPtr_grammarInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGrammarComponentName._operator_isEqual (_p->mGrammarComponentName).boolValue ()
         && mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mSourceFileExpression._operator_isEqual (_p->mSourceFileExpression).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue ()
         && mReturnedModelName._operator_isEqual (_p->mReturnedModelName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@grammarInstruction:"
           << mGrammarComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceFileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedModelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstruction (& typeid (cPtr_grammarInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_grammarInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_grammarInstruction::
GGS_grammarInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstruction::
GGS_grammarInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_grammarInstruction GGS_grammarInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_grammarInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstruction GGS_grammarInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_actualParameterList & argument_3,
                 const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_grammarInstruction::
reader_mSourceFileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mSourceFileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_grammarInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mReturnedModelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mReturnedModelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstruction::actualTypeName (void) const {
  return "grammarInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_treewalkingInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_treewalkingInstruction::
cPtr_treewalkingInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTreewalkingComponentName (argument_0),
mModelName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_treewalkingInstruction * GGS_treewalkingInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_treewalkingInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_treewalkingInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_treewalkingInstruction * _p = dynamic_cast <const cPtr_treewalkingInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTreewalkingComponentName._operator_isEqual (_p->mTreewalkingComponentName).boolValue ()
         && mModelName._operator_isEqual (_p->mModelName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_treewalkingInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@treewalkingInstruction:"
           << mTreewalkingComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_treewalkingInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_treewalkingInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_treewalkingInstruction (& typeid (cPtr_treewalkingInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_treewalkingInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_treewalkingInstruction::
GGS_treewalkingInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingInstruction::
GGS_treewalkingInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_treewalkingInstruction GGS_treewalkingInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_treewalkingInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_treewalkingInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_treewalkingInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_treewalkingInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_treewalkingInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingInstruction GGS_treewalkingInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_treewalkingInstruction result ;
  macroMyNew (result.mPointer, cPtr_treewalkingInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_treewalkingInstruction::
reader_mTreewalkingComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_treewalkingInstruction *) mPointer)->mTreewalkingComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_treewalkingInstruction::
reader_mModelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_treewalkingInstruction *) mPointer)->mModelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_treewalkingInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_treewalkingInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_treewalkingInstruction::actualTypeName (void) const {
  return "treewalkingInstruction" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeMethodInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstruction::
cPtr_typeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstruction * GGS_typeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstruction * _p = dynamic_cast <const cPtr_typeMethodInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMethodInstruction:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstruction (& typeid (cPtr_typeMethodInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMethodInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodInstruction::
GGS_typeMethodInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstruction::
GGS_typeMethodInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMethodInstruction GGS_typeMethodInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMethodInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstruction GGS_typeMethodInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_typeMethodInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstruction::actualTypeName (void) const {
  return "typeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

