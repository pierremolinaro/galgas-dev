//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'instructionMetamodel.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       june 3rd, 2008, at 21h47'32"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "instructionMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "instructionMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("instructionMetamodel", 41) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_instructionMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@syntaxInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstruction::
cPtr_syntaxInstruction (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxInstruction::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxInstruction" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "syntaxInstruction" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_syntaxInstruction * cPtr_syntaxInstruction::
_cloneObject (void) const {
  cPtr_syntaxInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxInstruction (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_syntaxInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstruction::
_addAssign_operation (const GGS_syntaxInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstruction GGS__list_syntaxInstruction::
_operator_concat (const GGS__list_syntaxInstruction & inOperand) const {
  GGS__list_syntaxInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_syntaxInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_syntaxInstruction  GGS__list_syntaxInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstruction  GGS__list_syntaxInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_syntaxInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_syntaxInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_syntaxInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
_addModel (const GGS_syntaxInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
method_first (C_Compiler & _inLexique,
              GGS_syntaxInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
method_last (C_Compiler & _inLexique,
             GGS_syntaxInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@syntaxInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_syntaxInstruction::actualTypeName (void) const {
 return "syntaxInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstruction * GGS_syntaxInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@semanticInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstruction::
cPtr_semanticInstruction (LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticInstruction::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticInstruction" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_semanticInstruction * cPtr_semanticInstruction::
_cloneObject (void) const {
  cPtr_semanticInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_semanticInstruction (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_semanticInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_semanticInstruction::
_addAssign_operation (const GGS_semanticInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction GGS__list_semanticInstruction::
_operator_concat (const GGS__list_semanticInstruction & inOperand) const {
  GGS__list_semanticInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_semanticInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction  GGS__list_semanticInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction  GGS__list_semanticInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_semanticInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_semanticInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
_addModel (const GGS_semanticInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
method_first (C_Compiler & _inLexique,
              GGS_semanticInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
method_last (C_Compiler & _inLexique,
             GGS_semanticInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@semanticInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_semanticInstruction::actualTypeName (void) const {
 return "semanticInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstruction * GGS_semanticInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@semanticInstructions'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructions::
cPtr_semanticInstructions (const GGS__list_semanticInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticInstructions::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_semanticInstructions * _p = dynamic_cast <const cPtr_semanticInstructions *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticInstructions::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticInstructions" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticInstructions::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructions::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticInstructions::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructions::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticInstructions" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_semanticInstructions * cPtr_semanticInstructions::
_cloneObject (void) const {
  cPtr_semanticInstructions * _p = NULL ;
  macroMyNew (_p, cPtr_semanticInstructions (mInstruction COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_semanticInstructions'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
_internalAppendValues (const GGS__list_semanticInstruction & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
_internalPrependValues (const GGS__list_semanticInstruction & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_semanticInstructions::
_addAssign_operation (const GGS_semanticInstructions & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstructions GGS__list_semanticInstructions::
_operator_concat (const GGS__list_semanticInstructions & inOperand) const {
  GGS__list_semanticInstructions result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticInstructions::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_semanticInstructions & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_semanticInstructions  GGS__list_semanticInstructions::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticInstructions result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstructions  GGS__list_semanticInstructions::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticInstructions & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticInstructions result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_semanticInstructions::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_semanticInstructions", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
_addModel (const GGS_semanticInstructions & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
method_first (C_Compiler & _inLexique,
              GGS_semanticInstructions & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
method_last (C_Compiler & _inLexique,
             GGS_semanticInstructions & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticInstructions & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticInstructions::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticInstructions & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@semanticInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticInstructions GGS_semanticInstructions::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_semanticInstruction & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_semanticInstructions result ;
  macroMyNew (result.mPointer, cPtr_semanticInstructions (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction  GGS_semanticInstructions::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticInstructions *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticInstructions *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructions::actualTypeName (void) const {
 return "semanticInstructions" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructions * GGS_semanticInstructions::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticInstructions *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@semanticDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclaration::
cPtr_semanticDeclaration (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticDeclaration::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticDeclaration::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticDeclaration" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticDeclaration" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_semanticDeclaration * cPtr_semanticDeclaration::
_cloneObject (void) const {
  cPtr_semanticDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_semanticDeclaration (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_semanticDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_semanticDeclaration::
_addAssign_operation (const GGS_semanticDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticDeclaration GGS__list_semanticDeclaration::
_operator_concat (const GGS__list_semanticDeclaration & inOperand) const {
  GGS__list_semanticDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_semanticDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_semanticDeclaration  GGS__list_semanticDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticDeclaration  GGS__list_semanticDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_semanticDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_semanticDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
_addModel (const GGS_semanticDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_semanticDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticDeclaration::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_semanticDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticDeclaration::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticDeclaration::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticDeclaration::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@semanticDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_semanticDeclaration::actualTypeName (void) const {
 return "semanticDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclaration * GGS_semanticDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@routineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclaration::
cPtr_routineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mRoutineName (argument_0),
mFormalParameters (argument_1),
mRoutineInstructions (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_routineDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_routineDeclaration * _p = dynamic_cast <const cPtr_routineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue ()
         && mRoutineInstructions._operator_isEqual (_p->mRoutineInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @routineDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_routineDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_routineDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "routineDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_routineDeclaration * cPtr_routineDeclaration::
_cloneObject (void) const {
  cPtr_routineDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_routineDeclaration (mRoutineName, mFormalParameters, mRoutineInstructions COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_routineDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_routineDeclaration::
_addAssign_operation (const GGS_routineDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_routineDeclaration GGS__list_routineDeclaration::
_operator_concat (const GGS__list_routineDeclaration & inOperand) const {
  GGS__list_routineDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_routineDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_routineDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRoutineName,
                                _p->mFormalParameters,
                                _p->mRoutineInstructions) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_routineDeclaration  GGS__list_routineDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_routineDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_routineDeclaration  GGS__list_routineDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_routineDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_routineDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_routineDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_routineDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
_addModel (const GGS_routineDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_routineDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineDeclaration::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mFormalParameters,
       _p->mRoutineInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_routineDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineDeclaration::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mFormalParameters,
       _p->mRoutineInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_routineDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineDeclaration::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mFormalParameters,
       _p->mRoutineInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_routineDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineDeclaration::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mFormalParameters,
       _p->mRoutineInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@routineDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDeclaration GGS_routineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_routineDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDeclaration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_routineDeclaration::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_routineDeclaration::
reader_mRoutineInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclaration::actualTypeName (void) const {
 return "routineDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclaration * GGS_routineDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_routineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@externRoutineDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclaration::
cPtr_externRoutineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mActionName (argument_0),
mFormalParameters (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_externRoutineDeclaration * _p = dynamic_cast <const cPtr_externRoutineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mActionName._operator_isEqual (_p->mActionName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @externRoutineDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_externRoutineDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_externRoutineDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "externRoutineDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_externRoutineDeclaration * cPtr_externRoutineDeclaration::
_cloneObject (void) const {
  cPtr_externRoutineDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_externRoutineDeclaration (mActionName, mFormalParameters COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_externRoutineDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_externRoutineDeclaration::
_addAssign_operation (const GGS_externRoutineDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_externRoutineDeclaration GGS__list_externRoutineDeclaration::
_operator_concat (const GGS__list_externRoutineDeclaration & inOperand) const {
  GGS__list_externRoutineDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_externRoutineDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_externRoutineDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mActionName,
                                _p->mFormalParameters) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_externRoutineDeclaration  GGS__list_externRoutineDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_externRoutineDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_externRoutineDeclaration  GGS__list_externRoutineDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_externRoutineDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_externRoutineDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_externRoutineDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_externRoutineDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
_addModel (const GGS_externRoutineDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_externRoutineDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_externRoutineDeclaration::constructor_new (_inLexique,
       _p->mActionName,
       _p->mFormalParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_externRoutineDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_externRoutineDeclaration::constructor_new (_inLexique,
       _p->mActionName,
       _p->mFormalParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_externRoutineDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_externRoutineDeclaration::constructor_new (_inLexique,
       _p->mActionName,
       _p->mFormalParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_externRoutineDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_externRoutineDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_externRoutineDeclaration::constructor_new (_inLexique,
       _p->mActionName,
       _p->mFormalParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@externRoutineDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclaration::
reader_mActionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mActionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_externRoutineDeclaration::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclaration::actualTypeName (void) const {
 return "externRoutineDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclaration * GGS_externRoutineDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_externRoutineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@localVariableDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclaration::
cPtr_localVariableDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_localVariableDeclaration * _p = dynamic_cast <const cPtr_localVariableDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @localVariableDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_localVariableDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_localVariableDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "localVariableDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_localVariableDeclaration * cPtr_localVariableDeclaration::
_cloneObject (void) const {
  cPtr_localVariableDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_localVariableDeclaration (mTypeName, mVariableName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_localVariableDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_localVariableDeclaration::
_addAssign_operation (const GGS_localVariableDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclaration GGS__list_localVariableDeclaration::
_operator_concat (const GGS__list_localVariableDeclaration & inOperand) const {
  GGS__list_localVariableDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_localVariableDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_localVariableDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mVariableName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclaration  GGS__list_localVariableDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_localVariableDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclaration  GGS__list_localVariableDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_localVariableDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_localVariableDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_localVariableDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_localVariableDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
_addModel (const GGS_localVariableDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_localVariableDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclaration::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_localVariableDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclaration::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_localVariableDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclaration::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_localVariableDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclaration::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@localVariableDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclaration GGS_localVariableDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclaration::actualTypeName (void) const {
 return "localVariableDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclaration * GGS_localVariableDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_localVariableDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@localVariableDeclarationWithInitialization'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitialization::
cPtr_localVariableDeclarationWithInitialization (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mConstructorName (argument_2),
mConstructorArguments (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitialization::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_localVariableDeclarationWithInitialization * _p = dynamic_cast <const cPtr_localVariableDeclarationWithInitialization *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mConstructorName._operator_isEqual (_p->mConstructorName).boolValue ()
         && mConstructorArguments._operator_isEqual (_p->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitialization::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @localVariableDeclarationWithInitialization" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstructorName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstructorArguments.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_localVariableDeclarationWithInitialization::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_localVariableDeclarationWithInitialization::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "localVariableDeclarationWithInitialization" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_localVariableDeclarationWithInitialization * cPtr_localVariableDeclarationWithInitialization::
_cloneObject (void) const {
  cPtr_localVariableDeclarationWithInitialization * _p = NULL ;
  macroMyNew (_p, cPtr_localVariableDeclarationWithInitialization (mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//         List '@_list_localVariableDeclarationWithInitialization'          *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_outExpressionList & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_outExpressionList & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_localVariableDeclarationWithInitialization::
_addAssign_operation (const GGS_localVariableDeclarationWithInitialization & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclarationWithInitialization GGS__list_localVariableDeclarationWithInitialization::
_operator_concat (const GGS__list_localVariableDeclarationWithInitialization & inOperand) const {
  GGS__list_localVariableDeclarationWithInitialization result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_localVariableDeclarationWithInitialization::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_localVariableDeclarationWithInitialization & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mVariableName,
                                _p->mConstructorName,
                                _p->mConstructorArguments) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclarationWithInitialization  GGS__list_localVariableDeclarationWithInitialization::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_localVariableDeclarationWithInitialization result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclarationWithInitialization  GGS__list_localVariableDeclarationWithInitialization::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_localVariableDeclarationWithInitialization & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_localVariableDeclarationWithInitialization result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_localVariableDeclarationWithInitialization::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_localVariableDeclarationWithInitialization", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
_addModel (const GGS_localVariableDeclarationWithInitialization & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
method_first (C_Compiler & _inLexique,
              GGS_localVariableDeclarationWithInitialization & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithInitialization::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mConstructorName,
       _p->mConstructorArguments) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
method_last (C_Compiler & _inLexique,
             GGS_localVariableDeclarationWithInitialization & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithInitialization::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mConstructorName,
       _p->mConstructorArguments) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_localVariableDeclarationWithInitialization & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithInitialization::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mConstructorName,
       _p->mConstructorArguments) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithInitialization::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_localVariableDeclarationWithInitialization & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithInitialization::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mConstructorName,
       _p->mConstructorArguments) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS entity '@localVariableDeclarationWithInitialization'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitialization (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitialization::actualTypeName (void) const {
 return "localVariableDeclarationWithInitialization" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitialization * GGS_localVariableDeclarationWithInitialization::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_localVariableDeclarationWithInitialization *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@localVariableDeclarationWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithAssignment::
cPtr_localVariableDeclarationWithAssignment (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithAssignment::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_localVariableDeclarationWithAssignment * _p = dynamic_cast <const cPtr_localVariableDeclarationWithAssignment *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithAssignment::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @localVariableDeclarationWithAssignment" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_localVariableDeclarationWithAssignment::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_localVariableDeclarationWithAssignment::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "localVariableDeclarationWithAssignment" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_localVariableDeclarationWithAssignment * cPtr_localVariableDeclarationWithAssignment::
_cloneObject (void) const {
  cPtr_localVariableDeclarationWithAssignment * _p = NULL ;
  macroMyNew (_p, cPtr_localVariableDeclarationWithAssignment (mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//           List '@_list_localVariableDeclarationWithAssignment'            *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_localVariableDeclarationWithAssignment::
_addAssign_operation (const GGS_localVariableDeclarationWithAssignment & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclarationWithAssignment GGS__list_localVariableDeclarationWithAssignment::
_operator_concat (const GGS__list_localVariableDeclarationWithAssignment & inOperand) const {
  GGS__list_localVariableDeclarationWithAssignment result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_localVariableDeclarationWithAssignment::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_localVariableDeclarationWithAssignment & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mVariableName,
                                _p->mSourceExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclarationWithAssignment  GGS__list_localVariableDeclarationWithAssignment::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_localVariableDeclarationWithAssignment result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_localVariableDeclarationWithAssignment  GGS__list_localVariableDeclarationWithAssignment::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_localVariableDeclarationWithAssignment & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_localVariableDeclarationWithAssignment result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_localVariableDeclarationWithAssignment::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_localVariableDeclarationWithAssignment", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
_addModel (const GGS_localVariableDeclarationWithAssignment & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
method_first (C_Compiler & _inLexique,
              GGS_localVariableDeclarationWithAssignment & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithAssignment::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
method_last (C_Compiler & _inLexique,
             GGS_localVariableDeclarationWithAssignment & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithAssignment::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_localVariableDeclarationWithAssignment & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithAssignment::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_localVariableDeclarationWithAssignment::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_localVariableDeclarationWithAssignment & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_localVariableDeclarationWithAssignment::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS entity '@localVariableDeclarationWithAssignment'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_localVariableDeclarationWithAssignment::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithAssignment::actualTypeName (void) const {
 return "localVariableDeclarationWithAssignment" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithAssignment * GGS_localVariableDeclarationWithAssignment::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_localVariableDeclarationWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@assignmentInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstruction::
cPtr_assignmentInstruction (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_assignmentInstruction * _p = dynamic_cast <const cPtr_assignmentInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @assignmentInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_assignmentInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_assignmentInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "assignmentInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_assignmentInstruction * cPtr_assignmentInstruction::
_cloneObject (void) const {
  cPtr_assignmentInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_assignmentInstruction (mTargetVariableName, mSourceExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_assignmentInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_assignmentInstruction::
_addAssign_operation (const GGS_assignmentInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_assignmentInstruction GGS__list_assignmentInstruction::
_operator_concat (const GGS__list_assignmentInstruction & inOperand) const {
  GGS__list_assignmentInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_assignmentInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_assignmentInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTargetVariableName,
                                _p->mSourceExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_assignmentInstruction  GGS__list_assignmentInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_assignmentInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_assignmentInstruction  GGS__list_assignmentInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_assignmentInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_assignmentInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_assignmentInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_assignmentInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
_addModel (const GGS_assignmentInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
method_first (C_Compiler & _inLexique,
              GGS_assignmentInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_assignmentInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
method_last (C_Compiler & _inLexique,
             GGS_assignmentInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_assignmentInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_assignmentInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_assignmentInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_assignmentInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_assignmentInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_assignmentInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@assignmentInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_assignmentInstruction GGS_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstruction::actualTypeName (void) const {
 return "assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstruction * GGS_assignmentInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@appendInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstruction::
cPtr_appendInstruction (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_appendInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_appendInstruction * _p = dynamic_cast <const cPtr_appendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @appendInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_appendInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_appendInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "appendInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_appendInstruction * cPtr_appendInstruction::
_cloneObject (void) const {
  cPtr_appendInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_appendInstruction (mTargetVariableName, mSourceExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_appendInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_appendInstruction::
_addAssign_operation (const GGS_appendInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_appendInstruction GGS__list_appendInstruction::
_operator_concat (const GGS__list_appendInstruction & inOperand) const {
  GGS__list_appendInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_appendInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_appendInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTargetVariableName,
                                _p->mSourceExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_appendInstruction  GGS__list_appendInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_appendInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_appendInstruction  GGS__list_appendInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_appendInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_appendInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_appendInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_appendInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
_addModel (const GGS_appendInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
method_first (C_Compiler & _inLexique,
              GGS_appendInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_appendInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
method_last (C_Compiler & _inLexique,
             GGS_appendInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_appendInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_appendInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_appendInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_appendInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_appendInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_appendInstruction::constructor_new (_inLexique,
       _p->mTargetVariableName,
       _p->mSourceExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@appendInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_appendInstruction GGS_appendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstruction result ;
  macroMyNew (result.mPointer, cPtr_appendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_appendInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstruction::actualTypeName (void) const {
 return "appendInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstruction * GGS_appendInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_appendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@foreachInstructionEnumeratedObjectElement'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObjectElement::
cPtr_foreachInstructionEnumeratedObjectElement (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedObjectElement::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObjectElement::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @foreachInstructionEnumeratedObjectElement" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionEnumeratedObjectElement::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionEnumeratedObjectElement::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "foreachInstructionEnumeratedObjectElement" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_foreachInstructionEnumeratedObjectElement * cPtr_foreachInstructionEnumeratedObjectElement::
_cloneObject (void) const {
  cPtr_foreachInstructionEnumeratedObjectElement * _p = NULL ;
  macroMyNew (_p, cPtr_foreachInstructionEnumeratedObjectElement (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//         List '@_list_foreachInstructionEnumeratedObjectElement'           *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionEnumeratedObjectElement::
_addAssign_operation (const GGS_foreachInstructionEnumeratedObjectElement & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObjectElement GGS__list_foreachInstructionEnumeratedObjectElement::
_operator_concat (const GGS__list_foreachInstructionEnumeratedObjectElement & inOperand) const {
  GGS__list_foreachInstructionEnumeratedObjectElement result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionEnumeratedObjectElement::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_foreachInstructionEnumeratedObjectElement & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObjectElement  GGS__list_foreachInstructionEnumeratedObjectElement::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionEnumeratedObjectElement result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObjectElement  GGS__list_foreachInstructionEnumeratedObjectElement::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_foreachInstructionEnumeratedObjectElement & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionEnumeratedObjectElement result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_foreachInstructionEnumeratedObjectElement::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_foreachInstructionEnumeratedObjectElement", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
_addModel (const GGS_foreachInstructionEnumeratedObjectElement & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstructionEnumeratedObjectElement & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObjectElement::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstructionEnumeratedObjectElement & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObjectElement::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_foreachInstructionEnumeratedObjectElement & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObjectElement::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObjectElement::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_foreachInstructionEnumeratedObjectElement & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObjectElement::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS entity '@foreachInstructionEnumeratedObjectElement'         *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObjectElement::actualTypeName (void) const {
 return "foreachInstructionEnumeratedObjectElement" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObjectElement * GGS_foreachInstructionEnumeratedObjectElement::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_foreachInstructionEnumeratedObjectElement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachInstructionJoker'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionJoker::
cPtr_foreachInstructionJoker (LOCATION_ARGS) :
cPtr_foreachInstructionEnumeratedObjectElement (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionJoker::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionJoker::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @foreachInstructionJoker" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionJoker::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionJoker::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 12 ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "foreachInstructionJoker" ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_foreachInstructionJoker * cPtr_foreachInstructionJoker::
_cloneObject (void) const {
  cPtr_foreachInstructionJoker * _p = NULL ;
  macroMyNew (_p, cPtr_foreachInstructionJoker (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_foreachInstructionJoker'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionJoker::
_addAssign_operation (const GGS_foreachInstructionJoker & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionJoker GGS__list_foreachInstructionJoker::
_operator_concat (const GGS__list_foreachInstructionJoker & inOperand) const {
  GGS__list_foreachInstructionJoker result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionJoker::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_foreachInstructionJoker & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionJoker  GGS__list_foreachInstructionJoker::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionJoker result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionJoker  GGS__list_foreachInstructionJoker::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_foreachInstructionJoker & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionJoker result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_foreachInstructionJoker::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_foreachInstructionJoker", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
_addModel (const GGS_foreachInstructionJoker & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstructionJoker & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionJoker::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstructionJoker & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionJoker::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_foreachInstructionJoker & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionJoker::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionJoker::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_foreachInstructionJoker & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionJoker::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@foreachInstructionJoker'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionJoker (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionJoker::actualTypeName (void) const {
 return "foreachInstructionJoker" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionJoker * GGS_foreachInstructionJoker::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_foreachInstructionJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@foreachInstructionEnumeratedConstant'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedConstant::
cPtr_foreachInstructionEnumeratedConstant (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_foreachInstructionEnumeratedObjectElement (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedConstant::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_foreachInstructionEnumeratedConstant * _p = dynamic_cast <const cPtr_foreachInstructionEnumeratedConstant *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstantName._operator_isEqual (_p->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedConstant::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @foreachInstructionEnumeratedConstant" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionEnumeratedConstant::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionEnumeratedConstant::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 13 ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "foreachInstructionEnumeratedConstant" ;
  if (inLevel > 0) {
    result = cPtr_foreachInstructionEnumeratedObjectElement::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_foreachInstructionEnumeratedConstant * cPtr_foreachInstructionEnumeratedConstant::
_cloneObject (void) const {
  cPtr_foreachInstructionEnumeratedConstant * _p = NULL ;
  macroMyNew (_p, cPtr_foreachInstructionEnumeratedConstant (mTypeName, mConstantName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@_list_foreachInstructionEnumeratedConstant'             *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionEnumeratedConstant::
_addAssign_operation (const GGS_foreachInstructionEnumeratedConstant & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedConstant GGS__list_foreachInstructionEnumeratedConstant::
_operator_concat (const GGS__list_foreachInstructionEnumeratedConstant & inOperand) const {
  GGS__list_foreachInstructionEnumeratedConstant result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionEnumeratedConstant::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_foreachInstructionEnumeratedConstant & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mConstantName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedConstant  GGS__list_foreachInstructionEnumeratedConstant::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionEnumeratedConstant result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedConstant  GGS__list_foreachInstructionEnumeratedConstant::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_foreachInstructionEnumeratedConstant & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionEnumeratedConstant result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_foreachInstructionEnumeratedConstant::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_foreachInstructionEnumeratedConstant", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
_addModel (const GGS_foreachInstructionEnumeratedConstant & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstructionEnumeratedConstant & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedConstant::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstructionEnumeratedConstant & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedConstant::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_foreachInstructionEnumeratedConstant & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedConstant::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedConstant::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_foreachInstructionEnumeratedConstant & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedConstant::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS entity '@foreachInstructionEnumeratedConstant'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedConstant (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedConstant::actualTypeName (void) const {
 return "foreachInstructionEnumeratedConstant" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedConstant * GGS_foreachInstructionEnumeratedConstant::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_foreachInstructionEnumeratedConstant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@foreachInstructionEnumeratedObject'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObject::
cPtr_foreachInstructionEnumeratedObject (const GGS_semanticExpression & argument_0,
                                const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mEnumeratedExpression (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedObject::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_foreachInstructionEnumeratedObject * _p = dynamic_cast <const cPtr_foreachInstructionEnumeratedObject *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumeratedExpression._operator_isEqual (_p->mEnumeratedExpression).boolValue ()
         && mElements._operator_isEqual (_p->mElements).boolValue ()
         && mEndsWithEllipsis._operator_isEqual (_p->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObject::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @foreachInstructionEnumeratedObject" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElements.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionEnumeratedObject::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObject::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstructionEnumeratedObject::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 14 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObject::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "foreachInstructionEnumeratedObject" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_foreachInstructionEnumeratedObject * cPtr_foreachInstructionEnumeratedObject::
_cloneObject (void) const {
  cPtr_foreachInstructionEnumeratedObject * _p = NULL ;
  macroMyNew (_p, cPtr_foreachInstructionEnumeratedObject (mEnumeratedExpression, mElements, mEndsWithEllipsis COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@_list_foreachInstructionEnumeratedObject'              *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                    const GGS_bool& argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                    const GGS_bool& argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionEnumeratedObject::
_addAssign_operation (const GGS_foreachInstructionEnumeratedObject & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObject GGS__list_foreachInstructionEnumeratedObject::
_operator_concat (const GGS__list_foreachInstructionEnumeratedObject & inOperand) const {
  GGS__list_foreachInstructionEnumeratedObject result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_foreachInstructionEnumeratedObject::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_foreachInstructionEnumeratedObject & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumeratedExpression,
                                _p->mElements,
                                _p->mEndsWithEllipsis) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObject  GGS__list_foreachInstructionEnumeratedObject::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionEnumeratedObject result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObject  GGS__list_foreachInstructionEnumeratedObject::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_foreachInstructionEnumeratedObject & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstructionEnumeratedObject result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_foreachInstructionEnumeratedObject::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_foreachInstructionEnumeratedObject", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
_addModel (const GGS_foreachInstructionEnumeratedObject & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstructionEnumeratedObject & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObject::constructor_new (_inLexique,
       _p->mEnumeratedExpression,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstructionEnumeratedObject & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObject::constructor_new (_inLexique,
       _p->mEnumeratedExpression,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_foreachInstructionEnumeratedObject & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObject::constructor_new (_inLexique,
       _p->mEnumeratedExpression,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstructionEnumeratedObject::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_foreachInstructionEnumeratedObject & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstructionEnumeratedObject::constructor_new (_inLexique,
       _p->mEnumeratedExpression,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS entity '@foreachInstructionEnumeratedObject'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObject GGS_foreachInstructionEnumeratedObject::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObject result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedObject (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstructionEnumeratedObject::
reader_mEnumeratedExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedObject *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedObject *) mPointer)->mEnumeratedExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObjectElement  GGS_foreachInstructionEnumeratedObject::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_foreachInstructionEnumeratedObjectElement   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedObject *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedObject *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObject::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedObject *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedObject *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObject::actualTypeName (void) const {
 return "foreachInstructionEnumeratedObject" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObject * GGS_foreachInstructionEnumeratedObject::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_foreachInstructionEnumeratedObject *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@foreachInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstruction::
cPtr_foreachInstruction (const GGS__list_foreachInstructionEnumeratedObject & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS__list_semanticInstruction & argument_3,
                                const GGS__list_semanticInstruction & argument_4,
                                const GGS_semanticInstructions & argument_5,
                                const GGS__list_semanticInstruction & argument_6
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mEnumeratedObjects (argument_0),
mIndexVariableName (argument_1),
mWhileExpression (argument_2),
mBeforeInstructionList (argument_3),
mBetweenInstructionList (argument_4),
mDoInstructionList (argument_5),
mAfterInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

bool cPtr_foreachInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_foreachInstruction * _p = dynamic_cast <const cPtr_foreachInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumeratedObjects._operator_isEqual (_p->mEnumeratedObjects).boolValue ()
         && mIndexVariableName._operator_isEqual (_p->mIndexVariableName).boolValue ()
         && mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mBeforeInstructionList._operator_isEqual (_p->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList._operator_isEqual (_p->mBetweenInstructionList).boolValue ()
         && mDoInstructionList._operator_isEqual (_p->mDoInstructionList).boolValue ()
         && mAfterInstructionList._operator_isEqual (_p->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @foreachInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedObjects.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIndexVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBeforeInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBetweenInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDoInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAfterInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_foreachInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 15 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "foreachInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_foreachInstruction * cPtr_foreachInstruction::
_cloneObject (void) const {
  cPtr_foreachInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_foreachInstruction (mEnumeratedObjects, mIndexVariableName, mWhileExpression, mBeforeInstructionList, mBetweenInstructionList, mDoInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_foreachInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
_internalAppendValues (const GGS__list_foreachInstructionEnumeratedObject & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2,
                    const GGS__list_semanticInstruction & argument_3,
                    const GGS__list_semanticInstruction & argument_4,
                    const GGS_semanticInstructions & argument_5,
                    const GGS__list_semanticInstruction & argument_6) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
_internalPrependValues (const GGS__list_foreachInstructionEnumeratedObject & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2,
                    const GGS__list_semanticInstruction & argument_3,
                    const GGS__list_semanticInstruction & argument_4,
                    const GGS_semanticInstructions & argument_5,
                    const GGS__list_semanticInstruction & argument_6) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_foreachInstruction::
_addAssign_operation (const GGS_foreachInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstruction GGS__list_foreachInstruction::
_operator_concat (const GGS__list_foreachInstruction & inOperand) const {
  GGS__list_foreachInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_foreachInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_foreachInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumeratedObjects,
                                _p->mIndexVariableName,
                                _p->mWhileExpression,
                                _p->mBeforeInstructionList,
                                _p->mBetweenInstructionList,
                                _p->mDoInstructionList,
                                _p->mAfterInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_foreachInstruction  GGS__list_foreachInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstruction  GGS__list_foreachInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_foreachInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_foreachInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_foreachInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_foreachInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
_addModel (const GGS_foreachInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstruction::constructor_new (_inLexique,
       _p->mEnumeratedObjects,
       _p->mIndexVariableName,
       _p->mWhileExpression,
       _p->mBeforeInstructionList,
       _p->mBetweenInstructionList,
       _p->mDoInstructionList,
       _p->mAfterInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstruction::constructor_new (_inLexique,
       _p->mEnumeratedObjects,
       _p->mIndexVariableName,
       _p->mWhileExpression,
       _p->mBeforeInstructionList,
       _p->mBetweenInstructionList,
       _p->mDoInstructionList,
       _p->mAfterInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_foreachInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstruction::constructor_new (_inLexique,
       _p->mEnumeratedObjects,
       _p->mIndexVariableName,
       _p->mWhileExpression,
       _p->mBeforeInstructionList,
       _p->mBetweenInstructionList,
       _p->mDoInstructionList,
       _p->mAfterInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_foreachInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_foreachInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_foreachInstruction::constructor_new (_inLexique,
       _p->mEnumeratedObjects,
       _p->mIndexVariableName,
       _p->mWhileExpression,
       _p->mBeforeInstructionList,
       _p->mBetweenInstructionList,
       _p->mDoInstructionList,
       _p->mAfterInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@foreachInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstruction GGS_foreachInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_foreachInstructionEnumeratedObject & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS__list_semanticInstruction & argument_3,
                 const GGS__list_semanticInstruction & argument_4,
                 const GGS_semanticInstructions & argument_5,
                 const GGS__list_semanticInstruction & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction result ;
  macroMyNew (result.mPointer, cPtr_foreachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObject  GGS_foreachInstruction::
reader_mEnumeratedObjects (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_foreachInstructionEnumeratedObject   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mEnumeratedObjects ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstruction::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction  GGS_foreachInstruction::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction  GGS_foreachInstruction::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_foreachInstruction::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstruction  GGS_foreachInstruction::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstruction::actualTypeName (void) const {
 return "foreachInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstruction * GGS_foreachInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_foreachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ifInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstruction::
cPtr_ifInstruction (const GGS__list_semanticExpression & argument_0,
                                const GGS__list_semanticInstructions & argument_1,
                                const GGS__list_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mIFexpressionList (argument_0),
mIFinstructionListList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_ifInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_ifInstruction * _p = dynamic_cast <const cPtr_ifInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIFexpressionList._operator_isEqual (_p->mIFexpressionList).boolValue ()
         && mIFinstructionListList._operator_isEqual (_p->mIFinstructionListList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @ifInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFinstructionListList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_ifInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_ifInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 16 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "ifInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_ifInstruction * cPtr_ifInstruction::
_cloneObject (void) const {
  cPtr_ifInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_ifInstruction (mIFexpressionList, mIFinstructionListList, mElseInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_ifInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
_internalAppendValues (const GGS__list_semanticExpression & argument_0,
                    const GGS__list_semanticInstructions & argument_1,
                    const GGS__list_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
_internalPrependValues (const GGS__list_semanticExpression & argument_0,
                    const GGS__list_semanticInstructions & argument_1,
                    const GGS__list_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_ifInstruction::
_addAssign_operation (const GGS_ifInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_ifInstruction GGS__list_ifInstruction::
_operator_concat (const GGS__list_ifInstruction & inOperand) const {
  GGS__list_ifInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_ifInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_ifInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIFexpressionList,
                                _p->mIFinstructionListList,
                                _p->mElseInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_ifInstruction  GGS__list_ifInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_ifInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_ifInstruction  GGS__list_ifInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_ifInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_ifInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_ifInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_ifInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
_addModel (const GGS_ifInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
method_first (C_Compiler & _inLexique,
              GGS_ifInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_ifInstruction::constructor_new (_inLexique,
       _p->mIFexpressionList,
       _p->mIFinstructionListList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
method_last (C_Compiler & _inLexique,
             GGS_ifInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_ifInstruction::constructor_new (_inLexique,
       _p->mIFexpressionList,
       _p->mIFinstructionListList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_ifInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_ifInstruction::constructor_new (_inLexique,
       _p->mIFexpressionList,
       _p->mIFinstructionListList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_ifInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_ifInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_ifInstruction::constructor_new (_inLexique,
       _p->mIFexpressionList,
       _p->mIFinstructionListList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@ifInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ifInstruction GGS_ifInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_semanticExpression & argument_0,
                 const GGS__list_semanticInstructions & argument_1,
                 const GGS__list_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstruction result ;
  macroMyNew (result.mPointer, cPtr_ifInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticExpression  GGS_ifInstruction::
reader_mIFexpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mIFexpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstructions  GGS_ifInstruction::
reader_mIFinstructionListList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mIFinstructionListList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstructions  GGS_ifInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstruction::actualTypeName (void) const {
 return "ifInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstruction * GGS_ifInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_ifInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@methodCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstruction::
cPtr_methodCallInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_methodCallInstruction * _p = dynamic_cast <const cPtr_methodCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @methodCallInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_methodCallInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_methodCallInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 17 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "methodCallInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_methodCallInstruction * cPtr_methodCallInstruction::
_cloneObject (void) const {
  cPtr_methodCallInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_methodCallInstruction (mReceiverExpression, mMethodName, mActualParameterList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_methodCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_methodCallInstruction::
_addAssign_operation (const GGS_methodCallInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_methodCallInstruction GGS__list_methodCallInstruction::
_operator_concat (const GGS__list_methodCallInstruction & inOperand) const {
  GGS__list_methodCallInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_methodCallInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_methodCallInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mMethodName,
                                _p->mActualParameterList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_methodCallInstruction  GGS__list_methodCallInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_methodCallInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_methodCallInstruction  GGS__list_methodCallInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_methodCallInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_methodCallInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_methodCallInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_methodCallInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
_addModel (const GGS_methodCallInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
method_first (C_Compiler & _inLexique,
              GGS_methodCallInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodCallInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
method_last (C_Compiler & _inLexique,
             GGS_methodCallInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodCallInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_methodCallInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodCallInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodCallInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_methodCallInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodCallInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@methodCallInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_methodCallInstruction GGS_methodCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_methodCallInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_methodCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstruction::actualTypeName (void) const {
 return "methodCallInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstruction * GGS_methodCallInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_methodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@modifierCallInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstruction::
cPtr_modifierCallInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mModifierName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_modifierCallInstruction * _p = dynamic_cast <const cPtr_modifierCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mModifierName._operator_isEqual (_p->mModifierName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @modifierCallInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModifierName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_modifierCallInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_modifierCallInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 18 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "modifierCallInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_modifierCallInstruction * cPtr_modifierCallInstruction::
_cloneObject (void) const {
  cPtr_modifierCallInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_modifierCallInstruction (mReceiverName, mModifierName, mActualParameterList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_modifierCallInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_modifierCallInstruction::
_addAssign_operation (const GGS_modifierCallInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_modifierCallInstruction GGS__list_modifierCallInstruction::
_operator_concat (const GGS__list_modifierCallInstruction & inOperand) const {
  GGS__list_modifierCallInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_modifierCallInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_modifierCallInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverName,
                                _p->mModifierName,
                                _p->mActualParameterList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_modifierCallInstruction  GGS__list_modifierCallInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_modifierCallInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_modifierCallInstruction  GGS__list_modifierCallInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_modifierCallInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_modifierCallInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_modifierCallInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_modifierCallInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
_addModel (const GGS_modifierCallInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
method_first (C_Compiler & _inLexique,
              GGS_modifierCallInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_modifierCallInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mModifierName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
method_last (C_Compiler & _inLexique,
             GGS_modifierCallInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_modifierCallInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mModifierName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_modifierCallInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_modifierCallInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mModifierName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_modifierCallInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_modifierCallInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_modifierCallInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mModifierName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@modifierCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_modifierCallInstruction GGS_modifierCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_modifierCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstruction::actualTypeName (void) const {
 return "modifierCallInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstruction * GGS_modifierCallInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_modifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@errorInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstruction::
cPtr_errorInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mErrorExpression (argument_1),
mBuiltVariableList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_errorInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_errorInstruction * _p = dynamic_cast <const cPtr_errorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mErrorExpression._operator_isEqual (_p->mErrorExpression).boolValue ()
         && mBuiltVariableList._operator_isEqual (_p->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @errorInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBuiltVariableList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_errorInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_errorInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 19 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "errorInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_errorInstruction * cPtr_errorInstruction::
_cloneObject (void) const {
  cPtr_errorInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_errorInstruction (mReceiverExpression, mErrorExpression, mBuiltVariableList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_errorInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_lstringlist & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_lstringlist & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_errorInstruction::
_addAssign_operation (const GGS_errorInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_errorInstruction GGS__list_errorInstruction::
_operator_concat (const GGS__list_errorInstruction & inOperand) const {
  GGS__list_errorInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_errorInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_errorInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mErrorExpression,
                                _p->mBuiltVariableList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_errorInstruction  GGS__list_errorInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_errorInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_errorInstruction  GGS__list_errorInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_errorInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_errorInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_errorInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_errorInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
_addModel (const GGS_errorInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
method_first (C_Compiler & _inLexique,
              GGS_errorInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_errorInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression,
       _p->mBuiltVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
method_last (C_Compiler & _inLexique,
             GGS_errorInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_errorInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression,
       _p->mBuiltVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_errorInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_errorInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression,
       _p->mBuiltVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_errorInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_errorInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_errorInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression,
       _p->mBuiltVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@errorInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_errorInstruction GGS_errorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstruction result ;
  macroMyNew (result.mPointer, cPtr_errorInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstruction::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstruction::actualTypeName (void) const {
 return "errorInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstruction * GGS_errorInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_errorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@warningInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstruction::
cPtr_warningInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mErrorExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_warningInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_warningInstruction * _p = dynamic_cast <const cPtr_warningInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mErrorExpression._operator_isEqual (_p->mErrorExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @warningInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_warningInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_warningInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 20 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "warningInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_warningInstruction * cPtr_warningInstruction::
_cloneObject (void) const {
  cPtr_warningInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_warningInstruction (mReceiverExpression, mErrorExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_warningInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_warningInstruction::
_addAssign_operation (const GGS_warningInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_warningInstruction GGS__list_warningInstruction::
_operator_concat (const GGS__list_warningInstruction & inOperand) const {
  GGS__list_warningInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_warningInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_warningInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mErrorExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_warningInstruction  GGS__list_warningInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_warningInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_warningInstruction  GGS__list_warningInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_warningInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_warningInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_warningInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_warningInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
_addModel (const GGS_warningInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
method_first (C_Compiler & _inLexique,
              GGS_warningInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_warningInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
method_last (C_Compiler & _inLexique,
             GGS_warningInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_warningInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_warningInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_warningInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_warningInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_warningInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_warningInstruction::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mErrorExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@warningInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_warningInstruction GGS_warningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstruction result ;
  macroMyNew (result.mPointer, cPtr_warningInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstruction::actualTypeName (void) const {
 return "warningInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstruction * GGS_warningInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_warningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@routineCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstruction::
cPtr_routineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_actualParameters & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mRoutineName (argument_0),
mActualParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_routineCallInstruction * _p = dynamic_cast <const cPtr_routineCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @routineCallInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_routineCallInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_routineCallInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 21 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "routineCallInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_routineCallInstruction * cPtr_routineCallInstruction::
_cloneObject (void) const {
  cPtr_routineCallInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_routineCallInstruction (mRoutineName, mActualParameterList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_routineCallInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_actualParameters & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_actualParameters & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_routineCallInstruction::
_addAssign_operation (const GGS_routineCallInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_routineCallInstruction GGS__list_routineCallInstruction::
_operator_concat (const GGS__list_routineCallInstruction & inOperand) const {
  GGS__list_routineCallInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_routineCallInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_routineCallInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRoutineName,
                                _p->mActualParameterList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_routineCallInstruction  GGS__list_routineCallInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_routineCallInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_routineCallInstruction  GGS__list_routineCallInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_routineCallInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_routineCallInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_routineCallInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_routineCallInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
_addModel (const GGS_routineCallInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
method_first (C_Compiler & _inLexique,
              GGS_routineCallInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineCallInstruction::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
method_last (C_Compiler & _inLexique,
             GGS_routineCallInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineCallInstruction::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_routineCallInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineCallInstruction::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_routineCallInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_routineCallInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_routineCallInstruction::constructor_new (_inLexique,
       _p->mRoutineName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@routineCallInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineCallInstruction GGS_routineCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_actualParameters & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_routineCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstruction::actualTypeName (void) const {
 return "routineCallInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstruction * GGS_routineCallInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_routineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@matchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchEntry::
cPtr_matchEntry (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_matchEntry::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_matchEntry::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @matchEntry" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_matchEntry::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_matchEntry::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 22 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "matchEntry" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_matchEntry * cPtr_matchEntry::
_cloneObject (void) const {
  cPtr_matchEntry * _p = NULL ;
  macroMyNew (_p, cPtr_matchEntry (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@_list_matchEntry'                          *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_matchEntry::
_addAssign_operation (const GGS_matchEntry & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_matchEntry GGS__list_matchEntry::
_operator_concat (const GGS__list_matchEntry & inOperand) const {
  GGS__list_matchEntry result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_matchEntry::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_matchEntry & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_matchEntry  GGS__list_matchEntry::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_matchEntry result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_matchEntry  GGS__list_matchEntry::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_matchEntry & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_matchEntry result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_matchEntry::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_matchEntry", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
_addModel (const GGS_matchEntry & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
method_first (C_Compiler & _inLexique,
              GGS_matchEntry & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchEntry::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
method_last (C_Compiler & _inLexique,
             GGS_matchEntry & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchEntry::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_matchEntry & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchEntry::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchEntry::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_matchEntry & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchEntry::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS entity '@matchEntry'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_matchEntry::actualTypeName (void) const {
 return "matchEntry" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchEntry * GGS_matchEntry::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_matchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@constantMatchEntry'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constantMatchEntry::
cPtr_constantMatchEntry (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_matchEntry (THERE),
mConstantName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_constantMatchEntry::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_constantMatchEntry * _p = dynamic_cast <const cPtr_constantMatchEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constantMatchEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @constantMatchEntry" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_constantMatchEntry::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_constantMatchEntry::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 23 ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "constantMatchEntry" ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_constantMatchEntry * cPtr_constantMatchEntry::
_cloneObject (void) const {
  cPtr_constantMatchEntry * _p = NULL ;
  macroMyNew (_p, cPtr_constantMatchEntry (mConstantName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_constantMatchEntry'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
_internalAppendValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
_internalPrependValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_constantMatchEntry::
_addAssign_operation (const GGS_constantMatchEntry & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_constantMatchEntry GGS__list_constantMatchEntry::
_operator_concat (const GGS__list_constantMatchEntry & inOperand) const {
  GGS__list_constantMatchEntry result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_constantMatchEntry::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_constantMatchEntry & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_constantMatchEntry  GGS__list_constantMatchEntry::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_constantMatchEntry result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_constantMatchEntry  GGS__list_constantMatchEntry::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_constantMatchEntry & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_constantMatchEntry result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_constantMatchEntry::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_constantMatchEntry", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
_addModel (const GGS_constantMatchEntry & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
method_first (C_Compiler & _inLexique,
              GGS_constantMatchEntry & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constantMatchEntry::constructor_new (_inLexique,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
method_last (C_Compiler & _inLexique,
             GGS_constantMatchEntry & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constantMatchEntry::constructor_new (_inLexique,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_constantMatchEntry & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constantMatchEntry::constructor_new (_inLexique,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constantMatchEntry::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_constantMatchEntry & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constantMatchEntry::constructor_new (_inLexique,
       _p->mConstantName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@constantMatchEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_constantMatchEntry GGS_constantMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_constantMatchEntry (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantMatchEntry::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constantMatchEntry *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constantMatchEntry::actualTypeName (void) const {
 return "constantMatchEntry" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constantMatchEntry * GGS_constantMatchEntry::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_constantMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@classMatchEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMatchEntry::
cPtr_classMatchEntry (const GGS_lstring & argument_0,
                                const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_matchEntry (THERE),
mClassName (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_classMatchEntry::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classMatchEntry * _p = dynamic_cast <const cPtr_classMatchEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mElements._operator_isEqual (_p->mElements).boolValue ()
         && mEndsWithEllipsis._operator_isEqual (_p->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMatchEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classMatchEntry" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElements.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classMatchEntry::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classMatchEntry::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 24 ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "classMatchEntry" ;
  if (inLevel > 0) {
    result = cPtr_matchEntry::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_classMatchEntry * cPtr_classMatchEntry::
_cloneObject (void) const {
  cPtr_classMatchEntry * _p = NULL ;
  macroMyNew (_p, cPtr_classMatchEntry (mClassName, mElements, mEndsWithEllipsis COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_classMatchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                    const GGS_bool& argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                    const GGS_bool& argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_classMatchEntry::
_addAssign_operation (const GGS_classMatchEntry & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_classMatchEntry GGS__list_classMatchEntry::
_operator_concat (const GGS__list_classMatchEntry & inOperand) const {
  GGS__list_classMatchEntry result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_classMatchEntry::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_classMatchEntry & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mClassName,
                                _p->mElements,
                                _p->mEndsWithEllipsis) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_classMatchEntry  GGS__list_classMatchEntry::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classMatchEntry result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classMatchEntry  GGS__list_classMatchEntry::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_classMatchEntry & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classMatchEntry result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_classMatchEntry::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_classMatchEntry", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
_addModel (const GGS_classMatchEntry & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
method_first (C_Compiler & _inLexique,
              GGS_classMatchEntry & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMatchEntry::constructor_new (_inLexique,
       _p->mClassName,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
method_last (C_Compiler & _inLexique,
             GGS_classMatchEntry & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMatchEntry::constructor_new (_inLexique,
       _p->mClassName,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_classMatchEntry & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMatchEntry::constructor_new (_inLexique,
       _p->mClassName,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMatchEntry::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_classMatchEntry & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMatchEntry::constructor_new (_inLexique,
       _p->mClassName,
       _p->mElements,
       _p->mEndsWithEllipsis) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@classMatchEntry'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMatchEntry GGS_classMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_foreachInstructionEnumeratedObjectElement & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_classMatchEntry (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMatchEntry::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_foreachInstructionEnumeratedObjectElement  GGS_classMatchEntry::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_foreachInstructionEnumeratedObjectElement   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMatchEntry::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMatchEntry::actualTypeName (void) const {
 return "classMatchEntry" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMatchEntry * GGS_classMatchEntry::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@matchInstructionBranch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstructionBranch::
cPtr_matchInstructionBranch (const GGS__list_matchEntry & argument_0,
                                const GGS_semanticInstructions & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMatchedEntryList (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_matchInstructionBranch::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_matchInstructionBranch * _p = dynamic_cast <const cPtr_matchInstructionBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchedEntryList._operator_isEqual (_p->mMatchedEntryList).boolValue ()
         && mMatchBranchInstructionList._operator_isEqual (_p->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstructionBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @matchInstructionBranch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchedEntryList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_matchInstructionBranch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionBranch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_matchInstructionBranch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 25 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionBranch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "matchInstructionBranch" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_matchInstructionBranch * cPtr_matchInstructionBranch::
_cloneObject (void) const {
  cPtr_matchInstructionBranch * _p = NULL ;
  macroMyNew (_p, cPtr_matchInstructionBranch (mMatchedEntryList, mMatchBranchInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_matchInstructionBranch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
_internalAppendValues (const GGS__list_matchEntry & argument_0,
                    const GGS_semanticInstructions & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
_internalPrependValues (const GGS__list_matchEntry & argument_0,
                    const GGS_semanticInstructions & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_matchInstructionBranch::
_addAssign_operation (const GGS_matchInstructionBranch & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_matchInstructionBranch GGS__list_matchInstructionBranch::
_operator_concat (const GGS__list_matchInstructionBranch & inOperand) const {
  GGS__list_matchInstructionBranch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_matchInstructionBranch::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_matchInstructionBranch & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMatchedEntryList,
                                _p->mMatchBranchInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_matchInstructionBranch  GGS__list_matchInstructionBranch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_matchInstructionBranch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_matchInstructionBranch  GGS__list_matchInstructionBranch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_matchInstructionBranch & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_matchInstructionBranch result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_matchInstructionBranch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_matchInstructionBranch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
_addModel (const GGS_matchInstructionBranch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
method_first (C_Compiler & _inLexique,
              GGS_matchInstructionBranch & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstructionBranch::constructor_new (_inLexique,
       _p->mMatchedEntryList,
       _p->mMatchBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
method_last (C_Compiler & _inLexique,
             GGS_matchInstructionBranch & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstructionBranch::constructor_new (_inLexique,
       _p->mMatchedEntryList,
       _p->mMatchBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_matchInstructionBranch & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstructionBranch::constructor_new (_inLexique,
       _p->mMatchedEntryList,
       _p->mMatchBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstructionBranch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_matchInstructionBranch & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstructionBranch::constructor_new (_inLexique,
       _p->mMatchedEntryList,
       _p->mMatchBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@matchInstructionBranch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchInstructionBranch GGS_matchInstructionBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_matchEntry & argument_0,
                 const GGS_semanticInstructions & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstructionBranch result ;
  macroMyNew (result.mPointer, cPtr_matchInstructionBranch (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_matchEntry  GGS_matchInstructionBranch::
reader_mMatchedEntryList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_matchEntry   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionBranch *) mPointer)->mMatchedEntryList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_matchInstructionBranch::
reader_mMatchBranchInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionBranch *) mPointer)->mMatchBranchInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstructionBranch::actualTypeName (void) const {
 return "matchInstructionBranch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstructionBranch * GGS_matchInstructionBranch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_matchInstructionBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@matchInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstruction::
cPtr_matchInstruction (const GGS_lstringlist & argument_0,
                                const GGS__list_matchInstructionBranch & argument_1,
                                const GGS__list_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mMatchedVariableNameList (argument_0),
mMatchInstructionBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_matchInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_matchInstruction * _p = dynamic_cast <const cPtr_matchInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchedVariableNameList._operator_isEqual (_p->mMatchedVariableNameList).boolValue ()
         && mMatchInstructionBranchList._operator_isEqual (_p->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @matchInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchedVariableNameList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchInstructionBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_matchInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_matchInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 26 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "matchInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_matchInstruction * cPtr_matchInstruction::
_cloneObject (void) const {
  cPtr_matchInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_matchInstruction (mMatchedVariableNameList, mMatchInstructionBranchList, mElseInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_matchInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
_internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS__list_matchInstructionBranch & argument_1,
                    const GGS__list_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
_internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS__list_matchInstructionBranch & argument_1,
                    const GGS__list_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_matchInstruction::
_addAssign_operation (const GGS_matchInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_matchInstruction GGS__list_matchInstruction::
_operator_concat (const GGS__list_matchInstruction & inOperand) const {
  GGS__list_matchInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_matchInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_matchInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMatchedVariableNameList,
                                _p->mMatchInstructionBranchList,
                                _p->mElseInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_matchInstruction  GGS__list_matchInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_matchInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_matchInstruction  GGS__list_matchInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_matchInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_matchInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_matchInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_matchInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
_addModel (const GGS_matchInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
method_first (C_Compiler & _inLexique,
              GGS_matchInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstruction::constructor_new (_inLexique,
       _p->mMatchedVariableNameList,
       _p->mMatchInstructionBranchList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
method_last (C_Compiler & _inLexique,
             GGS_matchInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstruction::constructor_new (_inLexique,
       _p->mMatchedVariableNameList,
       _p->mMatchInstructionBranchList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_matchInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstruction::constructor_new (_inLexique,
       _p->mMatchedVariableNameList,
       _p->mMatchInstructionBranchList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_matchInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_matchInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_matchInstruction::constructor_new (_inLexique,
       _p->mMatchedVariableNameList,
       _p->mMatchInstructionBranchList,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@matchInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchInstruction GGS_matchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0,
                 const GGS__list_matchInstructionBranch & argument_1,
                 const GGS__list_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstruction result ;
  macroMyNew (result.mPointer, cPtr_matchInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_matchInstruction::
reader_mMatchedVariableNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchedVariableNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_matchInstructionBranch  GGS_matchInstruction::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_matchInstructionBranch   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticInstructions  GGS_matchInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstruction::actualTypeName (void) const {
 return "matchInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstruction * GGS_matchInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_matchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@castInstructionBranch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstructionBranch::
cPtr_castInstructionBranch (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructions & argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mCastBranchInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_castInstructionBranch::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_castInstructionBranch * _p = dynamic_cast <const cPtr_castInstructionBranch *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mUseKindOfClass._operator_isEqual (_p->mUseKindOfClass).boolValue ()
         && mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstantVarName._operator_isEqual (_p->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused._operator_isEqual (_p->mConstantVarNameIsUnused).boolValue ()
         && mCastBranchInstructionList._operator_isEqual (_p->mCastBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstructionBranch::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @castInstructionBranch" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastBranchInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInstructionBranch::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstructionBranch::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInstructionBranch::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 27 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstructionBranch::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "castInstructionBranch" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_castInstructionBranch * cPtr_castInstructionBranch::
_cloneObject (void) const {
  cPtr_castInstructionBranch * _p = NULL ;
  macroMyNew (_p, cPtr_castInstructionBranch (mUseKindOfClass, mTypeName, mConstantVarName, mConstantVarNameIsUnused, mCastBranchInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_castInstructionBranch'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructions & argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructions & argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_castInstructionBranch::
_addAssign_operation (const GGS_castInstructionBranch & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_castInstructionBranch GGS__list_castInstructionBranch::
_operator_concat (const GGS__list_castInstructionBranch & inOperand) const {
  GGS__list_castInstructionBranch result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_castInstructionBranch::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_castInstructionBranch & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mUseKindOfClass,
                                _p->mTypeName,
                                _p->mConstantVarName,
                                _p->mConstantVarNameIsUnused,
                                _p->mCastBranchInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_castInstructionBranch  GGS__list_castInstructionBranch::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_castInstructionBranch result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_castInstructionBranch  GGS__list_castInstructionBranch::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_castInstructionBranch & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_castInstructionBranch result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_castInstructionBranch::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_castInstructionBranch", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
_addModel (const GGS_castInstructionBranch & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
method_first (C_Compiler & _inLexique,
              GGS_castInstructionBranch & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstructionBranch::constructor_new (_inLexique,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mConstantVarName,
       _p->mConstantVarNameIsUnused,
       _p->mCastBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
method_last (C_Compiler & _inLexique,
             GGS_castInstructionBranch & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstructionBranch::constructor_new (_inLexique,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mConstantVarName,
       _p->mConstantVarNameIsUnused,
       _p->mCastBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_castInstructionBranch & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstructionBranch::constructor_new (_inLexique,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mConstantVarName,
       _p->mConstantVarNameIsUnused,
       _p->mCastBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstructionBranch::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_castInstructionBranch & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstructionBranch::constructor_new (_inLexique,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mConstantVarName,
       _p->mConstantVarNameIsUnused,
       _p->mCastBranchInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@castInstructionBranch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInstructionBranch GGS_castInstructionBranch::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_bool& argument_3,
                 const GGS_semanticInstructions & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_castInstructionBranch result ;
  macroMyNew (result.mPointer, cPtr_castInstructionBranch (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranch::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionBranch *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranch::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionBranch *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranch::
reader_mConstantVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionBranch *) mPointer)->mConstantVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranch::
reader_mConstantVarNameIsUnused (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionBranch *) mPointer)->mConstantVarNameIsUnused ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_castInstructionBranch::
reader_mCastBranchInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionBranch *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionBranch *) mPointer)->mCastBranchInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstructionBranch::actualTypeName (void) const {
 return "castInstructionBranch" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstructionBranch * GGS_castInstructionBranch::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_castInstructionBranch *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@elseOrDefaultForCastInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseOrDefaultForCastInstruction::
cPtr_elseOrDefaultForCastInstruction (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_elseOrDefaultForCastInstruction::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_elseOrDefaultForCastInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_elseOrDefaultForCastInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_elseOrDefaultForCastInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 28 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "elseOrDefaultForCastInstruction" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_elseOrDefaultForCastInstruction * cPtr_elseOrDefaultForCastInstruction::
_cloneObject (void) const {
  cPtr_elseOrDefaultForCastInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_elseOrDefaultForCastInstruction (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@_list_elseOrDefaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_elseOrDefaultForCastInstruction::
_addAssign_operation (const GGS_elseOrDefaultForCastInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_elseOrDefaultForCastInstruction GGS__list_elseOrDefaultForCastInstruction::
_operator_concat (const GGS__list_elseOrDefaultForCastInstruction & inOperand) const {
  GGS__list_elseOrDefaultForCastInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_elseOrDefaultForCastInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_elseOrDefaultForCastInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_elseOrDefaultForCastInstruction  GGS__list_elseOrDefaultForCastInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_elseOrDefaultForCastInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_elseOrDefaultForCastInstruction  GGS__list_elseOrDefaultForCastInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_elseOrDefaultForCastInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_elseOrDefaultForCastInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_elseOrDefaultForCastInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_elseOrDefaultForCastInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
_addModel (const GGS_elseOrDefaultForCastInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
method_first (C_Compiler & _inLexique,
              GGS_elseOrDefaultForCastInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseOrDefaultForCastInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
method_last (C_Compiler & _inLexique,
             GGS_elseOrDefaultForCastInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseOrDefaultForCastInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_elseOrDefaultForCastInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseOrDefaultForCastInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseOrDefaultForCastInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_elseOrDefaultForCastInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseOrDefaultForCastInstruction::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS entity '@elseOrDefaultForCastInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_elseOrDefaultForCastInstruction::actualTypeName (void) const {
 return "elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseOrDefaultForCastInstruction * GGS_elseOrDefaultForCastInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@elseForCastInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseForCastInstruction::
cPtr_elseForCastInstruction (const GGS_semanticInstructions & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_elseForCastInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_elseForCastInstruction * _p = dynamic_cast <const cPtr_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_elseForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @elseForCastInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_elseForCastInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_elseForCastInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 29 ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "elseForCastInstruction" ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_elseForCastInstruction * cPtr_elseForCastInstruction::
_cloneObject (void) const {
  cPtr_elseForCastInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_elseForCastInstruction (mElseInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_elseForCastInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
_internalAppendValues (const GGS_semanticInstructions & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
_internalPrependValues (const GGS_semanticInstructions & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_elseForCastInstruction::
_addAssign_operation (const GGS_elseForCastInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_elseForCastInstruction GGS__list_elseForCastInstruction::
_operator_concat (const GGS__list_elseForCastInstruction & inOperand) const {
  GGS__list_elseForCastInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_elseForCastInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_elseForCastInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mElseInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_elseForCastInstruction  GGS__list_elseForCastInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_elseForCastInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_elseForCastInstruction  GGS__list_elseForCastInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_elseForCastInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_elseForCastInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_elseForCastInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_elseForCastInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
_addModel (const GGS_elseForCastInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
method_first (C_Compiler & _inLexique,
              GGS_elseForCastInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseForCastInstruction::constructor_new (_inLexique,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
method_last (C_Compiler & _inLexique,
             GGS_elseForCastInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseForCastInstruction::constructor_new (_inLexique,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_elseForCastInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseForCastInstruction::constructor_new (_inLexique,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_elseForCastInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_elseForCastInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_elseForCastInstruction::constructor_new (_inLexique,
       _p->mElseInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@elseForCastInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseForCastInstruction GGS_elseForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructions & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_elseForCastInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseForCastInstruction::actualTypeName (void) const {
 return "elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseForCastInstruction * GGS_elseForCastInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@defaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_defaultForCastInstruction::
cPtr_defaultForCastInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_defaultForCastInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_defaultForCastInstruction * _p = dynamic_cast <const cPtr_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_defaultForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @defaultForCastInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_defaultForCastInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_defaultForCastInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 30 ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "defaultForCastInstruction" ;
  if (inLevel > 0) {
    result = cPtr_elseOrDefaultForCastInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_defaultForCastInstruction * cPtr_defaultForCastInstruction::
_cloneObject (void) const {
  cPtr_defaultForCastInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_defaultForCastInstruction (mErrorLocationExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@_list_defaultForCastInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_defaultForCastInstruction::
_addAssign_operation (const GGS_defaultForCastInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_defaultForCastInstruction GGS__list_defaultForCastInstruction::
_operator_concat (const GGS__list_defaultForCastInstruction & inOperand) const {
  GGS__list_defaultForCastInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_defaultForCastInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_defaultForCastInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mErrorLocationExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_defaultForCastInstruction  GGS__list_defaultForCastInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_defaultForCastInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_defaultForCastInstruction  GGS__list_defaultForCastInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_defaultForCastInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_defaultForCastInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_defaultForCastInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_defaultForCastInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
_addModel (const GGS_defaultForCastInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
method_first (C_Compiler & _inLexique,
              GGS_defaultForCastInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_defaultForCastInstruction::constructor_new (_inLexique,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
method_last (C_Compiler & _inLexique,
             GGS_defaultForCastInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_defaultForCastInstruction::constructor_new (_inLexique,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_defaultForCastInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_defaultForCastInstruction::constructor_new (_inLexique,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_defaultForCastInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_defaultForCastInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_defaultForCastInstruction::constructor_new (_inLexique,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@defaultForCastInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_defaultForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_defaultForCastInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_defaultForCastInstruction::actualTypeName (void) const {
 return "defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_defaultForCastInstruction * GGS_defaultForCastInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@castInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstruction::
cPtr_castInstruction (const GGS_semanticExpression & argument_0,
                                const GGS__list_castInstructionBranch & argument_1,
                                const GGS_elseOrDefaultForCastInstruction & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mExpression (argument_0),
mCastInstructionBranchList (argument_1),
mElseOrDefault (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_castInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_castInstruction * _p = dynamic_cast <const cPtr_castInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && mCastInstructionBranchList._operator_isEqual (_p->mCastInstructionBranchList).boolValue ()
         && mElseOrDefault._operator_isEqual (_p->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @castInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastInstructionBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElseOrDefault.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 31 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "castInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_castInstruction * cPtr_castInstruction::
_cloneObject (void) const {
  cPtr_castInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_castInstruction (mExpression, mCastInstructionBranchList, mElseOrDefault COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_castInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS__list_castInstructionBranch & argument_1,
                    const GGS_elseOrDefaultForCastInstruction & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS__list_castInstructionBranch & argument_1,
                    const GGS_elseOrDefaultForCastInstruction & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_castInstruction::
_addAssign_operation (const GGS_castInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_castInstruction GGS__list_castInstruction::
_operator_concat (const GGS__list_castInstruction & inOperand) const {
  GGS__list_castInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_castInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_castInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression,
                                _p->mCastInstructionBranchList,
                                _p->mElseOrDefault) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_castInstruction  GGS__list_castInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_castInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_castInstruction  GGS__list_castInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_castInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_castInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_castInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_castInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
_addModel (const GGS_castInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
method_first (C_Compiler & _inLexique,
              GGS_castInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstruction::constructor_new (_inLexique,
       _p->mExpression,
       _p->mCastInstructionBranchList,
       _p->mElseOrDefault) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
method_last (C_Compiler & _inLexique,
             GGS_castInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstruction::constructor_new (_inLexique,
       _p->mExpression,
       _p->mCastInstructionBranchList,
       _p->mElseOrDefault) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_castInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstruction::constructor_new (_inLexique,
       _p->mExpression,
       _p->mCastInstructionBranchList,
       _p->mElseOrDefault) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_castInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInstruction::constructor_new (_inLexique,
       _p->mExpression,
       _p->mCastInstructionBranchList,
       _p->mElseOrDefault) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@castInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInstruction GGS_castInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS__list_castInstructionBranch & argument_1,
                 const GGS_elseOrDefaultForCastInstruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_castInstruction result ;
  macroMyNew (result.mPointer, cPtr_castInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_castInstructionBranch  GGS_castInstruction::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_castInstructionBranch   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction  GGS_castInstruction::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstruction::actualTypeName (void) const {
 return "castInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstruction * GGS_castInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_castInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@addInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstruction::
cPtr_addInstruction (const GGS_lstring & argument_0,
                                const GGS_outExpressionList & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mExpressionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_addInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_addInstruction * _p = dynamic_cast <const cPtr_addInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mExpressionList._operator_isEqual (_p->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @addInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_addInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_addInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 32 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "addInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_addInstruction * cPtr_addInstruction::
_cloneObject (void) const {
  cPtr_addInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_addInstruction (mReceiverName, mExpressionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_addInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_outExpressionList & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_outExpressionList & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_addInstruction::
_addAssign_operation (const GGS_addInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_addInstruction GGS__list_addInstruction::
_operator_concat (const GGS__list_addInstruction & inOperand) const {
  GGS__list_addInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_addInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_addInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverName,
                                _p->mExpressionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_addInstruction  GGS__list_addInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_addInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_addInstruction  GGS__list_addInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_addInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_addInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_addInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_addInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
_addModel (const GGS_addInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
method_first (C_Compiler & _inLexique,
              GGS_addInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mExpressionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
method_last (C_Compiler & _inLexique,
             GGS_addInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mExpressionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_addInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mExpressionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_addInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addInstruction::constructor_new (_inLexique,
       _p->mReceiverName,
       _p->mExpressionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@addInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_addInstruction GGS_addInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_outExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_addInstruction result ;
  macroMyNew (result.mPointer, cPtr_addInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_addInstruction::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstruction::actualTypeName (void) const {
 return "addInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstruction * GGS_addInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_addInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@incrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstruction::
cPtr_incrementInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_incrementInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_incrementInstruction * _p = dynamic_cast <const cPtr_incrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @incrementInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_incrementInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_incrementInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 33 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "incrementInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_incrementInstruction * cPtr_incrementInstruction::
_cloneObject (void) const {
  cPtr_incrementInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_incrementInstruction (mReceiverName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_incrementInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
_internalAppendValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
_internalPrependValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_incrementInstruction::
_addAssign_operation (const GGS_incrementInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_incrementInstruction GGS__list_incrementInstruction::
_operator_concat (const GGS__list_incrementInstruction & inOperand) const {
  GGS__list_incrementInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_incrementInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_incrementInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_incrementInstruction  GGS__list_incrementInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_incrementInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_incrementInstruction  GGS__list_incrementInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_incrementInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_incrementInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_incrementInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_incrementInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
_addModel (const GGS_incrementInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
method_first (C_Compiler & _inLexique,
              GGS_incrementInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_incrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
method_last (C_Compiler & _inLexique,
             GGS_incrementInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_incrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_incrementInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_incrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_incrementInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_incrementInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_incrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@incrementInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_incrementInstruction GGS_incrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_incrementInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstruction::actualTypeName (void) const {
 return "incrementInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstruction * GGS_incrementInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_incrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@decrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstruction::
cPtr_decrementInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mReceiverName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_decrementInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_decrementInstruction * _p = dynamic_cast <const cPtr_decrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @decrementInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_decrementInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_decrementInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 34 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "decrementInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_decrementInstruction * cPtr_decrementInstruction::
_cloneObject (void) const {
  cPtr_decrementInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_decrementInstruction (mReceiverName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_decrementInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
_internalAppendValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
_internalPrependValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_decrementInstruction::
_addAssign_operation (const GGS_decrementInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_decrementInstruction GGS__list_decrementInstruction::
_operator_concat (const GGS__list_decrementInstruction & inOperand) const {
  GGS__list_decrementInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_decrementInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_decrementInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_decrementInstruction  GGS__list_decrementInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_decrementInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_decrementInstruction  GGS__list_decrementInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_decrementInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_decrementInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_decrementInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_decrementInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
_addModel (const GGS_decrementInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
method_first (C_Compiler & _inLexique,
              GGS_decrementInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_decrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
method_last (C_Compiler & _inLexique,
             GGS_decrementInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_decrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_decrementInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_decrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_decrementInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_decrementInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_decrementInstruction::constructor_new (_inLexique,
       _p->mReceiverName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@decrementInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_decrementInstruction GGS_decrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_decrementInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstruction::actualTypeName (void) const {
 return "decrementInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstruction * GGS_decrementInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_decrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@loopInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstruction::
cPtr_loopInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructions & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_semanticInstructions & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mVariantExpression (argument_0),
mFirstInstructions (argument_1),
mLoopExpression (argument_2),
mSecondInstructions (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_loopInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_loopInstruction * _p = dynamic_cast <const cPtr_loopInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariantExpression._operator_isEqual (_p->mVariantExpression).boolValue ()
         && mFirstInstructions._operator_isEqual (_p->mFirstInstructions).boolValue ()
         && mLoopExpression._operator_isEqual (_p->mLoopExpression).boolValue ()
         && mSecondInstructions._operator_isEqual (_p->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @loopInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariantExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFirstInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLoopExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSecondInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_loopInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_loopInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 35 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "loopInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_loopInstruction * cPtr_loopInstruction::
_cloneObject (void) const {
  cPtr_loopInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_loopInstruction (mVariantExpression, mFirstInstructions, mLoopExpression, mSecondInstructions COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_loopInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructions & argument_1,
                    const GGS_semanticExpression & argument_2,
                    const GGS_semanticInstructions & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructions & argument_1,
                    const GGS_semanticExpression & argument_2,
                    const GGS_semanticInstructions & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_loopInstruction::
_addAssign_operation (const GGS_loopInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_loopInstruction GGS__list_loopInstruction::
_operator_concat (const GGS__list_loopInstruction & inOperand) const {
  GGS__list_loopInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_loopInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_loopInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariantExpression,
                                _p->mFirstInstructions,
                                _p->mLoopExpression,
                                _p->mSecondInstructions) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_loopInstruction  GGS__list_loopInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_loopInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_loopInstruction  GGS__list_loopInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_loopInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_loopInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_loopInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_loopInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
_addModel (const GGS_loopInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
method_first (C_Compiler & _inLexique,
              GGS_loopInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_loopInstruction::constructor_new (_inLexique,
       _p->mVariantExpression,
       _p->mFirstInstructions,
       _p->mLoopExpression,
       _p->mSecondInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
method_last (C_Compiler & _inLexique,
             GGS_loopInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_loopInstruction::constructor_new (_inLexique,
       _p->mVariantExpression,
       _p->mFirstInstructions,
       _p->mLoopExpression,
       _p->mSecondInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_loopInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_loopInstruction::constructor_new (_inLexique,
       _p->mVariantExpression,
       _p->mFirstInstructions,
       _p->mLoopExpression,
       _p->mSecondInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_loopInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_loopInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_loopInstruction::constructor_new (_inLexique,
       _p->mVariantExpression,
       _p->mFirstInstructions,
       _p->mLoopExpression,
       _p->mSecondInstructions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@loopInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loopInstruction GGS_loopInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticInstructions & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_semanticInstructions & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstruction result ;
  macroMyNew (result.mPointer, cPtr_loopInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_loopInstruction::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_loopInstruction::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstruction::actualTypeName (void) const {
 return "loopInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstruction * GGS_loopInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_loopInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@messageInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstruction::
cPtr_messageInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_messageInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_messageInstruction * _p = dynamic_cast <const cPtr_messageInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @messageInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_messageInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_messageInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 36 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "messageInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_messageInstruction * cPtr_messageInstruction::
_cloneObject (void) const {
  cPtr_messageInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_messageInstruction (mExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_messageInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
_internalAppendValues (const GGS_semanticExpression & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
_internalPrependValues (const GGS_semanticExpression & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_messageInstruction::
_addAssign_operation (const GGS_messageInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_messageInstruction GGS__list_messageInstruction::
_operator_concat (const GGS__list_messageInstruction & inOperand) const {
  GGS__list_messageInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_messageInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_messageInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_messageInstruction  GGS__list_messageInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_messageInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_messageInstruction  GGS__list_messageInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_messageInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_messageInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_messageInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_messageInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
_addModel (const GGS_messageInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
method_first (C_Compiler & _inLexique,
              GGS_messageInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_messageInstruction::constructor_new (_inLexique,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
method_last (C_Compiler & _inLexique,
             GGS_messageInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_messageInstruction::constructor_new (_inLexique,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_messageInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_messageInstruction::constructor_new (_inLexique,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_messageInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_messageInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_messageInstruction::constructor_new (_inLexique,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@messageInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_messageInstruction GGS_messageInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstruction result ;
  macroMyNew (result.mPointer, cPtr_messageInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_messageInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstruction::actualTypeName (void) const {
 return "messageInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstruction * GGS_messageInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_messageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@logInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstruction::
cPtr_logInstruction (const GGS_lstringlist & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mLoggedVariableList (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_logInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_logInstruction * _p = dynamic_cast <const cPtr_logInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLoggedVariableList._operator_isEqual (_p->mLoggedVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @logInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLoggedVariableList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_logInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_logInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 37 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "logInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_logInstruction * cPtr_logInstruction::
_cloneObject (void) const {
  cPtr_logInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_logInstruction (mLoggedVariableList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_logInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
_internalAppendValues (const GGS_lstringlist & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
_internalPrependValues (const GGS_lstringlist & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_logInstruction::
_addAssign_operation (const GGS_logInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_logInstruction GGS__list_logInstruction::
_operator_concat (const GGS__list_logInstruction & inOperand) const {
  GGS__list_logInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_logInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_logInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLoggedVariableList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_logInstruction  GGS__list_logInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_logInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_logInstruction  GGS__list_logInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_logInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_logInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_logInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_logInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
_addModel (const GGS_logInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
method_first (C_Compiler & _inLexique,
              GGS_logInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_logInstruction::constructor_new (_inLexique,
       _p->mLoggedVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
method_last (C_Compiler & _inLexique,
             GGS_logInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_logInstruction::constructor_new (_inLexique,
       _p->mLoggedVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_logInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_logInstruction::constructor_new (_inLexique,
       _p->mLoggedVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_logInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_logInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_logInstruction::constructor_new (_inLexique,
       _p->mLoggedVariableList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@logInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_logInstruction GGS_logInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_logInstruction result ;
  macroMyNew (result.mPointer, cPtr_logInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_logInstruction::
reader_mLoggedVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstruction *) mPointer)->mLoggedVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstruction::actualTypeName (void) const {
 return "logInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstruction * GGS_logInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_logInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@grammarInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstruction::
cPtr_grammarInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_actualParameters & argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mGrammarComponentName (argument_0),
mLabelName (argument_1),
mSourceFileExpression (argument_2),
mActualParameterList (argument_3),
mReturnedModelName (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_grammarInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_grammarInstruction * _p = dynamic_cast <const cPtr_grammarInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGrammarComponentName._operator_isEqual (_p->mGrammarComponentName).boolValue ()
         && mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mSourceFileExpression._operator_isEqual (_p->mSourceFileExpression).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue ()
         && mReturnedModelName._operator_isEqual (_p->mReturnedModelName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @grammarInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceFileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedModelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_grammarInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_grammarInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 38 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "grammarInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_grammarInstruction * cPtr_grammarInstruction::
_cloneObject (void) const {
  cPtr_grammarInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_grammarInstruction (mGrammarComponentName, mLabelName, mSourceFileExpression, mActualParameterList, mReturnedModelName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_grammarInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2,
                    const GGS_actualParameters & argument_3,
                    const GGS_lstring & argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_semanticExpression & argument_2,
                    const GGS_actualParameters & argument_3,
                    const GGS_lstring & argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_grammarInstruction::
_addAssign_operation (const GGS_grammarInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_grammarInstruction GGS__list_grammarInstruction::
_operator_concat (const GGS__list_grammarInstruction & inOperand) const {
  GGS__list_grammarInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_grammarInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_grammarInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mGrammarComponentName,
                                _p->mLabelName,
                                _p->mSourceFileExpression,
                                _p->mActualParameterList,
                                _p->mReturnedModelName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_grammarInstruction  GGS__list_grammarInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_grammarInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_grammarInstruction  GGS__list_grammarInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_grammarInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_grammarInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_grammarInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_grammarInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
_addModel (const GGS_grammarInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
method_first (C_Compiler & _inLexique,
              GGS_grammarInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_grammarInstruction::constructor_new (_inLexique,
       _p->mGrammarComponentName,
       _p->mLabelName,
       _p->mSourceFileExpression,
       _p->mActualParameterList,
       _p->mReturnedModelName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
method_last (C_Compiler & _inLexique,
             GGS_grammarInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_grammarInstruction::constructor_new (_inLexique,
       _p->mGrammarComponentName,
       _p->mLabelName,
       _p->mSourceFileExpression,
       _p->mActualParameterList,
       _p->mReturnedModelName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_grammarInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_grammarInstruction::constructor_new (_inLexique,
       _p->mGrammarComponentName,
       _p->mLabelName,
       _p->mSourceFileExpression,
       _p->mActualParameterList,
       _p->mReturnedModelName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_grammarInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_grammarInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_grammarInstruction::constructor_new (_inLexique,
       _p->mGrammarComponentName,
       _p->mLabelName,
       _p->mSourceFileExpression,
       _p->mActualParameterList,
       _p->mReturnedModelName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@grammarInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_grammarInstruction GGS_grammarInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_actualParameters & argument_3,
                 const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_grammarInstruction::
reader_mSourceFileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mSourceFileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_grammarInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mReturnedModelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mReturnedModelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstruction::actualTypeName (void) const {
 return "grammarInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstruction * GGS_grammarInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@treewalkingInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_treewalkingInstruction::
cPtr_treewalkingInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTreewalkingComponentName (argument_0),
mModelName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_treewalkingInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_treewalkingInstruction * _p = dynamic_cast <const cPtr_treewalkingInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTreewalkingComponentName._operator_isEqual (_p->mTreewalkingComponentName).boolValue ()
         && mModelName._operator_isEqual (_p->mModelName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_treewalkingInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @treewalkingInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTreewalkingComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_treewalkingInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_treewalkingInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_treewalkingInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 39 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_treewalkingInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "treewalkingInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_treewalkingInstruction * cPtr_treewalkingInstruction::
_cloneObject (void) const {
  cPtr_treewalkingInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_treewalkingInstruction (mTreewalkingComponentName, mModelName, mActualParameterList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_treewalkingInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_treewalkingInstruction::
_addAssign_operation (const GGS_treewalkingInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_treewalkingInstruction GGS__list_treewalkingInstruction::
_operator_concat (const GGS__list_treewalkingInstruction & inOperand) const {
  GGS__list_treewalkingInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_treewalkingInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_treewalkingInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTreewalkingComponentName,
                                _p->mModelName,
                                _p->mActualParameterList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_treewalkingInstruction  GGS__list_treewalkingInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_treewalkingInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_treewalkingInstruction  GGS__list_treewalkingInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_treewalkingInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_treewalkingInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_treewalkingInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_treewalkingInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
_addModel (const GGS_treewalkingInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
method_first (C_Compiler & _inLexique,
              GGS_treewalkingInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_treewalkingInstruction::constructor_new (_inLexique,
       _p->mTreewalkingComponentName,
       _p->mModelName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
method_last (C_Compiler & _inLexique,
             GGS_treewalkingInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_treewalkingInstruction::constructor_new (_inLexique,
       _p->mTreewalkingComponentName,
       _p->mModelName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_treewalkingInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_treewalkingInstruction::constructor_new (_inLexique,
       _p->mTreewalkingComponentName,
       _p->mModelName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_treewalkingInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_treewalkingInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_treewalkingInstruction::constructor_new (_inLexique,
       _p->mTreewalkingComponentName,
       _p->mModelName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@treewalkingInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_treewalkingInstruction GGS_treewalkingInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_treewalkingInstruction result ;
  macroMyNew (result.mPointer, cPtr_treewalkingInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_treewalkingInstruction::
reader_mTreewalkingComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_treewalkingInstruction *) mPointer)->mTreewalkingComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_treewalkingInstruction::
reader_mModelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_treewalkingInstruction *) mPointer)->mModelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_treewalkingInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_treewalkingInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_treewalkingInstruction::actualTypeName (void) const {
 return "treewalkingInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_treewalkingInstruction * GGS_treewalkingInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_treewalkingInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeMethodInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstruction::
cPtr_typeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstruction::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_typeMethodInstruction * _p = dynamic_cast <const cPtr_typeMethodInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @typeMethodInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_typeMethodInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_typeMethodInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 40 ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "typeMethodInstruction" ;
  if (inLevel > 0) {
    result = cPtr_semanticInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_typeMethodInstruction * cPtr_typeMethodInstruction::
_cloneObject (void) const {
  cPtr_typeMethodInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_typeMethodInstruction (mTypeName, mMethodName, mActualParameterList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_typeMethodInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_typeMethodInstruction::
_addAssign_operation (const GGS_typeMethodInstruction & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_typeMethodInstruction GGS__list_typeMethodInstruction::
_operator_concat (const GGS__list_typeMethodInstruction & inOperand) const {
  GGS__list_typeMethodInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_typeMethodInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_typeMethodInstruction & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mMethodName,
                                _p->mActualParameterList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_typeMethodInstruction  GGS__list_typeMethodInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_typeMethodInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_typeMethodInstruction  GGS__list_typeMethodInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeMethodInstruction & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_typeMethodInstruction result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_typeMethodInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_typeMethodInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
_addModel (const GGS_typeMethodInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
method_first (C_Compiler & _inLexique,
              GGS_typeMethodInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_typeMethodInstruction::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
method_last (C_Compiler & _inLexique,
             GGS_typeMethodInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_typeMethodInstruction::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_typeMethodInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_typeMethodInstruction::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_typeMethodInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_typeMethodInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_typeMethodInstruction::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mMethodName,
       _p->mActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@typeMethodInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodInstruction GGS_typeMethodInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_typeMethodInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstruction::actualTypeName (void) const {
 return "typeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstruction * GGS_typeMethodInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_typeMethodInstruction *) mPointer ;
  }
#endif

