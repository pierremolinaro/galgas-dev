//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'instructionMetamodel.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      april 29th, 2009, at 15h22'14"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "instructionMetamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "instructionMetamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_syntaxInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstruction::
cPtr_syntaxInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstruction * GGS_syntaxInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_syntaxInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@syntaxInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstruction (& typeid (cPtr_syntaxInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_syntaxInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__syntaxInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_syntaxInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxInstruction::
GGS_syntaxInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstruction::
GGS_syntaxInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_syntaxInstruction GGS_syntaxInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_syntaxInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstruction::actualTypeName (void) const {
  return "syntaxInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_syntaxInstruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__syntaxInstruction ("syntaxInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_semanticInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstruction::
cPtr_semanticInstruction (LOCATION_ARGS)
:cPtr_syntaxInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstruction * GGS_semanticInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@semanticInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstruction (& typeid (cPtr_semanticInstruction), & typeid (cPtr_syntaxInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_semanticInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticInstruction::
GGS_semanticInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstruction::
GGS_semanticInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_semanticInstruction GGS_semanticInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_semanticInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstruction::actualTypeName (void) const {
  return "semanticInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__semanticInstruction ("semanticInstruction", gClassInfoFor__syntaxInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticInstructionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionList::
elementOf_GGS_semanticInstructionList (const GGS_semanticInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionList * _p = dynamic_cast <const elementOf_GGS_semanticInstructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalAppendValues (const GGS_semanticInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalPrependValues (const GGS_semanticInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_addAssign_operation (const GGS_semanticInstruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
_operator_concat (const GGS_semanticInstructionList & inOperand) const {
  GGS_semanticInstructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_dotAssign_operation (const GGS_semanticInstructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_semanticInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_emptyList (void) {
  GGS_semanticInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_listWithValue (const GGS_semanticInstruction & argument_0) {
  GGS_semanticInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
internalSubListWithRange (GGS_semanticInstructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_semanticInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_semanticInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstruction  GGS_semanticInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstruction  & GGS_semanticInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_semanticDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclaration::
cPtr_semanticDeclaration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclaration * GGS_semanticDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclaration::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@semanticDeclaration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclaration (& typeid (cPtr_semanticDeclaration), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_semanticDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticDeclaration::
GGS_semanticDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclaration::
GGS_semanticDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_semanticDeclaration GGS_semanticDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_semanticDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclaration::actualTypeName (void) const {
  return "semanticDeclaration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_semanticDeclaration::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__semanticDeclaration ("semanticDeclaration") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationList::
elementOf_GGS_semanticDeclarationList (const GGS_semanticDeclaration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSemanticDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationList * _p = dynamic_cast <const elementOf_GGS_semanticDeclarationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSemanticDeclaration._operator_isEqual (_p->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_internalAppendValues (const GGS_semanticDeclaration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_internalPrependValues (const GGS_semanticDeclaration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_addAssign_operation (const GGS_semanticDeclaration & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
_operator_concat (const GGS_semanticDeclarationList & inOperand) const {
  GGS_semanticDeclarationList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_dotAssign_operation (const GGS_semanticDeclarationList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_semanticDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclaration  p_0 = p->mSemanticDeclaration ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclaration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSemanticDeclaration
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticDeclarationList::
constructor_emptyList (void) {
  GGS_semanticDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticDeclarationList::
constructor_listWithValue (const GGS_semanticDeclaration & argument_0) {
  GGS_semanticDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
internalSubListWithRange (GGS_semanticDeclarationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSemanticDeclaration) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_semanticDeclaration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticDeclaration ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_semanticDeclaration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticDeclaration ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticDeclaration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticDeclaration ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticDeclaration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticDeclaration ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclaration  GGS_semanticDeclarationList::
reader_mSemanticDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclaration  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSemanticDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_setMSemanticDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclaration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSemanticDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclaration  & GGS_semanticDeclarationList::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_externRoutineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclaration::
cPtr_externRoutineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mRoutineName (argument_0),
mFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclaration * GGS_externRoutineDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_externRoutineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externRoutineDeclaration * _p = dynamic_cast <const cPtr_externRoutineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@externRoutineDeclaration:"
           << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externRoutineDeclaration (& typeid (cPtr_externRoutineDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_externRoutineDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__externRoutineDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_externRoutineDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration::
GGS_externRoutineDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration::
GGS_externRoutineDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externRoutineDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_externRoutineDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_externRoutineDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externRoutineDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclaration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_externRoutineDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclaration::actualTypeName (void) const {
  return "externRoutineDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__externRoutineDeclaration ("externRoutineDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_routineDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclaration::
cPtr_routineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_externRoutineDeclaration (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclaration * GGS_routineDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineDeclaration * _p = dynamic_cast <const cPtr_routineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue ()
         && mRoutineInstructionList._operator_isEqual (_p->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routineDeclaration:"
           << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRoutineInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineDeclaration (& typeid (cPtr_routineDeclaration), & typeid (cPtr_externRoutineDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_routineDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__routineDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_routineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDeclaration::
GGS_routineDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclaration::
GGS_routineDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_routineDeclaration GGS_routineDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_routineDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_routineDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclaration GGS_routineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_routineDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_routineDeclaration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclaration::actualTypeName (void) const {
  return "routineDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__routineDeclaration ("routineDeclaration", gClassInfoFor__externRoutineDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_externFunctionDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externFunctionDeclaration::
cPtr_externFunctionDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mFunctionName (argument_0),
mFormalParameterList (argument_1),
mResultTypeName (argument_2),
mResultVariableName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externFunctionDeclaration * GGS_externFunctionDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_externFunctionDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externFunctionDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externFunctionDeclaration * _p = dynamic_cast <const cPtr_externFunctionDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFunctionName._operator_isEqual (_p->mFunctionName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue ()
         && mResultTypeName._operator_isEqual (_p->mResultTypeName).boolValue ()
         && mResultVariableName._operator_isEqual (_p->mResultVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externFunctionDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@externFunctionDeclaration:"
           << mFunctionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mResultTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mResultVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externFunctionDeclaration (& typeid (cPtr_externFunctionDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_externFunctionDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__externFunctionDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_externFunctionDeclaration'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_externFunctionDeclaration::
GGS_externFunctionDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclaration::
GGS_externFunctionDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_externFunctionDeclaration GGS_externFunctionDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externFunctionDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_externFunctionDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_externFunctionDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externFunctionDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclaration GGS_externFunctionDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclaration result ;
  macroMyNew (result.mPointer, cPtr_externFunctionDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclaration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_externFunctionDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclaration::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclaration::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externFunctionDeclaration::actualTypeName (void) const {
  return "externFunctionDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__externFunctionDeclaration ("externFunctionDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_functionDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionDeclaration::
cPtr_functionDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_externFunctionDeclaration (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
mFunctionInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionDeclaration * GGS_functionDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_functionDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionDeclaration * _p = dynamic_cast <const cPtr_functionDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFunctionName._operator_isEqual (_p->mFunctionName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue ()
         && mResultTypeName._operator_isEqual (_p->mResultTypeName).boolValue ()
         && mResultVariableName._operator_isEqual (_p->mResultVariableName).boolValue ()
         && mFunctionInstructionList._operator_isEqual (_p->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@functionDeclaration:"
           << mFunctionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mResultTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mResultVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFunctionInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionDeclaration (& typeid (cPtr_functionDeclaration), & typeid (cPtr_externFunctionDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_functionDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__functionDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_functionDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_functionDeclaration::
GGS_functionDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclaration::
GGS_functionDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_functionDeclaration GGS_functionDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_functionDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_functionDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclaration GGS_functionDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_functionDeclaration result ;
  macroMyNew (result.mPointer, cPtr_functionDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_functionDeclaration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclaration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionDeclaration::actualTypeName (void) const {
  return "functionDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__functionDeclaration ("functionDeclaration", gClassInfoFor__externFunctionDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_localVariableDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclaration::
cPtr_localVariableDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclaration * GGS_localVariableDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclaration * _p = dynamic_cast <const cPtr_localVariableDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclaration:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclaration (& typeid (cPtr_localVariableDeclaration), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localVariableDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_localVariableDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclaration::
GGS_localVariableDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclaration::
GGS_localVariableDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_localVariableDeclaration GGS_localVariableDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_localVariableDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclaration GGS_localVariableDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclaration::actualTypeName (void) const {
  return "localVariableDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localVariableDeclaration ("localVariableDeclaration", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         class 'cPtr_localVariableDeclarationWithInitialization'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitialization::
cPtr_localVariableDeclarationWithInitialization (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mConstructorName (argument_2),
mConstructorArguments (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitialization * GGS_localVariableDeclarationWithInitialization::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclarationWithInitialization *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitialization::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithInitialization * _p = dynamic_cast <const cPtr_localVariableDeclarationWithInitialization *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mConstructorName._operator_isEqual (_p->mConstructorName).boolValue ()
         && mConstructorArguments._operator_isEqual (_p->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitialization::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclarationWithInitialization:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithInitialization (& typeid (cPtr_localVariableDeclarationWithInitialization), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localVariableDeclarationWithInitialization::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithInitialization ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_localVariableDeclarationWithInitialization'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization::
GGS_localVariableDeclarationWithInitialization (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization::
GGS_localVariableDeclarationWithInitialization (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithInitialization) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_localVariableDeclarationWithInitialization (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithInitialization),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitialization (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitialization::actualTypeName (void) const {
  return "localVariableDeclarationWithInitialization" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localVariableDeclarationWithInitialization ("localVariableDeclarationWithInitialization", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_localVariableDeclarationWithAssignment'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithAssignment::
cPtr_localVariableDeclarationWithAssignment (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mVariableName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithAssignment * GGS_localVariableDeclarationWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclarationWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithAssignment::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithAssignment * _p = dynamic_cast <const cPtr_localVariableDeclarationWithAssignment *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithAssignment::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclarationWithAssignment:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithAssignment (& typeid (cPtr_localVariableDeclarationWithAssignment), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localVariableDeclarationWithAssignment::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithAssignment ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_localVariableDeclarationWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment::
GGS_localVariableDeclarationWithAssignment (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment::
GGS_localVariableDeclarationWithAssignment (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithAssignment) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_localVariableDeclarationWithAssignment (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithAssignment),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_localVariableDeclarationWithAssignment::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithAssignment::actualTypeName (void) const {
  return "localVariableDeclarationWithAssignment" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localVariableDeclarationWithAssignment ("localVariableDeclarationWithAssignment", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_assignmentInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstruction::
cPtr_assignmentInstruction (const GGS_lstring & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstruction * GGS_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstruction * _p = dynamic_cast <const cPtr_assignmentInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@assignmentInstruction:"
           << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstruction (& typeid (cPtr_assignmentInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_assignmentInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_assignmentInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_assignmentInstruction::
GGS_assignmentInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstruction::
GGS_assignmentInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_assignmentInstruction GGS_assignmentInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_assignmentInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstruction GGS_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstruction::actualTypeName (void) const {
  return "assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__assignmentInstruction ("assignmentInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_appendInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstruction::
cPtr_appendInstruction (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTargetVariableName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstruction * GGS_appendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_appendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstruction * _p = dynamic_cast <const cPtr_appendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVariableName._operator_isEqual (_p->mTargetVariableName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@appendInstruction:"
           << mTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstruction (& typeid (cPtr_appendInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_appendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_appendInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_appendInstruction::
GGS_appendInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstruction::
GGS_appendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_appendInstruction GGS_appendInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_appendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstruction GGS_appendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstruction result ;
  macroMyNew (result.mPointer, cPtr_appendInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_appendInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstruction::actualTypeName (void) const {
  return "appendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__appendInstruction ("appendInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_foreachInstructionEnumeratedObjectElement'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObjectElement::
cPtr_foreachInstructionEnumeratedObjectElement (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObjectElement * GGS_foreachInstructionEnumeratedObjectElement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionEnumeratedObjectElement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObjectElement::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionEnumeratedObjectElement:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedObjectElement (& typeid (cPtr_foreachInstructionEnumeratedObjectElement), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstructionEnumeratedObjectElement::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedObjectElement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_foreachInstructionEnumeratedObjectElement'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement::
GGS_foreachInstructionEnumeratedObjectElement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement::
GGS_foreachInstructionEnumeratedObjectElement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedObjectElement GGS_foreachInstructionEnumeratedObjectElement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElement *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedObjectElement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstructionEnumeratedObjectElement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedObjectElement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObjectElement::actualTypeName (void) const {
  return "foreachInstructionEnumeratedObjectElement" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_foreachInstructionEnumeratedObjectElement::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__foreachInstructionEnumeratedObjectElement ("foreachInstructionEnumeratedObjectElement") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_foreachInstructionJoker'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionJoker::
cPtr_foreachInstructionJoker (LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElement (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionJoker * GGS_foreachInstructionJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionJoker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionJoker::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionJoker (& typeid (cPtr_foreachInstructionJoker), & typeid (cPtr_foreachInstructionEnumeratedObjectElement), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstructionJoker::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionJoker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_foreachInstructionJoker'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker::
GGS_foreachInstructionJoker (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker::
GGS_foreachInstructionJoker (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionJoker *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionJoker) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstructionJoker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionJoker),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_foreachInstructionJoker * gSingleton_foreachInstructionJoker = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_foreachInstructionJoker (void) {
  macroDetachPointer (gSingleton_foreachInstructionJoker, cPtr_foreachInstructionJoker) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker result ;
  if (NULL == gSingleton_foreachInstructionJoker) {
    macroMyNew (gSingleton_foreachInstructionJoker, cPtr_foreachInstructionJoker (THERE)) ;
    registerReleaseRoutine (cleanUp_foreachInstructionJoker) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_foreachInstructionJoker) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionJoker::actualTypeName (void) const {
  return "foreachInstructionJoker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__foreachInstructionJoker ("foreachInstructionJoker", gClassInfoFor__foreachInstructionEnumeratedObjectElement) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_foreachInstructionEnumeratedConstant'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedConstant::
cPtr_foreachInstructionEnumeratedConstant (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElement (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedConstant * GGS_foreachInstructionEnumeratedConstant::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionEnumeratedConstant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedConstant::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionEnumeratedConstant * _p = dynamic_cast <const cPtr_foreachInstructionEnumeratedConstant *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstantName._operator_isEqual (_p->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedConstant::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionEnumeratedConstant:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedConstant (& typeid (cPtr_foreachInstructionEnumeratedConstant), & typeid (cPtr_foreachInstructionEnumeratedObjectElement), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstructionEnumeratedConstant::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedConstant ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_foreachInstructionEnumeratedConstant'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant::
GGS_foreachInstructionEnumeratedConstant (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant::
GGS_foreachInstructionEnumeratedConstant (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedConstant) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstructionEnumeratedConstant (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedConstant),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedConstant (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedConstant::actualTypeName (void) const {
  return "foreachInstructionEnumeratedConstant" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__foreachInstructionEnumeratedConstant ("foreachInstructionEnumeratedConstant", gClassInfoFor__foreachInstructionEnumeratedObjectElement) ;

//---------------------------------------------------------------------------*
//                                                                           *
//     Element of list '@foreachInstructionEnumeratedObjectElementList'      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
elementOf_GGS_foreachInstructionEnumeratedObjectElementList (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectElementList * _p = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectElementList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mElement._operator_isEqual (_p->mElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElement.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          List '@foreachInstructionEnumeratedObjectElementList'            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_internalAppendValues (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_internalPrependValues (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_addAssign_operation (const GGS_foreachInstructionEnumeratedObjectElement & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
_operator_concat (const GGS_foreachInstructionEnumeratedObjectElementList & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectElementList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectElementList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_foreachInstructionEnumeratedObjectElement  p_0 = p->mElement ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mElement
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectElementList::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectElementList::
constructor_listWithValue (const GGS_foreachInstructionEnumeratedObjectElement & argument_0) {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectElementList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mElement) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectElementList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachInstructionEnumeratedObjectElementList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
method_first (C_Compiler & _inLexique,
              GGS_foreachInstructionEnumeratedObjectElement & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
method_last (C_Compiler & _inLexique,
             GGS_foreachInstructionEnumeratedObjectElement & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_foreachInstructionEnumeratedObjectElement & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_foreachInstructionEnumeratedObjectElement & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mElement ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement  GGS_foreachInstructionEnumeratedObjectElementList::
reader_mElementAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElement  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElement ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_setMElementAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElement  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElement = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElement  & GGS_foreachInstructionEnumeratedObjectElementList::cEnumerator::_mElement (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mElement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@foreachInstructionEnumeratedObjectList'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectList::
elementOf_GGS_foreachInstructionEnumeratedObjectList (const GGS_semanticExpression & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEnumeratedExpression (argument_0),
mElementList (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectList * _p = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumeratedExpression._operator_isEqual (_p->mEnumeratedExpression).boolValue ()
         && mElementList._operator_isEqual (_p->mElementList).boolValue ()
         && mEndsWithEllipsis._operator_isEqual (_p->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElementList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@foreachInstructionEnumeratedObjectList'               *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_addAssign_operation (const GGS_semanticExpression & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
_operator_concat (const GGS_foreachInstructionEnumeratedObjectList & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mEnumeratedExpression ;
          GGS_foreachInstructionEnumeratedObjectElementList  p_1 = p->mElementList ;
          GGS_bool p_2 = p->mEndsWithEllipsis ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumeratedExpression,
                                _p->mElementList,
                                _p->mEndsWithEllipsis
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstructionEnumeratedObjectList::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstructionEnumeratedObjectList::
constructor_listWithValue (const GGS_semanticExpression & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2) {
  GGS_foreachInstructionEnumeratedObjectList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEnumeratedExpression, _p->mElementList, _p->mEndsWithEllipsis) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachInstructionEnumeratedObjectList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
method_first (C_Compiler & _inLexique,
              GGS_semanticExpression & _out_0,
              GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
              GGS_bool& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
method_last (C_Compiler & _inLexique,
             GGS_semanticExpression & _out_0,
             GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
             GGS_bool& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticExpression & _out_0,
                 GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
                 GGS_bool& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticExpression & _out_0,
                GGS_foreachInstructionEnumeratedObjectElementList & _out_1,
                GGS_bool& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumeratedExpression ;
    _out_1 = _p->mElementList ;
    _out_2 = _p->mEndsWithEllipsis ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstructionEnumeratedObjectList::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpression  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectList::
reader_mElementListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElementList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectList::
reader_mEndsWithEllipsisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndsWithEllipsis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMElementListAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElementList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMEndsWithEllipsisAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndsWithEllipsis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpression  & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementList  & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mElementList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mElementList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mEndsWithEllipsis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEndsWithEllipsis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_foreachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstruction::
cPtr_foreachInstruction (const GGS_foreachInstructionEnumeratedObjectList & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_semanticInstructionList & argument_3,
                                const GGS_semanticInstructionList & argument_4,
                                const GGS_semanticInstructionList & argument_5,
                                const GGS_semanticInstructionList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mEnumeratedObjectList (argument_0),
mIndexVariableName (argument_1),
mWhileExpression (argument_2),
mBeforeInstructionList (argument_3),
mBetweenInstructionList (argument_4),
mDoInstructionList (argument_5),
mAfterInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstruction * GGS_foreachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstruction * _p = dynamic_cast <const cPtr_foreachInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumeratedObjectList._operator_isEqual (_p->mEnumeratedObjectList).boolValue ()
         && mIndexVariableName._operator_isEqual (_p->mIndexVariableName).boolValue ()
         && mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mBeforeInstructionList._operator_isEqual (_p->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList._operator_isEqual (_p->mBetweenInstructionList).boolValue ()
         && mDoInstructionList._operator_isEqual (_p->mDoInstructionList).boolValue ()
         && mAfterInstructionList._operator_isEqual (_p->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@foreachInstruction:"
           << mEnumeratedObjectList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIndexVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBeforeInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBetweenInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDoInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfterInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstruction (& typeid (cPtr_foreachInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_foreachInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstruction::
GGS_foreachInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstruction::
GGS_foreachInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_foreachInstruction GGS_foreachInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_foreachInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstruction GGS_foreachInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_foreachInstructionEnumeratedObjectList & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_semanticInstructionList & argument_3,
                 const GGS_semanticInstructionList & argument_4,
                 const GGS_semanticInstructionList & argument_5,
                 const GGS_semanticInstructionList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction result ;
  macroMyNew (result.mPointer, cPtr_foreachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstruction::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstruction::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstruction::actualTypeName (void) const {
  return "foreachInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__foreachInstruction ("foreachInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ifBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ifBranchList::
elementOf_GGS_ifBranchList (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mIFinstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ifBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ifBranchList * _p = dynamic_cast <const elementOf_GGS_ifBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIFexpression._operator_isEqual (_p->mIFexpression).boolValue ()
         && mIFinstructionList._operator_isEqual (_p->mIFinstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ifBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFinstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@ifBranchList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_addAssign_operation (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
_operator_concat (const GGS_ifBranchList & inOperand) const {
  GGS_ifBranchList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_dotAssign_operation (const GGS_ifBranchList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ifBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mIFexpression ;
          GGS_semanticInstructionList  p_1 = p->mIFinstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIFexpression,
                                _p->mIFinstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifBranchList::
constructor_emptyList (void) {
  GGS_ifBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifBranchList::
constructor_listWithValue (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  GGS_ifBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
internalSubListWithRange (GGS_ifBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mIFexpression, _p->mIFinstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ifBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ifBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
method_first (C_Compiler & _inLexique,
              GGS_semanticExpression & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
method_last (C_Compiler & _inLexique,
             GGS_semanticExpression & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_semanticExpression & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_semanticExpression & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mIFinstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_ifBranchList::
reader_mIFexpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpression  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_ifBranchList::
reader_mIFinstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFinstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_setMIFexpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_setMIFinstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFinstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpression  & GGS_ifBranchList::cEnumerator::_mIFexpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mIFexpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_ifBranchList::cEnumerator::_mIFinstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mIFinstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ifInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstruction::
cPtr_ifInstruction (const GGS_ifBranchList & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mBranchList (argument_0),
mElseInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstruction * GGS_ifInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ifInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstruction * _p = dynamic_cast <const cPtr_ifInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mBranchList._operator_isEqual (_p->mBranchList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ifInstruction:"
           << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstruction (& typeid (cPtr_ifInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ifInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ifInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ifInstruction::
GGS_ifInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstruction::
GGS_ifInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ifInstruction GGS_ifInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ifInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstruction GGS_ifInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ifBranchList & argument_0,
                 const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstruction result ;
  macroMyNew (result.mPointer, cPtr_ifInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifInstruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ifBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_ifInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstruction::actualTypeName (void) const {
  return "ifInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ifInstruction ("ifInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_methodCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstruction::
cPtr_methodCallInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstruction * GGS_methodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_methodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstruction * _p = dynamic_cast <const cPtr_methodCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@methodCallInstruction:"
           << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstruction (& typeid (cPtr_methodCallInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_methodCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_methodCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_methodCallInstruction::
GGS_methodCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstruction::
GGS_methodCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_methodCallInstruction GGS_methodCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_methodCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstruction GGS_methodCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_methodCallInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_methodCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstruction::actualTypeName (void) const {
  return "methodCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__methodCallInstruction ("methodCallInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_modifierCallInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstruction::
cPtr_modifierCallInstruction (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mReceiverStructAttributes (argument_1),
mModifierName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstruction * GGS_modifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_modifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstruction * _p = dynamic_cast <const cPtr_modifierCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mReceiverStructAttributes._operator_isEqual (_p->mReceiverStructAttributes).boolValue ()
         && mModifierName._operator_isEqual (_p->mModifierName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@modifierCallInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverStructAttributes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstruction (& typeid (cPtr_modifierCallInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_modifierCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_modifierCallInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_modifierCallInstruction::
GGS_modifierCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstruction::
GGS_modifierCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_modifierCallInstruction GGS_modifierCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_modifierCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstruction GGS_modifierCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstruction::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_modifierCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstruction::actualTypeName (void) const {
  return "modifierCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__modifierCallInstruction ("modifierCallInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_errorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstruction::
cPtr_errorInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mErrorExpression (argument_1),
mBuiltVariableList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstruction * GGS_errorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_errorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstruction * _p = dynamic_cast <const cPtr_errorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mErrorExpression._operator_isEqual (_p->mErrorExpression).boolValue ()
         && mBuiltVariableList._operator_isEqual (_p->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@errorInstruction:"
           << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBuiltVariableList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstruction (& typeid (cPtr_errorInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_errorInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_errorInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_errorInstruction::
GGS_errorInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstruction::
GGS_errorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_errorInstruction GGS_errorInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_errorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstruction GGS_errorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstruction result ;
  macroMyNew (result.mPointer, cPtr_errorInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstruction::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstruction::actualTypeName (void) const {
  return "errorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__errorInstruction ("errorInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_warningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstruction::
cPtr_warningInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverExpression (argument_0),
mWarningExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstruction * GGS_warningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_warningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstruction * _p = dynamic_cast <const cPtr_warningInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mWarningExpression._operator_isEqual (_p->mWarningExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@warningInstruction:"
           << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWarningExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstruction (& typeid (cPtr_warningInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_warningInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_warningInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_warningInstruction::
GGS_warningInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstruction::
GGS_warningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_warningInstruction GGS_warningInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_warningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstruction GGS_warningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstruction result ;
  macroMyNew (result.mPointer, cPtr_warningInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mWarningExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mWarningExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstruction::actualTypeName (void) const {
  return "warningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__warningInstruction ("warningInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_routineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstruction::
cPtr_routineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_actualParameterList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mRoutineName (argument_0),
mActualParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstruction * GGS_routineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstruction * _p = dynamic_cast <const cPtr_routineCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routineCallInstruction:"
           << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstruction (& typeid (cPtr_routineCallInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_routineCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_routineCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineCallInstruction::
GGS_routineCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstruction::
GGS_routineCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_routineCallInstruction GGS_routineCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_routineCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstruction GGS_routineCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_actualParameterList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_routineCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstruction::actualTypeName (void) const {
  return "routineCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__routineCallInstruction ("routineCallInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_matchEntry'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchEntry::
cPtr_matchEntry (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchEntry * GGS_matchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_matchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_matchEntry::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@matchEntry:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchEntry (& typeid (cPtr_matchEntry), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_matchEntry::galgasRTTI (void) const {
  return & gClassInfoFor__matchEntry ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_matchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchEntry::
GGS_matchEntry (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchEntry::
GGS_matchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_matchEntry GGS_matchEntry::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchEntry _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_matchEntry) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_matchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchEntry::actualTypeName (void) const {
  return "matchEntry" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_matchEntry::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__matchEntry ("matchEntry") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@matchEntryList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchEntryList::
elementOf_GGS_matchEntryList (const GGS_matchEntry & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntry (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchEntryList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchEntryList * _p = dynamic_cast <const elementOf_GGS_matchEntryList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntry._operator_isEqual (_p->mEntry).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchEntryList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntry.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@matchEntryList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_internalAppendValues (const GGS_matchEntry & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_internalPrependValues (const GGS_matchEntry & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_addAssign_operation (const GGS_matchEntry & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
_operator_concat (const GGS_matchEntryList & inOperand) const {
  GGS_matchEntryList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_dotAssign_operation (const GGS_matchEntryList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_matchEntryList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntry  p_0 = p->mEntry ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntry & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntry
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchEntryList::
constructor_emptyList (void) {
  GGS_matchEntryList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchEntryList::
constructor_listWithValue (const GGS_matchEntry & argument_0) {
  GGS_matchEntryList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
internalSubListWithRange (GGS_matchEntryList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEntry) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchEntryList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@matchEntryList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
method_first (C_Compiler & _inLexique,
              GGS_matchEntry & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
method_last (C_Compiler & _inLexique,
             GGS_matchEntry & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_matchEntry & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_matchEntry & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntry ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntry  GGS_matchEntryList::
reader_mEntryAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntry  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntry ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_setMEntryAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntry  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntry = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntry  & GGS_matchEntryList::cEnumerator::_mEntry (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEntry ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_constantMatchEntry'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constantMatchEntry::
cPtr_constantMatchEntry (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntry (THERE),
mConstantName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constantMatchEntry * GGS_constantMatchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_constantMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constantMatchEntry::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constantMatchEntry * _p = dynamic_cast <const cPtr_constantMatchEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constantMatchEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@constantMatchEntry:"
           << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constantMatchEntry (& typeid (cPtr_constantMatchEntry), & typeid (cPtr_matchEntry), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_constantMatchEntry::galgasRTTI (void) const {
  return & gClassInfoFor__constantMatchEntry ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_constantMatchEntry'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_constantMatchEntry::
GGS_constantMatchEntry (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntry::
GGS_constantMatchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_constantMatchEntry GGS_constantMatchEntry::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constantMatchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_constantMatchEntry) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_constantMatchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constantMatchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntry GGS_constantMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_constantMatchEntry (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantMatchEntry::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constantMatchEntry *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constantMatchEntry::actualTypeName (void) const {
  return "constantMatchEntry" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__constantMatchEntry ("constantMatchEntry", gClassInfoFor__matchEntry) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_classMatchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMatchEntry::
cPtr_classMatchEntry (const GGS_lstring & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntry (THERE),
mClassName (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMatchEntry * GGS_classMatchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classMatchEntry::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classMatchEntry * _p = dynamic_cast <const cPtr_classMatchEntry *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mElements._operator_isEqual (_p->mElements).boolValue ()
         && mEndsWithEllipsis._operator_isEqual (_p->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMatchEntry::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classMatchEntry:"
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElements.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEndsWithEllipsis.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classMatchEntry (& typeid (cPtr_classMatchEntry), & typeid (cPtr_matchEntry), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_classMatchEntry::galgasRTTI (void) const {
  return & gClassInfoFor__classMatchEntry ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classMatchEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMatchEntry::
GGS_classMatchEntry (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntry::
GGS_classMatchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_classMatchEntry GGS_classMatchEntry::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classMatchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_classMatchEntry) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_classMatchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classMatchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntry GGS_classMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_classMatchEntry (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMatchEntry::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_classMatchEntry::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMatchEntry::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMatchEntry::actualTypeName (void) const {
  return "classMatchEntry" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__classMatchEntry ("classMatchEntry", gClassInfoFor__matchEntry) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@matchInstructionBranchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchList::
elementOf_GGS_matchInstructionBranchList (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMatchEntryList (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchList * _p = dynamic_cast <const elementOf_GGS_matchInstructionBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchEntryList._operator_isEqual (_p->mMatchEntryList).boolValue ()
         && mMatchBranchInstructionList._operator_isEqual (_p->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchEntryList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@matchInstructionBranchList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_internalAppendValues (const GGS_matchEntryList & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_internalPrependValues (const GGS_matchEntryList & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_addAssign_operation (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
_operator_concat (const GGS_matchInstructionBranchList & inOperand) const {
  GGS_matchInstructionBranchList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_dotAssign_operation (const GGS_matchInstructionBranchList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_matchInstructionBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryList  p_0 = p->mMatchEntryList ;
          GGS_semanticInstructionList  p_1 = p->mMatchBranchInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryList & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMatchEntryList,
                                _p->mMatchBranchInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstructionBranchList::
constructor_emptyList (void) {
  GGS_matchInstructionBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstructionBranchList::
constructor_listWithValue (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  GGS_matchInstructionBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
internalSubListWithRange (GGS_matchInstructionBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMatchEntryList, _p->mMatchBranchInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@matchInstructionBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
method_first (C_Compiler & _inLexique,
              GGS_matchEntryList & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
method_last (C_Compiler & _inLexique,
             GGS_matchEntryList & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_matchEntryList & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_matchEntryList & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMatchEntryList ;
    _out_1 = _p->mMatchBranchInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchInstructionBranchList::
reader_mMatchEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_matchInstructionBranchList::
reader_mMatchBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_setMMatchEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_setMMatchBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryList  & GGS_matchInstructionBranchList::cEnumerator::_mMatchEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mMatchEntryList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_matchInstructionBranchList::cEnumerator::_mMatchBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mMatchBranchInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_matchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstruction::
cPtr_matchInstruction (const GGS_lstringlist & argument_0,
                                const GGS_matchInstructionBranchList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mMatchedVariableNameList (argument_0),
mMatchInstructionBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstruction * GGS_matchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_matchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstruction * _p = dynamic_cast <const cPtr_matchInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMatchedVariableNameList._operator_isEqual (_p->mMatchedVariableNameList).boolValue ()
         && mMatchInstructionBranchList._operator_isEqual (_p->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@matchInstruction:"
           << mMatchedVariableNameList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMatchInstructionBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstruction (& typeid (cPtr_matchInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_matchInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__matchInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_matchInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchInstruction::
GGS_matchInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstruction::
GGS_matchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_matchInstruction GGS_matchInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_matchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstruction GGS_matchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0,
                 const GGS_matchInstructionBranchList & argument_1,
                 const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstruction result ;
  macroMyNew (result.mPointer, cPtr_matchInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_matchInstruction::
reader_mMatchedVariableNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchedVariableNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstruction::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_matchInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstruction::actualTypeName (void) const {
  return "matchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__matchInstruction ("matchInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@castInstructionBranchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchList::
elementOf_GGS_castInstructionBranchList (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mCastBranchInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchList * _p = dynamic_cast <const elementOf_GGS_castInstructionBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mUseKindOfClass._operator_isEqual (_p->mUseKindOfClass).boolValue ()
         && mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstantVarName._operator_isEqual (_p->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused._operator_isEqual (_p->mConstantVarNameIsUnused).boolValue ()
         && mCastBranchInstructionList._operator_isEqual (_p->mCastBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastBranchInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@castInstructionBranchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()&& argument_4._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
_operator_concat (const GGS_castInstructionBranchList & inOperand) const {
  GGS_castInstructionBranchList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_dotAssign_operation (const GGS_castInstructionBranchList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_castInstructionBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_lstring  p_1 = p->mTypeName ;
          GGS_lstring  p_2 = p->mConstantVarName ;
          GGS_bool p_3 = p->mConstantVarNameIsUnused ;
          GGS_semanticInstructionList  p_4 = p->mCastBranchInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_semanticInstructionList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mUseKindOfClass,
                                _p->mTypeName,
                                _p->mConstantVarName,
                                _p->mConstantVarNameIsUnused,
                                _p->mCastBranchInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstructionBranchList::
constructor_emptyList (void) {
  GGS_castInstructionBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstructionBranchList::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  GGS_castInstructionBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
internalSubListWithRange (GGS_castInstructionBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mUseKindOfClass, _p->mTypeName, _p->mConstantVarName, _p->mConstantVarNameIsUnused, _p->mCastBranchInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@castInstructionBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
method_first (C_Compiler & _inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3,
              GGS_semanticInstructionList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
method_last (C_Compiler & _inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3,
             GGS_semanticInstructionList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3,
                 GGS_semanticInstructionList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3,
                GGS_semanticInstructionList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mUseKindOfClass ;
    _out_1 = _p->mTypeName ;
    _out_2 = _p->mConstantVarName ;
    _out_3 = _p->mConstantVarNameIsUnused ;
    _out_4 = _p->mCastBranchInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchList::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchList::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchList::
reader_mConstantVarNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchList::
reader_mConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarNameIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_castInstructionBranchList::
reader_mCastBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMConstantVarNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarNameIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMCastBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchList::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchList::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchList::cEnumerator::_mConstantVarName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mConstantVarName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchList::cEnumerator::_mConstantVarNameIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mConstantVarNameIsUnused ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_castInstructionBranchList::cEnumerator::_mCastBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mCastBranchInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_elseOrDefaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseOrDefaultForCastInstruction::
cPtr_elseOrDefaultForCastInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseOrDefaultForCastInstruction * GGS_elseOrDefaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseOrDefaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_elseOrDefaultForCastInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@elseOrDefaultForCastInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseOrDefaultForCastInstruction (& typeid (cPtr_elseOrDefaultForCastInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_elseOrDefaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__elseOrDefaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_elseOrDefaultForCastInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction::
GGS_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction::
GGS_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_elseOrDefaultForCastInstruction GGS_elseOrDefaultForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseOrDefaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_elseOrDefaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_elseOrDefaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseOrDefaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseOrDefaultForCastInstruction::actualTypeName (void) const {
  return "elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_elseOrDefaultForCastInstruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__elseOrDefaultForCastInstruction ("elseOrDefaultForCastInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_elseForCastInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseForCastInstruction::
cPtr_elseForCastInstruction (const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseForCastInstruction * GGS_elseForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_elseForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_elseForCastInstruction * _p = dynamic_cast <const cPtr_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_elseForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@elseForCastInstruction:"
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseForCastInstruction (& typeid (cPtr_elseForCastInstruction), & typeid (cPtr_elseOrDefaultForCastInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_elseForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__elseForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_elseForCastInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseForCastInstruction::
GGS_elseForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstruction::
GGS_elseForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_elseForCastInstruction GGS_elseForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_elseForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_elseForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstruction GGS_elseForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_elseForCastInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseForCastInstruction::actualTypeName (void) const {
  return "elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__elseForCastInstruction ("elseForCastInstruction", gClassInfoFor__elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_defaultForCastInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_defaultForCastInstruction::
cPtr_defaultForCastInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_defaultForCastInstruction * GGS_defaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_defaultForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_defaultForCastInstruction * _p = dynamic_cast <const cPtr_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_defaultForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@defaultForCastInstruction:"
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_defaultForCastInstruction (& typeid (cPtr_defaultForCastInstruction), & typeid (cPtr_elseOrDefaultForCastInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_defaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__defaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_defaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction::
GGS_defaultForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction::
GGS_defaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_defaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_defaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_defaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_defaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_defaultForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_defaultForCastInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_defaultForCastInstruction::actualTypeName (void) const {
  return "defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__defaultForCastInstruction ("defaultForCastInstruction", gClassInfoFor__elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_castInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstruction::
cPtr_castInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_castInstructionBranchList & argument_1,
                                const GGS_elseOrDefaultForCastInstruction & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mExpression (argument_0),
mCastInstructionBranchList (argument_1),
mElseOrDefault (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstruction * GGS_castInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_castInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInstruction * _p = dynamic_cast <const cPtr_castInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && mCastInstructionBranchList._operator_isEqual (_p->mCastInstructionBranchList).boolValue ()
         && mElseOrDefault._operator_isEqual (_p->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@castInstruction:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCastInstructionBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseOrDefault.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInstruction (& typeid (cPtr_castInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_castInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__castInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_castInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInstruction::
GGS_castInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInstruction::
GGS_castInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_castInstruction GGS_castInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_castInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_castInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_castInstruction GGS_castInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_castInstructionBranchList & argument_1,
                 const GGS_elseOrDefaultForCastInstruction & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_castInstruction result ;
  macroMyNew (result.mPointer, cPtr_castInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstruction::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction  GGS_castInstruction::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstruction::actualTypeName (void) const {
  return "castInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__castInstruction ("castInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_addInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstruction::
cPtr_addInstruction (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mStructAttributeList (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstruction * GGS_addInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_addInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addInstruction * _p = dynamic_cast <const cPtr_addInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mExpressionList._operator_isEqual (_p->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@addInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addInstruction (& typeid (cPtr_addInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_addInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__addInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_addInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_addInstruction::
GGS_addInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addInstruction::
GGS_addInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_addInstruction GGS_addInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_addInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_addInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_addInstruction GGS_addInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addInstruction result ;
  macroMyNew (result.mPointer, cPtr_addInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_addInstruction::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstruction::actualTypeName (void) const {
  return "addInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__addInstruction ("addInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_removeInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_removeInstruction::
cPtr_removeInstruction (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0),
mStructAttributeList (argument_1),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_removeInstruction * GGS_removeInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_removeInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_removeInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_removeInstruction * _p = dynamic_cast <const cPtr_removeInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_removeInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@removeInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_removeInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_removeInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_removeInstruction (& typeid (cPtr_removeInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_removeInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__removeInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_removeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_removeInstruction::
GGS_removeInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_removeInstruction::
GGS_removeInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_removeInstruction GGS_removeInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_removeInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_removeInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_removeInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_removeInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_removeInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_removeInstruction GGS_removeInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_removeInstruction result ;
  macroMyNew (result.mPointer, cPtr_removeInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_removeInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_removeInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_removeInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_removeInstruction::actualTypeName (void) const {
  return "removeInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__removeInstruction ("removeInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_incrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstruction::
cPtr_incrementInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstruction * GGS_incrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_incrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstruction * _p = dynamic_cast <const cPtr_incrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@incrementInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstruction (& typeid (cPtr_incrementInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_incrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_incrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_incrementInstruction::
GGS_incrementInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstruction::
GGS_incrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_incrementInstruction GGS_incrementInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_incrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstruction GGS_incrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_incrementInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstruction::actualTypeName (void) const {
  return "incrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__incrementInstruction ("incrementInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_decrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstruction::
cPtr_decrementInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mReceiverName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstruction * GGS_decrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_decrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstruction * _p = dynamic_cast <const cPtr_decrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverName._operator_isEqual (_p->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@decrementInstruction:"
           << mReceiverName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstruction (& typeid (cPtr_decrementInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_decrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_decrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_decrementInstruction::
GGS_decrementInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstruction::
GGS_decrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_decrementInstruction GGS_decrementInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_decrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstruction GGS_decrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_decrementInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstruction::actualTypeName (void) const {
  return "decrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__decrementInstruction ("decrementInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_loopInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstruction::
cPtr_loopInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_semanticInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mVariantExpression (argument_0),
mFirstInstructions (argument_1),
mLoopExpression (argument_2),
mSecondInstructions (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstruction * GGS_loopInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_loopInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstruction * _p = dynamic_cast <const cPtr_loopInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariantExpression._operator_isEqual (_p->mVariantExpression).boolValue ()
         && mFirstInstructions._operator_isEqual (_p->mFirstInstructions).boolValue ()
         && mLoopExpression._operator_isEqual (_p->mLoopExpression).boolValue ()
         && mSecondInstructions._operator_isEqual (_p->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@loopInstruction:"
           << mVariantExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFirstInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLoopExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSecondInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstruction (& typeid (cPtr_loopInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_loopInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_loopInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loopInstruction::
GGS_loopInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstruction::
GGS_loopInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_loopInstruction GGS_loopInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_loopInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstruction GGS_loopInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_semanticInstructionList & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_semanticInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstruction result ;
  macroMyNew (result.mPointer, cPtr_loopInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_loopInstruction::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_loopInstruction::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstruction::actualTypeName (void) const {
  return "loopInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__loopInstruction ("loopInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_messageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstruction::
cPtr_messageInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstruction * GGS_messageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_messageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstruction * _p = dynamic_cast <const cPtr_messageInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@messageInstruction:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstruction (& typeid (cPtr_messageInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_messageInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_messageInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_messageInstruction::
GGS_messageInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstruction::
GGS_messageInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_messageInstruction GGS_messageInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_messageInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstruction GGS_messageInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstruction result ;
  macroMyNew (result.mPointer, cPtr_messageInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_messageInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstruction::actualTypeName (void) const {
  return "messageInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__messageInstruction ("messageInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_logInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstruction::
cPtr_logInstruction (const GGS_lstringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mLoggedVariableList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstruction * GGS_logInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_logInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstruction * _p = dynamic_cast <const cPtr_logInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLoggedVariableList._operator_isEqual (_p->mLoggedVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@logInstruction:"
           << mLoggedVariableList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstruction (& typeid (cPtr_logInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_logInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__logInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_logInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_logInstruction::
GGS_logInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstruction::
GGS_logInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_logInstruction GGS_logInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_logInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_logInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_logInstruction GGS_logInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_logInstruction result ;
  macroMyNew (result.mPointer, cPtr_logInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_logInstruction::
reader_mLoggedVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstruction *) mPointer)->mLoggedVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstruction::actualTypeName (void) const {
  return "logInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__logInstruction ("logInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_grammarInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstruction::
cPtr_grammarInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_actualParameterList & argument_4,
                                const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mGrammarComponentName (argument_0),
mLabelName (argument_1),
mSourceExpression (argument_2),
mSourceExpressionIsFile (argument_3),
mActualParameterList (argument_4),
mReturnedModelName (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstruction * GGS_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstruction * _p = dynamic_cast <const cPtr_grammarInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGrammarComponentName._operator_isEqual (_p->mGrammarComponentName).boolValue ()
         && mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue ()
         && mSourceExpressionIsFile._operator_isEqual (_p->mSourceExpressionIsFile).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue ()
         && mReturnedModelName._operator_isEqual (_p->mReturnedModelName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@grammarInstruction:"
           << mGrammarComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionIsFile.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedModelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstruction (& typeid (cPtr_grammarInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_grammarInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_grammarInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_grammarInstruction::
GGS_grammarInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstruction::
GGS_grammarInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_grammarInstruction GGS_grammarInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_grammarInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstruction GGS_grammarInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_bool& argument_3,
                 const GGS_actualParameterList & argument_4,
                 const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_grammarInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarInstruction::
reader_mSourceExpressionIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mSourceExpressionIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_grammarInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mReturnedModelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mReturnedModelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstruction::actualTypeName (void) const {
  return "grammarInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__grammarInstruction ("grammarInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@switchBranches'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_switchBranches::
elementOf_GGS_switchBranches (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSwitchConstantList (argument_0),
mInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_switchBranches::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_switchBranches * _p = dynamic_cast <const elementOf_GGS_switchBranches *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSwitchConstantList._operator_isEqual (_p->mSwitchConstantList).boolValue ()
         && mInstructions._operator_isEqual (_p->mInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_switchBranches::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSwitchConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@switchBranches'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_switchBranches::
_internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
_internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
_addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranches GGS_switchBranches::
_operator_concat (const GGS_switchBranches & inOperand) const {
  GGS_switchBranches result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
_dotAssign_operation (const GGS_switchBranches inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_switchBranches * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mSwitchConstantList ;
          GGS_semanticInstructionList  p_1 = p->mInstructions ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSwitchConstantList,
                                _p->mInstructions
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranches  GGS_switchBranches::
constructor_emptyList (void) {
  GGS_switchBranches result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranches  GGS_switchBranches::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  GGS_switchBranches result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
internalSubListWithRange (GGS_switchBranches & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSwitchConstantList, _p->mInstructions) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranches GGS_switchBranches::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranches result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranches GGS_switchBranches::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranches result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_switchBranches::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@switchBranches", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
method_first (C_Compiler & _inLexique,
              GGS_lstringlist & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSwitchConstantList ;
    _out_1 = _p->mInstructions ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
method_last (C_Compiler & _inLexique,
             GGS_lstringlist & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSwitchConstantList ;
    _out_1 = _p->mInstructions ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSwitchConstantList ;
    _out_1 = _p->mInstructions ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstringlist & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSwitchConstantList ;
    _out_1 = _p->mInstructions ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_switchBranches::
reader_mSwitchConstantListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSwitchConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_switchBranches::
reader_mInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_setMSwitchConstantListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSwitchConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_setMInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_switchBranches::cEnumerator::_mSwitchConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSwitchConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_switchBranches::cEnumerator::_mInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructions ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_switchInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_switchInstruction::
cPtr_switchInstruction (const GGS_semanticExpression & argument_0,
                                const GGS_switchBranches & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mSwitchExpression (argument_0),
mBranches (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_switchInstruction * GGS_switchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_switchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_switchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_switchInstruction * _p = dynamic_cast <const cPtr_switchInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSwitchExpression._operator_isEqual (_p->mSwitchExpression).boolValue ()
         && mBranches._operator_isEqual (_p->mBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_switchInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@switchInstruction:"
           << mSwitchExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranches.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_switchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_switchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_switchInstruction (& typeid (cPtr_switchInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_switchInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__switchInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_switchInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_switchInstruction::
GGS_switchInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_switchInstruction::
GGS_switchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_switchInstruction GGS_switchInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_switchInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_switchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_switchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_switchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_switchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstruction GGS_switchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_switchBranches & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_switchInstruction result ;
  macroMyNew (result.mPointer, cPtr_switchInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_switchInstruction::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstruction *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranches  GGS_switchInstruction::
reader_mBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_switchBranches   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstruction *) mPointer)->mBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_switchInstruction::actualTypeName (void) const {
  return "switchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__switchInstruction ("switchInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeMethodInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstruction::
cPtr_typeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (THERE),
mTypeName (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstruction * GGS_typeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstruction * _p = dynamic_cast <const cPtr_typeMethodInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMethodInstruction:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstruction (& typeid (cPtr_typeMethodInstruction), & typeid (cPtr_semanticInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMethodInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMethodInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodInstruction::
GGS_typeMethodInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstruction::
GGS_typeMethodInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMethodInstruction GGS_typeMethodInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMethodInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstruction GGS_typeMethodInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_typeMethodInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstruction::actualTypeName (void) const {
  return "typeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMethodInstruction ("typeMethodInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@abstractCategoryMethodList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractCategoryMethodList::
elementOf_GGS_abstractCategoryMethodList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAbstractCategoryMethodName (argument_0),
mAbstractCategoryFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractCategoryMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractCategoryMethodList * _p = dynamic_cast <const elementOf_GGS_abstractCategoryMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAbstractCategoryMethodName._operator_isEqual (_p->mAbstractCategoryMethodName).boolValue ()
         && mAbstractCategoryFormalParameterList._operator_isEqual (_p->mAbstractCategoryFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractCategoryMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstractCategoryMethodList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodList::
_operator_concat (const GGS_abstractCategoryMethodList & inOperand) const {
  GGS_abstractCategoryMethodList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_dotAssign_operation (const GGS_abstractCategoryMethodList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_abstractCategoryMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryMethodName ;
          GGS_formalParameterList  p_1 = p->mAbstractCategoryFormalParameterList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAbstractCategoryMethodName,
                                _p->mAbstractCategoryFormalParameterList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList  GGS_abstractCategoryMethodList::
constructor_emptyList (void) {
  GGS_abstractCategoryMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList  GGS_abstractCategoryMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1) {
  GGS_abstractCategoryMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
internalSubListWithRange (GGS_abstractCategoryMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAbstractCategoryMethodName, _p->mAbstractCategoryFormalParameterList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractCategoryMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractCategoryMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@abstractCategoryMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAbstractCategoryMethodName ;
    _out_1 = _p->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAbstractCategoryMethodName ;
    _out_1 = _p->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAbstractCategoryMethodName ;
    _out_1 = _p->mAbstractCategoryFormalParameterList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAbstractCategoryMethodName ;
    _out_1 = _p->mAbstractCategoryFormalParameterList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractCategoryMethodList::
reader_mAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_abstractCategoryMethodList::
reader_mAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_setMAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_setMAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractCategoryMethodList::cEnumerator::_mAbstractCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mAbstractCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterList  & GGS_abstractCategoryMethodList::cEnumerator::_mAbstractCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstractCategoryMethodList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractCategoryMethodListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractCategoryMethodListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject._operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractCategoryMethodListMap::cElement::
_description (C_Compiler & _inLexique,
              const sint32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (_inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap GGS_abstractCategoryMethodListMap::
constructor_emptyMap (void) {
  GGS_abstractCategoryMethodListMap result ;
  result._alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractCategoryMethodListMap::
_typeNameForDescriptionReader (void) const {
  return "@abstractCategoryMethodListMap" ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap GGS_abstractCategoryMethodListMap::
_operator_concat (const GGS_abstractCategoryMethodListMap & inOperand) const {
  GGS_abstractCategoryMethodListMap result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodListMap::
_dotAssign_operation (const GGS_abstractCategoryMethodListMap inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const sint32 objectCount = dictPtr->count () ;
      for (sint32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = _findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * elementPtr = NULL ;
           macroMyNew (elementPtr, cElement (HERE)) ;
           nodePtr->mObject._setPointer (elementPtr) ;
        }
        GGS_abstractCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr._dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodListMap::
_addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterList & inAttribute1) {
  if (_isBuilt () && inKey._isBuilt () && inAttribute0._isBuilt () && inAttribute1._isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = _findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * elementPtr = NULL ;
       macroMyNew (elementPtr, cElement (HERE)) ;
       nodePtr->mObject._setPointer (elementPtr) ;
    }
    GGS_abstractCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr._addAssign_operation (inAttribute0, inAttribute1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractCategoryMethodList result ;
  if (_isBuilt () && inKey._isBuilt ()) {
    cPtrDictionaryNode * nodePtr = _dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstractCategoryMethodList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractCategoryMethodListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result._setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractCategoryMethodListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (_isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const sint32 objectCount = dictPtr->count () ;
    for (sint32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result._addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap::cEnumerator::
cEnumerator (const GGS_abstractCategoryMethodListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstractCategoryMethodList & GGS_abstractCategoryMethodListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@categoryMethodList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_categoryMethodList::
elementOf_GGS_categoryMethodList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCategoryMethodName (argument_0),
mCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_categoryMethodList * _p = dynamic_cast <const elementOf_GGS_categoryMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCategoryMethodName._operator_isEqual (_p->mCategoryMethodName).boolValue ()
         && mCategoryFormalParameterList._operator_isEqual (_p->mCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList._operator_isEqual (_p->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@categoryMethodList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodList::
_operator_concat (const GGS_categoryMethodList & inOperand) const {
  GGS_categoryMethodList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_dotAssign_operation (const GGS_categoryMethodList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_categoryMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryMethodName ;
          GGS_formalParameterList  p_1 = p->mCategoryFormalParameterList ;
          GGS_semanticInstructionList  p_2 = p->mRoutineInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1,
                     const GGS_semanticInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCategoryMethodName,
                                _p->mCategoryFormalParameterList,
                                _p->mRoutineInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList  GGS_categoryMethodList::
constructor_emptyList (void) {
  GGS_categoryMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList  GGS_categoryMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  GGS_categoryMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
internalSubListWithRange (GGS_categoryMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mCategoryMethodName, _p->mCategoryFormalParameterList, _p->mRoutineInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_categoryMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_categoryMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@categoryMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1,
              GGS_semanticInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCategoryMethodName ;
    _out_1 = _p->mCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1,
             GGS_semanticInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCategoryMethodName ;
    _out_1 = _p->mCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1,
                 GGS_semanticInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCategoryMethodName ;
    _out_1 = _p->mCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1,
                GGS_semanticInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCategoryMethodName ;
    _out_1 = _p->mCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryMethodList::
reader_mCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_categoryMethodList::
reader_mCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_categoryMethodList::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_setMCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_setMCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_categoryMethodList::cEnumerator::_mCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterList  & GGS_categoryMethodList::cEnumerator::_mCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_categoryMethodList::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_categoryMethodList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_categoryMethodListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_categoryMethodListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject._operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_categoryMethodListMap::cElement::
_description (C_Compiler & _inLexique,
              const sint32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (_inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap GGS_categoryMethodListMap::
constructor_emptyMap (void) {
  GGS_categoryMethodListMap result ;
  result._alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodListMap::
_typeNameForDescriptionReader (void) const {
  return "@categoryMethodListMap" ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap GGS_categoryMethodListMap::
_operator_concat (const GGS_categoryMethodListMap & inOperand) const {
  GGS_categoryMethodListMap result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodListMap::
_dotAssign_operation (const GGS_categoryMethodListMap inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const sint32 objectCount = dictPtr->count () ;
      for (sint32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = _findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * elementPtr = NULL ;
           macroMyNew (elementPtr, cElement (HERE)) ;
           nodePtr->mObject._setPointer (elementPtr) ;
        }
        GGS_categoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr._dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodListMap::
_addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterList & inAttribute1,
                      const GGS_semanticInstructionList & inAttribute2) {
  if (_isBuilt () && inKey._isBuilt () && inAttribute0._isBuilt () && inAttribute1._isBuilt () && inAttribute2._isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = _findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * elementPtr = NULL ;
       macroMyNew (elementPtr, cElement (HERE)) ;
       nodePtr->mObject._setPointer (elementPtr) ;
    }
    GGS_categoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr._addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryMethodList result ;
  if (_isBuilt () && inKey._isBuilt ()) {
    cPtrDictionaryNode * nodePtr = _dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_categoryMethodList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_categoryMethodListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result._setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_categoryMethodListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (_isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const sint32 objectCount = dictPtr->count () ;
    for (sint32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result._addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap::cEnumerator::
cEnumerator (const GGS_categoryMethodListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_categoryMethodList & GGS_categoryMethodListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingCategoryMethodList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingCategoryMethodList::
elementOf_GGS_overridingCategoryMethodList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOverridingCategoryMethodName (argument_0),
mOverridingCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingCategoryMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingCategoryMethodList * _p = dynamic_cast <const elementOf_GGS_overridingCategoryMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOverridingCategoryMethodName._operator_isEqual (_p->mOverridingCategoryMethodName).boolValue ()
         && mOverridingCategoryFormalParameterList._operator_isEqual (_p->mOverridingCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList._operator_isEqual (_p->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingCategoryMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingCategoryMethodList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodList::
_operator_concat (const GGS_overridingCategoryMethodList & inOperand) const {
  GGS_overridingCategoryMethodList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_dotAssign_operation (const GGS_overridingCategoryMethodList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_overridingCategoryMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryMethodName ;
          GGS_formalParameterList  p_1 = p->mOverridingCategoryFormalParameterList ;
          GGS_semanticInstructionList  p_2 = p->mRoutineInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1,
                     const GGS_semanticInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOverridingCategoryMethodName,
                                _p->mOverridingCategoryFormalParameterList,
                                _p->mRoutineInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList  GGS_overridingCategoryMethodList::
constructor_emptyList (void) {
  GGS_overridingCategoryMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList  GGS_overridingCategoryMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  GGS_overridingCategoryMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
internalSubListWithRange (GGS_overridingCategoryMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mOverridingCategoryMethodName, _p->mOverridingCategoryFormalParameterList, _p->mRoutineInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingCategoryMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingCategoryMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingCategoryMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@overridingCategoryMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1,
              GGS_semanticInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOverridingCategoryMethodName ;
    _out_1 = _p->mOverridingCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1,
             GGS_semanticInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOverridingCategoryMethodName ;
    _out_1 = _p->mOverridingCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1,
                 GGS_semanticInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOverridingCategoryMethodName ;
    _out_1 = _p->mOverridingCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1,
                GGS_semanticInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOverridingCategoryMethodName ;
    _out_1 = _p->mOverridingCategoryFormalParameterList ;
    _out_2 = _p->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingCategoryMethodList::
reader_mOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_overridingCategoryMethodList::
reader_mOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_overridingCategoryMethodList::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_setMOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_setMOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingCategoryMethodList::cEnumerator::_mOverridingCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOverridingCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterList  & GGS_overridingCategoryMethodList::cEnumerator::_mOverridingCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOverridingCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_overridingCategoryMethodList::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingCategoryMethodList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingCategoryMethodListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingCategoryMethodListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject._operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingCategoryMethodListMap::cElement::
_description (C_Compiler & _inLexique,
              const sint32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (_inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap GGS_overridingCategoryMethodListMap::
constructor_emptyMap (void) {
  GGS_overridingCategoryMethodListMap result ;
  result._alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingCategoryMethodListMap::
_typeNameForDescriptionReader (void) const {
  return "@overridingCategoryMethodListMap" ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap GGS_overridingCategoryMethodListMap::
_operator_concat (const GGS_overridingCategoryMethodListMap & inOperand) const {
  GGS_overridingCategoryMethodListMap result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodListMap::
_dotAssign_operation (const GGS_overridingCategoryMethodListMap inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const sint32 objectCount = dictPtr->count () ;
      for (sint32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = _findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * elementPtr = NULL ;
           macroMyNew (elementPtr, cElement (HERE)) ;
           nodePtr->mObject._setPointer (elementPtr) ;
        }
        GGS_overridingCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr._dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodListMap::
_addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterList & inAttribute1,
                      const GGS_semanticInstructionList & inAttribute2) {
  if (_isBuilt () && inKey._isBuilt () && inAttribute0._isBuilt () && inAttribute1._isBuilt () && inAttribute2._isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = _findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * elementPtr = NULL ;
       macroMyNew (elementPtr, cElement (HERE)) ;
       nodePtr->mObject._setPointer (elementPtr) ;
    }
    GGS_overridingCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr._addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingCategoryMethodList result ;
  if (_isBuilt () && inKey._isBuilt ()) {
    cPtrDictionaryNode * nodePtr = _dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingCategoryMethodList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingCategoryMethodListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result._setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingCategoryMethodListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (_isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const sint32 objectCount = dictPtr->count () ;
    for (sint32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result._addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap::cEnumerator::
cEnumerator (const GGS_overridingCategoryMethodListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingCategoryMethodList & GGS_overridingCategoryMethodListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of 'semanticDeclarationStruct' struct            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticDeclarationStruct::GGS_semanticDeclarationStruct (void) :
mSemanticDeclarationList (),
mAbstractCategoryMethodListMap (),
mCategoryMethodListMap (),
mOverridingCategoryMethodListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStruct::~GGS_semanticDeclarationStruct (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationStruct::_drop (void) {
  mSemanticDeclarationList._drop () ;
  mAbstractCategoryMethodListMap._drop () ;
  mCategoryMethodListMap._drop () ;
  mOverridingCategoryMethodListMap._drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticDeclarationStruct::_isBuilt (void) const {
  return mSemanticDeclarationList._isBuilt ()
    && mAbstractCategoryMethodListMap._isBuilt ()
    && mCategoryMethodListMap._isBuilt ()
    && mOverridingCategoryMethodListMap._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStruct::
_operator_isEqual (const GGS_semanticDeclarationStruct & inOperand) const {
  return mSemanticDeclarationList._operator_isEqual (inOperand.mSemanticDeclarationList)
    ._operator_and (mAbstractCategoryMethodListMap._operator_isEqual (inOperand.mAbstractCategoryMethodListMap))
    ._operator_and (mCategoryMethodListMap._operator_isEqual (inOperand.mCategoryMethodListMap))
    ._operator_and (mOverridingCategoryMethodListMap._operator_isEqual (inOperand.mOverridingCategoryMethodListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStruct::
_operator_isNotEqual (const GGS_semanticDeclarationStruct & inOperand) const {
  return mSemanticDeclarationList._operator_isNotEqual (inOperand.mSemanticDeclarationList)
    ._operator_or (mAbstractCategoryMethodListMap._operator_isNotEqual (inOperand.mAbstractCategoryMethodListMap))
    ._operator_or (mCategoryMethodListMap._operator_isNotEqual (inOperand.mCategoryMethodListMap))
    ._operator_or (mOverridingCategoryMethodListMap._operator_isNotEqual (inOperand.mOverridingCategoryMethodListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStruct GGS_semanticDeclarationStruct::
constructor_new (const GGS_semanticDeclarationList & argument_0,
                 const GGS_abstractCategoryMethodListMap& argument_1,
                 const GGS_categoryMethodListMap& argument_2,
                 const GGS_overridingCategoryMethodListMap& argument_3) {
  GGS_semanticDeclarationStruct result ;
  result.mSemanticDeclarationList = argument_0 ;
  result.mAbstractCategoryMethodListMap = argument_1 ;
  result.mCategoryMethodListMap = argument_2 ;
  result.mOverridingCategoryMethodListMap = argument_3 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationStruct::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticDeclarationStruct" ;
  if (_isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mSemanticDeclarationList " ;
    _s << mSemanticDeclarationList.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryMethodListMap " ;
    _s << mAbstractCategoryMethodListMap.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodListMap " ;
    _s << mCategoryMethodListMap.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryMethodListMap " ;
    _s << mOverridingCategoryMethodListMap.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

