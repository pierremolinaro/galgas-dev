//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'instructionMetamodel.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 9th, 2009, at 16h27'51"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "instructionMetamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "instructionMetamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_syntaxInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstruction::
cPtr_syntaxInstruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstruction * GGS_syntaxInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_syntaxInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@syntaxInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstruction (& typeid (cPtr_syntaxInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_syntaxInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__syntaxInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_syntaxInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxInstruction::
GGS_syntaxInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstruction::
GGS_syntaxInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_syntaxInstruction GGS_syntaxInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_syntaxInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstruction::actualTypeName (void) const {
  return "syntaxInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_syntaxInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__syntaxInstruction ("syntaxInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_semanticInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstruction::
cPtr_semanticInstruction (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstruction (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstruction * GGS_semanticInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@semanticInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstruction (& typeid (cPtr_semanticInstruction), & typeid (cPtr_syntaxInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_semanticInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticInstruction::
GGS_semanticInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstruction::
GGS_semanticInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticInstruction GGS_semanticInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstruction::actualTypeName (void) const {
  return "semanticInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__semanticInstruction ("semanticInstruction", gClassInfoFor__syntaxInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticInstructionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionList::
elementOf_GGS_semanticInstructionList (const GGS_semanticInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionList * ptr = dynamic_cast <const elementOf_GGS_semanticInstructionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalAppendValues (const GGS_semanticInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_internalPrependValues (const GGS_semanticInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
addAssign_operation (const GGS_semanticInstruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
operator_concat (const GGS_semanticInstructionList & inOperand) const {
  GGS_semanticInstructionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
dotAssign_operation (const GGS_semanticInstructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_semanticInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_emptyList (void) {
  GGS_semanticInstructionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_semanticInstructionList::
constructor_listWithValue (const GGS_semanticInstruction & argument_0) {
  GGS_semanticInstructionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
internalSubListWithRange (GGS_semanticInstructionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList GGS_semanticInstructionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@semanticInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_first (C_Compiler & inLexique,
              GGS_semanticInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
method_last (C_Compiler & inLexique,
             GGS_semanticInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstruction  GGS_semanticInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstruction  & GGS_semanticInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_semanticDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclaration::
cPtr_semanticDeclaration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclaration * GGS_semanticDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclaration::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@semanticDeclaration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclaration (& typeid (cPtr_semanticDeclaration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_semanticDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticDeclaration::
GGS_semanticDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclaration::
GGS_semanticDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclaration GGS_semanticDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclaration::actualTypeName (void) const {
  return "semanticDeclaration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_semanticDeclaration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__semanticDeclaration ("semanticDeclaration") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationList::
elementOf_GGS_semanticDeclarationList (const GGS_semanticDeclaration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSemanticDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationList * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_internalAppendValues (const GGS_semanticDeclaration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_internalPrependValues (const GGS_semanticDeclaration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
addAssign_operation (const GGS_semanticDeclaration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
operator_concat (const GGS_semanticDeclarationList & inOperand) const {
  GGS_semanticDeclarationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
dotAssign_operation (const GGS_semanticDeclarationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_semanticDeclarationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclaration  p_0 = p->mSemanticDeclaration ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclaration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSemanticDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticDeclarationList::
constructor_emptyList (void) {
  GGS_semanticDeclarationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticDeclarationList::
constructor_listWithValue (const GGS_semanticDeclaration & argument_0) {
  GGS_semanticDeclarationList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
internalSubListWithRange (GGS_semanticDeclarationList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@semanticDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
method_first (C_Compiler & inLexique,
              GGS_semanticDeclaration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
method_last (C_Compiler & inLexique,
             GGS_semanticDeclaration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticDeclaration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticDeclaration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclaration  GGS_semanticDeclarationList::
reader_mSemanticDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclaration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSemanticDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_setMSemanticDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclaration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSemanticDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclaration  & GGS_semanticDeclarationList::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_externRoutineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclaration::
cPtr_externRoutineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mRoutineName (argument_0),
mFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclaration * GGS_externRoutineDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_externRoutineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externRoutineDeclaration * ptr = dynamic_cast <const cPtr_externRoutineDeclaration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclaration::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@externRoutineDeclaration:"
           << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externRoutineDeclaration (& typeid (cPtr_externRoutineDeclaration), & typeid (cPtr_semanticDeclaration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_externRoutineDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__externRoutineDeclaration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externRoutineDeclaration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externRoutineDeclaration (mRoutineName, mFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_externRoutineDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration::
GGS_externRoutineDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration::
GGS_externRoutineDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externRoutineDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_externRoutineDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externRoutineDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externRoutineDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclaration GGS_externRoutineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclaration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_externRoutineDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclaration::actualTypeName (void) const {
  return "externRoutineDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__externRoutineDeclaration ("externRoutineDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_routinePrototypeDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routinePrototypeDeclaration::
cPtr_routinePrototypeDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_externRoutineDeclaration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routinePrototypeDeclaration * GGS_routinePrototypeDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routinePrototypeDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routinePrototypeDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routinePrototypeDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routinePrototypeDeclaration * ptr = dynamic_cast <const cPtr_routinePrototypeDeclaration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routinePrototypeDeclaration::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routinePrototypeDeclaration:"
           << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routinePrototypeDeclaration (& typeid (cPtr_routinePrototypeDeclaration), & typeid (cPtr_externRoutineDeclaration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_routinePrototypeDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__routinePrototypeDeclaration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routinePrototypeDeclaration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routinePrototypeDeclaration (mRoutineName, mFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_routinePrototypeDeclaration'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclaration::
GGS_routinePrototypeDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclaration::
GGS_routinePrototypeDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routinePrototypeDeclaration GGS_routinePrototypeDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routinePrototypeDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_routinePrototypeDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routinePrototypeDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routinePrototypeDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclaration GGS_routinePrototypeDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclaration result ;
  macroMyNew (result.mPointer, cPtr_routinePrototypeDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routinePrototypeDeclaration::actualTypeName (void) const {
  return "routinePrototypeDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__routinePrototypeDeclaration ("routinePrototypeDeclaration", gClassInfoFor__externRoutineDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_routineDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclaration::
cPtr_routineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_routinePrototypeDeclaration (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclaration * GGS_routineDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routineDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineDeclaration * ptr = dynamic_cast <const cPtr_routineDeclaration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclaration::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routineDeclaration:"
           << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRoutineInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineDeclaration (& typeid (cPtr_routineDeclaration), & typeid (cPtr_routinePrototypeDeclaration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_routineDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__routineDeclaration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineDeclaration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineDeclaration (mRoutineName, mFormalParameterList, mRoutineInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_routineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDeclaration::
GGS_routineDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclaration::
GGS_routineDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineDeclaration GGS_routineDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_routineDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclaration GGS_routineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_routineDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_routineDeclaration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclaration::actualTypeName (void) const {
  return "routineDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__routineDeclaration ("routineDeclaration", gClassInfoFor__routinePrototypeDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_externFunctionDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externFunctionDeclaration::
cPtr_externFunctionDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mFunctionName (argument_0),
mFormalParameterList (argument_1),
mResultTypeName (argument_2),
mResultVariableName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externFunctionDeclaration * GGS_externFunctionDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_externFunctionDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externFunctionDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externFunctionDeclaration * ptr = dynamic_cast <const cPtr_externFunctionDeclaration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externFunctionDeclaration::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@externFunctionDeclaration:"
           << mFunctionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mResultTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mResultVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externFunctionDeclaration (& typeid (cPtr_externFunctionDeclaration), & typeid (cPtr_semanticDeclaration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_externFunctionDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__externFunctionDeclaration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externFunctionDeclaration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externFunctionDeclaration (mFunctionName, mFormalParameterList, mResultTypeName, mResultVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_externFunctionDeclaration'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_externFunctionDeclaration::
GGS_externFunctionDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclaration::
GGS_externFunctionDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externFunctionDeclaration GGS_externFunctionDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externFunctionDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_externFunctionDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externFunctionDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externFunctionDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclaration GGS_externFunctionDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclaration result ;
  macroMyNew (result.mPointer, cPtr_externFunctionDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclaration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_externFunctionDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclaration::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclaration::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclaration *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externFunctionDeclaration::actualTypeName (void) const {
  return "externFunctionDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__externFunctionDeclaration ("externFunctionDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_functionDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionDeclaration::
cPtr_functionDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_externFunctionDeclaration (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
mFunctionInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionDeclaration * GGS_functionDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_functionDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionDeclaration * ptr = dynamic_cast <const cPtr_functionDeclaration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionDeclaration::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@functionDeclaration:"
           << mFunctionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mResultTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mResultVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFunctionInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionDeclaration (& typeid (cPtr_functionDeclaration), & typeid (cPtr_externFunctionDeclaration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_functionDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__functionDeclaration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionDeclaration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionDeclaration (mFunctionName, mFormalParameterList, mResultTypeName, mResultVariableName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_functionDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_functionDeclaration::
GGS_functionDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclaration::
GGS_functionDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionDeclaration GGS_functionDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_functionDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclaration GGS_functionDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_functionDeclaration result ;
  macroMyNew (result.mPointer, cPtr_functionDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_functionDeclaration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclaration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionDeclaration::actualTypeName (void) const {
  return "functionDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__functionDeclaration ("functionDeclaration", gClassInfoFor__externFunctionDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_localVariableDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclaration::
cPtr_localVariableDeclaration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclaration * GGS_localVariableDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclaration * ptr = dynamic_cast <const cPtr_localVariableDeclaration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclaration::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclaration:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclaration (& typeid (cPtr_localVariableDeclaration), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localVariableDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclaration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclaration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclaration (mStartLocation, mTypeName, mVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_localVariableDeclaration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclaration::
GGS_localVariableDeclaration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclaration::
GGS_localVariableDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclaration GGS_localVariableDeclaration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclaration GGS_localVariableDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclaration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclaration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclaration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclaration::actualTypeName (void) const {
  return "localVariableDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localVariableDeclaration ("localVariableDeclaration", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         class 'cPtr_localVariableDeclarationWithInitialization'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitialization::
cPtr_localVariableDeclarationWithInitialization (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_outExpressionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitialization * GGS_localVariableDeclarationWithInitialization::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclarationWithInitialization *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitialization::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithInitialization * ptr = dynamic_cast <const cPtr_localVariableDeclarationWithInitialization *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitialization::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclarationWithInitialization:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitialization::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithInitialization (& typeid (cPtr_localVariableDeclarationWithInitialization), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localVariableDeclarationWithInitialization::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithInitialization ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationWithInitialization::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationWithInitialization (mStartLocation, mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_localVariableDeclarationWithInitialization'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization::
GGS_localVariableDeclarationWithInitialization (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization::
GGS_localVariableDeclarationWithInitialization (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithInitialization) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationWithInitialization (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithInitialization),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitialization GGS_localVariableDeclarationWithInitialization::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_outExpressionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitialization result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitialization (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_localVariableDeclarationWithInitialization::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitialization *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitialization *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitialization::actualTypeName (void) const {
  return "localVariableDeclarationWithInitialization" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localVariableDeclarationWithInitialization ("localVariableDeclarationWithInitialization", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_localVariableDeclarationWithAssignment'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithAssignment::
cPtr_localVariableDeclarationWithAssignment (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithAssignment * GGS_localVariableDeclarationWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localVariableDeclarationWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithAssignment::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithAssignment * ptr = dynamic_cast <const cPtr_localVariableDeclarationWithAssignment *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithAssignment::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localVariableDeclarationWithAssignment:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignment::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithAssignment (& typeid (cPtr_localVariableDeclarationWithAssignment), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localVariableDeclarationWithAssignment::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithAssignment ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationWithAssignment::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationWithAssignment (mStartLocation, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_localVariableDeclarationWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment::
GGS_localVariableDeclarationWithAssignment (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment::
GGS_localVariableDeclarationWithAssignment (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithAssignment) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationWithAssignment (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithAssignment),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignment GGS_localVariableDeclarationWithAssignment::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithAssignment (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignment::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_localVariableDeclarationWithAssignment::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithAssignment::actualTypeName (void) const {
  return "localVariableDeclarationWithAssignment" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localVariableDeclarationWithAssignment ("localVariableDeclarationWithAssignment", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_localConstantDeclarationWithSourceExpression'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localConstantDeclarationWithSourceExpression::
cPtr_localConstantDeclarationWithSourceExpression (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localConstantDeclarationWithSourceExpression * GGS_localConstantDeclarationWithSourceExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localConstantDeclarationWithSourceExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localConstantDeclarationWithSourceExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localConstantDeclarationWithSourceExpression * ptr = dynamic_cast <const cPtr_localConstantDeclarationWithSourceExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localConstantDeclarationWithSourceExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localConstantDeclarationWithSourceExpression:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithSourceExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithSourceExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localConstantDeclarationWithSourceExpression (& typeid (cPtr_localConstantDeclarationWithSourceExpression), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localConstantDeclarationWithSourceExpression::galgasRTTI (void) const {
  return & gClassInfoFor__localConstantDeclarationWithSourceExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localConstantDeclarationWithSourceExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localConstantDeclarationWithSourceExpression (mStartLocation, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_localConstantDeclarationWithSourceExpression'       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpression::
GGS_localConstantDeclarationWithSourceExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpression::
GGS_localConstantDeclarationWithSourceExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localConstantDeclarationWithSourceExpression GGS_localConstantDeclarationWithSourceExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpression *> (inPointer) != NULL)
      : (typeid (cPtr_localConstantDeclarationWithSourceExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localConstantDeclarationWithSourceExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localConstantDeclarationWithSourceExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpression GGS_localConstantDeclarationWithSourceExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpression result ;
  macroMyNew (result.mPointer, cPtr_localConstantDeclarationWithSourceExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithSourceExpression::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpression *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithSourceExpression::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpression *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_localConstantDeclarationWithSourceExpression::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpression *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localConstantDeclarationWithSourceExpression::actualTypeName (void) const {
  return "localConstantDeclarationWithSourceExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localConstantDeclarationWithSourceExpression ("localConstantDeclarationWithSourceExpression", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         class 'cPtr_localConstantDeclarationWithConstructorCall'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localConstantDeclarationWithConstructorCall::
cPtr_localConstantDeclarationWithConstructorCall (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_outExpressionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localConstantDeclarationWithConstructorCall * GGS_localConstantDeclarationWithConstructorCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_localConstantDeclarationWithConstructorCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localConstantDeclarationWithConstructorCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localConstantDeclarationWithConstructorCall * ptr = dynamic_cast <const cPtr_localConstantDeclarationWithConstructorCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localConstantDeclarationWithConstructorCall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@localConstantDeclarationWithConstructorCall:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithConstructorCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithConstructorCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localConstantDeclarationWithConstructorCall (& typeid (cPtr_localConstantDeclarationWithConstructorCall), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_localConstantDeclarationWithConstructorCall::galgasRTTI (void) const {
  return & gClassInfoFor__localConstantDeclarationWithConstructorCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localConstantDeclarationWithConstructorCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localConstantDeclarationWithConstructorCall (mStartLocation, mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_localConstantDeclarationWithConstructorCall'       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCall::
GGS_localConstantDeclarationWithConstructorCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCall::
GGS_localConstantDeclarationWithConstructorCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localConstantDeclarationWithConstructorCall GGS_localConstantDeclarationWithConstructorCall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCall *> (inPointer) != NULL)
      : (typeid (cPtr_localConstantDeclarationWithConstructorCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localConstantDeclarationWithConstructorCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localConstantDeclarationWithConstructorCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCall GGS_localConstantDeclarationWithConstructorCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_outExpressionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCall result ;
  macroMyNew (result.mPointer, cPtr_localConstantDeclarationWithConstructorCall (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCall::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCall *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCall::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCall *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCall::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCall *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_localConstantDeclarationWithConstructorCall::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCall *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localConstantDeclarationWithConstructorCall::actualTypeName (void) const {
  return "localConstantDeclarationWithConstructorCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__localConstantDeclarationWithConstructorCall ("localConstantDeclarationWithConstructorCall", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_assignmentInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstruction::
cPtr_assignmentInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstruction * GGS_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstruction * ptr = dynamic_cast <const cPtr_assignmentInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@assignmentInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstruction (& typeid (cPtr_assignmentInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_assignmentInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_assignmentInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_assignmentInstruction (mStartLocation, mTargetVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_assignmentInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_assignmentInstruction::
GGS_assignmentInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstruction::
GGS_assignmentInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_assignmentInstruction GGS_assignmentInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_assignmentInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstruction GGS_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstruction::actualTypeName (void) const {
  return "assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__assignmentInstruction ("assignmentInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_appendInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstruction::
cPtr_appendInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstruction * GGS_appendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_appendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstruction * ptr = dynamic_cast <const cPtr_appendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@appendInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstruction (& typeid (cPtr_appendInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_appendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_appendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_appendInstruction (mStartLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_appendInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_appendInstruction::
GGS_appendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstruction::
GGS_appendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_appendInstruction GGS_appendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_appendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstruction GGS_appendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstruction result ;
  macroMyNew (result.mPointer, cPtr_appendInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstruction::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_appendInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstruction::actualTypeName (void) const {
  return "appendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__appendInstruction ("appendInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_sendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sendInstruction::
cPtr_sendInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sendInstruction * GGS_sendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sendInstruction * ptr = dynamic_cast <const cPtr_sendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sendInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sendInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sendInstruction (& typeid (cPtr_sendInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__sendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sendInstruction (mStartLocation, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_sendInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sendInstruction::
GGS_sendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sendInstruction::
GGS_sendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sendInstruction GGS_sendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_sendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstruction GGS_sendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sendInstruction result ;
  macroMyNew (result.mPointer, cPtr_sendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_sendInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sendInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sendInstruction::actualTypeName (void) const {
  return "sendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sendInstruction ("sendInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_foreachInstructionEnumeratedObjectElement'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObjectElement::
cPtr_foreachInstructionEnumeratedObjectElement (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObjectElement * GGS_foreachInstructionEnumeratedObjectElement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionEnumeratedObjectElement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObjectElement::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionEnumeratedObjectElement:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedObjectElement (& typeid (cPtr_foreachInstructionEnumeratedObjectElement), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstructionEnumeratedObjectElement::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedObjectElement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_foreachInstructionEnumeratedObjectElement'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement::
GGS_foreachInstructionEnumeratedObjectElement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement::
GGS_foreachInstructionEnumeratedObjectElement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedObjectElement GGS_foreachInstructionEnumeratedObjectElement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElement *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedObjectElement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionEnumeratedObjectElement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedObjectElement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObjectElement::actualTypeName (void) const {
  return "foreachInstructionEnumeratedObjectElement" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_foreachInstructionEnumeratedObjectElement::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__foreachInstructionEnumeratedObjectElement ("foreachInstructionEnumeratedObjectElement") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_foreachInstructionJoker'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionJoker::
cPtr_foreachInstructionJoker (LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElement (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionJoker * GGS_foreachInstructionJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionJoker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionJoker::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJoker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionJoker (& typeid (cPtr_foreachInstructionJoker), & typeid (cPtr_foreachInstructionEnumeratedObjectElement), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstructionJoker::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionJoker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_foreachInstructionJoker'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker::
GGS_foreachInstructionJoker (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker::
GGS_foreachInstructionJoker (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionJoker *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionJoker) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionJoker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionJoker),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_foreachInstructionJoker * gSingleton_foreachInstructionJoker = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_foreachInstructionJoker (void) {
  macroDetachPointer (gSingleton_foreachInstructionJoker, cPtr_foreachInstructionJoker) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJoker GGS_foreachInstructionJoker::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJoker result ;
  if (NULL == gSingleton_foreachInstructionJoker) {
    macroMyNew (gSingleton_foreachInstructionJoker, cPtr_foreachInstructionJoker (THERE)) ;
    registerReleaseRoutine (cleanUp_foreachInstructionJoker) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_foreachInstructionJoker) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionJoker::actualTypeName (void) const {
  return "foreachInstructionJoker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__foreachInstructionJoker ("foreachInstructionJoker", gClassInfoFor__foreachInstructionEnumeratedObjectElement) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_foreachInstructionEnumeratedConstant'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedConstant::
cPtr_foreachInstructionEnumeratedConstant (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElement (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedConstant * GGS_foreachInstructionEnumeratedConstant::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstructionEnumeratedConstant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedConstant::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionEnumeratedConstant * ptr = dynamic_cast <const cPtr_foreachInstructionEnumeratedConstant *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedConstant::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@foreachInstructionEnumeratedConstant:"
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstantName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstant::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedConstant (& typeid (cPtr_foreachInstructionEnumeratedConstant), & typeid (cPtr_foreachInstructionEnumeratedObjectElement), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstructionEnumeratedConstant::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedConstant ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionEnumeratedConstant::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionEnumeratedConstant (mTypeName, mConstantName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_foreachInstructionEnumeratedConstant'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant::
GGS_foreachInstructionEnumeratedConstant (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant::
GGS_foreachInstructionEnumeratedConstant (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedConstant) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionEnumeratedConstant (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedConstant),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstant GGS_foreachInstructionEnumeratedConstant::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstant result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedConstant (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstant::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstant *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedConstant::actualTypeName (void) const {
  return "foreachInstructionEnumeratedConstant" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__foreachInstructionEnumeratedConstant ("foreachInstructionEnumeratedConstant", gClassInfoFor__foreachInstructionEnumeratedObjectElement) ;

//---------------------------------------------------------------------------*
//                                                                           *
//     Element of list '@foreachInstructionEnumeratedObjectElementList'      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
elementOf_GGS_foreachInstructionEnumeratedObjectElementList (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectElementList * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectElementList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElement.operator_isEqual (ptr->mElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectElementList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElement.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          List '@foreachInstructionEnumeratedObjectElementList'            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_internalAppendValues (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_internalPrependValues (const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
addAssign_operation (const GGS_foreachInstructionEnumeratedObjectElement & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
operator_concat (const GGS_foreachInstructionEnumeratedObjectElementList & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectElementList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectElementList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_foreachInstructionEnumeratedObjectElement  p_0 = p->mElement ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_foreachInstructionEnumeratedObjectElement & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mElement
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectElementList::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectElementList::
constructor_listWithValue (const GGS_foreachInstructionEnumeratedObjectElement & argument_0) {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectElementList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mElement) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList GGS_foreachInstructionEnumeratedObjectElementList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectElementList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@foreachInstructionEnumeratedObjectElementList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
method_first (C_Compiler & inLexique,
              GGS_foreachInstructionEnumeratedObjectElement & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
method_last (C_Compiler & inLexique,
             GGS_foreachInstructionEnumeratedObjectElement & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_foreachInstructionEnumeratedObjectElement & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_popLast (C_Compiler & inLexique,
                GGS_foreachInstructionEnumeratedObjectElement & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElement  GGS_foreachInstructionEnumeratedObjectElementList::
reader_mElementAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElement  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElement ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementList::
modifier_setMElementAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElement  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElement = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElement  & GGS_foreachInstructionEnumeratedObjectElementList::cEnumerator::_mElement (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@foreachInstructionEnumeratedObjectList'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectList::
elementOf_GGS_foreachInstructionEnumeratedObjectList (const GGS_bool& argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIsAscending (argument_0),
mEnumeratedExpression (argument_1),
mElementList (argument_2),
mEndsWithEllipsis (argument_3),
mPrefix (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectList * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mEnumeratedExpression.operator_isEqual (ptr->mEnumeratedExpression).boolValue ()
         && mElementList.operator_isEqual (ptr->mElementList).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAscending.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElementList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPrefix.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@foreachInstructionEnumeratedObjectList'               *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_foreachInstructionEnumeratedObjectElementList & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_foreachInstructionEnumeratedObjectElementList & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
operator_concat (const GGS_foreachInstructionEnumeratedObjectList & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAscending ;
          GGS_semanticExpression  p_1 = p->mEnumeratedExpression ;
          GGS_foreachInstructionEnumeratedObjectElementList  p_2 = p->mElementList ;
          GGS_bool p_3 = p->mEndsWithEllipsis ;
          GGS_lstring  p_4 = p->mPrefix ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_foreachInstructionEnumeratedObjectElementList & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_lstring & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mIsAscending,
                                ptr->mEnumeratedExpression,
                                ptr->mElementList,
                                ptr->mEndsWithEllipsis,
                                ptr->mPrefix
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstructionEnumeratedObjectList::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstructionEnumeratedObjectList::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  GGS_foreachInstructionEnumeratedObjectList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsAscending, ptr->mEnumeratedExpression, ptr->mElementList, ptr->mEndsWithEllipsis, ptr->mPrefix) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList GGS_foreachInstructionEnumeratedObjectList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@foreachInstructionEnumeratedObjectList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_semanticExpression & _out_1,
              GGS_foreachInstructionEnumeratedObjectElementList & _out_2,
              GGS_bool& _out_3,
              GGS_lstring & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_semanticExpression & _out_1,
             GGS_foreachInstructionEnumeratedObjectElementList & _out_2,
             GGS_bool& _out_3,
             GGS_lstring & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_semanticExpression & _out_1,
                 GGS_foreachInstructionEnumeratedObjectElementList & _out_2,
                 GGS_bool& _out_3,
                 GGS_lstring & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_semanticExpression & _out_1,
                GGS_foreachInstructionEnumeratedObjectElementList & _out_2,
                GGS_bool& _out_3,
                GGS_lstring & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectList::
reader_mIsAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstructionEnumeratedObjectList::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_foreachInstructionEnumeratedObjectList::
reader_mElementListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElementList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectList::
reader_mEndsWithEllipsisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndsWithEllipsis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedObjectList::
reader_mPrefixAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPrefix ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMIsAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMElementListAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElementList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMEndsWithEllipsisAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndsWithEllipsis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectList::
modifier_setMPrefixAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPrefix = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mIsAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsAscending ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpression  & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementList  & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mElementList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElementList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mEndsWithEllipsis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndsWithEllipsis ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_foreachInstructionEnumeratedObjectList::cEnumerator::_mPrefix (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mPrefix ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_foreachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstruction::
cPtr_foreachInstruction (const GGS_location & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpression & argument_3,
                                const GGS_semanticInstructionList & argument_4,
                                const GGS_semanticInstructionList & argument_5,
                                const GGS_semanticInstructionList & argument_6,
                                const GGS_semanticInstructionList & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mEnumeratedObjectList (argument_1),
mIndexVariableName (argument_2),
mWhileExpression (argument_3),
mBeforeInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mDoInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstruction * GGS_foreachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_foreachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstruction * ptr = dynamic_cast <const cPtr_foreachInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mEnumeratedObjectList.operator_isEqual (ptr->mEnumeratedObjectList).boolValue ()
         && mIndexVariableName.operator_isEqual (ptr->mIndexVariableName).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@foreachInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEnumeratedObjectList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIndexVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBeforeInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBetweenInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDoInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAfterInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstruction (& typeid (cPtr_foreachInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_foreachInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstruction (mStartLocation, mEnumeratedObjectList, mIndexVariableName, mWhileExpression, mBeforeInstructionList, mBetweenInstructionList, mDoInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_foreachInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachInstruction::
GGS_foreachInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstruction::
GGS_foreachInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstruction GGS_foreachInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstruction GGS_foreachInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpression & argument_3,
                 const GGS_semanticInstructionList & argument_4,
                 const GGS_semanticInstructionList & argument_5,
                 const GGS_semanticInstructionList & argument_6,
                 const GGS_semanticInstructionList & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstruction result ;
  macroMyNew (result.mPointer, cPtr_foreachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectList  GGS_foreachInstruction::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstruction::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_foreachInstruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_foreachInstruction::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstruction::actualTypeName (void) const {
  return "foreachInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__foreachInstruction ("foreachInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ifBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ifBranchList::
elementOf_GGS_ifBranchList (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mIFinstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ifBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ifBranchList * ptr = dynamic_cast <const elementOf_GGS_ifBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && mIFinstructionList.operator_isEqual (ptr->mIFinstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ifBranchList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFinstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@ifBranchList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
addAssign_operation (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
operator_concat (const GGS_ifBranchList & inOperand) const {
  GGS_ifBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
dotAssign_operation (const GGS_ifBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ifBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mIFexpression ;
          GGS_semanticInstructionList  p_1 = p->mIFinstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mIFexpression,
                                ptr->mIFinstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifBranchList::
constructor_emptyList (void) {
  GGS_ifBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifBranchList::
constructor_listWithValue (const GGS_semanticExpression & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  GGS_ifBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
internalSubListWithRange (GGS_ifBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIFexpression, ptr->mIFinstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList GGS_ifBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ifBranchList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@ifBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
method_first (C_Compiler & inLexique,
              GGS_semanticExpression & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
method_last (C_Compiler & inLexique,
             GGS_semanticExpression & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpression & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpression & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_ifBranchList::
reader_mIFexpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_ifBranchList::
reader_mIFinstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFinstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_setMIFexpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchList::
modifier_setMIFinstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFinstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpression  & GGS_ifBranchList::cEnumerator::_mIFexpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFexpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_ifBranchList::cEnumerator::_mIFinstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFinstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ifInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstruction::
cPtr_ifInstruction (const GGS_location & argument_0,
                                const GGS_ifBranchList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstruction * GGS_ifInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ifInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstruction * ptr = dynamic_cast <const cPtr_ifInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ifInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstruction (& typeid (cPtr_ifInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ifInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifInstruction (mStartLocation, mBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ifInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ifInstruction::
GGS_ifInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstruction::
GGS_ifInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifInstruction GGS_ifInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstruction GGS_ifInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ifBranchList & argument_1,
                 const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstruction result ;
  macroMyNew (result.mPointer, cPtr_ifInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchList  GGS_ifInstruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ifBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_ifInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstruction::actualTypeName (void) const {
  return "ifInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ifInstruction ("ifInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_methodCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstruction::
cPtr_methodCallInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstruction * GGS_methodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_methodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstruction * ptr = dynamic_cast <const cPtr_methodCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@methodCallInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstruction (& typeid (cPtr_methodCallInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_methodCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_methodCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_methodCallInstruction (mStartLocation, mReceiverExpression, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_methodCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_methodCallInstruction::
GGS_methodCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstruction::
GGS_methodCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_methodCallInstruction GGS_methodCallInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_methodCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstruction GGS_methodCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_methodCallInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_methodCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstruction::actualTypeName (void) const {
  return "methodCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__methodCallInstruction ("methodCallInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_modifierCallInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstruction::
cPtr_modifierCallInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_actualParameterList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mReceiverStructAttributes (argument_2),
mModifierName (argument_3),
mActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstruction * GGS_modifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_modifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstruction * ptr = dynamic_cast <const cPtr_modifierCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mReceiverStructAttributes.operator_isEqual (ptr->mReceiverStructAttributes).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@modifierCallInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverStructAttributes.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mModifierName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstruction (& typeid (cPtr_modifierCallInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_modifierCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_modifierCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_modifierCallInstruction (mStartLocation, mReceiverName, mReceiverStructAttributes, mModifierName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_modifierCallInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_modifierCallInstruction::
GGS_modifierCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstruction::
GGS_modifierCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_modifierCallInstruction GGS_modifierCallInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_modifierCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstruction GGS_modifierCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_actualParameterList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstruction::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstruction::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_modifierCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstruction::actualTypeName (void) const {
  return "modifierCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__modifierCallInstruction ("modifierCallInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_errorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstruction::
cPtr_errorInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mErrorExpression (argument_2),
mBuiltVariableList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstruction * GGS_errorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_errorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstruction * ptr = dynamic_cast <const cPtr_errorInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mErrorExpression.operator_isEqual (ptr->mErrorExpression).boolValue ()
         && mBuiltVariableList.operator_isEqual (ptr->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@errorInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mErrorExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBuiltVariableList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstruction (& typeid (cPtr_errorInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_errorInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_errorInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_errorInstruction (mStartLocation, mReceiverExpression, mErrorExpression, mBuiltVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_errorInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_errorInstruction::
GGS_errorInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstruction::
GGS_errorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_errorInstruction GGS_errorInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_errorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstruction GGS_errorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstruction result ;
  macroMyNew (result.mPointer, cPtr_errorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_errorInstruction::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstruction::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstruction *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstruction::actualTypeName (void) const {
  return "errorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__errorInstruction ("errorInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_warningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstruction::
cPtr_warningInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mWarningExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstruction * GGS_warningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_warningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstruction * ptr = dynamic_cast <const cPtr_warningInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mWarningExpression.operator_isEqual (ptr->mWarningExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@warningInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWarningExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstruction (& typeid (cPtr_warningInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_warningInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_warningInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_warningInstruction (mStartLocation, mReceiverExpression, mWarningExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_warningInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_warningInstruction::
GGS_warningInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstruction::
GGS_warningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_warningInstruction GGS_warningInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_warningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstruction GGS_warningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstruction result ;
  macroMyNew (result.mPointer, cPtr_warningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_warningInstruction::
reader_mWarningExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstruction *) mPointer)->mWarningExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstruction::actualTypeName (void) const {
  return "warningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__warningInstruction ("warningInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_routineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstruction::
cPtr_routineCallInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mRoutineName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstruction * GGS_routineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_routineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstruction * ptr = dynamic_cast <const cPtr_routineCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@routineCallInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstruction (& typeid (cPtr_routineCallInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_routineCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineCallInstruction (mStartLocation, mRoutineName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_routineCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineCallInstruction::
GGS_routineCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstruction::
GGS_routineCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineCallInstruction GGS_routineCallInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstruction GGS_routineCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_routineCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstruction::actualTypeName (void) const {
  return "routineCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__routineCallInstruction ("routineCallInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_matchEntry'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchEntry::
cPtr_matchEntry (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchEntry * GGS_matchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_matchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_matchEntry::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@matchEntry:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchEntry (& typeid (cPtr_matchEntry), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_matchEntry::galgasRTTI (void) const {
  return & gClassInfoFor__matchEntry ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_matchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchEntry::
GGS_matchEntry (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchEntry::
GGS_matchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchEntry GGS_matchEntry::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchEntry result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_matchEntry) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchEntry::actualTypeName (void) const {
  return "matchEntry" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_matchEntry::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__matchEntry ("matchEntry") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@matchEntryList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchEntryList::
elementOf_GGS_matchEntryList (const GGS_matchEntry & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntry (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchEntryList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchEntryList * ptr = dynamic_cast <const elementOf_GGS_matchEntryList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntry.operator_isEqual (ptr->mEntry).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchEntryList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntry.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@matchEntryList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_internalAppendValues (const GGS_matchEntry & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_internalPrependValues (const GGS_matchEntry & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
addAssign_operation (const GGS_matchEntry & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
operator_concat (const GGS_matchEntryList & inOperand) const {
  GGS_matchEntryList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
dotAssign_operation (const GGS_matchEntryList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_matchEntryList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntry  p_0 = p->mEntry ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntry & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mEntry
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchEntryList::
constructor_emptyList (void) {
  GGS_matchEntryList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchEntryList::
constructor_listWithValue (const GGS_matchEntry & argument_0) {
  GGS_matchEntryList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
internalSubListWithRange (GGS_matchEntryList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntry) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryList GGS_matchEntryList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchEntryList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@matchEntryList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
method_first (C_Compiler & inLexique,
              GGS_matchEntry & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
method_last (C_Compiler & inLexique,
             GGS_matchEntry & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntry & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntry & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntry  GGS_matchEntryList::
reader_mEntryAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntry  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntry ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryList::
modifier_setMEntryAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntry  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntry = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntry  & GGS_matchEntryList::cEnumerator::_mEntry (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntry ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_constantMatchEntry'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constantMatchEntry::
cPtr_constantMatchEntry (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntry (THERE),
mConstantName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constantMatchEntry * GGS_constantMatchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_constantMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constantMatchEntry::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constantMatchEntry * ptr = dynamic_cast <const cPtr_constantMatchEntry *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constantMatchEntry::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@constantMatchEntry:"
           << mConstantName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constantMatchEntry (& typeid (cPtr_constantMatchEntry), & typeid (cPtr_matchEntry), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_constantMatchEntry::galgasRTTI (void) const {
  return & gClassInfoFor__constantMatchEntry ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constantMatchEntry::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constantMatchEntry (mConstantName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_constantMatchEntry'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_constantMatchEntry::
GGS_constantMatchEntry (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntry::
GGS_constantMatchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constantMatchEntry GGS_constantMatchEntry::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constantMatchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_constantMatchEntry) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constantMatchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constantMatchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntry GGS_constantMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_constantMatchEntry (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantMatchEntry::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constantMatchEntry *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constantMatchEntry::actualTypeName (void) const {
  return "constantMatchEntry" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__constantMatchEntry ("constantMatchEntry", gClassInfoFor__matchEntry) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_classMatchEntry'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMatchEntry::
cPtr_classMatchEntry (const GGS_lstring & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntry (THERE),
mClassName (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMatchEntry * GGS_classMatchEntry::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classMatchEntry *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classMatchEntry::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classMatchEntry * ptr = dynamic_cast <const cPtr_classMatchEntry *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mElements.operator_isEqual (ptr->mElements).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMatchEntry::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classMatchEntry:"
           << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElements.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEndsWithEllipsis.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntry::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classMatchEntry (& typeid (cPtr_classMatchEntry), & typeid (cPtr_matchEntry), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_classMatchEntry::galgasRTTI (void) const {
  return & gClassInfoFor__classMatchEntry ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classMatchEntry::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classMatchEntry (mClassName, mElements, mEndsWithEllipsis COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classMatchEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMatchEntry::
GGS_classMatchEntry (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntry::
GGS_classMatchEntry (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classMatchEntry GGS_classMatchEntry::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classMatchEntry *> (inPointer) != NULL)
      : (typeid (cPtr_classMatchEntry) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classMatchEntry (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classMatchEntry),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntry GGS_classMatchEntry::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectElementList & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_classMatchEntry result ;
  macroMyNew (result.mPointer, cPtr_classMatchEntry (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMatchEntry::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementList  GGS_classMatchEntry::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMatchEntry::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntry *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntry *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMatchEntry::actualTypeName (void) const {
  return "classMatchEntry" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__classMatchEntry ("classMatchEntry", gClassInfoFor__matchEntry) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@matchInstructionBranchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchList::
elementOf_GGS_matchInstructionBranchList (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMatchEntryList (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchList * ptr = dynamic_cast <const elementOf_GGS_matchInstructionBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchEntryList.operator_isEqual (ptr->mMatchEntryList).boolValue ()
         && mMatchBranchInstructionList.operator_isEqual (ptr->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchEntryList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@matchInstructionBranchList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_internalAppendValues (const GGS_matchEntryList & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_internalPrependValues (const GGS_matchEntryList & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
addAssign_operation (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
operator_concat (const GGS_matchInstructionBranchList & inOperand) const {
  GGS_matchInstructionBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
dotAssign_operation (const GGS_matchInstructionBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_matchInstructionBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryList  p_0 = p->mMatchEntryList ;
          GGS_semanticInstructionList  p_1 = p->mMatchBranchInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryList & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mMatchEntryList,
                                ptr->mMatchBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstructionBranchList::
constructor_emptyList (void) {
  GGS_matchInstructionBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstructionBranchList::
constructor_listWithValue (const GGS_matchEntryList & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  GGS_matchInstructionBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
internalSubListWithRange (GGS_matchInstructionBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchEntryList, ptr->mMatchBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList GGS_matchInstructionBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@matchInstructionBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
method_first (C_Compiler & inLexique,
              GGS_matchEntryList & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
method_last (C_Compiler & inLexique,
             GGS_matchEntryList & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntryList & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntryList & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryList  GGS_matchInstructionBranchList::
reader_mMatchEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_matchInstructionBranchList::
reader_mMatchBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_setMMatchEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchList::
modifier_setMMatchBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryList  & GGS_matchInstructionBranchList::cEnumerator::_mMatchEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchEntryList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_matchInstructionBranchList::cEnumerator::_mMatchBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchBranchInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_matchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstruction::
cPtr_matchInstruction (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_matchInstructionBranchList & argument_2,
                                const GGS_semanticInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mMatchedVariableNameList (argument_1),
mMatchInstructionBranchList (argument_2),
mElseInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstruction * GGS_matchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_matchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstruction * ptr = dynamic_cast <const cPtr_matchInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mMatchedVariableNameList.operator_isEqual (ptr->mMatchedVariableNameList).boolValue ()
         && mMatchInstructionBranchList.operator_isEqual (ptr->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@matchInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMatchedVariableNameList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMatchInstructionBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstruction (& typeid (cPtr_matchInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_matchInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__matchInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_matchInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_matchInstruction (mStartLocation, mMatchedVariableNameList, mMatchInstructionBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_matchInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_matchInstruction::
GGS_matchInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstruction::
GGS_matchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchInstruction GGS_matchInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstruction GGS_matchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_matchInstructionBranchList & argument_2,
                 const GGS_semanticInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstruction result ;
  macroMyNew (result.mPointer, cPtr_matchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_matchInstruction::
reader_mMatchedVariableNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchedVariableNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchList  GGS_matchInstruction::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_matchInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstruction::actualTypeName (void) const {
  return "matchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__matchInstruction ("matchInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@castInstructionBranchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchList::
elementOf_GGS_castInstructionBranchList (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mCastBranchInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchList * ptr = dynamic_cast <const elementOf_GGS_castInstructionBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantVarName.operator_isEqual (ptr->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused.operator_isEqual (ptr->mConstantVarNameIsUnused).boolValue ()
         && mCastBranchInstructionList.operator_isEqual (ptr->mCastBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastBranchInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@castInstructionBranchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
operator_concat (const GGS_castInstructionBranchList & inOperand) const {
  GGS_castInstructionBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
dotAssign_operation (const GGS_castInstructionBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_castInstructionBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_lstring  p_1 = p->mTypeName ;
          GGS_lstring  p_2 = p->mConstantVarName ;
          GGS_bool p_3 = p->mConstantVarNameIsUnused ;
          GGS_semanticInstructionList  p_4 = p->mCastBranchInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_semanticInstructionList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mUseKindOfClass,
                                ptr->mTypeName,
                                ptr->mConstantVarName,
                                ptr->mConstantVarNameIsUnused,
                                ptr->mCastBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstructionBranchList::
constructor_emptyList (void) {
  GGS_castInstructionBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstructionBranchList::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  GGS_castInstructionBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
internalSubListWithRange (GGS_castInstructionBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mUseKindOfClass, ptr->mTypeName, ptr->mConstantVarName, ptr->mConstantVarNameIsUnused, ptr->mCastBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList GGS_castInstructionBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@castInstructionBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3,
              GGS_semanticInstructionList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3,
             GGS_semanticInstructionList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3,
                 GGS_semanticInstructionList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3,
                GGS_semanticInstructionList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchList::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchList::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchList::
reader_mConstantVarNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchList::
reader_mConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarNameIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_castInstructionBranchList::
reader_mCastBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMConstantVarNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarNameIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchList::
modifier_setMCastBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchList::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchList::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchList::cEnumerator::_mConstantVarName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchList::cEnumerator::_mConstantVarNameIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarNameIsUnused ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_castInstructionBranchList::cEnumerator::_mCastBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCastBranchInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_elseOrDefaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseOrDefaultForCastInstruction::
cPtr_elseOrDefaultForCastInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseOrDefaultForCastInstruction * GGS_elseOrDefaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseOrDefaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_elseOrDefaultForCastInstruction::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@elseOrDefaultForCastInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseOrDefaultForCastInstruction (& typeid (cPtr_elseOrDefaultForCastInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_elseOrDefaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__elseOrDefaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_elseOrDefaultForCastInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction::
GGS_elseOrDefaultForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction::
GGS_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_elseOrDefaultForCastInstruction GGS_elseOrDefaultForCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseOrDefaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_elseOrDefaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_elseOrDefaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseOrDefaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseOrDefaultForCastInstruction::actualTypeName (void) const {
  return "elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_elseOrDefaultForCastInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__elseOrDefaultForCastInstruction ("elseOrDefaultForCastInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_elseForCastInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseForCastInstruction::
cPtr_elseForCastInstruction (const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseForCastInstruction * GGS_elseForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_elseForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_elseForCastInstruction * ptr = dynamic_cast <const cPtr_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_elseForCastInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@elseForCastInstruction:"
           << mElseInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseForCastInstruction (& typeid (cPtr_elseForCastInstruction), & typeid (cPtr_elseOrDefaultForCastInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_elseForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__elseForCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_elseForCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_elseForCastInstruction (mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_elseForCastInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_elseForCastInstruction::
GGS_elseForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstruction::
GGS_elseForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_elseForCastInstruction GGS_elseForCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_elseForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_elseForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstruction GGS_elseForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_elseForCastInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseForCastInstruction::actualTypeName (void) const {
  return "elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__elseForCastInstruction ("elseForCastInstruction", gClassInfoFor__elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_defaultForCastInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_defaultForCastInstruction::
cPtr_defaultForCastInstruction (const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_defaultForCastInstruction * GGS_defaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_defaultForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_defaultForCastInstruction * ptr = dynamic_cast <const cPtr_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_defaultForCastInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@defaultForCastInstruction:"
           << mErrorLocationExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_defaultForCastInstruction (& typeid (cPtr_defaultForCastInstruction), & typeid (cPtr_elseOrDefaultForCastInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_defaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__defaultForCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_defaultForCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_defaultForCastInstruction (mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_defaultForCastInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction::
GGS_defaultForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction::
GGS_defaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_defaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_defaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_defaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_defaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstruction GGS_defaultForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_defaultForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_defaultForCastInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_defaultForCastInstruction::actualTypeName (void) const {
  return "defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__defaultForCastInstruction ("defaultForCastInstruction", gClassInfoFor__elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_castInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstruction::
cPtr_castInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_castInstructionBranchList & argument_2,
                                const GGS_elseOrDefaultForCastInstruction & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mExpression (argument_1),
mCastInstructionBranchList (argument_2),
mElseOrDefault (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstruction * GGS_castInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_castInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInstruction * ptr = dynamic_cast <const cPtr_castInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mCastInstructionBranchList.operator_isEqual (ptr->mCastInstructionBranchList).boolValue ()
         && mElseOrDefault.operator_isEqual (ptr->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@castInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCastInstructionBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseOrDefault.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInstruction (& typeid (cPtr_castInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_castInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__castInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInstruction (mStartLocation, mExpression, mCastInstructionBranchList, mElseOrDefault COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_castInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInstruction::
GGS_castInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInstruction::
GGS_castInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInstruction GGS_castInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_castInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstruction GGS_castInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_castInstructionBranchList & argument_2,
                 const GGS_elseOrDefaultForCastInstruction & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInstruction result ;
  macroMyNew (result.mPointer, cPtr_castInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchList  GGS_castInstruction::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstruction  GGS_castInstruction::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstruction::actualTypeName (void) const {
  return "castInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__castInstruction ("castInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_addInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstruction::
cPtr_addInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstruction * GGS_addInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_addInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addInstruction * ptr = dynamic_cast <const cPtr_addInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@addInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addInstruction (& typeid (cPtr_addInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_addInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__addInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addInstruction (mStartLocation, mReceiverName, mStructAttributeList, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_addInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_addInstruction::
GGS_addInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addInstruction::
GGS_addInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addInstruction GGS_addInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_addInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstruction GGS_addInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_outExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_addInstruction result ;
  macroMyNew (result.mPointer, cPtr_addInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_addInstruction::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstruction *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstruction::actualTypeName (void) const {
  return "addInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__addInstruction ("addInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_removeInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_removeInstruction::
cPtr_removeInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_removeInstruction * GGS_removeInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_removeInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_removeInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_removeInstruction * ptr = dynamic_cast <const cPtr_removeInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_removeInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@removeInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_removeInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_removeInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_removeInstruction (& typeid (cPtr_removeInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_removeInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__removeInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_removeInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_removeInstruction (mStartLocation, mReceiverName, mStructAttributeList, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_removeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_removeInstruction::
GGS_removeInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_removeInstruction::
GGS_removeInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_removeInstruction GGS_removeInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_removeInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_removeInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_removeInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_removeInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_removeInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_removeInstruction GGS_removeInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_removeInstruction result ;
  macroMyNew (result.mPointer, cPtr_removeInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_removeInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_removeInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_removeInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_removeInstruction::actualTypeName (void) const {
  return "removeInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__removeInstruction ("removeInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_incrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstruction::
cPtr_incrementInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstruction * GGS_incrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_incrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstruction * ptr = dynamic_cast <const cPtr_incrementInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@incrementInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstruction (& typeid (cPtr_incrementInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_incrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementInstruction (mStartLocation, mReceiverName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_incrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_incrementInstruction::
GGS_incrementInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstruction::
GGS_incrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementInstruction GGS_incrementInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstruction GGS_incrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_incrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstruction::actualTypeName (void) const {
  return "incrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__incrementInstruction ("incrementInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_decrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstruction::
cPtr_decrementInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mReceiverName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstruction * GGS_decrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_decrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstruction * ptr = dynamic_cast <const cPtr_decrementInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@decrementInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReceiverName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstruction (& typeid (cPtr_decrementInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_decrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_decrementInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_decrementInstruction (mStartLocation, mReceiverName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_decrementInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_decrementInstruction::
GGS_decrementInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstruction::
GGS_decrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_decrementInstruction GGS_decrementInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_decrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstruction GGS_decrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_decrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstruction::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstruction *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstruction::actualTypeName (void) const {
  return "decrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__decrementInstruction ("decrementInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_loopInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstruction::
cPtr_loopInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticInstructionList & argument_2,
                                const GGS_semanticExpression & argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mVariantExpression (argument_1),
mFirstInstructions (argument_2),
mLoopExpression (argument_3),
mSecondInstructions (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstruction * GGS_loopInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_loopInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstruction * ptr = dynamic_cast <const cPtr_loopInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mFirstInstructions.operator_isEqual (ptr->mFirstInstructions).boolValue ()
         && mLoopExpression.operator_isEqual (ptr->mLoopExpression).boolValue ()
         && mSecondInstructions.operator_isEqual (ptr->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@loopInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariantExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFirstInstructions.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLoopExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSecondInstructions.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstruction (& typeid (cPtr_loopInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_loopInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_loopInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_loopInstruction (mStartLocation, mVariantExpression, mFirstInstructions, mLoopExpression, mSecondInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_loopInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loopInstruction::
GGS_loopInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstruction::
GGS_loopInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_loopInstruction GGS_loopInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_loopInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstruction GGS_loopInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticInstructionList & argument_2,
                 const GGS_semanticExpression & argument_3,
                 const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstruction result ;
  macroMyNew (result.mPointer, cPtr_loopInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_loopInstruction::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_loopInstruction::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_loopInstruction::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstruction *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstruction::actualTypeName (void) const {
  return "loopInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__loopInstruction ("loopInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_messageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstruction::
cPtr_messageInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstruction * GGS_messageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_messageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstruction * ptr = dynamic_cast <const cPtr_messageInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@messageInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstruction (& typeid (cPtr_messageInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_messageInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_messageInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_messageInstruction (mStartLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_messageInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_messageInstruction::
GGS_messageInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstruction::
GGS_messageInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_messageInstruction GGS_messageInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_messageInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstruction GGS_messageInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstruction result ;
  macroMyNew (result.mPointer, cPtr_messageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_messageInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstruction::actualTypeName (void) const {
  return "messageInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__messageInstruction ("messageInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_logInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstruction::
cPtr_logInstruction (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mLoggedVariableList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstruction * GGS_logInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_logInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstruction * ptr = dynamic_cast <const cPtr_logInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mLoggedVariableList.operator_isEqual (ptr->mLoggedVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@logInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLoggedVariableList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstruction (& typeid (cPtr_logInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_logInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__logInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_logInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_logInstruction (mStartLocation, mLoggedVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_logInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_logInstruction::
GGS_logInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstruction::
GGS_logInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_logInstruction GGS_logInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_logInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_logInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstruction GGS_logInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_logInstruction result ;
  macroMyNew (result.mPointer, cPtr_logInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_logInstruction::
reader_mLoggedVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstruction *) mPointer)->mLoggedVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstruction::actualTypeName (void) const {
  return "logInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__logInstruction ("logInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_grammarInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstruction::
cPtr_grammarInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpression & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_actualParameterList & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mGrammarComponentName (argument_1),
mLabelName (argument_2),
mSourceExpression (argument_3),
mSourceExpressionIsFile (argument_4),
mActualParameterList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstruction * GGS_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstruction * ptr = dynamic_cast <const cPtr_grammarInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mGrammarComponentName.operator_isEqual (ptr->mGrammarComponentName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionIsFile.operator_isEqual (ptr->mSourceExpressionIsFile).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@grammarInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mGrammarComponentName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLabelName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionIsFile.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstruction (& typeid (cPtr_grammarInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_grammarInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstruction (mStartLocation, mGrammarComponentName, mLabelName, mSourceExpression, mSourceExpressionIsFile, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_grammarInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_grammarInstruction::
GGS_grammarInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstruction::
GGS_grammarInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstruction GGS_grammarInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstruction GGS_grammarInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpression & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_actualParameterList & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstruction::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_grammarInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarInstruction::
reader_mSourceExpressionIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mSourceExpressionIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_grammarInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstruction::actualTypeName (void) const {
  return "grammarInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__grammarInstruction ("grammarInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_withInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_withInstruction::
cPtr_withInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_semanticExpression & argument_5,
                                const GGS_semanticInstructionList & argument_6,
                                const GGS_semanticInstructionList & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mPrefix (argument_1),
mTargetObjectName (argument_2),
mStructAttributeList (argument_3),
mSearchMethodName (argument_4),
mKeyExpression (argument_5),
mDoBranchInstructions (argument_6),
mElseBranchInstructions (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_withInstruction * GGS_withInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_withInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_withInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_withInstruction * ptr = dynamic_cast <const cPtr_withInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue ()
         && mTargetObjectName.operator_isEqual (ptr->mTargetObjectName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_withInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@withInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mPrefix.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetObjectName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mKeyExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDoBranchInstructions.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseBranchInstructions.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_withInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_withInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_withInstruction (& typeid (cPtr_withInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_withInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__withInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_withInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_withInstruction (mStartLocation, mPrefix, mTargetObjectName, mStructAttributeList, mSearchMethodName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_withInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_withInstruction::
GGS_withInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_withInstruction::
GGS_withInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_withInstruction GGS_withInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_withInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_withInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_withInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_withInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_withInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withInstruction GGS_withInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_semanticExpression & argument_5,
                 const GGS_semanticInstructionList & argument_6,
                 const GGS_semanticInstructionList & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_withInstruction result ;
  macroMyNew (result.mPointer, cPtr_withInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstruction::
reader_mPrefix (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mPrefix ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstruction::
reader_mTargetObjectName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mTargetObjectName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_withInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstruction::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_withInstruction::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_withInstruction::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_withInstruction::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstruction *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_withInstruction::actualTypeName (void) const {
  return "withInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__withInstruction ("withInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@switchBranches'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_switchBranches::
elementOf_GGS_switchBranches (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSwitchConstantList (argument_0),
mInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_switchBranches::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_switchBranches * ptr = dynamic_cast <const elementOf_GGS_switchBranches *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchConstantList.operator_isEqual (ptr->mSwitchConstantList).boolValue ()
         && mInstructions.operator_isEqual (ptr->mInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_switchBranches::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSwitchConstantList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructions.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@switchBranches'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_switchBranches::
_internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
_internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranches GGS_switchBranches::
operator_concat (const GGS_switchBranches & inOperand) const {
  GGS_switchBranches result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
dotAssign_operation (const GGS_switchBranches inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_switchBranches * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mSwitchConstantList ;
          GGS_semanticInstructionList  p_1 = p->mInstructions ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_semanticInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSwitchConstantList,
                                ptr->mInstructions
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranches  GGS_switchBranches::
constructor_emptyList (void) {
  GGS_switchBranches result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranches  GGS_switchBranches::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionList & argument_1) {
  GGS_switchBranches result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
internalSubListWithRange (GGS_switchBranches & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSwitchConstantList, ptr->mInstructions) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranches GGS_switchBranches::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranches result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranches GGS_switchBranches::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranches result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_switchBranches::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@switchBranches", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
method_first (C_Compiler & inLexique,
              GGS_lstringlist & _out_0,
              GGS_semanticInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
method_last (C_Compiler & inLexique,
             GGS_lstringlist & _out_0,
             GGS_semanticInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_semanticInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstringlist & _out_0,
                GGS_semanticInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_switchBranches::
reader_mSwitchConstantListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSwitchConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_switchBranches::
reader_mInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_setMSwitchConstantListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSwitchConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranches::
modifier_setMInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_switchBranches::cEnumerator::_mSwitchConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSwitchConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_switchBranches::cEnumerator::_mInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructions ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_switchInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_switchInstruction::
cPtr_switchInstruction (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_switchBranches & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mSwitchExpression (argument_1),
mBranches (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_switchInstruction * GGS_switchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_switchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_switchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_switchInstruction * ptr = dynamic_cast <const cPtr_switchInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mBranches.operator_isEqual (ptr->mBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_switchInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@switchInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSwitchExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranches.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_switchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_switchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_switchInstruction (& typeid (cPtr_switchInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_switchInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__switchInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_switchInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_switchInstruction (mStartLocation, mSwitchExpression, mBranches COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_switchInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_switchInstruction::
GGS_switchInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_switchInstruction::
GGS_switchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_switchInstruction GGS_switchInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_switchInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_switchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_switchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_switchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_switchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstruction GGS_switchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_switchBranches & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_switchInstruction result ;
  macroMyNew (result.mPointer, cPtr_switchInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_switchInstruction::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstruction *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranches  GGS_switchInstruction::
reader_mBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_switchBranches   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstruction *) mPointer)->mBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_switchInstruction::actualTypeName (void) const {
  return "switchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__switchInstruction ("switchInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeMethodInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstruction::
cPtr_typeMethodInstruction (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstruction (argument_0 COMMA_THERE),
mTypeName (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstruction * GGS_typeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstruction * ptr = dynamic_cast <const cPtr_typeMethodInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMethodInstruction:"
           << mStartLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mActualParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstruction (& typeid (cPtr_typeMethodInstruction), & typeid (cPtr_semanticInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMethodInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodInstruction (mStartLocation, mTypeName, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMethodInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodInstruction::
GGS_typeMethodInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstruction::
GGS_typeMethodInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodInstruction GGS_typeMethodInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstruction GGS_typeMethodInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterList  GGS_typeMethodInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstruction::actualTypeName (void) const {
  return "typeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMethodInstruction ("typeMethodInstruction", gClassInfoFor__semanticInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@abstractCategoryMethodList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractCategoryMethodList::
elementOf_GGS_abstractCategoryMethodList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAbstractCategoryMethodName (argument_0),
mAbstractCategoryFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractCategoryMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractCategoryMethodList * ptr = dynamic_cast <const elementOf_GGS_abstractCategoryMethodList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractCategoryMethodName.operator_isEqual (ptr->mAbstractCategoryMethodName).boolValue ()
         && mAbstractCategoryFormalParameterList.operator_isEqual (ptr->mAbstractCategoryFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractCategoryMethodList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryMethodName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstractCategoryMethodList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodList::
operator_concat (const GGS_abstractCategoryMethodList & inOperand) const {
  GGS_abstractCategoryMethodList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
dotAssign_operation (const GGS_abstractCategoryMethodList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_abstractCategoryMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryMethodName ;
          GGS_formalParameterList  p_1 = p->mAbstractCategoryFormalParameterList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mAbstractCategoryMethodName,
                                ptr->mAbstractCategoryFormalParameterList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList  GGS_abstractCategoryMethodList::
constructor_emptyList (void) {
  GGS_abstractCategoryMethodList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList  GGS_abstractCategoryMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1) {
  GGS_abstractCategoryMethodList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
internalSubListWithRange (GGS_abstractCategoryMethodList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractCategoryMethodName, ptr->mAbstractCategoryFormalParameterList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractCategoryMethodList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractCategoryMethodList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryMethodList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@abstractCategoryMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractCategoryMethodList::
reader_mAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_abstractCategoryMethodList::
reader_mAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_setMAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodList::
modifier_setMAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractCategoryMethodList::cEnumerator::_mAbstractCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterList  & GGS_abstractCategoryMethodList::cEnumerator::_mAbstractCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstractCategoryMethodList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractCategoryMethodListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractCategoryMethodListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractCategoryMethodListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap GGS_abstractCategoryMethodListMap::
constructor_emptyMap (void) {
  GGS_abstractCategoryMethodListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractCategoryMethodListMap::
_typeNameForDescriptionReader (void) const {
  return "@abstractCategoryMethodListMap" ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap GGS_abstractCategoryMethodListMap::
operator_concat (const GGS_abstractCategoryMethodListMap & inOperand) const {
  GGS_abstractCategoryMethodListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodListMap::
dotAssign_operation (const GGS_abstractCategoryMethodListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstractCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryMethodListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterList & inAttribute1) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstractCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodList GGS_abstractCategoryMethodListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractCategoryMethodList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstractCategoryMethodList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractCategoryMethodListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractCategoryMethodListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodListMap::cEnumerator::
cEnumerator (const GGS_abstractCategoryMethodListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstractCategoryMethodList & GGS_abstractCategoryMethodListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@categoryMethodList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_categoryMethodList::
elementOf_GGS_categoryMethodList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCategoryMethodName (argument_0),
mCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_categoryMethodList * ptr = dynamic_cast <const elementOf_GGS_categoryMethodList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodName.operator_isEqual (ptr->mCategoryMethodName).boolValue ()
         && mCategoryFormalParameterList.operator_isEqual (ptr->mCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryMethodList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryMethodName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@categoryMethodList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodList::
operator_concat (const GGS_categoryMethodList & inOperand) const {
  GGS_categoryMethodList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
dotAssign_operation (const GGS_categoryMethodList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_categoryMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryMethodName ;
          GGS_formalParameterList  p_1 = p->mCategoryFormalParameterList ;
          GGS_semanticInstructionList  p_2 = p->mRoutineInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1,
                     const GGS_semanticInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mCategoryMethodName,
                                ptr->mCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList  GGS_categoryMethodList::
constructor_emptyList (void) {
  GGS_categoryMethodList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList  GGS_categoryMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  GGS_categoryMethodList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
internalSubListWithRange (GGS_categoryMethodList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCategoryMethodName, ptr->mCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_categoryMethodList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_categoryMethodList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@categoryMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1,
              GGS_semanticInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1,
             GGS_semanticInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1,
                 GGS_semanticInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1,
                GGS_semanticInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryMethodList::
reader_mCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_categoryMethodList::
reader_mCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_categoryMethodList::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_setMCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_setMCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodList::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_categoryMethodList::cEnumerator::_mCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterList  & GGS_categoryMethodList::cEnumerator::_mCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_categoryMethodList::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_categoryMethodList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_categoryMethodListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_categoryMethodListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_categoryMethodListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap GGS_categoryMethodListMap::
constructor_emptyMap (void) {
  GGS_categoryMethodListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodListMap::
_typeNameForDescriptionReader (void) const {
  return "@categoryMethodListMap" ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap GGS_categoryMethodListMap::
operator_concat (const GGS_categoryMethodListMap & inOperand) const {
  GGS_categoryMethodListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodListMap::
dotAssign_operation (const GGS_categoryMethodListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_categoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterList & inAttribute1,
                      const GGS_semanticInstructionList & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_categoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodList GGS_categoryMethodListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryMethodList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_categoryMethodList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_categoryMethodListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_categoryMethodListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodListMap::cEnumerator::
cEnumerator (const GGS_categoryMethodListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_categoryMethodList & GGS_categoryMethodListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingCategoryMethodList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingCategoryMethodList::
elementOf_GGS_overridingCategoryMethodList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOverridingCategoryMethodName (argument_0),
mOverridingCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingCategoryMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingCategoryMethodList * ptr = dynamic_cast <const elementOf_GGS_overridingCategoryMethodList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingCategoryMethodName.operator_isEqual (ptr->mOverridingCategoryMethodName).boolValue ()
         && mOverridingCategoryFormalParameterList.operator_isEqual (ptr->mOverridingCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingCategoryMethodList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryMethodName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingCategoryMethodList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodList::
operator_concat (const GGS_overridingCategoryMethodList & inOperand) const {
  GGS_overridingCategoryMethodList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
dotAssign_operation (const GGS_overridingCategoryMethodList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_overridingCategoryMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryMethodName ;
          GGS_formalParameterList  p_1 = p->mOverridingCategoryFormalParameterList ;
          GGS_semanticInstructionList  p_2 = p->mRoutineInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1,
                     const GGS_semanticInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mOverridingCategoryMethodName,
                                ptr->mOverridingCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList  GGS_overridingCategoryMethodList::
constructor_emptyList (void) {
  GGS_overridingCategoryMethodList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList  GGS_overridingCategoryMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  GGS_overridingCategoryMethodList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
internalSubListWithRange (GGS_overridingCategoryMethodList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingCategoryMethodName, ptr->mOverridingCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingCategoryMethodList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingCategoryMethodList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingCategoryMethodList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@overridingCategoryMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1,
              GGS_semanticInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1,
             GGS_semanticInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1,
                 GGS_semanticInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1,
                GGS_semanticInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingCategoryMethodList::
reader_mOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_overridingCategoryMethodList::
reader_mOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_overridingCategoryMethodList::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_setMOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_setMOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodList::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingCategoryMethodList::cEnumerator::_mOverridingCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterList  & GGS_overridingCategoryMethodList::cEnumerator::_mOverridingCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_overridingCategoryMethodList::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingCategoryMethodList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingCategoryMethodListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingCategoryMethodListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingCategoryMethodListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap GGS_overridingCategoryMethodListMap::
constructor_emptyMap (void) {
  GGS_overridingCategoryMethodListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingCategoryMethodListMap::
_typeNameForDescriptionReader (void) const {
  return "@overridingCategoryMethodListMap" ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap GGS_overridingCategoryMethodListMap::
operator_concat (const GGS_overridingCategoryMethodListMap & inOperand) const {
  GGS_overridingCategoryMethodListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodListMap::
dotAssign_operation (const GGS_overridingCategoryMethodListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryMethodListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterList & inAttribute1,
                      const GGS_semanticInstructionList & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingCategoryMethodList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodList GGS_overridingCategoryMethodListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingCategoryMethodList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingCategoryMethodList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingCategoryMethodListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingCategoryMethodListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodListMap::cEnumerator::
cEnumerator (const GGS_overridingCategoryMethodListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingCategoryMethodList & GGS_overridingCategoryMethodListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@abstractCategoryReaderList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractCategoryReaderList::
elementOf_GGS_abstractCategoryReaderList (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAbstractCategoryReaderName (argument_0),
mAbstractCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractCategoryReaderList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractCategoryReaderList * ptr = dynamic_cast <const elementOf_GGS_abstractCategoryReaderList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractCategoryReaderName.operator_isEqual (ptr->mAbstractCategoryReaderName).boolValue ()
         && mAbstractCategoryFormalInputParameterList.operator_isEqual (ptr->mAbstractCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractCategoryReaderList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryReaderName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalInputParameterList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstractCategoryReaderList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterList & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterList & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderList GGS_abstractCategoryReaderList::
operator_concat (const GGS_abstractCategoryReaderList & inOperand) const {
  GGS_abstractCategoryReaderList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
dotAssign_operation (const GGS_abstractCategoryReaderList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_abstractCategoryReaderList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryReaderName ;
          GGS_formalInputParameterList  p_1 = p->mAbstractCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterList & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mAbstractCategoryReaderName,
                                ptr->mAbstractCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderList  GGS_abstractCategoryReaderList::
constructor_emptyList (void) {
  GGS_abstractCategoryReaderList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderList  GGS_abstractCategoryReaderList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_abstractCategoryReaderList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
internalSubListWithRange (GGS_abstractCategoryReaderList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractCategoryReaderName, ptr->mAbstractCategoryFormalInputParameterList, ptr->mReturnedTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderList GGS_abstractCategoryReaderList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractCategoryReaderList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderList GGS_abstractCategoryReaderList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractCategoryReaderList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryReaderList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@abstractCategoryReaderList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterList & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterList & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterList & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterList & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractCategoryReaderList::
reader_mAbstractCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterList  GGS_abstractCategoryReaderList::
reader_mAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractCategoryReaderList::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
modifier_setMAbstractCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
modifier_setMAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderList::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractCategoryReaderList::cEnumerator::_mAbstractCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterList  & GGS_abstractCategoryReaderList::cEnumerator::_mAbstractCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractCategoryReaderList::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstractCategoryReaderList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractCategoryReaderListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractCategoryReaderListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractCategoryReaderListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderListMap GGS_abstractCategoryReaderListMap::
constructor_emptyMap (void) {
  GGS_abstractCategoryReaderListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractCategoryReaderListMap::
_typeNameForDescriptionReader (void) const {
  return "@abstractCategoryReaderListMap" ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderListMap GGS_abstractCategoryReaderListMap::
operator_concat (const GGS_abstractCategoryReaderListMap & inOperand) const {
  GGS_abstractCategoryReaderListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderListMap::
dotAssign_operation (const GGS_abstractCategoryReaderListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstractCategoryReaderList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractCategoryReaderListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterList & inAttribute1,
                      const GGS_lstring & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstractCategoryReaderList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderList GGS_abstractCategoryReaderListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractCategoryReaderList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstractCategoryReaderList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractCategoryReaderListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractCategoryReaderListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderListMap::cEnumerator::
cEnumerator (const GGS_abstractCategoryReaderListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstractCategoryReaderList & GGS_abstractCategoryReaderListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@categoryReaderList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_categoryReaderList::
elementOf_GGS_categoryReaderList (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCategoryReaderName (argument_0),
mReaderCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryReaderList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_categoryReaderList * ptr = dynamic_cast <const elementOf_GGS_categoryReaderList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryReaderName.operator_isEqual (ptr->mCategoryReaderName).boolValue ()
         && mReaderCategoryFormalInputParameterList.operator_isEqual (ptr->mReaderCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryReaderList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryReaderName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReaderCategoryFormalInputParameterList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@categoryReaderList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterList & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterList & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryReaderList GGS_categoryReaderList::
operator_concat (const GGS_categoryReaderList & inOperand) const {
  GGS_categoryReaderList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
dotAssign_operation (const GGS_categoryReaderList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_categoryReaderList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryReaderName ;
          GGS_formalInputParameterList  p_1 = p->mReaderCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionList  p_4 = p->mRoutineInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterList & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mCategoryReaderName,
                                ptr->mReaderCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryReaderList  GGS_categoryReaderList::
constructor_emptyList (void) {
  GGS_categoryReaderList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderList  GGS_categoryReaderList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  GGS_categoryReaderList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
internalSubListWithRange (GGS_categoryReaderList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCategoryReaderName, ptr->mReaderCategoryFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryReaderList GGS_categoryReaderList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_categoryReaderList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderList GGS_categoryReaderList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_categoryReaderList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryReaderList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@categoryReaderList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterList & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterList & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterList & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterList & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryReaderList::
reader_mCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterList  GGS_categoryReaderList::
reader_mReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReaderCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryReaderList::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryReaderList::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_categoryReaderList::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_setMCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_setMReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReaderCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderList::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_categoryReaderList::cEnumerator::_mCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterList  & GGS_categoryReaderList::cEnumerator::_mReaderCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReaderCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_categoryReaderList::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_categoryReaderList::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_categoryReaderList::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_categoryReaderList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_categoryReaderListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_categoryReaderListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_categoryReaderListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderListMap GGS_categoryReaderListMap::
constructor_emptyMap (void) {
  GGS_categoryReaderListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryReaderListMap::
_typeNameForDescriptionReader (void) const {
  return "@categoryReaderListMap" ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderListMap GGS_categoryReaderListMap::
operator_concat (const GGS_categoryReaderListMap & inOperand) const {
  GGS_categoryReaderListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderListMap::
dotAssign_operation (const GGS_categoryReaderListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_categoryReaderList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterList & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionList & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_categoryReaderList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryReaderList GGS_categoryReaderListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryReaderList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_categoryReaderList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_categoryReaderListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_categoryReaderListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderListMap::cEnumerator::
cEnumerator (const GGS_categoryReaderListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_categoryReaderList & GGS_categoryReaderListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingCategoryReaderList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingCategoryReaderList::
elementOf_GGS_overridingCategoryReaderList (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOverridingCategoryReaderName (argument_0),
mOverridingReaderFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingCategoryReaderList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingCategoryReaderList * ptr = dynamic_cast <const elementOf_GGS_overridingCategoryReaderList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingCategoryReaderName.operator_isEqual (ptr->mOverridingCategoryReaderName).boolValue ()
         && mOverridingReaderFormalInputParameterList.operator_isEqual (ptr->mOverridingReaderFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingCategoryReaderList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryReaderName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingReaderFormalInputParameterList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingCategoryReaderList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterList & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterList & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderList GGS_overridingCategoryReaderList::
operator_concat (const GGS_overridingCategoryReaderList & inOperand) const {
  GGS_overridingCategoryReaderList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
dotAssign_operation (const GGS_overridingCategoryReaderList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_overridingCategoryReaderList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryReaderName ;
          GGS_formalInputParameterList  p_1 = p->mOverridingReaderFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionList  p_4 = p->mRoutineInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterList & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mOverridingCategoryReaderName,
                                ptr->mOverridingReaderFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderList  GGS_overridingCategoryReaderList::
constructor_emptyList (void) {
  GGS_overridingCategoryReaderList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderList  GGS_overridingCategoryReaderList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionList & argument_4) {
  GGS_overridingCategoryReaderList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
internalSubListWithRange (GGS_overridingCategoryReaderList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingCategoryReaderName, ptr->mOverridingReaderFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderList GGS_overridingCategoryReaderList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingCategoryReaderList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderList GGS_overridingCategoryReaderList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingCategoryReaderList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingCategoryReaderList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@overridingCategoryReaderList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterList & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterList & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterList & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterList & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingCategoryReaderList::
reader_mOverridingCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterList  GGS_overridingCategoryReaderList::
reader_mOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingReaderFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingCategoryReaderList::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingCategoryReaderList::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_overridingCategoryReaderList::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_setMOverridingCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_setMOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingReaderFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderList::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingCategoryReaderList::cEnumerator::_mOverridingCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterList  & GGS_overridingCategoryReaderList::cEnumerator::_mOverridingReaderFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingReaderFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingCategoryReaderList::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingCategoryReaderList::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionList  & GGS_overridingCategoryReaderList::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingCategoryReaderList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingCategoryReaderListMap::cElement::_clone (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingCategoryReaderListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingCategoryReaderListMap::cElement::
_description (C_Compiler & inLexique,
              const PMSInt32 inIndentation
              COMMA_LOCATION_ARGS) const {
  const GGS_string s = mListObject.reader_description (inLexique COMMA_THERE, inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderListMap GGS_overridingCategoryReaderListMap::
constructor_emptyMap (void) {
  GGS_overridingCategoryReaderListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingCategoryReaderListMap::
_typeNameForDescriptionReader (void) const {
  return "@overridingCategoryReaderListMap" ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderListMap GGS_overridingCategoryReaderListMap::
operator_concat (const GGS_overridingCategoryReaderListMap & inOperand) const {
  GGS_overridingCategoryReaderListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderListMap::
dotAssign_operation (const GGS_overridingCategoryReaderListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingCategoryReaderList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingCategoryReaderListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterList & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionList & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingCategoryReaderList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderList GGS_overridingCategoryReaderListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingCategoryReaderList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingCategoryReaderList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingCategoryReaderListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingCategoryReaderListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryReaderListMap::cEnumerator::
cEnumerator (const GGS_overridingCategoryReaderListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingCategoryReaderList & GGS_overridingCategoryReaderListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of 'semanticDeclarationStruct' struct            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticDeclarationStruct::GGS_semanticDeclarationStruct (void) :
mSemanticDeclarationList (),
mAbstractCategoryMethodListMap (),
mCategoryMethodListMap (),
mOverridingCategoryMethodListMap (),
mAbstractCategoryReaderListMap (),
mCategoryReaderListMap (),
mOverridingCategoryReaderListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStruct::~GGS_semanticDeclarationStruct (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationStruct::drop (void) {
  mSemanticDeclarationList.drop () ;
  mAbstractCategoryMethodListMap.drop () ;
  mCategoryMethodListMap.drop () ;
  mOverridingCategoryMethodListMap.drop () ;
  mAbstractCategoryReaderListMap.drop () ;
  mCategoryReaderListMap.drop () ;
  mOverridingCategoryReaderListMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticDeclarationStruct::isBuilt (void) const {
  return mSemanticDeclarationList.isBuilt ()
    && mAbstractCategoryMethodListMap.isBuilt ()
    && mCategoryMethodListMap.isBuilt ()
    && mOverridingCategoryMethodListMap.isBuilt ()
    && mAbstractCategoryReaderListMap.isBuilt ()
    && mCategoryReaderListMap.isBuilt ()
    && mOverridingCategoryReaderListMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStruct::
operator_isEqual (const GGS_semanticDeclarationStruct & inOperand) const {
  return mSemanticDeclarationList.operator_isEqual (inOperand.mSemanticDeclarationList)
    .operator_and (mAbstractCategoryMethodListMap.operator_isEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_and (mCategoryMethodListMap.operator_isEqual (inOperand.mCategoryMethodListMap))
    .operator_and (mOverridingCategoryMethodListMap.operator_isEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_and (mAbstractCategoryReaderListMap.operator_isEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_and (mCategoryReaderListMap.operator_isEqual (inOperand.mCategoryReaderListMap))
    .operator_and (mOverridingCategoryReaderListMap.operator_isEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStruct::
operator_isNotEqual (const GGS_semanticDeclarationStruct & inOperand) const {
  return mSemanticDeclarationList.operator_isNotEqual (inOperand.mSemanticDeclarationList)
    .operator_or (mAbstractCategoryMethodListMap.operator_isNotEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_or (mCategoryMethodListMap.operator_isNotEqual (inOperand.mCategoryMethodListMap))
    .operator_or (mOverridingCategoryMethodListMap.operator_isNotEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_or (mAbstractCategoryReaderListMap.operator_isNotEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_or (mCategoryReaderListMap.operator_isNotEqual (inOperand.mCategoryReaderListMap))
    .operator_or (mOverridingCategoryReaderListMap.operator_isNotEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStruct GGS_semanticDeclarationStruct::
constructor_new (const GGS_semanticDeclarationList & argument_0,
                 const GGS_abstractCategoryMethodListMap& argument_1,
                 const GGS_categoryMethodListMap& argument_2,
                 const GGS_overridingCategoryMethodListMap& argument_3,
                 const GGS_abstractCategoryReaderListMap& argument_4,
                 const GGS_categoryReaderListMap& argument_5,
                 const GGS_overridingCategoryReaderListMap& argument_6) {
  GGS_semanticDeclarationStruct result ;
  result.mSemanticDeclarationList = argument_0 ;
  result.mAbstractCategoryMethodListMap = argument_1 ;
  result.mCategoryMethodListMap = argument_2 ;
  result.mOverridingCategoryMethodListMap = argument_3 ;
  result.mAbstractCategoryReaderListMap = argument_4 ;
  result.mCategoryReaderListMap = argument_5 ;
  result.mOverridingCategoryReaderListMap = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationStruct::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticDeclarationStruct" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mSemanticDeclarationList " ;
    _s << mSemanticDeclarationList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryMethodListMap " ;
    _s << mAbstractCategoryMethodListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodListMap " ;
    _s << mCategoryMethodListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryMethodListMap " ;
    _s << mOverridingCategoryMethodListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryReaderListMap " ;
    _s << mAbstractCategoryReaderListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryReaderListMap " ;
    _s << mCategoryReaderListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryReaderListMap " ;
    _s << mOverridingCategoryReaderListMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

