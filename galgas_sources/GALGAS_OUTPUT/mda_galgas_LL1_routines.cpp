//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'mda_galgas_LL1_routines.cpp'                     *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 8th, 2007, at 17h30'58"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "mda_galgas_LL1_routines.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "mda_galgas_LL1_routines.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "buildMapsForSemantics.h"
#include "galgas_LL1_grammar.h"
#include "grammarLL1grammar.h"
#include "guiLL1grammar.h"
#include "lexiqueLL1grammar.h"
#include "lexiqueTreewalkingForBuildingTerminalMap.h"
#include "metamodelLL1grammar.h"
#include "optionHeaderGeneration.h"
#include "optionImplementationGeneration.h"
#include "optionLL1grammar.h"
#include "optionTreewalkingForBuildingOptionMap.h"
#include "programSLRgrammar.h"
#include "projectLL1grammar.h"
#include "semanticsSLRgrammar.h"
#include "syntaxSLRgrammar.h"
#include "treewalkingSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "getOutputDirectory"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getOutputDirectory (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_string & var_cas_outOuputDirectory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getOutputDirectory at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outOuputDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (61)) ;
  var_cas_outOuputDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getOutputDirectory\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileOptionComponentLL1"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileOptionComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileOptionComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_optionComponentRoot  var_cas_optionComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      optionLL1grammar grammar_ ;
      try{
        var_cas_optionComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (73)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (73)) ;
    }
  }
  GGS_commandLineOptionMap  var_cas_boolOptionMap ;
  GGS_commandLineOptionMap  var_cas_uintOptionMap ;
  GGS_commandLineOptionMap  var_cas_stringOptionMap ;
  _walk_throught_optionTreewalkingForBuildingOptionMap (_inLexique, var_cas_optionComponentRoot, var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap) ;
  _walk_throught_optionHeaderGeneration (_inLexique, var_cas_optionComponentRoot, var_cas_inOutputDirectory, var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap) ;
  _walk_throught_optionImplementationGeneration (_inLexique, var_cas_optionComponentRoot, var_cas_inOutputDirectory, var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (93)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (93)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileOptionComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "compileMetamodelComponentLL1"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileMetamodelComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileMetamodelComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_metamodelComponentRoot  var_cas_metamodelComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      metamodelLL1grammar grammar_ ;
      try{
        var_cas_metamodelComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (107)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (107)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileMetamodelComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileLexiqueComponentLL1"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileLexiqueComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileLexiqueComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_lexiqueComponentRoot  var_cas_lexiqueComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      lexiqueLL1grammar grammar_ ;
      try{
        var_cas_lexiqueComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (117)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (117)) ;
    }
  }
  GGS_terminalMap  var_cas_terminalMap ;
  _walk_throught_lexiqueTreewalkingForBuildingTerminalMap (_inLexique, var_cas_lexiqueComponentRoot, var_cas_terminalMap) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileLexiqueComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "compileSemanticsComponentLL1"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileSemanticsComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileSemanticsComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticsComponentRoot  var_cas_semanticsComponentRoot ;
  GGS_location  var_cas_endOfSourceFile ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      semanticsSLRgrammar grammar_ ;
      try{
        var_cas_semanticsComponentRoot = grammar_.startParsing_ (*scanner_,
                                  var_cas_endOfSourceFile) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (134)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (134)) ;
    }
  }
  GGS_typeMap  var_cas_typeMap ;
  ::routine_constructBuiltinTypeMap (_inLexique,  var_cas_typeMap COMMA_SOURCE_FILE_AT_LINE (137)) ;
  GGS_stringset  var_cas_importedComponentSet ;
  var_cas_importedComponentSet = GGS_stringset::constructor_emptySet (_inLexique COMMA_HERE) ;
  _walk_throught_buildMapsForSemantics (_inLexique, var_cas_semanticsComponentRoot, var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (140)), var_cas_endOfSourceFile, var_cas_importedComponentSet, var_cas_typeMap) ;
  if (((var_cas_typeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (146)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_m ;
    var_cas_m = (var_cas_typeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (147)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (147)))._operator_concat (GGS_string (true, " type")) ;
    if (((var_cas_typeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (148)))._operator_isEqual (GGS_uint (true, 1U))).isBuiltAndTrue ()) {
      var_cas_m = GGS_string (true, "1 type is not defined:") ;
    }else{
      var_cas_m = (var_cas_typeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (151)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (151)))._operator_concat (GGS_string (true, " types are not defined:")) ;
    }
    const GGS_stringlist _var_6990 = var_cas_typeMap.reader_unsolvedIndexKeyStringList (_inLexique COMMA_SOURCE_FILE_AT_LINE (153)) ;
    GGS_stringlist::element_type * operand_6990 = _var_6990.firstObject () ;
    while ((operand_6990 != NULL)) {
      macroValidPointer (operand_6990) ;
      var_cas_m.writeString ("\n  - @") ;
      var_cas_m._dotAssign_operation (operand_6990->mValue) ;
      operand_6990 = operand_6990->nextObject () ;
    }
    var_cas_endOfSourceFile.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (156)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileSemanticsComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileSyntaxComponentLL1"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileSyntaxComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileSyntaxComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_syntaxComponentRoot  var_cas_syntaxComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      syntaxSLRgrammar grammar_ ;
      try{
        var_cas_syntaxComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (167)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (167)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileSyntaxComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileGrammarComponentLL1"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGrammarComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGrammarComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_grammarComponentRoot  var_cas_grammarComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      grammarLL1grammar grammar_ ;
      try{
        var_cas_grammarComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (177)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (177)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGrammarComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "compileGuiComponentLL1"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGuiComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGuiComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_guiComponentRoot  var_cas_guiComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      guiLL1grammar grammar_ ;
      try{
        var_cas_guiComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (187)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (187)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGuiComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "compileProgramComponentLL1"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileProgramComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileProgramComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_programComponentRoot  var_cas_programComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      programSLRgrammar grammar_ ;
      try{
        var_cas_programComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (197)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (197)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileProgramComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "compileTreewalkingComponentLL1"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileTreewalkingComponentLL1 (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileTreewalkingComponentLL1 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_treewalkingComponentRoot  var_cas_treewalkingComponentRoot ;
  { galgas_scanner * scanner_ = NULL ;
    const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
      ? var_cas_inSourceFile.string ()
      : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
    if (sourceFileName.fileExists ()) {
      macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
      scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
      treewalkingSLRgrammar grammar_ ;
      try{
        var_cas_treewalkingComponentRoot = grammar_.startParsing_ (*scanner_) ;
      }catch (const C_TextReadException & inFileReadError) {
        var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (207)) ;
      }
      macroDetachPointer (scanner_, galgas_scanner) ;
    }else{
      C_String message ;
      message << "The '" << sourceFileName << "' file does not exist" ;
      var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (207)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileTreewalkingComponentLL1\n") ;
  #endif
}

//---------------------------------------------------------------------------*

