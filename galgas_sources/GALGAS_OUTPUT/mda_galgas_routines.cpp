//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'mda_galgas_routines.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 10th, 2008, at 20h36'50"                     *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "mda_galgas_routines.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "mda_galgas_routines.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "galgas_LL1_grammar.h"
#include "grammarLL1grammar.h"
#include "optionLL1grammar.h"
#include "programSLRgrammar.h"
#include "projectLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "getOutputDirectory"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getOutputDirectory (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_string & var_cas_outOuputDirectory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getOutputDirectory at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outOuputDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (47)) ;
  var_cas_outOuputDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getOutputDirectory\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "performProjectGlobalCheckings"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_performProjectGlobalCheckings (C_Compiler & _inLexique,
                                const GGS_parsedComponentStruct  var_cas_inParsedComponentStruct,
                                const GGS_location   var_cas_inEndOfSourceFile COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_performProjectGlobalCheckings at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticDeclarationList  var_cas_semanticDeclarationList ;
  var_cas_semanticDeclarationList = GGS_semanticDeclarationList ::constructor_emptyList () ;
  {
    GGS_parsedSemanticsComponentMap::cEnumerator enumerator_3309 (var_cas_inParsedComponentStruct.reader_mParsedSemanticsComponentMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)), true) ;
    const GGS_parsedSemanticsComponentMap::cElement * operand_3309 = NULL ;
    while (((operand_3309 = enumerator_3309.nextObject ()))) {
      macroValidPointer (operand_3309) ;
      var_cas_semanticDeclarationList._dotAssign_operation (operand_3309->mInfo.mRoot.reader_mSemanticDeclarations (_inLexique COMMA_SOURCE_FILE_AT_LINE (60)).reader_mSemanticDeclarationList (_inLexique COMMA_SOURCE_FILE_AT_LINE (60))) ;
    }
  }
  GGS_semanticContext var_cas_semanticContext ;
  ::routine_buildSemanticContext (_inLexique,  var_cas_semanticDeclarationList,  var_cas_inEndOfSourceFile,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (64)) ;
  if (((GGS_uint ::constructor_errorCount (_inLexique COMMA_HERE))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_abstractCategoryMethodListMap var_cas_abstractCategoryMethodListMap ;
    var_cas_abstractCategoryMethodListMap = GGS_abstractCategoryMethodListMap::constructor_emptyMap () ;
    GGS_categoryMethodListMap var_cas_categoryMethodListMap ;
    var_cas_categoryMethodListMap = GGS_categoryMethodListMap::constructor_emptyMap () ;
    GGS_overridingCategoryMethodListMap var_cas_overridingCategoryMethodListMap ;
    var_cas_overridingCategoryMethodListMap = GGS_overridingCategoryMethodListMap::constructor_emptyMap () ;
    {
      GGS_parsedSemanticsComponentMap::cEnumerator enumerator_4011 (var_cas_inParsedComponentStruct.reader_mParsedSemanticsComponentMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (71)), true) ;
      const GGS_parsedSemanticsComponentMap::cElement * operand_4011 = NULL ;
      while (((operand_4011 = enumerator_4011.nextObject ()))) {
        macroValidPointer (operand_4011) ;
        var_cas_abstractCategoryMethodListMap._dotAssign_operation (operand_4011->mInfo.mRoot.reader_mSemanticDeclarations (_inLexique COMMA_SOURCE_FILE_AT_LINE (72)).reader_mAbstractCategoryMethodListMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (72))) ;
        var_cas_overridingCategoryMethodListMap._dotAssign_operation (operand_4011->mInfo.mRoot.reader_mSemanticDeclarations (_inLexique COMMA_SOURCE_FILE_AT_LINE (73)).reader_mOverridingCategoryMethodListMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (73))) ;
      }
    }
    GGS_descendantClassListMap var_cas_descendantClassListMap ;
    var_cas_descendantClassListMap = var_cas_semanticContext.reader_mDescendantClassListMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (75)) ;
    {
      GGS_abstractCategoryMethodListMap::cEnumerator enumerator_4437 (var_cas_abstractCategoryMethodListMap, true) ;
      while (enumerator_4437.hc ()) {
        GGS_classIndexList  var_cas_descendantClasses ;
        var_cas_descendantClasses = var_cas_descendantClassListMap.reader_listForKey (_inLexique, enumerator_4437._key (HERE) COMMA_SOURCE_FILE_AT_LINE (77)) ;
        {
          GGS_abstractCategoryMethodList::cEnumerator enumerator_4547 (enumerator_4437._object (HERE), true) ;
          const GGS_abstractCategoryMethodList::cElement * operand_4547 = NULL ;
          while (((operand_4547 = enumerator_4547.nextObject ()))) {
            macroValidPointer (operand_4547) ;
            {
              GGS_classIndexList::cEnumerator enumerator_4669 (var_cas_descendantClasses, true) ;
              const GGS_classIndexList::cElement * operand_4669 = NULL ;
              while (((operand_4669 = enumerator_4669.nextObject ()))) {
                macroValidPointer (operand_4669) ;
                GGS_lstring  var_cas_descendantClassName ;
                GGS_ACGalgasType  automatic_var_0 ;
                const GGS_typeMapIndex  _temp_4739 = operand_4669->mClassMapindex ;
                if (_temp_4739._isBuilt ()) {
                  _temp_4739 (HERE)->method_searchKey (_inLexique, var_cas_descendantClassName, automatic_var_0 COMMA_SOURCE_FILE_AT_LINE (81)) ;
                }
                GGS_overridingCategoryMethodList  var_cas_overridingMethods ;
                var_cas_overridingMethods = var_cas_overridingCategoryMethodListMap.reader_listForKey (_inLexique, var_cas_descendantClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (82)) COMMA_SOURCE_FILE_AT_LINE (82)) ;
                GGS_bool var_cas_found ;
                var_cas_found = GGS_bool (true, false) ;
                {
                  GGS_overridingCategoryMethodList::cEnumerator enumerator_4973 (var_cas_overridingMethods, true) ;
                  const GGS_overridingCategoryMethodList::cElement * operand_4973 = NULL ;
                  while (((operand_4973 = enumerator_4973.nextObject ()))
                      && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                    macroValidPointer (operand_4973) ;
                    var_cas_found = (operand_4547->mAbstractCategoryMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (85)))._operator_isEqual (operand_4973->mOverridingCategoryMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (85))) ;
                  }
                }
                if (((var_cas_found)._operator_not ()).isBuiltAndTrue ()) {
                  GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((GGS_string (true, "an abstract category method '"))._operator_concat (operand_4547->mAbstractCategoryMethodName))._operator_concat (GGS_string (true, "' is defined for class '@")))._operator_concat (enumerator_4437._key (HERE)))._operator_concat (GGS_string (true, "', but descendant class '@")))._operator_concat (var_cas_descendantClassName))._operator_concat (GGS_string (true, "' does not implement this method")) COMMA_SOURCE_FILE_AT_LINE (90)) ;
                }
              }
            }
          }
        }
        enumerator_4437.next () ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_performProjectGlobalCheckings\n") ;
  #endif
}

//---------------------------------------------------------------------------*

