//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'mda_galgas_routines.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 11th, 2008, at 19h35'0"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "mda_galgas_routines.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "mda_galgas_routines.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "galgas_LL1_grammar.h"
#include "grammarLL1grammar.h"
#include "optionLL1grammar.h"
#include "programSLRgrammar.h"
#include "projectLL1grammar.h"
#include "syntaxSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "getOutputDirectory"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getOutputDirectory (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                GGS_string & var_cas_outOuputDirectory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getOutputDirectory at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outOuputDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (47)) ;
  var_cas_outOuputDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getOutputDirectory\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "checkCategoryDefinitionForClass"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkCategoryDefinitionForClass (C_Compiler & _inLexique,
                                const GGS_string  var_cas_inClassNameForErrorSignaling,
                                const GGS_string  var_cas_inClassName,
                                const GGS_lstring   var_cas_inAbstractCategoryMethodName,
                                const GGS_descendantClassListMap  var_cas_inDescendantClassListMap,
                                const GGS_overridingCategoryMethodListMap  var_cas_inOverridingCategoryMethodListMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkCategoryDefinitionForClass at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_classIndexList  var_cas_descendantClasses ;
  var_cas_descendantClasses = var_cas_inDescendantClassListMap.reader_listForKey (_inLexique, var_cas_inClassName COMMA_SOURCE_FILE_AT_LINE (60)) ;
  {
    GGS_classIndexList::cEnumerator enumerator_3470 (var_cas_descendantClasses, true) ;
    const GGS_classIndexList::cElement * operand_3470 = NULL ;
    while (((operand_3470 = enumerator_3470.nextObject ()))) {
      macroValidPointer (operand_3470) ;
      GGS_lstring  var_cas_descendantClassName ;
      GGS_ACGalgasType  var_cas_t ;
      const GGS_typeMapIndex  _temp_3552 = operand_3470->mClassMapindex ;
      if (_temp_3552._isBuilt ()) {
        _temp_3552 (HERE)->method_searchKey (_inLexique, var_cas_descendantClassName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (62)) ;
      }
      GGS_bool var_cas_isAbstract ;
      { const GGS_ACGalgasType _var_3829 = var_cas_t ; // CAST instruction
        if (_var_3829.getPtr () != NULL) {
          macroValidPointer (_var_3829.getPtr ()) ;
          if (dynamic_cast <cPtr_classGalgasType *> (_var_3829.getPtr ()) != NULL) {
            const GGS_classGalgasType var_cas_classType (_var_3829.getPtr ()) ;
            var_cas_isAbstract = var_cas_classType.reader_mIsAbstract (_inLexique COMMA_SOURCE_FILE_AT_LINE (66)) ;
          }else{
            var_cas_descendantClassName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '@"))._operator_concat (var_cas_descendantClassName))._operator_concat (GGS_string (true, "' type should be a class")) COMMA_SOURCE_FILE_AT_LINE (69)) ;
            var_cas_isAbstract._drop () ;
          }
        }
      }
      GGS_overridingCategoryMethodList  var_cas_overridingMethods ;
      var_cas_overridingMethods = var_cas_inOverridingCategoryMethodListMap.reader_listForKey (_inLexique, var_cas_descendantClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (70)) COMMA_SOURCE_FILE_AT_LINE (70)) ;
      GGS_bool var_cas_found ;
      var_cas_found = GGS_bool (true, false) ;
      {
        GGS_overridingCategoryMethodList::cEnumerator enumerator_4027 (var_cas_overridingMethods, true) ;
        const GGS_overridingCategoryMethodList::cElement * operand_4027 = NULL ;
        while (((operand_4027 = enumerator_4027.nextObject ()))
            && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
          macroValidPointer (operand_4027) ;
          var_cas_found = (var_cas_inAbstractCategoryMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (73)))._operator_isEqual (operand_4027->mOverridingCategoryMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (73))) ;
        }
      }
      if (((var_cas_found)._operator_not ()).isBuiltAndTrue ()) {
        if ((var_cas_isAbstract).isBuiltAndTrue ()) {
          ::routine_checkCategoryDefinitionForClass (_inLexique,  var_cas_inClassNameForErrorSignaling,  var_cas_descendantClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (79)),  var_cas_inAbstractCategoryMethodName,  var_cas_inDescendantClassListMap,  var_cas_inOverridingCategoryMethodListMap COMMA_SOURCE_FILE_AT_LINE (77)) ;
        }else{
          var_cas_inAbstractCategoryMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((GGS_string (true, "an abstract category method '"))._operator_concat (var_cas_inAbstractCategoryMethodName))._operator_concat (GGS_string (true, "' is defined for abstract class '@")))._operator_concat (var_cas_inClassNameForErrorSignaling))._operator_concat (GGS_string (true, "', but concrete descendant class '@")))._operator_concat (var_cas_descendantClassName))._operator_concat (GGS_string (true, "' does not implement this method")) COMMA_SOURCE_FILE_AT_LINE (88)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkCategoryDefinitionForClass\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "performProjectGlobalCheckings"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_performProjectGlobalCheckings (C_Compiler & _inLexique,
                                const GGS_parsedComponentStruct  var_cas_inParsedComponentStruct,
                                const GGS_location   var_cas_inEndOfSourceFile COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_performProjectGlobalCheckings at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticDeclarationList  var_cas_semanticDeclarationList ;
  var_cas_semanticDeclarationList = GGS_semanticDeclarationList ::constructor_emptyList () ;
  {
    GGS_parsedSemanticsComponentMap::cEnumerator enumerator_5135 (var_cas_inParsedComponentStruct.reader_mParsedSemanticsComponentMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (101)), true) ;
    const GGS_parsedSemanticsComponentMap::cElement * operand_5135 = NULL ;
    while (((operand_5135 = enumerator_5135.nextObject ()))) {
      macroValidPointer (operand_5135) ;
      var_cas_semanticDeclarationList._dotAssign_operation (operand_5135->mInfo.mRoot.reader_mSemanticDeclarations (_inLexique COMMA_SOURCE_FILE_AT_LINE (102)).reader_mSemanticDeclarationList (_inLexique COMMA_SOURCE_FILE_AT_LINE (102))) ;
    }
  }
  GGS_semanticContext var_cas_semanticContext ;
  ::routine_buildSemanticContext (_inLexique,  var_cas_semanticDeclarationList,  var_cas_inEndOfSourceFile,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (106)) ;
  if (((GGS_uint ::constructor_errorCount (_inLexique COMMA_HERE))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_abstractCategoryMethodListMap var_cas_abstractCategoryMethodListMap ;
    var_cas_abstractCategoryMethodListMap = GGS_abstractCategoryMethodListMap::constructor_emptyMap () ;
    GGS_categoryMethodListMap var_cas_categoryMethodListMap ;
    var_cas_categoryMethodListMap = GGS_categoryMethodListMap::constructor_emptyMap () ;
    GGS_overridingCategoryMethodListMap var_cas_overridingCategoryMethodListMap ;
    var_cas_overridingCategoryMethodListMap = GGS_overridingCategoryMethodListMap::constructor_emptyMap () ;
    {
      GGS_parsedSemanticsComponentMap::cEnumerator enumerator_5837 (var_cas_inParsedComponentStruct.reader_mParsedSemanticsComponentMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (113)), true) ;
      const GGS_parsedSemanticsComponentMap::cElement * operand_5837 = NULL ;
      while (((operand_5837 = enumerator_5837.nextObject ()))) {
        macroValidPointer (operand_5837) ;
        var_cas_abstractCategoryMethodListMap._dotAssign_operation (operand_5837->mInfo.mRoot.reader_mSemanticDeclarations (_inLexique COMMA_SOURCE_FILE_AT_LINE (114)).reader_mAbstractCategoryMethodListMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (114))) ;
        var_cas_overridingCategoryMethodListMap._dotAssign_operation (operand_5837->mInfo.mRoot.reader_mSemanticDeclarations (_inLexique COMMA_SOURCE_FILE_AT_LINE (115)).reader_mOverridingCategoryMethodListMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (115))) ;
      }
    }
    GGS_descendantClassListMap var_cas_descendantClassListMap ;
    var_cas_descendantClassListMap = var_cas_semanticContext.reader_mDescendantClassListMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (117)) ;
    {
      GGS_abstractCategoryMethodListMap::cEnumerator enumerator_6263 (var_cas_abstractCategoryMethodListMap, true) ;
      while (enumerator_6263.hc ()) {
        {
          GGS_abstractCategoryMethodList::cEnumerator enumerator_6287 (enumerator_6263._object (HERE), true) ;
          const GGS_abstractCategoryMethodList::cElement * operand_6287 = NULL ;
          while (((operand_6287 = enumerator_6287.nextObject ()))) {
            macroValidPointer (operand_6287) ;
            ::routine_checkCategoryDefinitionForClass (_inLexique,  enumerator_6263._key (HERE),  enumerator_6263._key (HERE),  operand_6287->mAbstractCategoryMethodName,  var_cas_descendantClassListMap,  var_cas_overridingCategoryMethodListMap COMMA_SOURCE_FILE_AT_LINE (120)) ;
          }
        }
        enumerator_6263.next () ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_performProjectGlobalCheckings\n") ;
  #endif
}

//---------------------------------------------------------------------------*

