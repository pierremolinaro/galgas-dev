//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticsTypes.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 23th, 2010, at 11h53'43"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ACGalgasType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ACGalgasType::
cPtr_ACGalgasType (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ACGalgasType * GGS_ACGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ACGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ACGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
method_checkTypeCrossReferences (C_CompilerEx & /* inLexique */,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_ACGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@ACGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ACGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ACGalgasType (& typeid (cPtr_ACGalgasType), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ACGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__ACGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ACGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ACGalgasType ("ACGalgasType", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ACGalgasType::
GGS_ACGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ACGalgasType GGS_ACGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ACGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ACGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ACGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ACGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ACGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ACGalgasType::actualTypeName (void) const {
  return "ACGalgasType" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_ACGalgasType::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__ACGalgasType ("ACGalgasType", & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ACGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ACGalgasType * p = NULL ;
    macroMyNew (p, GGS_ACGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ACGalgasType GGS_ACGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ACGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ACGalgasType * p = dynamic_cast <const GGS_ACGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ACGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ACGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ACGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_typeMap'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeMap::e_typeMap (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@typeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMap ("typeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeMap::
elementOf_GGS_typeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeMap * ptr = dynamic_cast <const elementOf_GGS_typeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mType.operator_isEqual (ptr->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeMap * info = (e_typeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
operator_isEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMap::
operator_isNotEqual (const GGS_typeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ACGalgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeMap info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ACGalgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ACGalgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ACGalgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ACGalgasType  & GGS_typeMap::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMap * p = NULL ;
    macroMyNew (p, GGS_typeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMap GGS_typeMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMap * p = dynamic_cast <const GGS_typeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        map index '@typeMapIndex'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMapIndex ("typeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeMapIndex GGS_typeMapIndex::
constructor_null (C_CompilerEx & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
operator_isEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapIndex::
operator_isNotEqual (const GGS_typeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @typeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
class_method_makeRegularIndex (C_CompilerEx & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_typeMap & ioMap,
                               GGS_typeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

const utf32 GGS_typeMapIndex::kMapIndexSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeMapIndex::
method_searchKey (C_CompilerEx & inLexique,
                   GGS_lstring & outKey,
                   GGS_ACGalgasType & outAttribute1
                   COMMA_LOCATION_ARGS) const {
  bool shouldDropArguments = true ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      AC_galgas_map::emitMapSemanticErrorMessage (inLexique, mKey,
                                                  kMapIndexSearchMessage_searchKey
                                                  COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_typeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_typeMap * p = (const elementOf_GGS_typeMap *) mIndex.retrieve () ;
      outKey = mKey ;
      outAttribute1 = p->mInfo.mType ;
      shouldDropArguments = false ;
    }
    break ;
  case kNull:
    inLexique.onTheFlyRunTimeError ("key access on a null index" COMMA_THERE) ;
    break ;
  }
  if (shouldDropArguments) {
    outKey.drop () ;
    outAttribute1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMapIndex * p = NULL ;
    macroMyNew (p, GGS_typeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex GGS_typeMapIndex::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMapIndex * p = dynamic_cast <const GGS_typeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMapIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@sortedTypeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedTypeList::
elementOf_GGS_sortedTypeList (const GGS_ACGalgasType & argument_0,
                                const GGS_string& argument_1):
mType (argument_0),
mSortString (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedTypeList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedTypeList * ptr = dynamic_cast <const elementOf_GGS_sortedTypeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mSortString.operator_isEqual (ptr->mSortString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_sortedTypeList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_sortedTypeList * operand = (const elementOf_GGS_sortedTypeList *) inOperand ;
  PMSInt32 result = mSortString.compareForSortedList (operand->mSortString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedTypeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortString.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Sorted list '@sortedTypeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedTypeList ("sortedTypeList", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_sortedTypeList::GGS_sortedTypeList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList::
GGS_sortedTypeList (const GGS_sortedTypeList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedTypeList::
operator_isEqual (const GGS_sortedTypeList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedTypeList::
operator_isNotEqual (const GGS_sortedTypeList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
internalAppendValues (const GGS_ACGalgasType & argument_0,
                    const GGS_string& argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
addAssign_operation (const GGS_ACGalgasType & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList GGS_sortedTypeList::
operator_concat (const GGS_sortedTypeList & inOperand) const {
  GGS_sortedTypeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
dotAssign_operation (const GGS_sortedTypeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortedTypeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ACGalgasType  p_0 = p->mType ;
          GGS_string p_1 = p->mSortString ;
          internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mSortString) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList  GGS_sortedTypeList::
constructor_emptySortedList (void) {
  GGS_sortedTypeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList  GGS_sortedTypeList::
constructor_sortedListWithValue (const GGS_ACGalgasType & argument_0,
                           const GGS_string& argument_1) {
  GGS_sortedTypeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedTypeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortedTypeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
method_smallest (C_CompilerEx & inLexique,
                 GGS_ACGalgasType & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
method_greatest (C_CompilerEx & inLexique,
             GGS_ACGalgasType & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_ACGalgasType & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedTypeList::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_ACGalgasType & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mSortString ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_ACGalgasType  & GGS_sortedTypeList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_sortedTypeList::cEnumerator::_mSortString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortString ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortedTypeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedTypeList * p = NULL ;
    macroMyNew (p, GGS_sortedTypeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedTypeList GGS_sortedTypeList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedTypeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedTypeList * p = dynamic_cast <const GGS_sortedTypeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedTypeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedTypeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedTypeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@typeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeList::
elementOf_GGS_typeList (const GGS_ACGalgasType & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeList * ptr = dynamic_cast <const elementOf_GGS_typeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             List '@typeList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeList ("typeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeList::
internalAppendValues (const GGS_ACGalgasType & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
internalPrependValues (const GGS_ACGalgasType & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
addAssign_operation (const GGS_ACGalgasType & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
operator_concat (const GGS_typeList & inOperand) const {
  GGS_typeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
dotAssign_operation (const GGS_typeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ACGalgasType  p_0 = p->mType ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_ACGalgasType & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeList  GGS_typeList::
constructor_emptyList (void) {
  GGS_typeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList  GGS_typeList::
constructor_listWithValue (const GGS_ACGalgasType & argument_0) {
  GGS_typeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
internalSubListWithRange (GGS_typeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
method_first (C_CompilerEx & inLexique,
              GGS_ACGalgasType & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
method_last (C_CompilerEx & inLexique,
             GGS_ACGalgasType & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_ACGalgasType & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_ACGalgasType & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_ACGalgasType  GGS_typeList::
reader_mTypeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_ACGalgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeList::
modifier_setMTypeAtIndex (C_CompilerEx & inLexique,
                              const GGS_ACGalgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_ACGalgasType  & GGS_typeList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeList * p = NULL ;
    macroMyNew (p, GGS_typeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeList GGS_typeList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeList * p = dynamic_cast <const GGS_typeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@signature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_signature::
elementOf_GGS_signature (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mFormalArgumentName (argument_1),
mFormalArgumentPassingMode (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_signature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_signature * ptr = dynamic_cast <const elementOf_GGS_signature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_signature::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@signature'                              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_signature ("signature", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_signature::
internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalArgumentPassingMode& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalArgumentPassingMode& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
operator_concat (const GGS_signature & inOperand) const {
  GGS_signature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
dotAssign_operation (const GGS_signature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_signature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mFormalArgumentName ;
          GGS_formalArgumentPassingMode p_2 = p->mFormalArgumentPassingMode ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalArgumentPassingMode& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mFormalArgumentName,
                                ptr->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_signature::
constructor_emptyList (void) {
  GGS_signature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_signature::
constructor_listWithValue (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalArgumentPassingMode& argument_2) {
  GGS_signature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
internalSubListWithRange (GGS_signature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mFormalArgumentName, ptr->mFormalArgumentPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_signature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_signature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_signature::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@signature", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
method_first (C_CompilerEx & inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1,
              GGS_formalArgumentPassingMode& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
method_last (C_CompilerEx & inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1,
             GGS_formalArgumentPassingMode& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalArgumentPassingMode& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1,
                GGS_formalArgumentPassingMode& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_signature::
reader_mAttributeTypeIndexAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_signature::
reader_mFormalArgumentNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingMode GGS_signature::
reader_mFormalArgumentPassingModeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingMode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_setMAttributeTypeIndexAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_setMFormalArgumentNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signature::
modifier_setMFormalArgumentPassingModeAtIndex (C_CompilerEx & inLexique,
                              const GGS_formalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_signature::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_signature::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingMode & GGS_signature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_signature::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_signature * p = NULL ;
    macroMyNew (p, GGS_signature (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature GGS_signature::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_signature result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_signature * p = dynamic_cast <const GGS_signature *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_signature, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_signature::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_signature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@attributeList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeList::
elementOf_GGS_attributeList (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeList * ptr = dynamic_cast <const elementOf_GGS_attributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@attributeList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeList ("attributeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_attributeList::
internalAppendValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
internalPrependValues (const GGS_typeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
addAssign_operation (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
operator_concat (const GGS_attributeList & inOperand) const {
  GGS_attributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
dotAssign_operation (const GGS_attributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_attributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mAttributeName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeMapIndex & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_emptyList (void) {
  GGS_attributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_attributeList::
constructor_listWithValue (const GGS_typeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_attributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
internalSubListWithRange (GGS_attributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@attributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_first (C_CompilerEx & inLexique,
              GGS_typeMapIndex & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
method_last (C_CompilerEx & inLexique,
             GGS_typeMapIndex & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeMapIndex & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeMapIndex & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_attributeList::
reader_mAttributeTypeIndexAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeList::
reader_mAttributeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_setMAttributeTypeIndexAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeList::
modifier_setMAttributeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeMapIndex  & GGS_attributeList::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeList * p = NULL ;
    macroMyNew (p, GGS_attributeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList GGS_attributeList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeList * p = dynamic_cast <const GGS_attributeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_primitiveGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_primitiveGalgasType::
cPtr_primitiveGalgasType (LOCATION_ARGS)
:cPtr_ACGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_primitiveGalgasType * GGS_primitiveGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_primitiveGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_primitiveGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_primitiveGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@primitiveGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_primitiveGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_primitiveGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_primitiveGalgasType (& typeid (cPtr_primitiveGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_primitiveGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__primitiveGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_primitiveGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_primitiveGalgasType ("primitiveGalgasType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_primitiveGalgasType::
GGS_primitiveGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_primitiveGalgasType::
GGS_primitiveGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_primitiveGalgasType GGS_primitiveGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_primitiveGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_primitiveGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_primitiveGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_primitiveGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_primitiveGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_primitiveGalgasType::actualTypeName (void) const {
  return "primitiveGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__primitiveGalgasType ("primitiveGalgasType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_primitiveGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_primitiveGalgasType * p = NULL ;
    macroMyNew (p, GGS_primitiveGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveGalgasType GGS_primitiveGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_primitiveGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_primitiveGalgasType * p = dynamic_cast <const GGS_primitiveGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_primitiveGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_primitiveGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_primitiveGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_dataGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_dataGalgasType::
cPtr_dataGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_dataGalgasType * GGS_dataGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_dataGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_dataGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_dataGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_dataGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@dataGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_dataGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_dataGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_dataGalgasType (& typeid (cPtr_dataGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_dataGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__dataGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_dataGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_dataGalgasType ("dataGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_dataGalgasType::
GGS_dataGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_dataGalgasType::
GGS_dataGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_dataGalgasType GGS_dataGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_dataGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_dataGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_dataGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_dataGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_dataGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_dataGalgasType * gSingleton_dataGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_dataGalgasType (void) {
  macroDetachPointer (gSingleton_dataGalgasType, cPtr_dataGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_dataGalgasType GGS_dataGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_dataGalgasType result ;
  if (NULL == gSingleton_dataGalgasType) {
    macroMyNew (gSingleton_dataGalgasType, cPtr_dataGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_dataGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_dataGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_dataGalgasType::actualTypeName (void) const {
  return "dataGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__dataGalgasType ("dataGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_dataGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_dataGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_dataGalgasType * p = NULL ;
    macroMyNew (p, GGS_dataGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dataGalgasType GGS_dataGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_dataGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_dataGalgasType * p = dynamic_cast <const GGS_dataGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_dataGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_dataGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_dataGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasType::
cPtr_typeGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasType * GGS_typeGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasType (& typeid (cPtr_typeGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasType ("typeGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasType::
GGS_typeGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasType::
GGS_typeGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasType GGS_typeGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgasType * gSingleton_typeGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgasType (void) {
  macroDetachPointer (gSingleton_typeGalgasType, cPtr_typeGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasType GGS_typeGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasType result ;
  if (NULL == gSingleton_typeGalgasType) {
    macroMyNew (gSingleton_typeGalgasType, cPtr_typeGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasType::actualTypeName (void) const {
  return "typeGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasType ("typeGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_typeGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasType GGS_typeGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasType * p = dynamic_cast <const GGS_typeGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_objectGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_objectGalgasType::
cPtr_objectGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_objectGalgasType * GGS_objectGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_objectGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_objectGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_objectGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_objectGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@objectGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_objectGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_objectGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_objectGalgasType (& typeid (cPtr_objectGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_objectGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__objectGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_objectGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_objectGalgasType ("objectGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_objectGalgasType::
GGS_objectGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_objectGalgasType::
GGS_objectGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_objectGalgasType GGS_objectGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_objectGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_objectGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_objectGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_objectGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_objectGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_objectGalgasType * gSingleton_objectGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_objectGalgasType (void) {
  macroDetachPointer (gSingleton_objectGalgasType, cPtr_objectGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_objectGalgasType GGS_objectGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_objectGalgasType result ;
  if (NULL == gSingleton_objectGalgasType) {
    macroMyNew (gSingleton_objectGalgasType, cPtr_objectGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_objectGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_objectGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_objectGalgasType::actualTypeName (void) const {
  return "objectGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__objectGalgasType ("objectGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_objectGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_objectGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_objectGalgasType * p = NULL ;
    macroMyNew (p, GGS_objectGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectGalgasType GGS_objectGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_objectGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_objectGalgasType * p = dynamic_cast <const GGS_objectGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_objectGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_objectGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_objectGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_functionGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionGalgasType::
cPtr_functionGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionGalgasType * GGS_functionGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_functionGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_functionGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@functionGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionGalgasType (& typeid (cPtr_functionGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__functionGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_functionGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionGalgasType ("functionGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_functionGalgasType::
GGS_functionGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionGalgasType::
GGS_functionGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionGalgasType GGS_functionGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_functionGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_functionGalgasType * gSingleton_functionGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_functionGalgasType (void) {
  macroDetachPointer (gSingleton_functionGalgasType, cPtr_functionGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_functionGalgasType GGS_functionGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_functionGalgasType result ;
  if (NULL == gSingleton_functionGalgasType) {
    macroMyNew (gSingleton_functionGalgasType, cPtr_functionGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_functionGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_functionGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionGalgasType::actualTypeName (void) const {
  return "functionGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionGalgasType ("functionGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_functionGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionGalgasType * p = NULL ;
    macroMyNew (p, GGS_functionGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionGalgasType GGS_functionGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionGalgasType * p = dynamic_cast <const GGS_functionGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_locationGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_locationGalgasType::
cPtr_locationGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_locationGalgasType * GGS_locationGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_locationGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_locationGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_locationGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_locationGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@locationGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_locationGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_locationGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_locationGalgasType (& typeid (cPtr_locationGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_locationGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__locationGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_locationGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_locationGalgasType ("locationGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_locationGalgasType::
GGS_locationGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType::
GGS_locationGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_locationGalgasType GGS_locationGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_locationGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_locationGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_locationGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_locationGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_locationGalgasType * gSingleton_locationGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_locationGalgasType (void) {
  macroDetachPointer (gSingleton_locationGalgasType, cPtr_locationGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType GGS_locationGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType result ;
  if (NULL == gSingleton_locationGalgasType) {
    macroMyNew (gSingleton_locationGalgasType, cPtr_locationGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_locationGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_locationGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_locationGalgasType::actualTypeName (void) const {
  return "locationGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__locationGalgasType ("locationGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_locationGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_locationGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_locationGalgasType * p = NULL ;
    macroMyNew (p, GGS_locationGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationGalgasType GGS_locationGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_locationGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_locationGalgasType * p = dynamic_cast <const GGS_locationGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_locationGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_locationGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_locationGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_stringGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringGalgasType::
cPtr_stringGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringGalgasType * GGS_stringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@stringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringGalgasType (& typeid (cPtr_stringGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__stringGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_stringGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringGalgasType ("stringGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType::
GGS_stringGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringGalgasType GGS_stringGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_stringGalgasType * gSingleton_stringGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_stringGalgasType (void) {
  macroDetachPointer (gSingleton_stringGalgasType, cPtr_stringGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType GGS_stringGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  if (NULL == gSingleton_stringGalgasType) {
    macroMyNew (gSingleton_stringGalgasType, cPtr_stringGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_stringGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_stringGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringGalgasType::actualTypeName (void) const {
  return "stringGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringGalgasType ("stringGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_stringGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringGalgasType * p = NULL ;
    macroMyNew (p, GGS_stringGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringGalgasType GGS_stringGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringGalgasType * p = dynamic_cast <const GGS_stringGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_charGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charGalgasType::
cPtr_charGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charGalgasType * GGS_charGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_charGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_charGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_charGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@charGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charGalgasType (& typeid (cPtr_charGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_charGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__charGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_charGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_charGalgasType ("charGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType::
GGS_charGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_charGalgasType GGS_charGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_charGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_charGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_charGalgasType * gSingleton_charGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_charGalgasType (void) {
  macroDetachPointer (gSingleton_charGalgasType, cPtr_charGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType GGS_charGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  if (NULL == gSingleton_charGalgasType) {
    macroMyNew (gSingleton_charGalgasType, cPtr_charGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_charGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_charGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charGalgasType::actualTypeName (void) const {
  return "charGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__charGalgasType ("charGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_charGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_charGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_charGalgasType * p = NULL ;
    macroMyNew (p, GGS_charGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charGalgasType GGS_charGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_charGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_charGalgasType * p = dynamic_cast <const GGS_charGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_charGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_charGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_charGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_boolGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolGalgasType::
cPtr_boolGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolGalgasType * GGS_boolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_boolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_boolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_boolGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@boolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolGalgasType (& typeid (cPtr_boolGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_boolGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__boolGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_boolGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_boolGalgasType ("boolGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType::
GGS_boolGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_boolGalgasType GGS_boolGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_boolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_boolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_boolGalgasType * gSingleton_boolGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_boolGalgasType (void) {
  macroDetachPointer (gSingleton_boolGalgasType, cPtr_boolGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType GGS_boolGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  if (NULL == gSingleton_boolGalgasType) {
    macroMyNew (gSingleton_boolGalgasType, cPtr_boolGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_boolGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_boolGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolGalgasType::actualTypeName (void) const {
  return "boolGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__boolGalgasType ("boolGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_boolGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_boolGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_boolGalgasType * p = NULL ;
    macroMyNew (p, GGS_boolGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolGalgasType GGS_boolGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_boolGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_boolGalgasType * p = dynamic_cast <const GGS_boolGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_boolGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_boolGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_boolGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_uintGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintGalgasType::
cPtr_uintGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintGalgasType * GGS_uintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uintGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@uintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintGalgasType (& typeid (cPtr_uintGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__uintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_uintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uintGalgasType ("uintGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType::
GGS_uintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uintGalgasType GGS_uintGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_uintGalgasType * gSingleton_uintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_uintGalgasType (void) {
  macroDetachPointer (gSingleton_uintGalgasType, cPtr_uintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType GGS_uintGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  if (NULL == gSingleton_uintGalgasType) {
    macroMyNew (gSingleton_uintGalgasType, cPtr_uintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_uintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_uintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintGalgasType::actualTypeName (void) const {
  return "uintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uintGalgasType ("uintGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_uintGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uintGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uintGalgasType * p = NULL ;
    macroMyNew (p, GGS_uintGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintGalgasType GGS_uintGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uintGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uintGalgasType * p = dynamic_cast <const GGS_uintGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uintGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uintGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_sintGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintGalgasType::
cPtr_sintGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintGalgasType * GGS_sintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sintGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@sintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintGalgasType (& typeid (cPtr_sintGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__sintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_sintGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sintGalgasType ("sintGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType::
GGS_sintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sintGalgasType GGS_sintGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_sintGalgasType * gSingleton_sintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_sintGalgasType (void) {
  macroDetachPointer (gSingleton_sintGalgasType, cPtr_sintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType GGS_sintGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  if (NULL == gSingleton_sintGalgasType) {
    macroMyNew (gSingleton_sintGalgasType, cPtr_sintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_sintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_sintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintGalgasType::actualTypeName (void) const {
  return "sintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sintGalgasType ("sintGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_sintGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sintGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sintGalgasType * p = NULL ;
    macroMyNew (p, GGS_sintGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintGalgasType GGS_sintGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sintGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sintGalgasType * p = dynamic_cast <const GGS_sintGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sintGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sintGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_uint64GalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64GalgasType::
cPtr_uint64GalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64GalgasType * GGS_uint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64GalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@uint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64GalgasType (& typeid (cPtr_uint64GalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__uint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64GalgasType ("uint64GalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType::
GGS_uint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64GalgasType GGS_uint64GalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_uint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_uint64GalgasType * gSingleton_uint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_uint64GalgasType (void) {
  macroDetachPointer (gSingleton_uint64GalgasType, cPtr_uint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType GGS_uint64GalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  if (NULL == gSingleton_uint64GalgasType) {
    macroMyNew (gSingleton_uint64GalgasType, cPtr_uint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_uint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_uint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64GalgasType::actualTypeName (void) const {
  return "uint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64GalgasType ("uint64GalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_uint64GalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64GalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64GalgasType * p = NULL ;
    macroMyNew (p, GGS_uint64GalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64GalgasType GGS_uint64GalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64GalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64GalgasType * p = dynamic_cast <const GGS_uint64GalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64GalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64GalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_sint64GalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64GalgasType::
cPtr_sint64GalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64GalgasType * GGS_sint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64GalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@sint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64GalgasType (& typeid (cPtr_sint64GalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__sint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint64GalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64GalgasType ("sint64GalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType::
GGS_sint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64GalgasType GGS_sint64GalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_sint64GalgasType * gSingleton_sint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_sint64GalgasType (void) {
  macroDetachPointer (gSingleton_sint64GalgasType, cPtr_sint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType GGS_sint64GalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  if (NULL == gSingleton_sint64GalgasType) {
    macroMyNew (gSingleton_sint64GalgasType, cPtr_sint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_sint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_sint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64GalgasType::actualTypeName (void) const {
  return "sint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64GalgasType ("sint64GalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_sint64GalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64GalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64GalgasType * p = NULL ;
    macroMyNew (p, GGS_sint64GalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64GalgasType GGS_sint64GalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64GalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64GalgasType * p = dynamic_cast <const GGS_sint64GalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64GalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64GalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_doubleGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doubleGalgasType::
cPtr_doubleGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doubleGalgasType * GGS_doubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_doubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_doubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_doubleGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@doubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doubleGalgasType (& typeid (cPtr_doubleGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_doubleGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__doubleGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_doubleGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_doubleGalgasType ("doubleGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType::
GGS_doubleGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_doubleGalgasType GGS_doubleGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_doubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_doubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_doubleGalgasType * gSingleton_doubleGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_doubleGalgasType (void) {
  macroDetachPointer (gSingleton_doubleGalgasType, cPtr_doubleGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType GGS_doubleGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  if (NULL == gSingleton_doubleGalgasType) {
    macroMyNew (gSingleton_doubleGalgasType, cPtr_doubleGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_doubleGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_doubleGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doubleGalgasType::actualTypeName (void) const {
  return "doubleGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__doubleGalgasType ("doubleGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_doubleGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_doubleGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_doubleGalgasType * p = NULL ;
    macroMyNew (p, GGS_doubleGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doubleGalgasType GGS_doubleGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_doubleGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_doubleGalgasType * p = dynamic_cast <const GGS_doubleGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_doubleGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_doubleGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_doubleGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_lstringGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lstringGalgasType::
cPtr_lstringGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lstringGalgasType * GGS_lstringGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lstringGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lstringGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lstringGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lstringGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lstringGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lstringGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lstringGalgasType (& typeid (cPtr_lstringGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lstringGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lstringGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lstringGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lstringGalgasType ("lstringGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType::
GGS_lstringGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lstringGalgasType GGS_lstringGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lstringGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lstringGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lstringGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lstringGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lstringGalgasType * gSingleton_lstringGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lstringGalgasType (void) {
  macroDetachPointer (gSingleton_lstringGalgasType, cPtr_lstringGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType GGS_lstringGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  if (NULL == gSingleton_lstringGalgasType) {
    macroMyNew (gSingleton_lstringGalgasType, cPtr_lstringGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lstringGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lstringGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lstringGalgasType::actualTypeName (void) const {
  return "lstringGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lstringGalgasType ("lstringGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_lstringGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lstringGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lstringGalgasType * p = NULL ;
    macroMyNew (p, GGS_lstringGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringGalgasType GGS_lstringGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lstringGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lstringGalgasType * p = dynamic_cast <const GGS_lstringGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lstringGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lstringGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lstringGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_lcharGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lcharGalgasType::
cPtr_lcharGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lcharGalgasType * GGS_lcharGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lcharGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lcharGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lcharGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lcharGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lcharGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lcharGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lcharGalgasType (& typeid (cPtr_lcharGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lcharGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lcharGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lcharGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lcharGalgasType ("lcharGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType::
GGS_lcharGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lcharGalgasType GGS_lcharGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lcharGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lcharGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lcharGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lcharGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lcharGalgasType * gSingleton_lcharGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lcharGalgasType (void) {
  macroDetachPointer (gSingleton_lcharGalgasType, cPtr_lcharGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType GGS_lcharGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  if (NULL == gSingleton_lcharGalgasType) {
    macroMyNew (gSingleton_lcharGalgasType, cPtr_lcharGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lcharGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lcharGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lcharGalgasType::actualTypeName (void) const {
  return "lcharGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lcharGalgasType ("lcharGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_lcharGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lcharGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lcharGalgasType * p = NULL ;
    macroMyNew (p, GGS_lcharGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lcharGalgasType GGS_lcharGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lcharGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lcharGalgasType * p = dynamic_cast <const GGS_lcharGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lcharGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lcharGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lcharGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_lboolGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lboolGalgasType::
cPtr_lboolGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lboolGalgasType * GGS_lboolGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lboolGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lboolGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lboolGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lboolGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lboolGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lboolGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lboolGalgasType (& typeid (cPtr_lboolGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lboolGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lboolGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lboolGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lboolGalgasType ("lboolGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType::
GGS_lboolGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lboolGalgasType GGS_lboolGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lboolGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lboolGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lboolGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lboolGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lboolGalgasType * gSingleton_lboolGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lboolGalgasType (void) {
  macroDetachPointer (gSingleton_lboolGalgasType, cPtr_lboolGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType GGS_lboolGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  if (NULL == gSingleton_lboolGalgasType) {
    macroMyNew (gSingleton_lboolGalgasType, cPtr_lboolGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lboolGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lboolGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lboolGalgasType::actualTypeName (void) const {
  return "lboolGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lboolGalgasType ("lboolGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_lboolGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lboolGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lboolGalgasType * p = NULL ;
    macroMyNew (p, GGS_lboolGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lboolGalgasType GGS_lboolGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lboolGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lboolGalgasType * p = dynamic_cast <const GGS_lboolGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lboolGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lboolGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lboolGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_luintGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luintGalgasType::
cPtr_luintGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luintGalgasType * GGS_luintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luintGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@luintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luintGalgasType (& typeid (cPtr_luintGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_luintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__luintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_luintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_luintGalgasType ("luintGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType::
GGS_luintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_luintGalgasType GGS_luintGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_luintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_luintGalgasType * gSingleton_luintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_luintGalgasType (void) {
  macroDetachPointer (gSingleton_luintGalgasType, cPtr_luintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType GGS_luintGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  if (NULL == gSingleton_luintGalgasType) {
    macroMyNew (gSingleton_luintGalgasType, cPtr_luintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_luintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_luintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luintGalgasType::actualTypeName (void) const {
  return "luintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__luintGalgasType ("luintGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_luintGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_luintGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_luintGalgasType * p = NULL ;
    macroMyNew (p, GGS_luintGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luintGalgasType GGS_luintGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_luintGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_luintGalgasType * p = dynamic_cast <const GGS_luintGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_luintGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_luintGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_luintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_lsintGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsintGalgasType::
cPtr_lsintGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsintGalgasType * GGS_lsintGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsintGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsintGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsintGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsintGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lsintGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsintGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsintGalgasType (& typeid (cPtr_lsintGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lsintGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lsintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_lsintGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lsintGalgasType ("lsintGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType::
GGS_lsintGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lsintGalgasType GGS_lsintGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsintGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsintGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lsintGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsintGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lsintGalgasType * gSingleton_lsintGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lsintGalgasType (void) {
  macroDetachPointer (gSingleton_lsintGalgasType, cPtr_lsintGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType GGS_lsintGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  if (NULL == gSingleton_lsintGalgasType) {
    macroMyNew (gSingleton_lsintGalgasType, cPtr_lsintGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lsintGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lsintGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsintGalgasType::actualTypeName (void) const {
  return "lsintGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lsintGalgasType ("lsintGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_lsintGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lsintGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lsintGalgasType * p = NULL ;
    macroMyNew (p, GGS_lsintGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsintGalgasType GGS_lsintGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lsintGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lsintGalgasType * p = dynamic_cast <const GGS_lsintGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lsintGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lsintGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lsintGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_luint64GalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luint64GalgasType::
cPtr_luint64GalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luint64GalgasType * GGS_luint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_luint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_luint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_luint64GalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@luint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luint64GalgasType (& typeid (cPtr_luint64GalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_luint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__luint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_luint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_luint64GalgasType ("luint64GalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType::
GGS_luint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_luint64GalgasType GGS_luint64GalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_luint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_luint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_luint64GalgasType * gSingleton_luint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_luint64GalgasType (void) {
  macroDetachPointer (gSingleton_luint64GalgasType, cPtr_luint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType GGS_luint64GalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  if (NULL == gSingleton_luint64GalgasType) {
    macroMyNew (gSingleton_luint64GalgasType, cPtr_luint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_luint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_luint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luint64GalgasType::actualTypeName (void) const {
  return "luint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__luint64GalgasType ("luint64GalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_luint64GalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_luint64GalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_luint64GalgasType * p = NULL ;
    macroMyNew (p, GGS_luint64GalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64GalgasType GGS_luint64GalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_luint64GalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_luint64GalgasType * p = dynamic_cast <const GGS_luint64GalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_luint64GalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_luint64GalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_luint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_lsint64GalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsint64GalgasType::
cPtr_lsint64GalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsint64GalgasType * GGS_lsint64GalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lsint64GalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_lsint64GalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsint64GalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_lsint64GalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@lsint64GalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsint64GalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsint64GalgasType (& typeid (cPtr_lsint64GalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lsint64GalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__lsint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lsint64GalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lsint64GalgasType ("lsint64GalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType::
GGS_lsint64GalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lsint64GalgasType GGS_lsint64GalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsint64GalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_lsint64GalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lsint64GalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsint64GalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_lsint64GalgasType * gSingleton_lsint64GalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_lsint64GalgasType (void) {
  macroDetachPointer (gSingleton_lsint64GalgasType, cPtr_lsint64GalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType GGS_lsint64GalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  if (NULL == gSingleton_lsint64GalgasType) {
    macroMyNew (gSingleton_lsint64GalgasType, cPtr_lsint64GalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_lsint64GalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_lsint64GalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsint64GalgasType::actualTypeName (void) const {
  return "lsint64GalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lsint64GalgasType ("lsint64GalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_lsint64GalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lsint64GalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lsint64GalgasType * p = NULL ;
    macroMyNew (p, GGS_lsint64GalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64GalgasType GGS_lsint64GalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lsint64GalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lsint64GalgasType * p = dynamic_cast <const GGS_lsint64GalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lsint64GalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lsint64GalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lsint64GalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ldoubleGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ldoubleGalgasType::
cPtr_ldoubleGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ldoubleGalgasType * GGS_ldoubleGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ldoubleGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ldoubleGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ldoubleGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_ldoubleGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@ldoubleGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ldoubleGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ldoubleGalgasType (& typeid (cPtr_ldoubleGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ldoubleGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__ldoubleGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ldoubleGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ldoubleGalgasType ("ldoubleGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType::
GGS_ldoubleGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ldoubleGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_ldoubleGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ldoubleGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ldoubleGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_ldoubleGalgasType * gSingleton_ldoubleGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_ldoubleGalgasType (void) {
  macroDetachPointer (gSingleton_ldoubleGalgasType, cPtr_ldoubleGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType GGS_ldoubleGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  if (NULL == gSingleton_ldoubleGalgasType) {
    macroMyNew (gSingleton_ldoubleGalgasType, cPtr_ldoubleGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_ldoubleGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_ldoubleGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ldoubleGalgasType::actualTypeName (void) const {
  return "ldoubleGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ldoubleGalgasType ("ldoubleGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_ldoubleGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ldoubleGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ldoubleGalgasType * p = NULL ;
    macroMyNew (p, GGS_ldoubleGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldoubleGalgasType GGS_ldoubleGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ldoubleGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ldoubleGalgasType * p = dynamic_cast <const GGS_ldoubleGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ldoubleGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ldoubleGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ldoubleGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_stringsetGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetGalgasType::
cPtr_stringsetGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetGalgasType * GGS_stringsetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_stringsetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_stringsetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@stringsetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetGalgasType (& typeid (cPtr_stringsetGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringsetGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__stringsetGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_stringsetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringsetGalgasType ("stringsetGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType::
GGS_stringsetGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringsetGalgasType GGS_stringsetGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringsetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_stringsetGalgasType * gSingleton_stringsetGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_stringsetGalgasType (void) {
  macroDetachPointer (gSingleton_stringsetGalgasType, cPtr_stringsetGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType GGS_stringsetGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  if (NULL == gSingleton_stringsetGalgasType) {
    macroMyNew (gSingleton_stringsetGalgasType, cPtr_stringsetGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_stringsetGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_stringsetGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetGalgasType::actualTypeName (void) const {
  return "stringsetGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringsetGalgasType ("stringsetGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_stringsetGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringsetGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringsetGalgasType * p = NULL ;
    macroMyNew (p, GGS_stringsetGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetGalgasType GGS_stringsetGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringsetGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringsetGalgasType * p = dynamic_cast <const GGS_stringsetGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringsetGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringsetGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringsetGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_binarysetGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetGalgasType::
cPtr_binarysetGalgasType (LOCATION_ARGS)
:cPtr_primitiveGalgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetGalgasType * GGS_binarysetGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_binarysetGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_binarysetGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@binarysetGalgasType:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetGalgasType (& typeid (cPtr_binarysetGalgasType), & typeid (cPtr_primitiveGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_binarysetGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__binarysetGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_binarysetGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_binarysetGalgasType ("binarysetGalgasType", true, & kTypeDescriptor_GGS_primitiveGalgasType) ;

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType::
GGS_binarysetGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_binarysetGalgasType GGS_binarysetGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_binarysetGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_binarysetGalgasType * gSingleton_binarysetGalgasType = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_binarysetGalgasType (void) {
  macroDetachPointer (gSingleton_binarysetGalgasType, cPtr_binarysetGalgasType) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType GGS_binarysetGalgasType::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  if (NULL == gSingleton_binarysetGalgasType) {
    macroMyNew (gSingleton_binarysetGalgasType, cPtr_binarysetGalgasType (THERE)) ;
    registerReleaseRoutine (cleanUp_binarysetGalgasType) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_binarysetGalgasType) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetGalgasType::actualTypeName (void) const {
  return "binarysetGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__binarysetGalgasType ("binarysetGalgasType", gClassInfoFor__primitiveGalgasType, & kTypeDescriptor_GGS_binarysetGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_binarysetGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_binarysetGalgasType * p = NULL ;
    macroMyNew (p, GGS_binarysetGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetGalgasType GGS_binarysetGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_binarysetGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_binarysetGalgasType * p = dynamic_cast <const GGS_binarysetGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_binarysetGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_binarysetGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_binarysetGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@classMethodList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMethodList::
elementOf_GGS_classMethodList (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mMethodSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classMethodList * ptr = dynamic_cast <const elementOf_GGS_classMethodList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mMethodSignature.operator_isEqual (ptr->mMethodSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMethodList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodSignature.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@classMethodList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMethodList ("classMethodList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_classMethodList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_signature & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_signature & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
operator_concat (const GGS_classMethodList & inOperand) const {
  GGS_classMethodList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
dotAssign_operation (const GGS_classMethodList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_classMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_signature  p_1 = p->mMethodSignature ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_signature & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mMethodSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classMethodList::
constructor_emptyList (void) {
  GGS_classMethodList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList  GGS_classMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_signature & argument_1) {
  GGS_classMethodList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
internalSubListWithRange (GGS_classMethodList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mMethodSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classMethodList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classMethodList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMethodList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@classMethodList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_signature & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_signature & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_signature & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_signature & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mMethodSignature ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMethodList::
reader_mMethodNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signature  GGS_classMethodList::
reader_mMethodSignatureAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_signature  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_setMMethodNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodList::
modifier_setMMethodSignatureAtIndex (C_CompilerEx & inLexique,
                              const GGS_signature  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_classMethodList::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signature  & GGS_classMethodList::cEnumerator::_mMethodSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classMethodList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMethodList * p = NULL ;
    macroMyNew (p, GGS_classMethodList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodList GGS_classMethodList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMethodList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMethodList * p = dynamic_cast <const GGS_classMethodList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMethodList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMethodList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMethodList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_classGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classGalgasType::
cPtr_classGalgasType (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeMapIndex & argument_2,
                                const GGS_attributeList & argument_3,
                                const GGS_classMethodList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mIsAbstract (argument_0),
mClassName (argument_1),
mSuperClassIndex (argument_2),
mAttributeList (argument_3),
mMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classGalgasType * GGS_classGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classGalgasType * ptr = dynamic_cast <const cPtr_classGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mSuperClassIndex.operator_isEqual (ptr->mSuperClassIndex).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
method_checkTypeCrossReferences (C_CompilerEx & inLexique,
                                GGS_uint  var_cas_inTypeCount COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_classPath = mClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (342)) ;
  GGS_stringset  var_cas_superClassSet = GGS_stringset ::constructor_setWithString (mClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (343))) ;
  GGS_typeMapIndex  var_cas_superClassIndex = mSuperClassIndex ;
  GGS_bool var_cas_circularityError = GGS_bool (false) ;
  GGS_bool var_cas_ok = GGS_bool (true) ;
  GGS_uint _variant_17708 = var_cas_inTypeCount ;
  GGS_bool _condition_17708 (_variant_17708.isBuilt (), true) ;
  while (_condition_17708.isBuiltAndTrue ()) {
    _condition_17708 = ((var_cas_superClassIndex.reader_isRegular (inLexique COMMA_SOURCE_FILE_AT_LINE (348))).operator_and (var_cas_ok)).operator_and ((var_cas_circularityError).operator_not ()) ;
    if (_condition_17708.isBuiltAndTrue ()) {
      if (_variant_17708.uintValue () == 0) {
        inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (369)) ;
        _condition_17708 = GGS_bool (false) ;
      }else{
        _variant_17708.decrement_operation (inLexique COMMA_HERE) ;
        GGS_lstring  var_cas_superClassName ;
        GGS_ACGalgasType  var_cas_t ;
        const GGS_typeMapIndex  temp_16963 = var_cas_superClassIndex ;
        if (temp_16963.isBuilt ()) {
          temp_16963 (HERE)->method_searchKey (inLexique, var_cas_superClassName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (352)) ;
        }
        var_cas_circularityError = var_cas_superClassSet.reader_hasKey (var_cas_superClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (354))) ;
        var_cas_superClassSet.addAssign_operation (var_cas_superClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (355))) ;
        var_cas_classPath.appendCString (".") ;
        var_cas_classPath.dotAssign_operation (var_cas_superClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (356))) ;
        GGS_typeMapIndex  var_cas_superSuperClassIndex ;
        { const GGS_ACGalgasType _var_17645 = var_cas_t ; // CAST instruction
          if (_var_17645.getPtr () != NULL) {
            macroValidPointer (_var_17645.getPtr ()) ;
            if (dynamic_cast <cPtr_classGalgasType *> (_var_17645.getPtr ()) != NULL) {
              const GGS_classGalgasType var_cas_kClassType (_var_17645.getPtr ()) ;
              var_cas_superSuperClassIndex = var_cas_kClassType.reader_mSuperClassIndex (inLexique COMMA_SOURCE_FILE_AT_LINE (361)) ;
            }else{
              mClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this class inherits from @")).operator_concat (var_cas_superClassName)).operator_concat (GGS_string (", but @"))).operator_concat (var_cas_superClassName)).operator_concat (GGS_string (" is not a class")) COMMA_SOURCE_FILE_AT_LINE (367)) ;
              var_cas_superSuperClassIndex.drop () ;
            }
          }
        }
        var_cas_superClassIndex = var_cas_superSuperClassIndex ;
      }
    }
  }
  const GGS_bool cond_17955 = var_cas_circularityError ;
  if (cond_17955.isBuiltAndTrue ()) {
    mClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("inheritance circularity for class '")).operator_concat (mClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (374)))).operator_concat (GGS_string ("': "))).operator_concat (var_cas_classPath.reader_stringByReplacingStringByString (inLexique, GGS_string ("."), GGS_string (" extends ") COMMA_SOURCE_FILE_AT_LINE (375))) COMMA_SOURCE_FILE_AT_LINE (376)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_classGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classGalgasType:"
           << mIsAbstract.reader_description (inIndentation + 1)
           << mClassName.reader_description (inIndentation + 1)
           << mSuperClassIndex.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classGalgasType (& typeid (cPtr_classGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__classGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classGalgasType (mIsAbstract, mClassName, mSuperClassIndex, mAttributeList, mMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_classGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classGalgasType ("classGalgasType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType::
GGS_classGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classGalgasType GGS_classGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_classGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType GGS_classGalgasType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeMapIndex & argument_2,
                 const GGS_attributeList & argument_3,
                 const GGS_classMethodList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  macroMyNew (result.mPointer, cPtr_classGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classGalgasType::
reader_mIsAbstract (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapIndex  GGS_classGalgasType::
reader_mSuperClassIndex (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classGalgasType *) mPointer)->mSuperClassIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classGalgasType::actualTypeName (void) const {
  return "classGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classGalgasType ("classGalgasType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_classGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classGalgasType * p = NULL ;
    macroMyNew (p, GGS_classGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classGalgasType GGS_classGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classGalgasType * p = dynamic_cast <const GGS_classGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_listGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listGalgasType::
cPtr_listGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listGalgasType * GGS_listGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listGalgasType * ptr = dynamic_cast <const cPtr_listGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listGalgasType:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listGalgasType (& typeid (cPtr_listGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__listGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listGalgasType (mListTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_listGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listGalgasType ("listGalgasType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType::
GGS_listGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listGalgasType GGS_listGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_listGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType GGS_listGalgasType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  macroMyNew (result.mPointer, cPtr_listGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listGalgasType::
reader_mListTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listGalgasType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeList  GGS_listGalgasType::
reader_mAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listGalgasType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listGalgasType::actualTypeName (void) const {
  return "listGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listGalgasType ("listGalgasType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_listGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listGalgasType * p = NULL ;
    macroMyNew (p, GGS_listGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listGalgasType GGS_listGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listGalgasType * p = dynamic_cast <const GGS_listGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_listmapGalgasType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapGalgasType::
cPtr_listmapGalgasType (const GGS_lstring & argument_0,
                                const GGS_typeMapIndex & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListmapTypeName (argument_0),
mAssociatedListTypeIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapGalgasType * GGS_listmapGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listmapGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapGalgasType * ptr = dynamic_cast <const cPtr_listmapGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mAssociatedListTypeIndex.operator_isEqual (ptr->mAssociatedListTypeIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapGalgasType::
method_checkTypeCrossReferences (C_CompilerEx & inLexique,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring  var_cas_listTypeName ;
  GGS_ACGalgasType  var_cas_t ;
  const GGS_typeMapIndex  temp_19191 = mAssociatedListTypeIndex ;
  if (temp_19191.isBuilt ()) {
    temp_19191 (HERE)->method_searchKey (inLexique, var_cas_listTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (405)) ;
  }
  { const GGS_ACGalgasType _var_19460 = var_cas_t ; // CAST instruction
    if (_var_19460.getPtr () != NULL) {
      macroValidPointer (_var_19460.getPtr ()) ;
      if (dynamic_cast <cPtr_listGalgasType *> (_var_19460.getPtr ()) != NULL) {
      }else{
        var_cas_listTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this mapindex type refers to @")).operator_concat (var_cas_listTypeName)).operator_concat (GGS_string (" as a list, but @"))).operator_concat (var_cas_listTypeName)).operator_concat (GGS_string (" is not a list")) COMMA_SOURCE_FILE_AT_LINE (413)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_listmapGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listmapGalgasType:"
           << mListmapTypeName.reader_description (inIndentation + 1)
           << mAssociatedListTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapGalgasType (& typeid (cPtr_listmapGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listmapGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__listmapGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapGalgasType (mListmapTypeName, mAssociatedListTypeIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_listmapGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listmapGalgasType ("listmapGalgasType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_listmapGalgasType::
GGS_listmapGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapGalgasType::
GGS_listmapGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapGalgasType GGS_listmapGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_listmapGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapGalgasType GGS_listmapGalgasType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeMapIndex & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listmapGalgasType result ;
  macroMyNew (result.mPointer, cPtr_listmapGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapGalgasType::actualTypeName (void) const {
  return "listmapGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listmapGalgasType ("listmapGalgasType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_listmapGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listmapGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listmapGalgasType * p = NULL ;
    macroMyNew (p, GGS_listmapGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapGalgasType GGS_listmapGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listmapGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listmapGalgasType * p = dynamic_cast <const GGS_listmapGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listmapGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listmapGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listmapGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_structGalgasType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structGalgasType::
cPtr_structGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structGalgasType * GGS_structGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_structGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structGalgasType * ptr = dynamic_cast <const cPtr_structGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructTypeName.operator_isEqual (ptr->mStructTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structGalgasType:"
           << mStructTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structGalgasType (& typeid (cPtr_structGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__structGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structGalgasType (mStructTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_structGalgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structGalgasType ("structGalgasType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_structGalgasType::
GGS_structGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structGalgasType::
GGS_structGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structGalgasType GGS_structGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_structGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structGalgasType GGS_structGalgasType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structGalgasType result ;
  macroMyNew (result.mPointer, cPtr_structGalgasType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structGalgasType::actualTypeName (void) const {
  return "structGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structGalgasType ("structGalgasType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_structGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structGalgasType * p = NULL ;
    macroMyNew (p, GGS_structGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structGalgasType GGS_structGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structGalgasType * p = dynamic_cast <const GGS_structGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sortDescriptorList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortDescriptorList::
elementOf_GGS_sortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortDescriptorList * ptr = dynamic_cast <const elementOf_GGS_sortDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortDescriptorList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@sortDescriptorList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortDescriptorList ("sortDescriptorList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
operator_concat (const GGS_sortDescriptorList & inOperand) const {
  GGS_sortDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
dotAssign_operation (const GGS_sortDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_emptyList (void) {
  GGS_sortDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_sortDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
internalSubListWithRange (GGS_sortDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortDescriptorList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortDescriptorList::
reader_mAttributeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortDescriptorList::
reader_mAscendingAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_setMAttributeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_setMAscendingAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sortDescriptorList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortDescriptorList::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortDescriptorList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortDescriptorList * p = NULL ;
    macroMyNew (p, GGS_sortDescriptorList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortDescriptorList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortDescriptorList * p = dynamic_cast <const GGS_sortDescriptorList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortDescriptorList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortDescriptorList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortDescriptorList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_sortedlistGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedlistGalgasType::
cPtr_sortedlistGalgasType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1,
                                const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedlistGalgasType * GGS_sortedlistGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sortedlistGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedlistGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedlistGalgasType * ptr = dynamic_cast <const cPtr_sortedlistGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedlistGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sortedlistGalgasType:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedlistGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedlistGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedlistGalgasType (& typeid (cPtr_sortedlistGalgasType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sortedlistGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__sortedlistGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedlistGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedlistGalgasType (mListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sortedlistGalgasType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedlistGalgasType ("sortedlistGalgasType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType::
GGS_sortedlistGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType::
GGS_sortedlistGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedlistGalgasType GGS_sortedlistGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedlistGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_sortedlistGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedlistGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedlistGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType GGS_sortedlistGalgasType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1,
                 const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType result ;
  macroMyNew (result.mPointer, cPtr_sortedlistGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortedlistGalgasType::
reader_mSortDescriptorList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortDescriptorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedlistGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedlistGalgasType *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedlistGalgasType::actualTypeName (void) const {
  return "sortedlistGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sortedlistGalgasType ("sortedlistGalgasType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_sortedlistGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sortedlistGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedlistGalgasType * p = NULL ;
    macroMyNew (p, GGS_sortedlistGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedlistGalgasType GGS_sortedlistGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedlistGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedlistGalgasType * p = dynamic_cast <const GGS_sortedlistGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedlistGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedlistGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedlistGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_mapMethodMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapMethodMap::e_mapMethodMap (void) :
mMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@mapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapMethodMap ("mapMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodMap::
elementOf_GGS_mapMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapMethodMap * ptr = dynamic_cast <const elementOf_GGS_mapMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMessage.operator_isEqual (ptr->mInfo.mMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapMethodMap::
operator_isEqual (const GGS_mapMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapMethodMap::
operator_isNotEqual (const GGS_mapMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapMethodMap info  ;
    info.mMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_mapMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodMap::cEnumerator::_mMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapMethodMap * p = NULL ;
    macroMyNew (p, GGS_mapMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapMethodMap * p = dynamic_cast <const GGS_mapMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapMethodMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_mapType'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapType::
cPtr_mapType (const GGS_lstring & argument_0,
                                const GGS_attributeList & argument_1,
                                const GGS_mapMethodMap & argument_2,
                                const GGS_mapMethodMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1),
mInsertMethodMap (argument_2),
mRemoveMethodMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapType * GGS_mapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapType * ptr = dynamic_cast <const cPtr_mapType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mInsertMethodMap.operator_isEqual (ptr->mInsertMethodMap).boolValue ()
         && mRemoveMethodMap.operator_isEqual (ptr->mRemoveMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapType:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mInsertMethodMap.reader_description (inIndentation + 1)
           << mRemoveMethodMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapType (& typeid (cPtr_mapType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapType::galgasRTTI (void) const {
  return & gClassInfoFor__mapType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapType (mMapTypeName, mAttributeList, mInsertMethodMap, mRemoveMethodMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_mapType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapType ("mapType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_mapType::
GGS_mapType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapType::
GGS_mapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapType GGS_mapType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapType *> (inPointer) != NULL)
      : (typeid (cPtr_mapType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapType GGS_mapType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeList & argument_1,
                 const GGS_mapMethodMap & argument_2,
                 const GGS_mapMethodMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapType result ;
  macroMyNew (result.mPointer, cPtr_mapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapType::actualTypeName (void) const {
  return "mapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapType ("mapType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_mapType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapType * p = NULL ;
    macroMyNew (p, GGS_mapType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapType GGS_mapType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapType * p = dynamic_cast <const GGS_mapType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_mapindexType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexType::
cPtr_mapindexType (const GGS_lstring & argument_0,
                                const GGS_typeMapIndex & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mMapIndexTypeName (argument_0),
mIndexOfMapType (argument_1),
mSearchMethodName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexType * GGS_mapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexType * ptr = dynamic_cast <const cPtr_mapindexType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapIndexTypeName.operator_isEqual (ptr->mMapIndexTypeName).boolValue ()
         && mIndexOfMapType.operator_isEqual (ptr->mIndexOfMapType).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexType::
method_checkTypeCrossReferences (C_CompilerEx & inLexique,
                                GGS_uint  /* var_cas_inTypeCount */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring  var_cas_mapTypeName ;
  GGS_ACGalgasType  var_cas_t ;
  const GGS_typeMapIndex  temp_22338 = mIndexOfMapType ;
  if (temp_22338.isBuilt ()) {
    temp_22338 (HERE)->method_searchKey (inLexique, var_cas_mapTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (481)) ;
  }
  { const GGS_ACGalgasType _var_22592 = var_cas_t ; // CAST instruction
    if (_var_22592.getPtr () != NULL) {
      macroValidPointer (_var_22592.getPtr ()) ;
      if (dynamic_cast <cPtr_mapType *> (_var_22592.getPtr ()) != NULL) {
      }else{
        var_cas_mapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this mapindex type refers to @")).operator_concat (var_cas_mapTypeName)).operator_concat (GGS_string (" as a map, but @"))).operator_concat (var_cas_mapTypeName)).operator_concat (GGS_string (" is not a map")) COMMA_SOURCE_FILE_AT_LINE (489)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_mapindexType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapindexType:"
           << mMapIndexTypeName.reader_description (inIndentation + 1)
           << mIndexOfMapType.reader_description (inIndentation + 1)
           << mSearchMethodName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexType (& typeid (cPtr_mapindexType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapindexType::galgasRTTI (void) const {
  return & gClassInfoFor__mapindexType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapindexType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapindexType (mMapIndexTypeName, mIndexOfMapType, mSearchMethodName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mapindexType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapindexType ("mapindexType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType::
GGS_mapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapindexType GGS_mapindexType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType GGS_mapindexType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeMapIndex & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  macroMyNew (result.mPointer, cPtr_mapindexType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexType::actualTypeName (void) const {
  return "mapindexType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapindexType ("mapindexType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_mapindexType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapindexType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapindexType * p = NULL ;
    macroMyNew (p, GGS_mapindexType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexType GGS_mapindexType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapindexType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapindexType * p = dynamic_cast <const GGS_mapindexType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapindexType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapindexType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapindexType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@enumConstructorMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumConstructorMap ("enumConstructorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumConstructorMap::
elementOf_GGS_enumConstructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstructorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumConstructorMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstructorMap * info = (e_enumConstructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumConstructorMap * info = (e_enumConstructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumConstructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstructorMap::
operator_isEqual (const GGS_enumConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstructorMap::
operator_isNotEqual (const GGS_enumConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumConstructorMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumConstructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (','),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumConstructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumConstructorMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_enumConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumConstructorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumConstructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumConstructorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumConstructorMap * p = NULL ;
    macroMyNew (p, GGS_enumConstructorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstructorMap GGS_enumConstructorMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumConstructorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumConstructorMap * p = dynamic_cast <const GGS_enumConstructorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumConstructorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumConstructorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumConstructorMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageMap ("enumMessageMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageMap::
elementOf_GGS_enumMessageMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageMap::
operator_isEqual (const GGS_enumMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageMap::
operator_isNotEqual (const GGS_enumMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
insertElement (C_CompilerEx & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumMessageMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
searchElement (C_CompilerEx & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumMessageMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumMessageMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_enumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumMessageMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageMap * p = NULL ;
    macroMyNew (p, GGS_enumMessageMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageMap * p = dynamic_cast <const GGS_enumMessageMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_enumType'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumType::
cPtr_enumType (const GGS_lstring & argument_0,
                                const GGS_enumConstructorMap & argument_1,
                                const GGS_enumMessageMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_ACGalgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstructorMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumType * GGS_enumType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumType * ptr = dynamic_cast <const cPtr_enumType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mEnumConstructorMap.operator_isEqual (ptr->mEnumConstructorMap).boolValue ()
         && mEnumMessageMap.operator_isEqual (ptr->mEnumMessageMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumType:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mEnumConstructorMap.reader_description (inIndentation + 1)
           << mEnumMessageMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumType (& typeid (cPtr_enumType), & typeid (cPtr_ACGalgasType), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumType::galgasRTTI (void) const {
  return & gClassInfoFor__enumType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumType (mEnumTypeName, mEnumConstructorMap, mEnumMessageMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_enumType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumType ("enumType", true, & kTypeDescriptor_GGS_ACGalgasType) ;

//---------------------------------------------------------------------------*

GGS_enumType::
GGS_enumType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumType::
GGS_enumType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumType GGS_enumType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumType *> (inPointer) != NULL)
      : (typeid (cPtr_enumType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumType GGS_enumType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstructorMap & argument_1,
                 const GGS_enumMessageMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumType result ;
  macroMyNew (result.mPointer, cPtr_enumType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumType::actualTypeName (void) const {
  return "enumType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumType ("enumType", gClassInfoFor__ACGalgasType, & kTypeDescriptor_GGS_enumType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumType * p = NULL ;
    macroMyNew (p, GGS_enumType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumType GGS_enumType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumType * p = dynamic_cast <const GGS_enumType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "addTypeList"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addTypeList (C_CompilerEx & inLexique,
                                const GGS_string  var_cas_inElementTypeName,
                                GGS_typeMap  & var_cas_ioTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addTypeList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_attributeList  var_cas_lstringAttribute = GGS_attributeList ::constructor_emptyList () ;
  GGS_typeMapIndex  var_cas_lstringIndex ;
  GGS_typeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inElementTypeName, GGS_location (inLexique) COMMA_HERE), var_cas_ioTypeMap, var_cas_lstringIndex COMMA_SOURCE_FILE_AT_LINE (532)) ;
  var_cas_lstringAttribute.addAssign_operation (var_cas_lstringIndex, GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
  GGS_lstring  var_cas_lstringlist = GGS_lstring ::constructor_new (inLexique, (var_cas_inElementTypeName).operator_concat (GGS_string ("list")), GGS_location (inLexique) COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (inLexique, var_cas_lstringlist, GGS_listGalgasType ::constructor_new (inLexique, var_cas_lstringlist, var_cas_lstringAttribute COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (535)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addTypeList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of once function "constructPrimitiveTypeMap"         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_typeMap  gCachedResultForOnceFunction_constructPrimitiveTypeMap ;
static bool gCacheFlagForOnceFunction_constructPrimitiveTypeMap = false ;

//---------------------------------------------------------------------------*

GGS_typeMap  function_constructPrimitiveTypeMap (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_constructPrimitiveTypeMap) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_constructPrimitiveTypeMap at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_typeMap  var_cas_outTypeMap ;
    var_cas_outTypeMap = GGS_typeMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), GGS_stringGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (543)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("char"), GGS_location (inLexique) COMMA_HERE), GGS_charGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (544)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_HERE), GGS_boolGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (545)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), GGS_uintGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (546)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint"), GGS_location (inLexique) COMMA_HERE), GGS_sintGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (547)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64"), GGS_location (inLexique) COMMA_HERE), GGS_uint64GalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (548)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint64"), GGS_location (inLexique) COMMA_HERE), GGS_sint64GalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (549)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("double"), GGS_location (inLexique) COMMA_HERE), GGS_doubleGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (550)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), GGS_lstringGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (551)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lchar"), GGS_location (inLexique) COMMA_HERE), GGS_lcharGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (552)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lbool"), GGS_location (inLexique) COMMA_HERE), GGS_lboolGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (553)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint"), GGS_location (inLexique) COMMA_HERE), GGS_luintGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (554)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint"), GGS_location (inLexique) COMMA_HERE), GGS_lsintGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (555)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint64"), GGS_location (inLexique) COMMA_HERE), GGS_luint64GalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (556)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint64"), GGS_location (inLexique) COMMA_HERE), GGS_lsint64GalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (557)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("ldouble"), GGS_location (inLexique) COMMA_HERE), GGS_ldoubleGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (558)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("binaryset"), GGS_location (inLexique) COMMA_HERE), GGS_binarysetGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (559)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("stringset"), GGS_location (inLexique) COMMA_HERE), GGS_stringsetGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (560)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_HERE), GGS_locationGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (561)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("data"), GGS_location (inLexique) COMMA_HERE), GGS_dataGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (562)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("type"), GGS_location (inLexique) COMMA_HERE), GGS_typeGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (563)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("function"), GGS_location (inLexique) COMMA_HERE), GGS_functionGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (564)) ;
    var_cas_outTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("object"), GGS_location (inLexique) COMMA_HERE), GGS_objectGalgasType ::constructor_new (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (565)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_constructPrimitiveTypeMap\n") ;
    #endif
    gCacheFlagForOnceFunction_constructPrimitiveTypeMap = true ;
    gCachedResultForOnceFunction_constructPrimitiveTypeMap = var_cas_outTypeMap ;
  }
  return gCachedResultForOnceFunction_constructPrimitiveTypeMap ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_constructPrimitiveTypeMap (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_typeMap  result = function_constructPrimitiveTypeMap (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_constructPrimitiveTypeMap ("constructPrimitiveTypeMap",
                              functionForGenericCall_constructPrimitiveTypeMap,
                              & kTypeDescriptor_GGS_typeMap ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "constructBuiltinTypeMap"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_typeMap  gCachedResultForOnceFunction_constructBuiltinTypeMap ;
static bool gCacheFlagForOnceFunction_constructBuiltinTypeMap = false ;

//---------------------------------------------------------------------------*

GGS_typeMap  function_constructBuiltinTypeMap (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_constructBuiltinTypeMap) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_constructBuiltinTypeMap at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_typeMap  var_cas_outTypeMap ;
    var_cas_outTypeMap = function_constructPrimitiveTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (571)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("lstring"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (573)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("string"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (575)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("type"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (577)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("uint64"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (579)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("luint"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (581)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("uint"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (583)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("function"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (585)) ;
    ::routine_addTypeList (inLexique,  GGS_string ("object"),  var_cas_outTypeMap COMMA_SOURCE_FILE_AT_LINE (587)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_constructBuiltinTypeMap\n") ;
    #endif
    gCacheFlagForOnceFunction_constructBuiltinTypeMap = true ;
    gCachedResultForOnceFunction_constructBuiltinTypeMap = var_cas_outTypeMap ;
  }
  return gCachedResultForOnceFunction_constructBuiltinTypeMap ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_constructBuiltinTypeMap (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_typeMap  result = function_constructBuiltinTypeMap (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_constructBuiltinTypeMap ("constructBuiltinTypeMap",
                              functionForGenericCall_constructBuiltinTypeMap,
                              & kTypeDescriptor_GGS_typeMap ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "build_lstringlist_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_ACGalgasType  gCachedResultForOnceFunction_build_lstringlist_type ;
static bool gCacheFlagForOnceFunction_build_lstringlist_type = false ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType  function_build_lstringlist_type (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_build_lstringlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_build_lstringlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_ACGalgasType  var_cas_outType ;
    const GGS_typeMap  var_cas_typeMap = function_constructBuiltinTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (593)) ;
    const GGS_typeMap  temp_27869 = var_cas_typeMap ;
    if (temp_27869.isBuilt ()) {
      temp_27869 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstringlist"), GGS_location (inLexique) COMMA_HERE), var_cas_outType COMMA_SOURCE_FILE_AT_LINE (594)) ;
    }
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_build_lstringlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_build_lstringlist_type = true ;
    gCachedResultForOnceFunction_build_lstringlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_build_lstringlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_build_lstringlist_type (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_ACGalgasType  result = function_build_lstringlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_build_lstringlist_type ("build_lstringlist_type",
                              functionForGenericCall_build_lstringlist_type,
                              & kTypeDescriptor_GGS_ACGalgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "build_stringlist_type"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_ACGalgasType  gCachedResultForOnceFunction_build_stringlist_type ;
static bool gCacheFlagForOnceFunction_build_stringlist_type = false ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType  function_build_stringlist_type (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_build_stringlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_build_stringlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_ACGalgasType  var_cas_outType ;
    const GGS_typeMap  var_cas_typeMap = function_constructBuiltinTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (600)) ;
    const GGS_typeMap  temp_28140 = var_cas_typeMap ;
    if (temp_28140.isBuilt ()) {
      temp_28140 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("stringlist"), GGS_location (inLexique) COMMA_HERE), var_cas_outType COMMA_SOURCE_FILE_AT_LINE (601)) ;
    }
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_build_stringlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_build_stringlist_type = true ;
    gCachedResultForOnceFunction_build_stringlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_build_stringlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_build_stringlist_type (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_ACGalgasType  result = function_build_stringlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_build_stringlist_type ("build_stringlist_type",
                              functionForGenericCall_build_stringlist_type,
                              & kTypeDescriptor_GGS_ACGalgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "build_uint64list_type"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_ACGalgasType  gCachedResultForOnceFunction_build_uint64list_type ;
static bool gCacheFlagForOnceFunction_build_uint64list_type = false ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType  function_build_uint64list_type (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_build_uint64list_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_build_uint64list_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_ACGalgasType  var_cas_outType ;
    const GGS_typeMap  var_cas_typeMap = function_constructBuiltinTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (607)) ;
    const GGS_typeMap  temp_28410 = var_cas_typeMap ;
    if (temp_28410.isBuilt ()) {
      temp_28410 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64list"), GGS_location (inLexique) COMMA_HERE), var_cas_outType COMMA_SOURCE_FILE_AT_LINE (608)) ;
    }
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_build_uint64list_type\n") ;
    #endif
    gCacheFlagForOnceFunction_build_uint64list_type = true ;
    gCachedResultForOnceFunction_build_uint64list_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_build_uint64list_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_build_uint64list_type (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_ACGalgasType  result = function_build_uint64list_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_build_uint64list_type ("build_uint64list_type",
                              functionForGenericCall_build_uint64list_type,
                              & kTypeDescriptor_GGS_ACGalgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of once function "build_typelist_type"            *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_ACGalgasType  gCachedResultForOnceFunction_build_typelist_type ;
static bool gCacheFlagForOnceFunction_build_typelist_type = false ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType  function_build_typelist_type (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_build_typelist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_build_typelist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_ACGalgasType  var_cas_outType ;
    const GGS_typeMap  var_cas_typeMap = function_constructBuiltinTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (614)) ;
    const GGS_typeMap  temp_28678 = var_cas_typeMap ;
    if (temp_28678.isBuilt ()) {
      temp_28678 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("typelist"), GGS_location (inLexique) COMMA_HERE), var_cas_outType COMMA_SOURCE_FILE_AT_LINE (615)) ;
    }
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_build_typelist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_build_typelist_type = true ;
    gCachedResultForOnceFunction_build_typelist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_build_typelist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_build_typelist_type (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_ACGalgasType  result = function_build_typelist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_build_typelist_type ("build_typelist_type",
                              functionForGenericCall_build_typelist_type,
                              & kTypeDescriptor_GGS_ACGalgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "build_objectlist_type"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_ACGalgasType  gCachedResultForOnceFunction_build_objectlist_type ;
static bool gCacheFlagForOnceFunction_build_objectlist_type = false ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType  function_build_objectlist_type (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_build_objectlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_build_objectlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_ACGalgasType  var_cas_outType ;
    const GGS_typeMap  var_cas_typeMap = function_constructBuiltinTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (621)) ;
    const GGS_typeMap  temp_28946 = var_cas_typeMap ;
    if (temp_28946.isBuilt ()) {
      temp_28946 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("objectlist"), GGS_location (inLexique) COMMA_HERE), var_cas_outType COMMA_SOURCE_FILE_AT_LINE (622)) ;
    }
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_build_objectlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_build_objectlist_type = true ;
    gCachedResultForOnceFunction_build_objectlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_build_objectlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_build_objectlist_type (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_ACGalgasType  result = function_build_objectlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_build_objectlist_type ("build_objectlist_type",
                              functionForGenericCall_build_objectlist_type,
                              & kTypeDescriptor_GGS_ACGalgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "build_functionlist_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_ACGalgasType  gCachedResultForOnceFunction_build_functionlist_type ;
static bool gCacheFlagForOnceFunction_build_functionlist_type = false ;

//---------------------------------------------------------------------------*

GGS_ACGalgasType  function_build_functionlist_type (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_build_functionlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_build_functionlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_ACGalgasType  var_cas_outType ;
    const GGS_typeMap  var_cas_typeMap = function_constructBuiltinTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (628)) ;
    const GGS_typeMap  temp_29218 = var_cas_typeMap ;
    if (temp_29218.isBuilt ()) {
      temp_29218 (HERE)->method_searchKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("functionlist"), GGS_location (inLexique) COMMA_HERE), var_cas_outType COMMA_SOURCE_FILE_AT_LINE (629)) ;
    }
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_build_functionlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_build_functionlist_type = true ;
    gCachedResultForOnceFunction_build_functionlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_build_functionlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_build_functionlist_type (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_ACGalgasType  result = function_build_functionlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_build_functionlist_type ("build_functionlist_type",
                              functionForGenericCall_build_functionlist_type,
                              & kTypeDescriptor_GGS_ACGalgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticsTypes (void) {
  gCachedResultForOnceFunction_constructPrimitiveTypeMap.drop () ;
  gCachedResultForOnceFunction_constructBuiltinTypeMap.drop () ;
  gCachedResultForOnceFunction_build_lstringlist_type.drop () ;
  gCachedResultForOnceFunction_build_stringlist_type.drop () ;
  gCachedResultForOnceFunction_build_uint64list_type.drop () ;
  gCachedResultForOnceFunction_build_typelist_type.drop () ;
  gCachedResultForOnceFunction_build_objectlist_type.drop () ;
  gCachedResultForOnceFunction_build_functionlist_type.drop () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsTypes (NULL, epilogueRoutineFor_semanticsTypes) ;

//---------------------------------------------------------------------------*

