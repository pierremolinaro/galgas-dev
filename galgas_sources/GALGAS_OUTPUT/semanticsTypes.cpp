//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticsTypes.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 25th, 2010, at 17h56'53"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@unifiedTypeMapIndexList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_unifiedTypeMapIndexList::
elementOf_GGS_unifiedTypeMapIndexList (const GGS_unifiedTypeMapIndex & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mType (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unifiedTypeMapIndexList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_unifiedTypeMapIndexList * ptr = dynamic_cast <const elementOf_GGS_unifiedTypeMapIndexList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unifiedTypeMapIndexList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@unifiedTypeMapIndexList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMapIndexList ("unifiedTypeMapIndexList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::
operator_concat (const GGS_unifiedTypeMapIndexList & inOperand) const {
  GGS_unifiedTypeMapIndexList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
dotAssign_operation (const GGS_unifiedTypeMapIndexList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_unifiedTypeMapIndexList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mType ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList  GGS_unifiedTypeMapIndexList::
constructor_emptyList (void) {
  GGS_unifiedTypeMapIndexList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList  GGS_unifiedTypeMapIndexList::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0) {
  GGS_unifiedTypeMapIndexList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
internalSubListWithRange (GGS_unifiedTypeMapIndexList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMapIndexList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@unifiedTypeMapIndexList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_unifiedTypeMapIndexList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_unifiedTypeMapIndexList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMapIndexList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMapIndexList * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMapIndexList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndexList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMapIndexList * p = dynamic_cast <const GGS_unifiedTypeMapIndexList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMapIndexList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMapIndexList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMapIndexList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_constructorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_constructorMap::e_constructorMap (void) :
mArgumentTypeList (),
mHasCompilerArgument (),
mReturnedType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorMap ("constructorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_constructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constructorMap * ptr = dynamic_cast <const elementOf_GGS_constructorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentTypeList.operator_isEqual (ptr->mInfo.mArgumentTypeList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_constructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator_isEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator_isNotEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_unifiedTypeMapIndex & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_constructorMap info  ;
    info.mArgumentTypeList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    info.mReturnedType = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_unifiedTypeMapIndex   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mArgumentTypeList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    outParameter2 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_constructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_unifiedTypeMapIndex   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_constructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constructorMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_unifiedTypeMapIndex & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_constructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_constructorMap::cEnumerator::_mArgumentTypeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_constructorMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_constructorMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_constructorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorMap * p = NULL ;
    macroMyNew (p, GGS_constructorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorMap * p = dynamic_cast <const GGS_constructorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'readerQualifier' Enumeration                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerQualifier ("readerQualifier", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_readerQualifier::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_isEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_isNotEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_infOrEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_supOrEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_strictInf (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_strictSup (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerQualifier::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @readerQualifier" ;
  switch (mValue) {
  case enum_isAbstract:
    s << " isAbstract>" ;
    break ;
  case enum_isBasic:
    s << " isBasic>" ;
    break ;
  case enum_isInherited:
    s << " isInherited>" ;
    break ;
  case enum_isOverriding:
    s << " isOverriding>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_readerQualifier::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerQualifier * p = NULL ;
    macroMyNew (p, GGS_readerQualifier (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerQualifier GGS_readerQualifier::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerQualifier result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerQualifier * p = dynamic_cast <const GGS_readerQualifier *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerQualifier, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerQualifier::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerQualifier ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_readerMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_readerMap::e_readerMap (void) :
mArgumentTypeList (),
mHasLexiqueArgument (),
mReturnedType (),
mQualifier (),
mImplicitConversionReader () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@readerMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerMap ("readerMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_readerMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasLexiqueArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mQualifier.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mImplicitConversionReader.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_readerMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_readerMap * ptr = dynamic_cast <const elementOf_GGS_readerMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentTypeList.operator_isEqual (ptr->mInfo.mArgumentTypeList)).boolValue ()
           && (mInfo.mHasLexiqueArgument.operator_isEqual (ptr->mInfo.mHasLexiqueArgument)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue ()
           && (mInfo.mQualifier.operator_isEqual (ptr->mInfo.mQualifier)).boolValue ()
           && (mInfo.mImplicitConversionReader.operator_isEqual (ptr->mInfo.mImplicitConversionReader)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_readerMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator_isEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator_isNotEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_unifiedTypeMapIndex & inParameter2,
                const GGS_readerQualifier& inParameter3,
                const GGS_string& inParameter4,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_readerMap info  ;
    info.mArgumentTypeList = inParameter0 ;
    info.mHasLexiqueArgument = inParameter1 ;
    info.mReturnedType = inParameter2 ;
    info.mQualifier = inParameter3 ;
    info.mImplicitConversionReader = inParameter4 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_unifiedTypeMapIndex   & outParameter2,
               GGS_readerQualifier  & outParameter3,
               GGS_string  & outParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mArgumentTypeList ;
    outParameter1 = node->mInfo.mHasLexiqueArgument ;
    outParameter2 = node->mInfo.mReturnedType ;
    outParameter3 = node->mInfo.mQualifier ;
    outParameter4 = node->mInfo.mImplicitConversionReader ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_readerMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_readerMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_unifiedTypeMapIndex   & outParameter2,
                                GGS_readerQualifier  & outParameter3,
                                GGS_string  & outParameter4 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_readerMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_readerMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_unifiedTypeMapIndex & inParameter2,
                                const GGS_readerQualifier& inParameter3,
                                const GGS_string& inParameter4 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_readerMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_readerMap::cEnumerator::_mArgumentTypeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_readerMap::cEnumerator::_mHasLexiqueArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasLexiqueArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_readerMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_readerQualifier & GGS_readerMap::cEnumerator::_mQualifier (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mQualifier ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_readerMap::cEnumerator::_mImplicitConversionReader (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImplicitConversionReader ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_readerMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerMap * p = NULL ;
    macroMyNew (p, GGS_readerMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerMap * p = dynamic_cast <const GGS_readerMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerMap ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList &  inParameter0,
                                const GGS_bool&  inParameter1,
                                const GGS_unifiedTypeMapIndex &  inParameter2,
                                const GGS_readerQualifier&  inParameter3,
                                const GGS_string&  inParameter4 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()
  && inParameter2.isBuilt ()
  && inParameter3.isBuilt ()
  && inParameter4.isBuilt ()) {
    insulateMap () ;
    e_readerMap info ;
    info.mArgumentTypeList =  inParameter0 ;
    info.mHasLexiqueArgument =  inParameter1 ;
    info.mReturnedType =  inParameter2 ;
    info.mQualifier =  inParameter3 ;
    info.mImplicitConversionReader =  inParameter4 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@formalParameterSignature'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterSignature::
elementOf_GGS_formalParameterSignature (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mParameterType (argument_0),
mFormalParameterPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterSignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterSignature * ptr = dynamic_cast <const elementOf_GGS_formalParameterSignature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mParameterType.operator_isEqual (ptr->mParameterType).boolValue ()
         && mFormalParameterPassingMode.operator_isEqual (ptr->mFormalParameterPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterSignature::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mParameterType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterPassingMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@formalParameterSignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterSignature ("formalParameterSignature", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_formalArgumentPassingModeAST& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_formalArgumentPassingModeAST& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
operator_concat (const GGS_formalParameterSignature & inOperand) const {
  GGS_formalParameterSignature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
dotAssign_operation (const GGS_formalParameterSignature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mParameterType ;
          GGS_formalArgumentPassingModeAST p_1 = p->mFormalParameterPassingMode ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0,
                     const GGS_formalArgumentPassingModeAST& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mParameterType,
                                ptr->mFormalParameterPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature  GGS_formalParameterSignature::
constructor_emptyList (void) {
  GGS_formalParameterSignature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature  GGS_formalParameterSignature::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1) {
  GGS_formalParameterSignature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalSubListWithRange (GGS_formalParameterSignature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mParameterType, ptr->mFormalParameterPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterSignature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterSignature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterSignature::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterSignature", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0,
              GGS_formalArgumentPassingModeAST& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0,
             GGS_formalArgumentPassingModeAST& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0,
                 GGS_formalArgumentPassingModeAST& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0,
                GGS_formalArgumentPassingModeAST& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_formalParameterSignature::
reader_mParameterTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mParameterType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterSignature::
reader_mFormalParameterPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_setMParameterTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mParameterType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_setMFormalParameterPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_formalParameterSignature::cEnumerator::_mParameterType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mParameterType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterSignature::cEnumerator::_mFormalParameterPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterPassingMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterSignature::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterSignature * p = NULL ;
    macroMyNew (p, GGS_formalParameterSignature (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterSignature result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterSignature * p = dynamic_cast <const GGS_formalParameterSignature *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterSignature, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterSignature::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_modifierMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_modifierMap::e_modifierMap (void) :
mParameterList (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@modifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierMap ("modifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_modifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_modifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_modifierMap * ptr = dynamic_cast <const elementOf_GGS_modifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_modifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator_isEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator_isNotEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_modifierMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_modifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_modifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_modifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_modifierMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_modifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_modifierMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_modifierMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_modifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierMap * p = NULL ;
    macroMyNew (p, GGS_modifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierMap * p = dynamic_cast <const GGS_modifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierMap ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap () ;
    e_modifierMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_instanceMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_instanceMethodMap::e_instanceMethodMap (void) :
mParameterList (),
mDeclarationLocation (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@instanceMethodMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_instanceMethodMap ("instanceMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_instanceMethodMap::
elementOf_GGS_instanceMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_instanceMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instanceMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDeclarationLocation.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instanceMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_instanceMethodMap * ptr = dynamic_cast <const elementOf_GGS_instanceMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mDeclarationLocation.operator_isEqual (ptr->mInfo.mDeclarationLocation)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_instanceMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_instanceMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_instanceMethodMap * info = (e_instanceMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_instanceMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_instanceMethodMap * info = (e_instanceMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_instanceMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_instanceMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instanceMethodMap::
operator_isEqual (const GGS_instanceMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instanceMethodMap::
operator_isNotEqual (const GGS_instanceMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                const GGS_location & inParameter1,
                const GGS_bool& inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_instanceMethodMap info  ;
    info.mParameterList = inParameter0 ;
    info.mDeclarationLocation = inParameter1 ;
    info.mHasCompilerArgument = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_location   & outParameter1,
               GGS_bool  & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mDeclarationLocation ;
    outParameter2 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kSearchMessage_searchInheritedKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('o'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('\''),
  TO_UNICODE (','),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_location   & outParameter1,
                                GGS_bool  & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
method_searchInheritedKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_location   & outParameter1,
                                GGS_bool  & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchInheritedKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_location & inParameter1,
                                const GGS_bool& inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_instanceMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_instanceMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instanceMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instanceMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @instanceMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_instanceMethodMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_instanceMethodMap::cEnumerator::_mDeclarationLocation (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDeclarationLocation ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_instanceMethodMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_instanceMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_instanceMethodMap * p = NULL ;
    macroMyNew (p, GGS_instanceMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_instanceMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_instanceMethodMap * p = dynamic_cast <const GGS_instanceMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_instanceMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_instanceMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_instanceMethodMap ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_location &  inParameter1,
                                const GGS_bool&  inParameter2 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()
  && inParameter2.isBuilt ()) {
    insulateMap () ;
    e_instanceMethodMap info ;
    info.mParameterList =  inParameter0 ;
    info.mDeclarationLocation =  inParameter1 ;
    info.mHasCompilerArgument =  inParameter2 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_classMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_classMethodMap::e_classMethodMap (void) :
mParameterList (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@classMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMethodMap ("classMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_classMethodMap::
elementOf_GGS_classMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_classMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_classMethodMap * ptr = dynamic_cast <const elementOf_GGS_classMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMethodMap * info = (e_classMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_classMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_classMethodMap * info = (e_classMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_classMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMethodMap::
operator_isEqual (const GGS_classMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMethodMap::
operator_isNotEqual (const GGS_classMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_classMethodMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_classMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @classMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_classMethodMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_classMethodMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMethodMap * p = NULL ;
    macroMyNew (p, GGS_classMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMethodMap * p = dynamic_cast <const GGS_classMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMethodMap ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap () ;
    e_classMethodMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@enumerationDescriptorList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumerationDescriptorList::
elementOf_GGS_enumerationDescriptorList (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumeratedType (argument_0),
mEnumerationName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumerationDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumerationDescriptorList * ptr = dynamic_cast <const elementOf_GGS_enumerationDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumeratedType.operator_isEqual (ptr->mEnumeratedType).boolValue ()
         && mEnumerationName.operator_isEqual (ptr->mEnumerationName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumerationDescriptorList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumerationName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumerationDescriptorList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumerationDescriptorList ("enumerationDescriptorList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
operator_concat (const GGS_enumerationDescriptorList & inOperand) const {
  GGS_enumerationDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
dotAssign_operation (const GGS_enumerationDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumerationDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mEnumeratedType ;
          GGS_string p_1 = p->mEnumerationName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumeratedType,
                                ptr->mEnumerationName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_enumerationDescriptorList::
constructor_emptyList (void) {
  GGS_enumerationDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_enumerationDescriptorList::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_string& argument_1) {
  GGS_enumerationDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalSubListWithRange (GGS_enumerationDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumeratedType, ptr->mEnumerationName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumerationDescriptorList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumerationDescriptorList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_enumerationDescriptorList::
reader_mEnumeratedTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumerationDescriptorList::
reader_mEnumerationNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumerationName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_setMEnumeratedTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_setMEnumerationNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumerationName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_enumerationDescriptorList::cEnumerator::_mEnumeratedType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumerationDescriptorList::cEnumerator::_mEnumerationName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumerationName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumerationDescriptorList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumerationDescriptorList * p = NULL ;
    macroMyNew (p, GGS_enumerationDescriptorList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumerationDescriptorList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumerationDescriptorList * p = dynamic_cast <const GGS_enumerationDescriptorList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumerationDescriptorList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumerationDescriptorList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumerationDescriptorList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typedAttributeList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typedAttributeList::
elementOf_GGS_typedAttributeList (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typedAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typedAttributeList * ptr = dynamic_cast <const elementOf_GGS_typedAttributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typedAttributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typedAttributeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typedAttributeList ("typedAttributeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
operator_concat (const GGS_typedAttributeList & inOperand) const {
  GGS_typedAttributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
dotAssign_operation (const GGS_typedAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typedAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mAttributeName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_typedAttributeList::
constructor_emptyList (void) {
  GGS_typedAttributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_typedAttributeList::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typedAttributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalSubListWithRange (GGS_typedAttributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typedAttributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typedAttributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_typedAttributeList::
reader_mAttributeTypeIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typedAttributeList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMAttributeTypeIndexAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_typedAttributeList::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typedAttributeList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typedAttributeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typedAttributeList * p = NULL ;
    macroMyNew (p, GGS_typedAttributeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typedAttributeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typedAttributeList * p = dynamic_cast <const GGS_typedAttributeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typedAttributeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typedAttributeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typedAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Class for 'typeKindEnum' Enumeration                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeKindEnum ("typeKindEnum", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_typeKindEnum::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_isEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_isNotEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_infOrEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_supOrEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_strictInf (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_strictSup (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeKindEnum::
reader_kind (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [10] = {"",
    "class",
    "enumeration",
    "list map",
    "list",
    "map index",
    "map",
    "primitive",
    "sorted list",
    "struct"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeKindEnum::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @typeKindEnum" ;
  switch (mValue) {
  case enum_classType:
    s << " classType>" ;
    break ;
  case enum_enumType:
    s << " enumType>" ;
    break ;
  case enum_listMapType:
    s << " listMapType>" ;
    break ;
  case enum_listType:
    s << " listType>" ;
    break ;
  case enum_mapIndexType:
    s << " mapIndexType>" ;
    break ;
  case enum_mapType:
    s << " mapType>" ;
    break ;
  case enum_primitiveType:
    s << " primitiveType>" ;
    break ;
  case enum_sortedListType:
    s << " sortedListType>" ;
    break ;
  case enum_structType:
    s << " structType>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeKindEnum::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeKindEnum * p = NULL ;
    macroMyNew (p, GGS_typeKindEnum (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKindEnum GGS_typeKindEnum::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeKindEnum result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeKindEnum * p = dynamic_cast <const GGS_typeKindEnum *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeKindEnum, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeKindEnum::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeKindEnum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@nativeAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nativeAttributeList::
elementOf_GGS_nativeAttributeList (const GGS_string& argument_0,
                                const GGS_bool& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_string& argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCppClassName (argument_0),
mIsPointer (argument_1),
mAttributeName (argument_2),
mUseReferenceForConstructor (argument_3),
mGetterName (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nativeAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_nativeAttributeList * ptr = dynamic_cast <const elementOf_GGS_nativeAttributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppClassName.operator_isEqual (ptr->mCppClassName).boolValue ()
         && mIsPointer.operator_isEqual (ptr->mIsPointer).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mUseReferenceForConstructor.operator_isEqual (ptr->mUseReferenceForConstructor).boolValue ()
         && mGetterName.operator_isEqual (ptr->mGetterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nativeAttributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppClassName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsPointer.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseReferenceForConstructor.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGetterName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@nativeAttributeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nativeAttributeList ("nativeAttributeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_bool& argument_1,
                    const GGS_string& argument_2,
                    const GGS_bool& argument_3,
                    const GGS_string& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_bool& argument_1,
                    const GGS_string& argument_2,
                    const GGS_bool& argument_3,
                    const GGS_string& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_bool& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_string& argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList GGS_nativeAttributeList::
operator_concat (const GGS_nativeAttributeList & inOperand) const {
  GGS_nativeAttributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
dotAssign_operation (const GGS_nativeAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_nativeAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mCppClassName ;
          GGS_bool p_1 = p->mIsPointer ;
          GGS_string p_2 = p->mAttributeName ;
          GGS_bool p_3 = p->mUseReferenceForConstructor ;
          GGS_string p_4 = p->mGetterName ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_bool& argument_1,
                     const GGS_string& argument_2,
                     const GGS_bool& argument_3,
                     const GGS_string& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCppClassName,
                                ptr->mIsPointer,
                                ptr->mAttributeName,
                                ptr->mUseReferenceForConstructor,
                                ptr->mGetterName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList  GGS_nativeAttributeList::
constructor_emptyList (void) {
  GGS_nativeAttributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList  GGS_nativeAttributeList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_bool& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_string& argument_4) {
  GGS_nativeAttributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
internalSubListWithRange (GGS_nativeAttributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCppClassName, ptr->mIsPointer, ptr->mAttributeName, ptr->mUseReferenceForConstructor, ptr->mGetterName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList GGS_nativeAttributeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_nativeAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList GGS_nativeAttributeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_nativeAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nativeAttributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@nativeAttributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_bool& _out_1,
              GGS_string& _out_2,
              GGS_bool& _out_3,
              GGS_string& _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppClassName ;
    _out_1 = ptr->mIsPointer ;
    _out_2 = ptr->mAttributeName ;
    _out_3 = ptr->mUseReferenceForConstructor ;
    _out_4 = ptr->mGetterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_bool& _out_1,
             GGS_string& _out_2,
             GGS_bool& _out_3,
             GGS_string& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppClassName ;
    _out_1 = ptr->mIsPointer ;
    _out_2 = ptr->mAttributeName ;
    _out_3 = ptr->mUseReferenceForConstructor ;
    _out_4 = ptr->mGetterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_bool& _out_1,
                 GGS_string& _out_2,
                 GGS_bool& _out_3,
                 GGS_string& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppClassName ;
    _out_1 = ptr->mIsPointer ;
    _out_2 = ptr->mAttributeName ;
    _out_3 = ptr->mUseReferenceForConstructor ;
    _out_4 = ptr->mGetterName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_bool& _out_1,
                GGS_string& _out_2,
                GGS_bool& _out_3,
                GGS_string& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppClassName ;
    _out_1 = ptr->mIsPointer ;
    _out_2 = ptr->mAttributeName ;
    _out_3 = ptr->mUseReferenceForConstructor ;
    _out_4 = ptr->mGetterName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_nativeAttributeList::
reader_mCppClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nativeAttributeList::
reader_mIsPointerAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsPointer ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nativeAttributeList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nativeAttributeList::
reader_mUseReferenceForConstructorAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseReferenceForConstructor ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nativeAttributeList::
reader_mGetterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGetterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_setMCppClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_setMIsPointerAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsPointer = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_setMUseReferenceForConstructorAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseReferenceForConstructor = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nativeAttributeList::
modifier_setMGetterNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGetterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nativeAttributeList::cEnumerator::_mCppClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_nativeAttributeList::cEnumerator::_mIsPointer (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsPointer ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nativeAttributeList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_nativeAttributeList::cEnumerator::_mUseReferenceForConstructor (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseReferenceForConstructor ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nativeAttributeList::cEnumerator::_mGetterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGetterName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nativeAttributeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nativeAttributeList * p = NULL ;
    macroMyNew (p, GGS_nativeAttributeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList GGS_nativeAttributeList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nativeAttributeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nativeAttributeList * p = dynamic_cast <const GGS_nativeAttributeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nativeAttributeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nativeAttributeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nativeAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryAddOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryAddOperator (C_Compiler & COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryAddOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryAddOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryAddOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryAddOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryAddOperator ("binaryAddOperator",
                              functionForGenericCall_binaryAddOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binarySubOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binarySubOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binarySubOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (202)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binarySubOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binarySubOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binarySubOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binarySubOperator ("binarySubOperator",
                              functionForGenericCall_binarySubOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryMulOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryMulOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryMulOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (203)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryMulOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryMulOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryMulOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryMulOperator ("binaryMulOperator",
                              functionForGenericCall_binaryMulOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryDivOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryDivOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryDivOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (3U) COMMA_SOURCE_FILE_AT_LINE (204)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryDivOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryDivOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryDivOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryDivOperator ("binaryDivOperator",
                              functionForGenericCall_binaryDivOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryModOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryModOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryModOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (4U) COMMA_SOURCE_FILE_AT_LINE (205)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryModOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryModOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryModOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryModOperator ("binaryModOperator",
                              functionForGenericCall_binaryModOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of function "binaryShiftOperator"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryShiftOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryShiftOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (5U) COMMA_SOURCE_FILE_AT_LINE (206)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryShiftOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryShiftOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryShiftOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryShiftOperator ("binaryShiftOperator",
                              functionForGenericCall_binaryShiftOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "unaryPlusOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_unaryPlusOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_unaryPlusOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (6U) COMMA_SOURCE_FILE_AT_LINE (207)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_unaryPlusOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryPlusOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryPlusOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryPlusOperator ("unaryPlusOperator",
                              functionForGenericCall_unaryPlusOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of function "unaryMinusOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_unaryMinusOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_unaryMinusOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (7U) COMMA_SOURCE_FILE_AT_LINE (208)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_unaryMinusOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryMinusOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryMinusOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryMinusOperator ("unaryMinusOperator",
                              functionForGenericCall_unaryMinusOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of function "unaryTildeOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_unaryTildeOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_unaryTildeOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (8U) COMMA_SOURCE_FILE_AT_LINE (209)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_unaryTildeOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryTildeOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryTildeOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryTildeOperator ("unaryTildeOperator",
                              functionForGenericCall_unaryTildeOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "incDecOperator"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_incDecOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_incDecOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (9U) COMMA_SOURCE_FILE_AT_LINE (210)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_incDecOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_incDecOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_incDecOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_incDecOperator ("incDecOperator",
                              functionForGenericCall_incDecOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryAndOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryAndOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryAndOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (10U) COMMA_SOURCE_FILE_AT_LINE (212)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryAndOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryAndOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryAndOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryAndOperator ("binaryAndOperator",
                              functionForGenericCall_binaryAndOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryOrOperator"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryOrOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryOrOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (11U) COMMA_SOURCE_FILE_AT_LINE (213)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryOrOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryOrOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryOrOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryOrOperator ("binaryOrOperator",
                              functionForGenericCall_binaryOrOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "binaryXorOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryXorOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryXorOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (12U) COMMA_SOURCE_FILE_AT_LINE (214)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryXorOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryXorOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryXorOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryXorOperator ("binaryXorOperator",
                              functionForGenericCall_binaryXorOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "unaryNotOperator"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_unaryNotOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_unaryNotOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (13U) COMMA_SOURCE_FILE_AT_LINE (215)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_unaryNotOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryNotOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryNotOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryNotOperator ("unaryNotOperator",
                              functionForGenericCall_unaryNotOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of function "binaryConcatOperator"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_binaryConcatOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_binaryConcatOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (14U) COMMA_SOURCE_FILE_AT_LINE (217)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_binaryConcatOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryConcatOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryConcatOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryConcatOperator ("binaryConcatOperator",
                              functionForGenericCall_binaryConcatOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "dotAssignOperator"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_dotAssignOperator (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_dotAssignOperator at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (15U) COMMA_SOURCE_FILE_AT_LINE (218)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_dotAssignOperator\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_dotAssignOperator (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_dotAssignOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_dotAssignOperator ("dotAssignOperator",
                              functionForGenericCall_dotAssignOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of function "generateEnumerationHelperMethods"        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_generateEnumerationHelperMethods (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_generateEnumerationHelperMethods at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (25U) COMMA_SOURCE_FILE_AT_LINE (220)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_generateEnumerationHelperMethods\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateEnumerationHelperMethods (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateEnumerationHelperMethods (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateEnumerationHelperMethods ("generateEnumerationHelperMethods",
                              functionForGenericCall_generateEnumerationHelperMethods,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//   Implementation of function "generateCppConstructorWithAttributeList"    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_generateCppConstructorWithAttributeList (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_generateCppConstructorWithAttributeList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (26U) COMMA_SOURCE_FILE_AT_LINE (221)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_generateCppConstructorWithAttributeList\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateCppConstructorWithAttributeList (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateCppConstructorWithAttributeList (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateCppConstructorWithAttributeList ("generateCppConstructorWithAttributeList",
                              functionForGenericCall_generateCppConstructorWithAttributeList,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of function "generateCppConstructorWithNativeAttributeList" *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_generateCppConstructorWithNativeAttributeList (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_generateCppConstructorWithNativeAttributeList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (27U) COMMA_SOURCE_FILE_AT_LINE (222)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_generateCppConstructorWithNativeAttributeList\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateCppConstructorWithNativeAttributeList (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateCppConstructorWithNativeAttributeList (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateCppConstructorWithNativeAttributeList ("generateCppConstructorWithNativeAttributeList",
                              functionForGenericCall_generateCppConstructorWithNativeAttributeList,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of function "doNotGenererateObjectCompare"          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_doNotGenererateObjectCompare (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_doNotGenererateObjectCompare at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (28U) COMMA_SOURCE_FILE_AT_LINE (223)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_doNotGenererateObjectCompare\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_doNotGenererateObjectCompare (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_doNotGenererateObjectCompare (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_doNotGenererateObjectCompare ("doNotGenererateObjectCompare",
                              functionForGenericCall_doNotGenererateObjectCompare,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//   Implementation of function "generateDescriptionReaderUtilityMethod"     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_generateDescriptionReaderUtilityMethod (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_generateDescriptionReaderUtilityMethod at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (29U) COMMA_SOURCE_FILE_AT_LINE (224)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_generateDescriptionReaderUtilityMethod\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateDescriptionReaderUtilityMethod (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateDescriptionReaderUtilityMethod (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateDescriptionReaderUtilityMethod ("generateDescriptionReaderUtilityMethod",
                              functionForGenericCall_generateDescriptionReaderUtilityMethod,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of function "generateNativeNewConstructor"          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_generateNativeNewConstructor (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_generateNativeNewConstructor at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (30U) COMMA_SOURCE_FILE_AT_LINE (225)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_generateNativeNewConstructor\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateNativeNewConstructor (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateNativeNewConstructor (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateNativeNewConstructor ("generateNativeNewConstructor",
                              functionForGenericCall_generateNativeNewConstructor,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of function "generateVirtualDestructor"           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_generateVirtualDestructor (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_generateVirtualDestructor at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_outMask ;
  var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (31U) COMMA_SOURCE_FILE_AT_LINE (226)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_generateVirtualDestructor\n") ;
  #endif
  return var_cas_outMask ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateVirtualDestructor (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateVirtualDestructor (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateVirtualDestructor ("generateVirtualDestructor",
                              functionForGenericCall_generateVirtualDestructor,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_unifiedTypeMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_unifiedTypeMap::e_unifiedTypeMap (void) :
mIsConcrete (),
mSuperType (),
mTypeKindEnum (),
mInheritedTypedAttributeList (),
mCurrentTypedAttributeList (),
mConstructorMap (),
mReaderMap (),
mModifierMap (),
mInstanceMethodMap (),
mClassMethodMap (),
mEnumerationDescriptor (),
mHandledOperatorFlags (),
mAddAssignOperatorArguments (),
mMinusAssignOperatorArguments (),
mNativeAttributeList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@unifiedTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMap ("unifiedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_unifiedTypeMap::
elementOf_GGS_unifiedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_unifiedTypeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unifiedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsConcrete.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSuperType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTypeKindEnum.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInheritedTypedAttributeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCurrentTypedAttributeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mConstructorMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReaderMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mModifierMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInstanceMethodMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mClassMethodMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEnumerationDescriptor.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHandledOperatorFlags.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAddAssignOperatorArguments.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMinusAssignOperatorArguments.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNativeAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unifiedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_unifiedTypeMap * ptr = dynamic_cast <const elementOf_GGS_unifiedTypeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIsConcrete.operator_isEqual (ptr->mInfo.mIsConcrete)).boolValue ()
           && (mInfo.mSuperType.operator_isEqual (ptr->mInfo.mSuperType)).boolValue ()
           && (mInfo.mTypeKindEnum.operator_isEqual (ptr->mInfo.mTypeKindEnum)).boolValue ()
           && (mInfo.mInheritedTypedAttributeList.operator_isEqual (ptr->mInfo.mInheritedTypedAttributeList)).boolValue ()
           && (mInfo.mCurrentTypedAttributeList.operator_isEqual (ptr->mInfo.mCurrentTypedAttributeList)).boolValue ()
           && (mInfo.mConstructorMap.operator_isEqual (ptr->mInfo.mConstructorMap)).boolValue ()
           && (mInfo.mReaderMap.operator_isEqual (ptr->mInfo.mReaderMap)).boolValue ()
           && (mInfo.mModifierMap.operator_isEqual (ptr->mInfo.mModifierMap)).boolValue ()
           && (mInfo.mInstanceMethodMap.operator_isEqual (ptr->mInfo.mInstanceMethodMap)).boolValue ()
           && (mInfo.mClassMethodMap.operator_isEqual (ptr->mInfo.mClassMethodMap)).boolValue ()
           && (mInfo.mEnumerationDescriptor.operator_isEqual (ptr->mInfo.mEnumerationDescriptor)).boolValue ()
           && (mInfo.mHandledOperatorFlags.operator_isEqual (ptr->mInfo.mHandledOperatorFlags)).boolValue ()
           && (mInfo.mAddAssignOperatorArguments.operator_isEqual (ptr->mInfo.mAddAssignOperatorArguments)).boolValue ()
           && (mInfo.mMinusAssignOperatorArguments.operator_isEqual (ptr->mInfo.mMinusAssignOperatorArguments)).boolValue ()
           && (mInfo.mNativeAttributeList.operator_isEqual (ptr->mInfo.mNativeAttributeList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_unifiedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_unifiedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_unifiedTypeMap * info = (e_unifiedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_unifiedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_unifiedTypeMap * info = (e_unifiedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_unifiedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMap::
operator_isEqual (const GGS_unifiedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMap::
operator_isNotEqual (const GGS_unifiedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_bool& inParameter0,
                const GGS_unifiedTypeMapIndex & inParameter1,
                const GGS_typeKindEnum& inParameter2,
                const GGS_typedAttributeList & inParameter3,
                const GGS_typedAttributeList & inParameter4,
                const GGS_constructorMap & inParameter5,
                const GGS_readerMap & inParameter6,
                const GGS_modifierMap & inParameter7,
                const GGS_instanceMethodMap & inParameter8,
                const GGS_classMethodMap & inParameter9,
                const GGS_enumerationDescriptorList & inParameter10,
                const GGS_uint & inParameter11,
                const GGS_unifiedTypeMapIndexList & inParameter12,
                const GGS_unifiedTypeMapIndexList & inParameter13,
                const GGS_nativeAttributeList & inParameter14,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inParameter8.isBuilt ()
   && inParameter9.isBuilt ()
   && inParameter10.isBuilt ()
   && inParameter11.isBuilt ()
   && inParameter12.isBuilt ()
   && inParameter13.isBuilt ()
   && inParameter14.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_unifiedTypeMap info  ;
    info.mIsConcrete = inParameter0 ;
    info.mSuperType = inParameter1 ;
    info.mTypeKindEnum = inParameter2 ;
    info.mInheritedTypedAttributeList = inParameter3 ;
    info.mCurrentTypedAttributeList = inParameter4 ;
    info.mConstructorMap = inParameter5 ;
    info.mReaderMap = inParameter6 ;
    info.mModifierMap = inParameter7 ;
    info.mInstanceMethodMap = inParameter8 ;
    info.mClassMethodMap = inParameter9 ;
    info.mEnumerationDescriptor = inParameter10 ;
    info.mHandledOperatorFlags = inParameter11 ;
    info.mAddAssignOperatorArguments = inParameter12 ;
    info.mMinusAssignOperatorArguments = inParameter13 ;
    info.mNativeAttributeList = inParameter14 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_unifiedTypeMapIndex   & outParameter1,
               GGS_typeKindEnum  & outParameter2,
               GGS_typedAttributeList   & outParameter3,
               GGS_typedAttributeList   & outParameter4,
               GGS_constructorMap   & outParameter5,
               GGS_readerMap   & outParameter6,
               GGS_modifierMap   & outParameter7,
               GGS_instanceMethodMap   & outParameter8,
               GGS_classMethodMap   & outParameter9,
               GGS_enumerationDescriptorList   & outParameter10,
               GGS_uint   & outParameter11,
               GGS_unifiedTypeMapIndexList   & outParameter12,
               GGS_unifiedTypeMapIndexList   & outParameter13,
               GGS_nativeAttributeList   & outParameter14,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    outParameter6.drop () ;
    outParameter7.drop () ;
    outParameter8.drop () ;
    outParameter9.drop () ;
    outParameter10.drop () ;
    outParameter11.drop () ;
    outParameter12.drop () ;
    outParameter13.drop () ;
    outParameter14.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIsConcrete ;
    outParameter1 = node->mInfo.mSuperType ;
    outParameter2 = node->mInfo.mTypeKindEnum ;
    outParameter3 = node->mInfo.mInheritedTypedAttributeList ;
    outParameter4 = node->mInfo.mCurrentTypedAttributeList ;
    outParameter5 = node->mInfo.mConstructorMap ;
    outParameter6 = node->mInfo.mReaderMap ;
    outParameter7 = node->mInfo.mModifierMap ;
    outParameter8 = node->mInfo.mInstanceMethodMap ;
    outParameter9 = node->mInfo.mClassMethodMap ;
    outParameter10 = node->mInfo.mEnumerationDescriptor ;
    outParameter11 = node->mInfo.mHandledOperatorFlags ;
    outParameter12 = node->mInfo.mAddAssignOperatorArguments ;
    outParameter13 = node->mInfo.mMinusAssignOperatorArguments ;
    outParameter14 = node->mInfo.mNativeAttributeList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_unifiedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_unifiedTypeMapIndex   & outParameter1,
                                GGS_typeKindEnum  & outParameter2,
                                GGS_typedAttributeList   & outParameter3,
                                GGS_typedAttributeList   & outParameter4,
                                GGS_constructorMap   & outParameter5,
                                GGS_readerMap   & outParameter6,
                                GGS_modifierMap   & outParameter7,
                                GGS_instanceMethodMap   & outParameter8,
                                GGS_classMethodMap   & outParameter9,
                                GGS_enumerationDescriptorList   & outParameter10,
                                GGS_uint   & outParameter11,
                                GGS_unifiedTypeMapIndexList   & outParameter12,
                                GGS_unifiedTypeMapIndexList   & outParameter13,
                                GGS_nativeAttributeList   & outParameter14 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  outParameter8,
                  outParameter9,
                  outParameter10,
                  outParameter11,
                  outParameter12,
                  outParameter13,
                  outParameter14,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_unifiedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_unifiedTypeMapIndex & inParameter1,
                                const GGS_typeKindEnum& inParameter2,
                                const GGS_typedAttributeList & inParameter3,
                                const GGS_typedAttributeList & inParameter4,
                                const GGS_constructorMap & inParameter5,
                                const GGS_readerMap & inParameter6,
                                const GGS_modifierMap & inParameter7,
                                const GGS_instanceMethodMap & inParameter8,
                                const GGS_classMethodMap & inParameter9,
                                const GGS_enumerationDescriptorList & inParameter10,
                                const GGS_uint & inParameter11,
                                const GGS_unifiedTypeMapIndexList & inParameter12,
                                const GGS_unifiedTypeMapIndexList & inParameter13,
                                const GGS_nativeAttributeList & inParameter14 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 inParameter8,
                 inParameter9,
                 inParameter10,
                 inParameter11,
                 inParameter12,
                 inParameter13,
                 inParameter14,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_unifiedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @unifiedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_unifiedTypeMap::cEnumerator::_mIsConcrete (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsConcrete ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_unifiedTypeMap::cEnumerator::_mSuperType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSuperType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeKindEnum & GGS_unifiedTypeMap::cEnumerator::_mTypeKindEnum (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTypeKindEnum ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typedAttributeList  & GGS_unifiedTypeMap::cEnumerator::_mInheritedTypedAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInheritedTypedAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typedAttributeList  & GGS_unifiedTypeMap::cEnumerator::_mCurrentTypedAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCurrentTypedAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_constructorMap  & GGS_unifiedTypeMap::cEnumerator::_mConstructorMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mConstructorMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_readerMap  & GGS_unifiedTypeMap::cEnumerator::_mReaderMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReaderMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_modifierMap  & GGS_unifiedTypeMap::cEnumerator::_mModifierMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModifierMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instanceMethodMap  & GGS_unifiedTypeMap::cEnumerator::_mInstanceMethodMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInstanceMethodMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_classMethodMap  & GGS_unifiedTypeMap::cEnumerator::_mClassMethodMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mClassMethodMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumerationDescriptorList  & GGS_unifiedTypeMap::cEnumerator::_mEnumerationDescriptor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEnumerationDescriptor ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_unifiedTypeMap::cEnumerator::_mHandledOperatorFlags (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHandledOperatorFlags ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_unifiedTypeMap::cEnumerator::_mAddAssignOperatorArguments (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAddAssignOperatorArguments ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_unifiedTypeMap::cEnumerator::_mMinusAssignOperatorArguments (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMinusAssignOperatorArguments ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_nativeAttributeList  & GGS_unifiedTypeMap::cEnumerator::_mNativeAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNativeAttributeList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMap * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMap * p = dynamic_cast <const GGS_unifiedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     map index '@unifiedTypeMapIndex'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMapIndex ("unifiedTypeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex GGS_unifiedTypeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapIndex::
operator_isEqual (const GGS_unifiedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapIndex::
operator_isNotEqual (const GGS_unifiedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @unifiedTypeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_unifiedTypeMap & ioMap,
                               GGS_unifiedTypeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex GGS_unifiedTypeMapIndex::constructor_searchKey (C_Compiler & inLexique,
              const GGS_unifiedTypeMap & inMap,
              const GGS_lstring & inKey
              COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndex result ;
  result.mState = kRegular ;
  result.mKey = inKey ;
  inMap.searchIndex (inLexique, inKey, GGS_unifiedTypeMap::kSearchMessage_searchKey, result.mIndex COMMA_THERE) ;
  if (result.mIndex.retrieve () == NULL) {
    result.drop () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapIndex::reader_mIsConcrete (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mIsConcrete ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_unifiedTypeMapIndex::reader_mSuperType (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mSuperType ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKindEnum GGS_unifiedTypeMapIndex::reader_mTypeKindEnum (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typeKindEnum result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mTypeKindEnum ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_unifiedTypeMapIndex::reader_mInheritedTypedAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mInheritedTypedAttributeList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_unifiedTypeMapIndex::reader_mCurrentTypedAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mCurrentTypedAttributeList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap  GGS_unifiedTypeMapIndex::reader_mConstructorMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_constructorMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mConstructorMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap  GGS_unifiedTypeMapIndex::reader_mReaderMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_readerMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mReaderMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap  GGS_unifiedTypeMapIndex::reader_mModifierMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_modifierMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mModifierMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap  GGS_unifiedTypeMapIndex::reader_mInstanceMethodMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_instanceMethodMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mInstanceMethodMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap  GGS_unifiedTypeMapIndex::reader_mClassMethodMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_classMethodMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mClassMethodMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_unifiedTypeMapIndex::reader_mEnumerationDescriptor (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mEnumerationDescriptor ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_unifiedTypeMapIndex::reader_mHandledOperatorFlags (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mHandledOperatorFlags ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList  GGS_unifiedTypeMapIndex::reader_mAddAssignOperatorArguments (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mAddAssignOperatorArguments ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList  GGS_unifiedTypeMapIndex::reader_mMinusAssignOperatorArguments (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mMinusAssignOperatorArguments ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nativeAttributeList  GGS_unifiedTypeMapIndex::reader_mNativeAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_nativeAttributeList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mNativeAttributeList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMapIndex * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex GGS_unifiedTypeMapIndex::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMapIndex * p = dynamic_cast <const GGS_unifiedTypeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMapIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_genericTypeTypeAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_genericTypeTypeAST::
cPtr_genericTypeTypeAST (const GGS_string& argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mTypeName (argument_0),
mSuperTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_genericTypeTypeAST * GGS_genericTypeTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_genericTypeTypeAST) ;
    return (cPtr_genericTypeTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_genericTypeTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_genericTypeTypeAST * ptr = dynamic_cast <const cPtr_genericTypeTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mSuperTypeName.operator_isEqual (ptr->mSuperTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_genericTypeTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@genericTypeTypeAST:"
           << mTypeName.reader_description (inIndentation + 1)
           << mSuperTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_genericTypeTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_genericTypeTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_genericTypeTypeAST (& typeid (cPtr_genericTypeTypeAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_genericTypeTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__genericTypeTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_genericTypeTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_genericTypeTypeAST (mTypeName, mSuperTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_genericTypeTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_genericTypeTypeAST ("genericTypeTypeAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_genericTypeTypeAST::
GGS_genericTypeTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_genericTypeTypeAST::
GGS_genericTypeTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_genericTypeTypeAST GGS_genericTypeTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_genericTypeTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_genericTypeTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_genericTypeTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_genericTypeTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_genericTypeTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_genericTypeTypeAST GGS_genericTypeTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_genericTypeTypeAST result ;
  macroMyNew (result.mPointer, cPtr_genericTypeTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_genericTypeTypeAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_genericTypeTypeAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_genericTypeTypeAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_genericTypeTypeAST::
reader_mSuperTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_genericTypeTypeAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_genericTypeTypeAST *) mPointer)->mSuperTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_genericTypeTypeAST::actualTypeName (void) const {
  return "genericTypeTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__genericTypeTypeAST ("genericTypeTypeAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_genericTypeTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_genericTypeTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_genericTypeTypeAST * p = NULL ;
    macroMyNew (p, GGS_genericTypeTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_genericTypeTypeAST GGS_genericTypeTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_genericTypeTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_genericTypeTypeAST * p = dynamic_cast <const GGS_genericTypeTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_genericTypeTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_genericTypeTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_genericTypeTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_predefinedTypeAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_predefinedTypeAST::
cPtr_predefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mPredefinedTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_predefinedTypeAST * GGS_predefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_predefinedTypeAST) ;
    return (cPtr_predefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_predefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@predefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_predefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_predefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_predefinedTypeAST (& typeid (cPtr_predefinedTypeAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_predefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__predefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_predefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_predefinedTypeAST ("predefinedTypeAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST::
GGS_predefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST::
GGS_predefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_predefinedTypeAST GGS_predefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_predefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_predefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_predefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_predefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_predefinedTypeAST::
reader_mPredefinedTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_predefinedTypeAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_predefinedTypeAST *) mPointer)->mPredefinedTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_predefinedTypeAST::actualTypeName (void) const {
  return "predefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__predefinedTypeAST ("predefinedTypeAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_predefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_predefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_predefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST GGS_predefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_predefinedTypeAST * p = dynamic_cast <const GGS_predefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_predefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_predefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_predefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_binarysetPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetPredefinedTypeAST::
cPtr_binarysetPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetPredefinedTypeAST * GGS_binarysetPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_binarysetPredefinedTypeAST) ;
    return (cPtr_binarysetPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_binarysetPredefinedTypeAST * ptr = dynamic_cast <const cPtr_binarysetPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@binarysetPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetPredefinedTypeAST (& typeid (cPtr_binarysetPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_binarysetPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__binarysetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_binarysetPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_binarysetPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_binarysetPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_binarysetPredefinedTypeAST ("binarysetPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST::
GGS_binarysetPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST::
GGS_binarysetPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_binarysetPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_binarysetPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetPredefinedTypeAST::actualTypeName (void) const {
  return "binarysetPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__binarysetPredefinedTypeAST ("binarysetPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_binarysetPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_binarysetPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_binarysetPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_binarysetPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_binarysetPredefinedTypeAST * p = dynamic_cast <const GGS_binarysetPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_binarysetPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_binarysetPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_binarysetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_boolPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolPredefinedTypeAST::
cPtr_boolPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolPredefinedTypeAST * GGS_boolPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_boolPredefinedTypeAST) ;
    return (cPtr_boolPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_boolPredefinedTypeAST * ptr = dynamic_cast <const cPtr_boolPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_boolPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@boolPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolPredefinedTypeAST (& typeid (cPtr_boolPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_boolPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__boolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_boolPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_boolPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_boolPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_boolPredefinedTypeAST ("boolPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST::
GGS_boolPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST::
GGS_boolPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_boolPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_boolPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_boolPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolPredefinedTypeAST::actualTypeName (void) const {
  return "boolPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__boolPredefinedTypeAST ("boolPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_boolPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_boolPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_boolPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_boolPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_boolPredefinedTypeAST * p = dynamic_cast <const GGS_boolPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_boolPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_boolPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_boolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_uintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintPredefinedTypeAST::
cPtr_uintPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintPredefinedTypeAST * GGS_uintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uintPredefinedTypeAST) ;
    return (cPtr_uintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_uintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintPredefinedTypeAST (& typeid (cPtr_uintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__uintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uintPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_uintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uintPredefinedTypeAST ("uintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST::
GGS_uintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST::
GGS_uintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_uintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_uintPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintPredefinedTypeAST::actualTypeName (void) const {
  return "uintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uintPredefinedTypeAST ("uintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_uintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_uintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uintPredefinedTypeAST * p = dynamic_cast <const GGS_uintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_uint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64PredefinedTypeAST::
cPtr_uint64PredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64PredefinedTypeAST * GGS_uint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64PredefinedTypeAST) ;
    return (cPtr_uint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_uint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64PredefinedTypeAST (& typeid (cPtr_uint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__uint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64PredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_uint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64PredefinedTypeAST ("uint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST::
GGS_uint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST::
GGS_uint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_uint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_uint64PredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64PredefinedTypeAST::actualTypeName (void) const {
  return "uint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64PredefinedTypeAST ("uint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_uint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_uint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64PredefinedTypeAST * p = dynamic_cast <const GGS_uint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_sintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintPredefinedTypeAST::
cPtr_sintPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintPredefinedTypeAST * GGS_sintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sintPredefinedTypeAST) ;
    return (cPtr_sintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_sintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintPredefinedTypeAST (& typeid (cPtr_sintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__sintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sintPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sintPredefinedTypeAST ("sintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST::
GGS_sintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST::
GGS_sintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_sintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_sintPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintPredefinedTypeAST::actualTypeName (void) const {
  return "sintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sintPredefinedTypeAST ("sintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_sintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_sintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sintPredefinedTypeAST * p = dynamic_cast <const GGS_sintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_sint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64PredefinedTypeAST::
cPtr_sint64PredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64PredefinedTypeAST * GGS_sint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64PredefinedTypeAST) ;
    return (cPtr_sint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_sint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64PredefinedTypeAST (& typeid (cPtr_sint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__sint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64PredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_sint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64PredefinedTypeAST ("sint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST::
GGS_sint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST::
GGS_sint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_sint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_sint64PredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64PredefinedTypeAST::actualTypeName (void) const {
  return "sint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64PredefinedTypeAST ("sint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_sint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_sint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64PredefinedTypeAST * p = dynamic_cast <const GGS_sint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_charPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charPredefinedTypeAST::
cPtr_charPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charPredefinedTypeAST * GGS_charPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_charPredefinedTypeAST) ;
    return (cPtr_charPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_charPredefinedTypeAST * ptr = dynamic_cast <const cPtr_charPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_charPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@charPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charPredefinedTypeAST (& typeid (cPtr_charPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_charPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__charPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_charPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_charPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_charPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_charPredefinedTypeAST ("charPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST::
GGS_charPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST::
GGS_charPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_charPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_charPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_charPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charPredefinedTypeAST::actualTypeName (void) const {
  return "charPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__charPredefinedTypeAST ("charPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_charPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_charPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_charPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_charPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_charPredefinedTypeAST * p = dynamic_cast <const GGS_charPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_charPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_charPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_charPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_doublePredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doublePredefinedTypeAST::
cPtr_doublePredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doublePredefinedTypeAST * GGS_doublePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_doublePredefinedTypeAST) ;
    return (cPtr_doublePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doublePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_doublePredefinedTypeAST * ptr = dynamic_cast <const cPtr_doublePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_doublePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@doublePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doublePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doublePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doublePredefinedTypeAST (& typeid (cPtr_doublePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_doublePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__doublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_doublePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_doublePredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_doublePredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_doublePredefinedTypeAST ("doublePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST::
GGS_doublePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST::
GGS_doublePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doublePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_doublePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_doublePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doublePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_doublePredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doublePredefinedTypeAST::actualTypeName (void) const {
  return "doublePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__doublePredefinedTypeAST ("doublePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_doublePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_doublePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_doublePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_doublePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_doublePredefinedTypeAST * p = dynamic_cast <const GGS_doublePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_doublePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_doublePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_doublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_stringPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringPredefinedTypeAST::
cPtr_stringPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringPredefinedTypeAST * GGS_stringPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_stringPredefinedTypeAST) ;
    return (cPtr_stringPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_stringPredefinedTypeAST * ptr = dynamic_cast <const cPtr_stringPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_stringPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@stringPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringPredefinedTypeAST (& typeid (cPtr_stringPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__stringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_stringPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_stringPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_stringPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringPredefinedTypeAST ("stringPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST::
GGS_stringPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST::
GGS_stringPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_stringPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_stringPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringPredefinedTypeAST::actualTypeName (void) const {
  return "stringPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringPredefinedTypeAST ("stringPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_stringPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_stringPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringPredefinedTypeAST * p = dynamic_cast <const GGS_stringPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_locationPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_locationPredefinedTypeAST::
cPtr_locationPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_locationPredefinedTypeAST * GGS_locationPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_locationPredefinedTypeAST) ;
    return (cPtr_locationPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_locationPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_locationPredefinedTypeAST * ptr = dynamic_cast <const cPtr_locationPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_locationPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@locationPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_locationPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_locationPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_locationPredefinedTypeAST (& typeid (cPtr_locationPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_locationPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__locationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_locationPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_locationPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_locationPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_locationPredefinedTypeAST ("locationPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST::
GGS_locationPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST::
GGS_locationPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_locationPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_locationPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_locationPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_locationPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_locationPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_locationPredefinedTypeAST::actualTypeName (void) const {
  return "locationPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__locationPredefinedTypeAST ("locationPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_locationPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_locationPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_locationPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_locationPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_locationPredefinedTypeAST * p = dynamic_cast <const GGS_locationPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_locationPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_locationPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_locationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_stringsetPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetPredefinedTypeAST::
cPtr_stringsetPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetPredefinedTypeAST * GGS_stringsetPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_stringsetPredefinedTypeAST) ;
    return (cPtr_stringsetPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_stringsetPredefinedTypeAST * ptr = dynamic_cast <const cPtr_stringsetPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@stringsetPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetPredefinedTypeAST (& typeid (cPtr_stringsetPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringsetPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__stringsetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_stringsetPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_stringsetPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_stringsetPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringsetPredefinedTypeAST ("stringsetPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST::
GGS_stringsetPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST::
GGS_stringsetPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringsetPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_stringsetPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetPredefinedTypeAST::actualTypeName (void) const {
  return "stringsetPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringsetPredefinedTypeAST ("stringsetPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_stringsetPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringsetPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringsetPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_stringsetPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringsetPredefinedTypeAST * p = dynamic_cast <const GGS_stringsetPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringsetPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringsetPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringsetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_objectPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_objectPredefinedTypeAST::
cPtr_objectPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_objectPredefinedTypeAST * GGS_objectPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_objectPredefinedTypeAST) ;
    return (cPtr_objectPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_objectPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_objectPredefinedTypeAST * ptr = dynamic_cast <const cPtr_objectPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_objectPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@objectPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_objectPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_objectPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_objectPredefinedTypeAST (& typeid (cPtr_objectPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_objectPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__objectPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_objectPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_objectPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_objectPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_objectPredefinedTypeAST ("objectPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST::
GGS_objectPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST::
GGS_objectPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_objectPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_objectPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_objectPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_objectPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_objectPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_objectPredefinedTypeAST::actualTypeName (void) const {
  return "objectPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__objectPredefinedTypeAST ("objectPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_objectPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_objectPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_objectPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_objectPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_objectPredefinedTypeAST * p = dynamic_cast <const GGS_objectPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_objectPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_objectPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_objectPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_functionPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionPredefinedTypeAST::
cPtr_functionPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionPredefinedTypeAST * GGS_functionPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionPredefinedTypeAST) ;
    return (cPtr_functionPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionPredefinedTypeAST * ptr = dynamic_cast <const cPtr_functionPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionPredefinedTypeAST (& typeid (cPtr_functionPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_functionPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionPredefinedTypeAST ("functionPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST::
GGS_functionPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST::
GGS_functionPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_functionPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionPredefinedTypeAST::actualTypeName (void) const {
  return "functionPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionPredefinedTypeAST ("functionPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_functionPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_functionPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionPredefinedTypeAST * p = dynamic_cast <const GGS_functionPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typePredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typePredefinedTypeAST::
cPtr_typePredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typePredefinedTypeAST * GGS_typePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typePredefinedTypeAST) ;
    return (cPtr_typePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typePredefinedTypeAST * ptr = dynamic_cast <const cPtr_typePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typePredefinedTypeAST (& typeid (cPtr_typePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__typePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typePredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typePredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typePredefinedTypeAST ("typePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST::
GGS_typePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST::
GGS_typePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_typePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_typePredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typePredefinedTypeAST::actualTypeName (void) const {
  return "typePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typePredefinedTypeAST ("typePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_typePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_typePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typePredefinedTypeAST * p = dynamic_cast <const GGS_typePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_dataPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_dataPredefinedTypeAST::
cPtr_dataPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_dataPredefinedTypeAST * GGS_dataPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_dataPredefinedTypeAST) ;
    return (cPtr_dataPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_dataPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_dataPredefinedTypeAST * ptr = dynamic_cast <const cPtr_dataPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_dataPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@dataPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_dataPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_dataPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_dataPredefinedTypeAST (& typeid (cPtr_dataPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_dataPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__dataPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_dataPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_dataPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_dataPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_dataPredefinedTypeAST ("dataPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST::
GGS_dataPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST::
GGS_dataPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_dataPredefinedTypeAST GGS_dataPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_dataPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_dataPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_dataPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_dataPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_dataPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST GGS_dataPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_dataPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_dataPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_dataPredefinedTypeAST::actualTypeName (void) const {
  return "dataPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__dataPredefinedTypeAST ("dataPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_dataPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_dataPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_dataPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_dataPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST GGS_dataPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_dataPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_dataPredefinedTypeAST * p = dynamic_cast <const GGS_dataPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_dataPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_dataPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_dataPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@predefinedTypeAST.getSuperType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getSuperType (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_14369,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_unifiedTypeMapIndex  & var_cas_outSuperType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14369 != NULL) {
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("root"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (315)), var_cas_ioUnifiedTypeMap, var_cas_outSuperType COMMA_SOURCE_FILE_AT_LINE (315)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Virtual Table for category method '@predefinedTypeAST.getSuperType'     *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getSuperType> gDispatchTableForMethod__predefinedTypeAST__getSuperType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getSuperType (typeCategoryMethod__predefinedTypeAST__getSuperType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getSuperType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getSuperType
findCategoryMethod__predefinedTypeAST__getSuperType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getSuperType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getSuperType.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getSuperType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getSuperType (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getSuperType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@predefinedTypeAST.getConstructorMap'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getConstructorMap (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_14735,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_constructorMap  & var_cas_outConstructorMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14735 != NULL) {
    var_cas_outConstructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (324)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@predefinedTypeAST.getConstructorMap'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getConstructorMap> gDispatchTableForMethod__predefinedTypeAST__getConstructorMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getConstructorMap (typeCategoryMethod__predefinedTypeAST__getConstructorMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getConstructorMap
findCategoryMethod__predefinedTypeAST__getConstructorMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getConstructorMap result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getConstructorMap (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getConstructorMap (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@predefinedTypeAST.getReaderMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getReaderMap (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_15002,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_readerMap  & var_cas_outReaderMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15002 != NULL) {
    var_cas_outReaderMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (333)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Virtual Table for category method '@predefinedTypeAST.getReaderMap'     *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getReaderMap> gDispatchTableForMethod__predefinedTypeAST__getReaderMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getReaderMap (typeCategoryMethod__predefinedTypeAST__getReaderMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getReaderMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getReaderMap
findCategoryMethod__predefinedTypeAST__getReaderMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getReaderMap result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getReaderMap.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getReaderMap (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getReaderMap (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getReaderMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@predefinedTypeAST.getModifierMap'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getModifierMap (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_15251,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_modifierMap  & var_cas_outModifierMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15251 != NULL) {
    var_cas_outModifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (342)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@predefinedTypeAST.getModifierMap'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getModifierMap> gDispatchTableForMethod__predefinedTypeAST__getModifierMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getModifierMap (typeCategoryMethod__predefinedTypeAST__getModifierMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getModifierMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getModifierMap
findCategoryMethod__predefinedTypeAST__getModifierMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getModifierMap result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getModifierMap.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getModifierMap (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getModifierMap (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getModifierMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@predefinedTypeAST.getInstanceMethodMap'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_15514,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15514 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (351)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getInstanceMethodMap'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap> gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap (typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap
findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@predefinedTypeAST.getClassMethodMap'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getClassMethodMap (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_15798,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_classMethodMap  & var_cas_outClassMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15798 != NULL) {
    var_cas_outClassMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (360)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@predefinedTypeAST.getClassMethodMap'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getClassMethodMap> gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getClassMethodMap (typeCategoryMethod__predefinedTypeAST__getClassMethodMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getClassMethodMap
findCategoryMethod__predefinedTypeAST__getClassMethodMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getClassMethodMap result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getClassMethodMap (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category reader '@predefinedTypeAST.getSupportedOperatorFlags'       *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint 
category_reader__predefinedTypeAST__getSupportedOperatorFlags (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_16078
                                COMMA_UNUSED_LOCATION_ARGS) {
  GGS_uint  var_cas_outFlags ;
  if (operand_16078 != NULL) {
    var_cas_outFlags = GGS_uint (0U) ;
  }
  return var_cas_outFlags ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category reader '@predefinedTypeAST.getSupportedOperatorFlags'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags> gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags ;

//---------------------------------------------------------------------------*

void
enterCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

static GGS_uint 
category_reader__predefinedTypeAST_defaultReader_getSupportedOperatorFlags (C_Compiler &,
                                const cPtr_predefinedTypeAST *
                                COMMA_UNUSED_LOCATION_ARGS) {
  return GGS_uint  () ;
}

//---------------------------------------------------------------------------*

typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags
findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.count ()) {
    result = gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (superClassPtr) ;
      gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  if (NULL == result) {
    result = category_reader__predefinedTypeAST_defaultReader_getSupportedOperatorFlags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@predefinedTypeAST.getAddAssignArgumentList'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getAddAssignArgumentList (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_16285,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_unifiedTypeMapIndexList  & var_cas_outAddAssignArgumentList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16285 != NULL) {
    var_cas_outAddAssignArgumentList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getAddAssignArgumentList'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList> gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList
findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@predefinedTypeAST.getMinusAssignArgumentList'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getMinusAssignArgumentList (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_16621,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_unifiedTypeMapIndexList  & var_cas_outAddAssignArgumentList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16621 != NULL) {
    var_cas_outAddAssignArgumentList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getMinusAssignArgumentList'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList> gDispatchTableForMethod__predefinedTypeAST__getMinusAssignArgumentList ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList (typeCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getMinusAssignArgumentList.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList
findCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getMinusAssignArgumentList.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getMinusAssignArgumentList (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getMinusAssignArgumentList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category reader '@predefinedTypeAST.getNativeAttributeList'         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_nativeAttributeList 
category_reader__predefinedTypeAST__getNativeAttributeList (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_17265
                                COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nativeAttributeList  var_cas_outNativeAttributeList ;
  if (operand_17265 != NULL) {
    var_cas_outNativeAttributeList = GGS_nativeAttributeList ::constructor_emptyList () ;
  }
  return var_cas_outNativeAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category reader '@predefinedTypeAST.getNativeAttributeList'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryReader__predefinedTypeAST__getNativeAttributeList> gDispatchTableForReader__predefinedTypeAST__getNativeAttributeList ;

//---------------------------------------------------------------------------*

void
enterCategoryReader__predefinedTypeAST__getNativeAttributeList (typeCategoryReader__predefinedTypeAST__getNativeAttributeList inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForReader__predefinedTypeAST__getNativeAttributeList.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

static GGS_nativeAttributeList 
category_reader__predefinedTypeAST_defaultReader_getNativeAttributeList (C_Compiler &,
                                const cPtr_predefinedTypeAST *
                                COMMA_UNUSED_LOCATION_ARGS) {
  return GGS_nativeAttributeList  () ;
}

//---------------------------------------------------------------------------*

typeCategoryReader__predefinedTypeAST__getNativeAttributeList
findCategoryReader__predefinedTypeAST__getNativeAttributeList (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryReader__predefinedTypeAST__getNativeAttributeList result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForReader__predefinedTypeAST__getNativeAttributeList.count ()) {
    result = gDispatchTableForReader__predefinedTypeAST__getNativeAttributeList (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryReader__predefinedTypeAST__getNativeAttributeList (superClassPtr) ;
      gDispatchTableForReader__predefinedTypeAST__getNativeAttributeList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  if (NULL == result) {
    result = category_reader__predefinedTypeAST_defaultReader_getNativeAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@predefinedTypeAST.getEnumerationList'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getEnumerationList (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_17851,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_enumerationDescriptorList  & var_cas_outEnumerationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17851 != NULL) {
    var_cas_outEnumerationList = GGS_enumerationDescriptorList ::constructor_emptyList () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getEnumerationList'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getEnumerationList> gDispatchTableForMethod__predefinedTypeAST__getEnumerationList ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getEnumerationList (typeCategoryMethod__predefinedTypeAST__getEnumerationList inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getEnumerationList
findCategoryMethod__predefinedTypeAST__getEnumerationList (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getEnumerationList result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.count ()) {
    result = gDispatchTableForMethod__predefinedTypeAST__getEnumerationList (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__predefinedTypeAST__getEnumerationList (superClassPtr) ;
      gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsTypes (void) {
  enterCategoryMethod__predefinedTypeAST__getSuperType (category_method__predefinedTypeAST__getSuperType, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getConstructorMap (category_method__predefinedTypeAST__getConstructorMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getReaderMap (category_method__predefinedTypeAST__getReaderMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getModifierMap (category_method__predefinedTypeAST__getModifierMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap (category_method__predefinedTypeAST__getInstanceMethodMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getClassMethodMap (category_method__predefinedTypeAST__getClassMethodMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (category_reader__predefinedTypeAST__getSupportedOperatorFlags, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (category_method__predefinedTypeAST__getAddAssignArgumentList, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList (category_method__predefinedTypeAST__getMinusAssignArgumentList, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryReader__predefinedTypeAST__getNativeAttributeList (category_reader__predefinedTypeAST__getNativeAttributeList, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getEnumerationList (category_method__predefinedTypeAST__getEnumerationList, gClassInfoFor__predefinedTypeAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticsTypes (void) {
  gDispatchTableForMethod__predefinedTypeAST__getSuperType.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getReaderMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getModifierMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.free () ;
  gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getMinusAssignArgumentList.free () ;
  gDispatchTableForReader__predefinedTypeAST__getNativeAttributeList.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsTypes (prologueRoutineFor_semanticsTypes, epilogueRoutineFor_semanticsTypes) ;

//---------------------------------------------------------------------------*

