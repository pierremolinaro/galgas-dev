//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticsTypes.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 12th, 2010, at 16h49'36"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@unifiedTypeMapIndexList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_unifiedTypeMapIndexList::
elementOf_GGS_unifiedTypeMapIndexList (const GGS_unifiedTypeMapIndex & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mType (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unifiedTypeMapIndexList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_unifiedTypeMapIndexList * ptr = dynamic_cast <const elementOf_GGS_unifiedTypeMapIndexList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unifiedTypeMapIndexList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@unifiedTypeMapIndexList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMapIndexList ("unifiedTypeMapIndexList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::
operator_concat (const GGS_unifiedTypeMapIndexList & inOperand) const {
  GGS_unifiedTypeMapIndexList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
dotAssign_operation (const GGS_unifiedTypeMapIndexList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_unifiedTypeMapIndexList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mType ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList  GGS_unifiedTypeMapIndexList::
constructor_emptyList (void) {
  GGS_unifiedTypeMapIndexList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList  GGS_unifiedTypeMapIndexList::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0) {
  GGS_unifiedTypeMapIndexList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
internalSubListWithRange (GGS_unifiedTypeMapIndexList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMapIndexList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@unifiedTypeMapIndexList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_unifiedTypeMapIndexList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndexList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_unifiedTypeMapIndexList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMapIndexList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMapIndexList * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMapIndexList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_unifiedTypeMapIndexList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndexList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMapIndexList * p = dynamic_cast <const GGS_unifiedTypeMapIndexList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMapIndexList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMapIndexList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMapIndexList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_constructorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_constructorMap::e_constructorMap (void) :
mArgumentTypeList (),
mHasLexique (),
mReturnedType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorMap ("constructorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_constructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasLexique.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constructorMap * ptr = dynamic_cast <const elementOf_GGS_constructorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentTypeList.operator_isEqual (ptr->mInfo.mArgumentTypeList)).boolValue ()
           && (mInfo.mHasLexique.operator_isEqual (ptr->mInfo.mHasLexique)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_constructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator_isEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator_isNotEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_unifiedTypeMapIndex & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_constructorMap info  ;
    info.mArgumentTypeList = inParameter0 ;
    info.mHasLexique = inParameter1 ;
    info.mReturnedType = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_unifiedTypeMapIndex   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mArgumentTypeList ;
    outParameter1 = node->mInfo.mHasLexique ;
    outParameter2 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_constructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_unifiedTypeMapIndex   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_constructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constructorMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_unifiedTypeMapIndex & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_constructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_constructorMap::cEnumerator::_mArgumentTypeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_constructorMap::cEnumerator::_mHasLexique (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasLexique ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_constructorMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_constructorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorMap * p = NULL ;
    macroMyNew (p, GGS_constructorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorMap * p = dynamic_cast <const GGS_constructorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'readerQualifier' Enumeration                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerQualifier ("readerQualifier", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_readerQualifier::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_isEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_isNotEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_infOrEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_supOrEqual (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_strictInf (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerQualifier::
operator_strictSup (const GGS_readerQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerQualifier::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @readerQualifier" ;
  switch (mValue) {
  case enum_isAbstract:
    s << " isAbstract>" ;
    break ;
  case enum_isBasic:
    s << " isBasic>" ;
    break ;
  case enum_isInherited:
    s << " isInherited>" ;
    break ;
  case enum_isOverriding:
    s << " isOverriding>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_readerQualifier::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerQualifier * p = NULL ;
    macroMyNew (p, GGS_readerQualifier (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerQualifier GGS_readerQualifier::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerQualifier result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerQualifier * p = dynamic_cast <const GGS_readerQualifier *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerQualifier, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerQualifier::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerQualifier ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_readerMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_readerMap::e_readerMap (void) :
mArgumentTypeList (),
mHasLexiqueArgument (),
mReturnedType (),
mQualifier (),
mImplicitConversionReader () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@readerMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerMap ("readerMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_readerMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasLexiqueArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mQualifier.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mImplicitConversionReader.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_readerMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_readerMap * ptr = dynamic_cast <const elementOf_GGS_readerMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentTypeList.operator_isEqual (ptr->mInfo.mArgumentTypeList)).boolValue ()
           && (mInfo.mHasLexiqueArgument.operator_isEqual (ptr->mInfo.mHasLexiqueArgument)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue ()
           && (mInfo.mQualifier.operator_isEqual (ptr->mInfo.mQualifier)).boolValue ()
           && (mInfo.mImplicitConversionReader.operator_isEqual (ptr->mInfo.mImplicitConversionReader)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_readerMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator_isEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator_isNotEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_unifiedTypeMapIndex & inParameter2,
                const GGS_readerQualifier& inParameter3,
                const GGS_string& inParameter4,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_readerMap info  ;
    info.mArgumentTypeList = inParameter0 ;
    info.mHasLexiqueArgument = inParameter1 ;
    info.mReturnedType = inParameter2 ;
    info.mQualifier = inParameter3 ;
    info.mImplicitConversionReader = inParameter4 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_unifiedTypeMapIndex   & outParameter2,
               GGS_readerQualifier  & outParameter3,
               GGS_string  & outParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mArgumentTypeList ;
    outParameter1 = node->mInfo.mHasLexiqueArgument ;
    outParameter2 = node->mInfo.mReturnedType ;
    outParameter3 = node->mInfo.mQualifier ;
    outParameter4 = node->mInfo.mImplicitConversionReader ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_readerMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_readerMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_unifiedTypeMapIndex   & outParameter2,
                                GGS_readerQualifier  & outParameter3,
                                GGS_string  & outParameter4 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_readerMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_readerMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_unifiedTypeMapIndex & inParameter2,
                                const GGS_readerQualifier& inParameter3,
                                const GGS_string& inParameter4 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_readerMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_readerMap::cEnumerator::_mArgumentTypeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_readerMap::cEnumerator::_mHasLexiqueArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasLexiqueArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_readerMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_readerQualifier & GGS_readerMap::cEnumerator::_mQualifier (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mQualifier ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_readerMap::cEnumerator::_mImplicitConversionReader (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImplicitConversionReader ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_readerMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerMap * p = NULL ;
    macroMyNew (p, GGS_readerMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerMap * p = dynamic_cast <const GGS_readerMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerMap ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList &  inParameter0,
                                const GGS_bool&  inParameter1,
                                const GGS_unifiedTypeMapIndex &  inParameter2,
                                const GGS_readerQualifier&  inParameter3,
                                const GGS_string&  inParameter4 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()
  && inParameter2.isBuilt ()
  && inParameter3.isBuilt ()
  && inParameter4.isBuilt ()) {
    insulateMap () ;
    e_readerMap info ;
    info.mArgumentTypeList =  inParameter0 ;
    info.mHasLexiqueArgument =  inParameter1 ;
    info.mReturnedType =  inParameter2 ;
    info.mQualifier =  inParameter3 ;
    info.mImplicitConversionReader =  inParameter4 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@formalParameterSignature'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterSignature::
elementOf_GGS_formalParameterSignature (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mParameterType (argument_0),
mFormalParameterPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterSignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterSignature * ptr = dynamic_cast <const elementOf_GGS_formalParameterSignature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mParameterType.operator_isEqual (ptr->mParameterType).boolValue ()
         && mFormalParameterPassingMode.operator_isEqual (ptr->mFormalParameterPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterSignature::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mParameterType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterPassingMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@formalParameterSignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterSignature ("formalParameterSignature", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_formalArgumentPassingModeAST& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_formalArgumentPassingModeAST& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
operator_concat (const GGS_formalParameterSignature & inOperand) const {
  GGS_formalParameterSignature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
dotAssign_operation (const GGS_formalParameterSignature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mParameterType ;
          GGS_formalArgumentPassingModeAST p_1 = p->mFormalParameterPassingMode ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0,
                     const GGS_formalArgumentPassingModeAST& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mParameterType,
                                ptr->mFormalParameterPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature  GGS_formalParameterSignature::
constructor_emptyList (void) {
  GGS_formalParameterSignature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature  GGS_formalParameterSignature::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1) {
  GGS_formalParameterSignature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalSubListWithRange (GGS_formalParameterSignature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mParameterType, ptr->mFormalParameterPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterSignature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterSignature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterSignature::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterSignature", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0,
              GGS_formalArgumentPassingModeAST& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0,
             GGS_formalArgumentPassingModeAST& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0,
                 GGS_formalArgumentPassingModeAST& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0,
                GGS_formalArgumentPassingModeAST& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mParameterType ;
    _out_1 = ptr->mFormalParameterPassingMode ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_formalParameterSignature::
reader_mParameterTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mParameterType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterSignature::
reader_mFormalParameterPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_setMParameterTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mParameterType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_setMFormalParameterPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_formalParameterSignature::cEnumerator::_mParameterType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mParameterType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterSignature::cEnumerator::_mFormalParameterPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterPassingMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterSignature::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterSignature * p = NULL ;
    macroMyNew (p, GGS_formalParameterSignature (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterSignature result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterSignature * p = dynamic_cast <const GGS_formalParameterSignature *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterSignature, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterSignature::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_modifierMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_modifierMap::e_modifierMap (void) :
mParameterList (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@modifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierMap ("modifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_modifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_modifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_modifierMap * ptr = dynamic_cast <const elementOf_GGS_modifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_modifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator_isEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator_isNotEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_modifierMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_modifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_modifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_modifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_modifierMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_modifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_modifierMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_modifierMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_modifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierMap * p = NULL ;
    macroMyNew (p, GGS_modifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierMap * p = dynamic_cast <const GGS_modifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierMap ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap () ;
    e_modifierMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_instanceMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_instanceMethodMap::e_instanceMethodMap (void) :
mParameterList (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@instanceMethodMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_instanceMethodMap ("instanceMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_instanceMethodMap::
elementOf_GGS_instanceMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_instanceMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instanceMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instanceMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_instanceMethodMap * ptr = dynamic_cast <const elementOf_GGS_instanceMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_instanceMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_instanceMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_instanceMethodMap * info = (e_instanceMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_instanceMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_instanceMethodMap * info = (e_instanceMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_instanceMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_instanceMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instanceMethodMap::
operator_isEqual (const GGS_instanceMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instanceMethodMap::
operator_isNotEqual (const GGS_instanceMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_instanceMethodMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_instanceMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_instanceMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instanceMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instanceMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @instanceMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_instanceMethodMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_instanceMethodMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_instanceMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_instanceMethodMap * p = NULL ;
    macroMyNew (p, GGS_instanceMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_instanceMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_instanceMethodMap * p = dynamic_cast <const GGS_instanceMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_instanceMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_instanceMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_instanceMethodMap ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap () ;
    e_instanceMethodMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_classMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_classMethodMap::e_classMethodMap (void) :
mParameterList (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@classMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMethodMap ("classMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_classMethodMap::
elementOf_GGS_classMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_classMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_classMethodMap * ptr = dynamic_cast <const elementOf_GGS_classMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMethodMap * info = (e_classMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_classMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_classMethodMap * info = (e_classMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_classMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMethodMap::
operator_isEqual (const GGS_classMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMethodMap::
operator_isNotEqual (const GGS_classMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_classMethodMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_classMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @classMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_classMethodMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_classMethodMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMethodMap * p = NULL ;
    macroMyNew (p, GGS_classMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMethodMap * p = dynamic_cast <const GGS_classMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMethodMap ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap () ;
    e_classMethodMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@enumerationDescriptorList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumerationDescriptorList::
elementOf_GGS_enumerationDescriptorList (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumeratedType (argument_0),
mEnumerationName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumerationDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumerationDescriptorList * ptr = dynamic_cast <const elementOf_GGS_enumerationDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumeratedType.operator_isEqual (ptr->mEnumeratedType).boolValue ()
         && mEnumerationName.operator_isEqual (ptr->mEnumerationName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumerationDescriptorList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumerationName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumerationDescriptorList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumerationDescriptorList ("enumerationDescriptorList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
operator_concat (const GGS_enumerationDescriptorList & inOperand) const {
  GGS_enumerationDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
dotAssign_operation (const GGS_enumerationDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumerationDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mEnumeratedType ;
          GGS_string p_1 = p->mEnumerationName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumeratedType,
                                ptr->mEnumerationName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_enumerationDescriptorList::
constructor_emptyList (void) {
  GGS_enumerationDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_enumerationDescriptorList::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_string& argument_1) {
  GGS_enumerationDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalSubListWithRange (GGS_enumerationDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumeratedType, ptr->mEnumerationName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumerationDescriptorList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumerationDescriptorList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_enumerationDescriptorList::
reader_mEnumeratedTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumerationDescriptorList::
reader_mEnumerationNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumerationName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_setMEnumeratedTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_setMEnumerationNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumerationName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_enumerationDescriptorList::cEnumerator::_mEnumeratedType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumerationDescriptorList::cEnumerator::_mEnumerationName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumerationName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumerationDescriptorList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumerationDescriptorList * p = NULL ;
    macroMyNew (p, GGS_enumerationDescriptorList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumerationDescriptorList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumerationDescriptorList * p = dynamic_cast <const GGS_enumerationDescriptorList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumerationDescriptorList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumerationDescriptorList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumerationDescriptorList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typedAttributeList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typedAttributeList::
elementOf_GGS_typedAttributeList (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typedAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typedAttributeList * ptr = dynamic_cast <const elementOf_GGS_typedAttributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typedAttributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typedAttributeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typedAttributeList ("typedAttributeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalAppendValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalPrependValues (const GGS_unifiedTypeMapIndex & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
addAssign_operation (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
operator_concat (const GGS_typedAttributeList & inOperand) const {
  GGS_typedAttributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
dotAssign_operation (const GGS_typedAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typedAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapIndex  p_0 = p->mAttributeTypeIndex ;
          GGS_lstring  p_1 = p->mAttributeName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapIndex & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_typedAttributeList::
constructor_emptyList (void) {
  GGS_typedAttributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_typedAttributeList::
constructor_listWithValue (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typedAttributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalSubListWithRange (GGS_typedAttributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typedAttributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typedAttributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapIndex & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapIndex & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapIndex & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapIndex & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_typedAttributeList::
reader_mAttributeTypeIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typedAttributeList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMAttributeTypeIndexAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapIndex  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_typedAttributeList::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typedAttributeList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typedAttributeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typedAttributeList * p = NULL ;
    macroMyNew (p, GGS_typedAttributeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typedAttributeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typedAttributeList * p = dynamic_cast <const GGS_typedAttributeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typedAttributeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typedAttributeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typedAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Class for 'typeKindEnum' Enumeration                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeKindEnum ("typeKindEnum", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_typeKindEnum::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_isEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_isNotEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_infOrEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_supOrEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_strictInf (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_strictSup (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeKindEnum::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @typeKindEnum" ;
  switch (mValue) {
  case enum_classType:
    s << " classType>" ;
    break ;
  case enum_enumType:
    s << " enumType>" ;
    break ;
  case enum_listMapType:
    s << " listMapType>" ;
    break ;
  case enum_listType:
    s << " listType>" ;
    break ;
  case enum_mapIndexType:
    s << " mapIndexType>" ;
    break ;
  case enum_mapType:
    s << " mapType>" ;
    break ;
  case enum_primitiveType:
    s << " primitiveType>" ;
    break ;
  case enum_sortedListType:
    s << " sortedListType>" ;
    break ;
  case enum_structType:
    s << " structType>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeKindEnum::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeKindEnum * p = NULL ;
    macroMyNew (p, GGS_typeKindEnum (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKindEnum GGS_typeKindEnum::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeKindEnum result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeKindEnum * p = dynamic_cast <const GGS_typeKindEnum *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeKindEnum, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeKindEnum::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeKindEnum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_unifiedTypeMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_unifiedTypeMap::e_unifiedTypeMap (void) :
mIsConcrete (),
mSuperType (),
mTypeKindEnum (),
mTypedAttributeList (),
mConstructorMap (),
mReaderMap (),
mModifierMap (),
mInstanceMethodMap (),
mClassMethodMap (),
mEnumerationDescriptor () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@unifiedTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMap ("unifiedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_unifiedTypeMap::
elementOf_GGS_unifiedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_unifiedTypeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unifiedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsConcrete.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSuperType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTypeKindEnum.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTypedAttributeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mConstructorMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReaderMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mModifierMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInstanceMethodMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mClassMethodMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEnumerationDescriptor.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unifiedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_unifiedTypeMap * ptr = dynamic_cast <const elementOf_GGS_unifiedTypeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIsConcrete.operator_isEqual (ptr->mInfo.mIsConcrete)).boolValue ()
           && (mInfo.mSuperType.operator_isEqual (ptr->mInfo.mSuperType)).boolValue ()
           && (mInfo.mTypeKindEnum.operator_isEqual (ptr->mInfo.mTypeKindEnum)).boolValue ()
           && (mInfo.mTypedAttributeList.operator_isEqual (ptr->mInfo.mTypedAttributeList)).boolValue ()
           && (mInfo.mConstructorMap.operator_isEqual (ptr->mInfo.mConstructorMap)).boolValue ()
           && (mInfo.mReaderMap.operator_isEqual (ptr->mInfo.mReaderMap)).boolValue ()
           && (mInfo.mModifierMap.operator_isEqual (ptr->mInfo.mModifierMap)).boolValue ()
           && (mInfo.mInstanceMethodMap.operator_isEqual (ptr->mInfo.mInstanceMethodMap)).boolValue ()
           && (mInfo.mClassMethodMap.operator_isEqual (ptr->mInfo.mClassMethodMap)).boolValue ()
           && (mInfo.mEnumerationDescriptor.operator_isEqual (ptr->mInfo.mEnumerationDescriptor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_unifiedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_unifiedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_unifiedTypeMap * info = (e_unifiedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_unifiedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_unifiedTypeMap * info = (e_unifiedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_unifiedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMap::
operator_isEqual (const GGS_unifiedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMap::
operator_isNotEqual (const GGS_unifiedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_bool& inParameter0,
                const GGS_unifiedTypeMapIndex & inParameter1,
                const GGS_typeKindEnum& inParameter2,
                const GGS_typedAttributeList & inParameter3,
                const GGS_constructorMap & inParameter4,
                const GGS_readerMap & inParameter5,
                const GGS_modifierMap & inParameter6,
                const GGS_instanceMethodMap & inParameter7,
                const GGS_classMethodMap & inParameter8,
                const GGS_enumerationDescriptorList & inParameter9,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inParameter8.isBuilt ()
   && inParameter9.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_unifiedTypeMap info  ;
    info.mIsConcrete = inParameter0 ;
    info.mSuperType = inParameter1 ;
    info.mTypeKindEnum = inParameter2 ;
    info.mTypedAttributeList = inParameter3 ;
    info.mConstructorMap = inParameter4 ;
    info.mReaderMap = inParameter5 ;
    info.mModifierMap = inParameter6 ;
    info.mInstanceMethodMap = inParameter7 ;
    info.mClassMethodMap = inParameter8 ;
    info.mEnumerationDescriptor = inParameter9 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_unifiedTypeMapIndex   & outParameter1,
               GGS_typeKindEnum  & outParameter2,
               GGS_typedAttributeList   & outParameter3,
               GGS_constructorMap   & outParameter4,
               GGS_readerMap   & outParameter5,
               GGS_modifierMap   & outParameter6,
               GGS_instanceMethodMap   & outParameter7,
               GGS_classMethodMap   & outParameter8,
               GGS_enumerationDescriptorList   & outParameter9,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    outParameter6.drop () ;
    outParameter7.drop () ;
    outParameter8.drop () ;
    outParameter9.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIsConcrete ;
    outParameter1 = node->mInfo.mSuperType ;
    outParameter2 = node->mInfo.mTypeKindEnum ;
    outParameter3 = node->mInfo.mTypedAttributeList ;
    outParameter4 = node->mInfo.mConstructorMap ;
    outParameter5 = node->mInfo.mReaderMap ;
    outParameter6 = node->mInfo.mModifierMap ;
    outParameter7 = node->mInfo.mInstanceMethodMap ;
    outParameter8 = node->mInfo.mClassMethodMap ;
    outParameter9 = node->mInfo.mEnumerationDescriptor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_unifiedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_unifiedTypeMapIndex   & outParameter1,
                                GGS_typeKindEnum  & outParameter2,
                                GGS_typedAttributeList   & outParameter3,
                                GGS_constructorMap   & outParameter4,
                                GGS_readerMap   & outParameter5,
                                GGS_modifierMap   & outParameter6,
                                GGS_instanceMethodMap   & outParameter7,
                                GGS_classMethodMap   & outParameter8,
                                GGS_enumerationDescriptorList   & outParameter9 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  outParameter8,
                  outParameter9,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_unifiedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_unifiedTypeMapIndex & inParameter1,
                                const GGS_typeKindEnum& inParameter2,
                                const GGS_typedAttributeList & inParameter3,
                                const GGS_constructorMap & inParameter4,
                                const GGS_readerMap & inParameter5,
                                const GGS_modifierMap & inParameter6,
                                const GGS_instanceMethodMap & inParameter7,
                                const GGS_classMethodMap & inParameter8,
                                const GGS_enumerationDescriptorList & inParameter9 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 inParameter8,
                 inParameter9,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_unifiedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @unifiedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_unifiedTypeMap::cEnumerator::_mIsConcrete (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsConcrete ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_unifiedTypeMap::cEnumerator::_mSuperType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSuperType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeKindEnum & GGS_unifiedTypeMap::cEnumerator::_mTypeKindEnum (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTypeKindEnum ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typedAttributeList  & GGS_unifiedTypeMap::cEnumerator::_mTypedAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTypedAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_constructorMap  & GGS_unifiedTypeMap::cEnumerator::_mConstructorMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mConstructorMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_readerMap  & GGS_unifiedTypeMap::cEnumerator::_mReaderMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReaderMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_modifierMap  & GGS_unifiedTypeMap::cEnumerator::_mModifierMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModifierMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instanceMethodMap  & GGS_unifiedTypeMap::cEnumerator::_mInstanceMethodMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInstanceMethodMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_classMethodMap  & GGS_unifiedTypeMap::cEnumerator::_mClassMethodMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mClassMethodMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumerationDescriptorList  & GGS_unifiedTypeMap::cEnumerator::_mEnumerationDescriptor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEnumerationDescriptor ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMap * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMap * p = dynamic_cast <const GGS_unifiedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     map index '@unifiedTypeMapIndex'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMapIndex ("unifiedTypeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex GGS_unifiedTypeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapIndex::
operator_isEqual (const GGS_unifiedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapIndex::
operator_isNotEqual (const GGS_unifiedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @unifiedTypeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_unifiedTypeMap & ioMap,
                               GGS_unifiedTypeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapIndex::reader_mIsConcrete (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mIsConcrete ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_unifiedTypeMapIndex::reader_mSuperType (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mSuperType ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKindEnum GGS_unifiedTypeMapIndex::reader_mTypeKindEnum (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typeKindEnum result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mTypeKindEnum ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_unifiedTypeMapIndex::reader_mTypedAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mTypedAttributeList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap  GGS_unifiedTypeMapIndex::reader_mConstructorMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_constructorMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mConstructorMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap  GGS_unifiedTypeMapIndex::reader_mReaderMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_readerMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mReaderMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap  GGS_unifiedTypeMapIndex::reader_mModifierMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_modifierMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mModifierMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap  GGS_unifiedTypeMapIndex::reader_mInstanceMethodMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_instanceMethodMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mInstanceMethodMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap  GGS_unifiedTypeMapIndex::reader_mClassMethodMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_classMethodMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mClassMethodMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_unifiedTypeMapIndex::reader_mEnumerationDescriptor (C_Compiler & inLexique COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      inLexique.onTheFlyRunTimeError ("bound entry has been deleted" COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError ("entry is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mEnumerationDescriptor ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMapIndex * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex GGS_unifiedTypeMapIndex::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMapIndex * p = dynamic_cast <const GGS_unifiedTypeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMapIndex ;
}

//---------------------------------------------------------------------------*

